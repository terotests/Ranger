; EVGLayout.rgr - Layout algorithm for EVG

Import "EVGElement.rgr"
Import "EVGTextMeasurer.rgr"
Import "EVGImageMeasurer.rgr"

class EVGLayout {
    def measurer:EVGTextMeasurer
    def imageMeasurer:EVGImageMeasurer
    def pageWidth:double 612.0
    def pageHeight:double 792.0
    def currentPage:int 0
    def debug:boolean false
    
    Constructor () {
        def m (new SimpleTextMeasurer())
        measurer = m
        def im (new SimpleImageMeasurer())
        imageMeasurer = im
    }
    
    fn setMeasurer:void (m:EVGTextMeasurer) {
        measurer = m
    }
    
    fn setImageMeasurer:void (m:EVGImageMeasurer) {
        imageMeasurer = m
    }
    
    fn setPageSize:void (w:double h:double) {
        pageWidth = w
        pageHeight = h
    }
    
    fn setDebug:void (d:boolean) {
        debug = d
    }
    
    fn log:void (msg:string) {
        if debug {
            print msg
        }
    }
    
    fn layout:void (root:EVGElement) {
        ; Layout the entire element tree
        this.log("EVGLayout: Starting layout")
        currentPage = 0
        
        ; Resolve root dimensions
        if (root.width.isSet == false) {
            root.width = (EVGUnit.px(pageWidth))
        }
        if (root.height.isSet == false) {
            root.height = (EVGUnit.px(pageHeight))
        }
        
        ; Layout root at (0, 0)
        this.layoutElement(root 0.0 0.0 pageWidth pageHeight)
        
        this.log("EVGLayout: Layout complete")
    }
    
    fn layoutElement:void (element:EVGElement parentX:double parentY:double parentWidth:double parentHeight:double) {
        ; Resolve units for this element (will be skipped if already resolved in layoutChildren)
        element.resolveUnits(parentWidth parentHeight)
        
        ; Calculate element dimensions
        def width:double parentWidth
        if element.width.isSet {
            width = element.width.pixels
        }
        
        def height:double 0.0
        def autoHeight:boolean true
        
        ; Special handling for Page elements - they always use page size
        if ((element.tagName == "Page") || (element.tagName == "page")) {
            if (element.width.isSet == false) {
                width = pageWidth
            }
            if (element.height.isSet == false) {
                height = pageHeight
                autoHeight = false
            }
        }
        if element.height.isSet {
            height = element.height.pixels
            autoHeight = false
        }
        
        ; For image elements, calculate dimensions based on aspect ratio
        if ((element.tagName == "image") || (element.tagName == "Image") || (element.tagName == "img")) {
            def imgSrc:string element.src
            if ((strlen imgSrc) > 0) {
                def dims:EVGImageDimensions (imageMeasurer.getImageDimensions(imgSrc))
                if dims.isValid {
                    if (element.width.isSet && (element.height.isSet == false)) {
                        ; Width is set, calculate height from aspect ratio
                        height = (width / dims.aspectRatio)
                        autoHeight = false
                        this.log(("  Image aspect ratio: " + (to_string dims.aspectRatio) + " -> height=" + (to_string height)))
                    }
                    if ((element.width.isSet == false) && element.height.isSet) {
                        ; Height is set, calculate width from aspect ratio
                        width = (height * dims.aspectRatio)
                        this.log(("  Image aspect ratio: " + (to_string dims.aspectRatio) + " -> width=" + (to_string width)))
                    }
                    if ((element.width.isSet == false) && (element.height.isSet == false)) {
                        ; Neither set, use natural size (capped at parent)
                        width = (to_double dims.width)
                        height = (to_double dims.height)
                        if (width > parentWidth) {
                            def scale:double (parentWidth / width)
                            width = parentWidth
                            height = (height * scale)
                        }
                        autoHeight = false
                        this.log(("  Image natural size: " + (to_string width) + "x" + (to_string height)))
                    }
                }
            }
        }
        
        ; Apply min/max constraints
        if element.minWidth.isSet {
            if (width < element.minWidth.pixels) {
                width = element.minWidth.pixels
            }
        }
        if element.maxWidth.isSet {
            if (width > element.maxWidth.pixels) {
                width = element.maxWidth.pixels
            }
        }
        
        ; Store calculated dimensions (before content layout for children to reference)
        element.calculatedWidth = width
        element.calculatedInnerWidth = (element.box.getInnerWidth(width))
        
        ; If height is explicitly set (not auto), pre-calculate inner height for children
        ; This allows children with height="100%" to resolve correctly
        if (autoHeight == false) {
            element.calculatedHeight = height
            element.calculatedInnerHeight = (element.box.getInnerHeight(height))
        }
        
        ; Handle absolute positioning
        if element.isAbsolute {
            this.layoutAbsolute(element parentWidth parentHeight)
        }
        
        ; Layout children and get content height
        def childCount:int (element.getChildCount())
        def contentHeight:double 0.0
        
        if (childCount > 0) {
            contentHeight = (this.layoutChildren(element))
        } {
            ; No children - check if element has text content
            def textContent:string element.textContent
            if ((strlen textContent) > 0) {
                ; Element has text content (View with text, span, text, Label, etc.)
                def fontSize:double element.inheritedFontSize
                if element.fontSize.isSet {
                    fontSize = element.fontSize.pixels
                }
                if (fontSize <= 0.0) {
                    fontSize = 14.0
                }
                
                ; Get line height
                def lineHeightFactor:double element.lineHeight
                if (lineHeightFactor <= 0.0) {
                    lineHeightFactor = 1.2
                }
                def lineSpacing:double (fontSize * lineHeightFactor)
                
                ; Calculate number of wrapped lines based on text width
                def availableWidth:double (width - element.box.paddingLeftPx - element.box.paddingRightPx)
                def lineCount:int (this.estimateLineCount(textContent availableWidth fontSize))
                
                contentHeight = (lineSpacing * (to_double lineCount))
            }
        }
        
        ; Finalize height
        if autoHeight {
            ; Add padding and border
            height = contentHeight + element.box.paddingTopPx + element.box.paddingBottomPx + (element.box.borderWidthPx * 2.0)
        }
        
        ; Apply min/max height constraints
        if element.minHeight.isSet {
            if (height < element.minHeight.pixels) {
                height = element.minHeight.pixels
            }
        }
        if element.maxHeight.isSet {
            if (height > element.maxHeight.pixels) {
                height = element.maxHeight.pixels
            }
        }
        
        element.calculatedHeight = height
        element.calculatedInnerHeight = (element.box.getInnerHeight(height))
        element.calculatedPage = currentPage
        element.isLayoutComplete = true
        
        this.log(("  Laid out " + element.tagName + " id=" + element.id + " at (" + (to_string element.calculatedX) + "," + (to_string element.calculatedY) + ") size=" + (to_string width) + "x" + (to_string height)))
    }
    
    fn layoutChildren:double (parent:EVGElement) {
        ; Layout all children using flow algorithm
        ; Returns total content height
        
        def childCount:int (parent.getChildCount())
        if (childCount == 0) {
            return 0.0
        }
        
        def innerWidth:double parent.calculatedInnerWidth
        def innerHeight:double parent.calculatedInnerHeight
        
        ; Starting position (after border and padding, NOT margin)
        ; Margin is OUTSIDE the element, padding is INSIDE
        def startX:double (parent.calculatedX + parent.box.borderWidthPx + parent.box.paddingLeftPx)
        def startY:double (parent.calculatedY + parent.box.borderWidthPx + parent.box.paddingTopPx)
        
        def currentX:double startX
        def currentY:double startY
        def rowHeight:double 0.0
        def rowElements:[EVGElement]
        def totalHeight:double 0.0
        
        ; Check layout direction using flexDirection (CSS standard)
        def isColumn:boolean (parent.flexDirection == "column")
        
        ; For row layout with flex items, we need to calculate available space first
        if (isColumn == false) {
            ; Calculate total fixed width and total flex
            def fixedWidth:double 0.0
            def totalFlex:double 0.0
            def j:int 0
            while (j < childCount) {
                def c:EVGElement (parent.getChild(j))
                c.resolveUnits(innerWidth innerHeight)
                if c.width.isSet {
                    fixedWidth = fixedWidth + c.width.pixels + c.box.marginLeftPx + c.box.marginRightPx
                } {
                    if (c.flex > 0.0) {
                        totalFlex = totalFlex + c.flex
                        fixedWidth = fixedWidth + c.box.marginLeftPx + c.box.marginRightPx
                    } {
                        ; No width and no flex - treat as taking full width (will wrap)
                        fixedWidth = fixedWidth + innerWidth + c.box.marginLeftPx + c.box.marginRightPx
                    }
                }
                j = j + 1
            }
            
            ; Calculate available space for flex items
            def availableForFlex:double (innerWidth - fixedWidth)
            if (availableForFlex < 0.0) {
                availableForFlex = 0.0
            }
            
            ; Assign flex widths to children
            if (totalFlex > 0.0) {
                j = 0
                while (j < childCount) {
                    def c:EVGElement (parent.getChild(j))
                    if ((c.width.isSet == false) && (c.flex > 0.0)) {
                        def flexWidth:double ((availableForFlex * c.flex) / totalFlex)
                        c.calculatedFlexWidth = flexWidth
                    }
                    j = j + 1
                }
            }
        }
        
        def i:int 0
        while (i < childCount) {
            def child:EVGElement (parent.getChild(i))
            
            ; Inherit properties from parent
            child.inheritProperties(parent)
            
            ; Resolve child units
            child.resolveUnits(innerWidth innerHeight)
            
            ; Skip absolute positioned elements in flow
            if child.isAbsolute {
                ; Layer elements use parent's full dimensions, not inner dimensions
                if ((child.tagName == "layer") || (child.tagName == "Layer")) {
                    ; Re-resolve Layer dimensions with parent's full width/height
                    child.unitsResolved = false
                    child.resolveUnits(parent.calculatedWidth parent.calculatedHeight)
                    
                    ; Set Layer's calculated dimensions to parent's full size
                    child.calculatedWidth = parent.calculatedWidth
                    child.calculatedHeight = parent.calculatedHeight
                    child.calculatedInnerWidth = (child.box.getInnerWidth(child.calculatedWidth))
                    child.calculatedInnerHeight = (child.box.getInnerHeight(child.calculatedHeight))
                    
                    ; Ensure height.isSet is true for alignment calculations
                    child.height.isSet = true
                    child.height.pixels = child.calculatedHeight
                    
                    this.layoutAbsolute(child parent.calculatedWidth parent.calculatedHeight)
                    ; Layer positions relative to parent's edge (0,0), not content area
                    child.calculatedX = child.calculatedX + parent.calculatedX
                    child.calculatedY = child.calculatedY + parent.calculatedY
                } {
                    this.layoutAbsolute(child innerWidth innerHeight)
                    child.calculatedX = child.calculatedX + startX
                    child.calculatedY = child.calculatedY + startY
                }
                ; Recurse for children of absolute element
                if ((child.getChildCount()) > 0) {
                    this.layoutChildren(child)
                }
                i = i + 1
                continue
            }
            
            ; Calculate child dimensions
            ; Start with available inner width minus child's margins
            def availableForChild:double (innerWidth - child.box.marginLeftPx - child.box.marginRightPx)
            def childWidth:double availableForChild
            
            if child.width.isSet {
                ; If width is explicitly set and it's 100% (resolved to innerWidth), 
                ; we should still subtract margins for proper fit
                if (child.width.pixels >= innerWidth) {
                    ; Width was 100% - use available space after margins
                    childWidth = availableForChild
                } {
                    ; Width was set to a specific value - use it
                    childWidth = child.width.pixels
                }
            } {
                ; No width set - check if this child has a calculated flex width
                if (child.calculatedFlexWidth > 0.0) {
                    childWidth = child.calculatedFlexWidth
                }
            }
            
            ; Total width including margins
            def childTotalWidth:double (childWidth + child.box.marginLeftPx + child.box.marginRightPx)
            
            ; Check if we need to wrap to next row (for row direction)
            if (isColumn == false) {
                def availableWidth:double ((startX + innerWidth) - currentX)
                if ((childTotalWidth > availableWidth) && ((array_length rowElements) > 0)) {
                    ; Wrap to next row
                    this.alignRow(rowElements parent rowHeight startX innerWidth)
                    currentY = currentY + rowHeight
                    totalHeight = totalHeight + rowHeight
                    currentX = startX
                    rowHeight = 0.0
                    clear rowElements
                }
            }
            
            ; Position child
            child.calculatedX = currentX + child.box.marginLeftPx
            child.calculatedY = currentY + child.box.marginTopPx
            
            ; Layout child element (recursive)
            ; Units were already resolved in layoutChildren, pass childWidth so layoutElement knows the actual size
            this.layoutElement(child child.calculatedX child.calculatedY childWidth innerHeight)
            
            ; Get actual child height after layout
            def childHeight:double child.calculatedHeight
            def childTotalHeight:double (childHeight + child.box.marginTopPx + child.box.marginBottomPx)
            
            ; Update position tracking
            if isColumn {
                ; Column direction: stack vertically
                currentY = currentY + childTotalHeight
                totalHeight = totalHeight + childTotalHeight
            } {
                ; Row direction: advance horizontally
                currentX = currentX + childTotalWidth
                push rowElements child
                if (childTotalHeight > rowHeight) {
                    rowHeight = childTotalHeight
                }
            }
            
            ; Handle explicit line break
            if child.lineBreak {
                if (isColumn == false) {
                    this.alignRow(rowElements parent rowHeight startX innerWidth)
                    currentY = currentY + rowHeight
                    totalHeight = totalHeight + rowHeight
                    currentX = startX
                    rowHeight = 0.0
                    clear rowElements
                }
            }
            
            i = i + 1
        }
        
        ; Handle final row (for row layout)
        if ((isColumn == false) && ((array_length rowElements) > 0)) {
            this.alignRow(rowElements parent rowHeight startX innerWidth)
            totalHeight = totalHeight + rowHeight
        }
        
        ; Handle column alignment (for column layout)
        if isColumn {
            this.alignColumn(parent totalHeight startX startY innerWidth innerHeight)
        }
        
        return totalHeight
    }
    
    fn alignColumn:void (parent:EVGElement contentHeight:double startX:double startY:double innerWidth:double innerHeight:double) {
        ; Apply justifyContent (vertical) and alignItems (horizontal) alignment for column layout
        def childCount:int (parent.getChildCount())
        if (childCount == 0) {
            return
        }
        
        ; Get effective alignment values
        ; For column direction: justifyContent = vertical (main axis), alignItems = horizontal (cross axis)
        def verticalAlign:string parent.justifyContent
        def horizontalAlign:string parent.alignItems
        
        ; Calculate vertical offset based on justifyContent
        def availableHeight:double innerHeight
        if parent.height.isSet {
            availableHeight = parent.calculatedInnerHeight
        }
        
        def offsetY:double 0.0
        if (verticalAlign == "center") {
            offsetY = ((availableHeight - contentHeight) / 2.0)
        }
        if ((verticalAlign == "flex-end") || (verticalAlign == "end")) {
            offsetY = (availableHeight - contentHeight)
        }
        if (verticalAlign == "space-between") {
            ; Space between is handled differently - distribute space between items
            ; For now, just don't offset
            offsetY = 0.0
        }
        
        ; Apply offsets to all non-absolute children
        def i:int 0
        while (i < childCount) {
            def child:EVGElement (parent.getChild(i))
            
            ; Skip absolute positioned elements (they're handled separately)
            if (child.isAbsolute == false) {
                ; Apply vertical offset
                if (offsetY != 0.0) {
                    child.calculatedY = child.calculatedY + offsetY
                }
                
                ; Apply horizontal alignment (alignItems)
                def childTotalWidth:double (child.calculatedWidth + child.box.marginLeftPx + child.box.marginRightPx)
                def offsetX:double 0.0
                
                if (horizontalAlign == "center") {
                    offsetX = ((innerWidth - childTotalWidth) / 2.0)
                }
                if ((horizontalAlign == "flex-end") || (horizontalAlign == "end")) {
                    offsetX = (innerWidth - childTotalWidth)
                }
                
                if (offsetX != 0.0) {
                    child.calculatedX = child.calculatedX + offsetX
                }
            }
            
            i = i + 1
        }
    }
    
    fn alignRow:void (rowElements:[EVGElement] parent:EVGElement rowHeight:double startX:double innerWidth:double) {
        ; Apply horizontal and vertical alignment to a row of elements
        def elementCount:int (array_length rowElements)
        if (elementCount == 0) {
            return
        }
        
        ; Calculate row width
        def rowWidth:double 0.0
        def i:int 0
        while (i < elementCount) {
            def el:EVGElement (itemAt rowElements i)
            rowWidth = rowWidth + el.calculatedWidth + el.box.marginLeftPx + el.box.marginRightPx
            i = i + 1
        }
        
        ; Determine alignment based on flexDirection
        ; For row direction: justifyContent = horizontal, alignItems = vertical
        ; For column direction: justifyContent = vertical, alignItems = horizontal
        def isColumn:boolean (parent.flexDirection == "column")
        
        ; Get effective alignment values
        def mainAxisAlign:string parent.justifyContent
        def crossAxisAlign:string parent.alignItems
        
        ; Horizontal alignment (justifyContent for row, alignItems for column)
        def horizontalAlign:string mainAxisAlign
        if isColumn {
            horizontalAlign = crossAxisAlign
        }
        ; Also check legacy 'align' property
        if ((strlen parent.align) > 0) {
            horizontalAlign = parent.align
        }
        
        def offsetX:double 0.0
        if (horizontalAlign == "center") {
            offsetX = ((innerWidth - rowWidth) / 2.0)
        }
        if ((horizontalAlign == "flex-end") || (horizontalAlign == "right")) {
            offsetX = (innerWidth - rowWidth)
        }
        
        ; Vertical alignment (alignItems for row, justifyContent for column)
        def verticalAlignVal:string crossAxisAlign
        if isColumn {
            verticalAlignVal = mainAxisAlign
        }
        ; Also check legacy 'verticalAlign' property
        if ((strlen parent.verticalAlign) > 0) {
            if (parent.verticalAlign != "top") {
                verticalAlignVal = parent.verticalAlign
            }
        }
        
        ; For vertical alignment, use parent's inner height if it has a fixed height
        ; This allows verticalAlign to work when parent has explicit height
        def effectiveRowHeight:double rowHeight
        if parent.height.isSet {
            def parentInnerHeight:double parent.calculatedInnerHeight
            if (parentInnerHeight > rowHeight) {
                effectiveRowHeight = parentInnerHeight
            }
        }
        
        ; Apply alignment offsets
        i = 0
        while (i < elementCount) {
            def el:EVGElement (itemAt rowElements i)
            
            ; Horizontal offset
            if (offsetX != 0.0) {
                el.calculatedX = el.calculatedX + offsetX
            }
            
            ; Vertical alignment within row
            def childTotalHeight:double (el.calculatedHeight + el.box.marginTopPx + el.box.marginBottomPx)
            def offsetY:double 0.0
            
            if (verticalAlignVal == "center") {
                offsetY = ((effectiveRowHeight - childTotalHeight) / 2.0)
            }
            if ((verticalAlignVal == "flex-end") || (verticalAlignVal == "bottom")) {
                offsetY = (effectiveRowHeight - childTotalHeight)
            }
            
            if (offsetY != 0.0) {
                el.calculatedY = el.calculatedY + offsetY
            }
            
            i = i + 1
        }
    }
    
    fn layoutAbsolute:void (element:EVGElement parentWidth:double parentHeight:double) {
        ; Position absolutely positioned element
        
        ; X position
        if element.left.isSet {
            element.calculatedX = element.left.pixels + element.box.marginLeftPx
        } {
            if element.x.isSet {
                element.calculatedX = element.x.pixels + element.box.marginLeftPx
            } {
                if element.right.isSet {
                    def width:double element.calculatedWidth
                    if (width == 0.0) {
                        if element.width.isSet {
                            width = element.width.pixels
                        }
                    }
                    element.calculatedX = parentWidth - element.right.pixels - width - element.box.marginRightPx
                }
            }
        }
        
        ; Y position
        if element.top.isSet {
            element.calculatedY = element.top.pixels + element.box.marginTopPx
        } {
            if element.y.isSet {
                element.calculatedY = element.y.pixels + element.box.marginTopPx
            } {
                if element.bottom.isSet {
                    def height:double element.calculatedHeight
                    if (height == 0.0) {
                        if element.height.isSet {
                            height = element.height.pixels
                        }
                    }
                    element.calculatedY = parentHeight - element.bottom.pixels - height - element.box.marginBottomPx
                }
            }
        }
    }
    
    fn printLayout:void (element:EVGElement indent:int) {
        ; Print layout tree for debugging
        def indentStr:string ""
        def i:int 0
        while (i < indent) {
            indentStr = indentStr + "  "
            i = i + 1
        }
        
        print (indentStr + element.tagName + " id=\"" + element.id + "\" (" + (to_string element.calculatedX) + ", " + (to_string element.calculatedY) + ") " + (to_string element.calculatedWidth) + "x" + (to_string element.calculatedHeight))
        
        def childCount:int (element.getChildCount())
        i = 0
        while (i < childCount) {
            def child:EVGElement (element.getChild(i))
            this.printLayout(child (indent + 1))
            i = i + 1
        }
    }
    
    fn estimateLineCount:int (text:string maxWidth:double fontSize:double) {
        ; Estimate how many lines text will wrap to
        if ((strlen text) == 0) {
            return 1
        }
        if (maxWidth <= 0.0) {
            return 1
        }
        
        ; Split text into words
        def words:[string] (strsplit text " ")
        def lineCount:int 1
        def currentLineWidth:double 0.0
        def spaceWidth:double (fontSize * 0.3)
        
        def i:int 0
        while (i < (array_length words)) {
            def word:string (itemAt words i)
            def wordWidth:double (measurer.measureTextWidth(word "Helvetica" fontSize))
            
            if (currentLineWidth == 0.0) {
                ; First word on line
                currentLineWidth = wordWidth
            } {
                ; Check if word fits on current line
                def testWidth:double (currentLineWidth + spaceWidth + wordWidth)
                if (testWidth > maxWidth) {
                    ; Word doesn't fit, wrap to new line
                    lineCount = lineCount + 1
                    currentLineWidth = wordWidth
                } {
                    currentLineWidth = testWidth
                }
            }
            
            i = i + 1
        }
        
        return lineCount
    }
}
