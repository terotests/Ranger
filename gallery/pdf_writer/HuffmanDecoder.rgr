; HuffmanDecoder.rgr - Huffman table building and decoding for JPEG

class HuffmanTable {
    def bits:[int]           ; Count of codes at each length (index 0-15 = lengths 1-16)
    def values:[int]         ; Symbol values in order
    def maxCode:[int]        ; Max code value for each length
    def minCode:[int]        ; Min code value for each length
    def valPtr:[int]         ; Index into values for each length
    def tableClass:int 0     ; 0 = DC, 1 = AC
    def tableId:int 0        ; Table ID (0-3)
    
    Constructor () {
        ; Initialize arrays
        def i 0
        while (i < 16) {
            push bits 0
            push maxCode -1
            push minCode 0
            push valPtr 0
            i = i + 1
        }
    }
    
    fn build:void () {
        ; Build decoding tables from bits and values arrays
        ; Generate maxCode, minCode, valPtr for fast decoding
        
        def code:int 0
        def valueIdx:int 0
        
        def i 0
        while (i < 16) {
            def count:int (at bits i)
            if (count > 0) {
                set minCode i code
                set valPtr i valueIdx
                valueIdx = valueIdx + count
                code = code + count
                set maxCode i (code - 1)
            } {
                set maxCode i -1
                set minCode i 0
                set valPtr i valueIdx
            }
            code = (bit_shl code 1)
            i = i + 1
        }
    }
    
    fn decode:int (reader:BitReader) {
        ; Decode one symbol from bit stream
        def code:int 0
        def length:int 0
        
        while (length < 16) {
            def bit:int (reader.readBit())
            code = (bit_or (bit_shl code 1) bit)
            
            def maxC:int (at maxCode length)
            if (maxC >= 0) {
                if (code <= maxC) {
                    ; Found valid code
                    def minC:int (at minCode length)
                    def ptr:int (at valPtr length)
                    def idx:int (ptr + (code - minC))
                    return (at values idx)
                }
            }
            
            length = length + 1
        }
        
        ; Code not found - error
        print "Huffman decode error: code not found"
        return 0
    }
}

class HuffmanDecoder {
    ; DC tables (indexed by table ID)
    def dcTable0:HuffmanTable (new HuffmanTable())
    def dcTable1:HuffmanTable (new HuffmanTable())
    ; AC tables (indexed by table ID)
    def acTable0:HuffmanTable (new HuffmanTable())
    def acTable1:HuffmanTable (new HuffmanTable())
    
    Constructor () {
    }
    
    fn getDCTable:HuffmanTable (id:int) {
        if (id == 0) {
            return dcTable0
        }
        return dcTable1
    }
    
    fn getACTable:HuffmanTable (id:int) {
        if (id == 0) {
            return acTable0
        }
        return acTable1
    }
    
    fn parseDHT:void (data:buffer pos:int length:int) {
        ; Parse Define Huffman Table marker
        ; Format: [tableInfo] [bits[16]] [values...]
        ; tableInfo: high nibble = class (0=DC, 1=AC), low nibble = table ID
        
        def endPos:int (pos + length)
        
        while (pos < endPos) {
            def tableInfo:int (buffer_get data pos)
            pos = pos + 1
            
            def tableClass:int (bit_shr tableInfo 4)
            def tableId:int (bit_and tableInfo 15)
            
            ; Select target table
            def table:HuffmanTable (this.getDCTable(tableId))
            if (tableClass == 1) {
                table = (this.getACTable(tableId))
            }
            
            table.tableClass = tableClass
            table.tableId = tableId
            
            ; Clear and read bits array (counts for each code length)
            clear table.bits
            def totalSymbols:int 0
            def i 0
            while (i < 16) {
                def count:int (buffer_get data pos)
                push table.bits count
                totalSymbols = totalSymbols + count
                pos = pos + 1
                i = i + 1
            }
            
            ; Read symbol values
            clear table.values
            clear table.maxCode
            clear table.minCode
            clear table.valPtr
            i = 0
            while (i < 16) {
                push table.maxCode -1
                push table.minCode 0
                push table.valPtr 0
                i = i + 1
            }
            
            i = 0
            while (i < totalSymbols) {
                push table.values (buffer_get data pos)
                pos = pos + 1
                i = i + 1
            }
            
            ; Build decoding structures
            table.build()
            
            def classStr "DC"
            if (tableClass == 1) {
                classStr = "AC"
            }
            print ("  Huffman table " + classStr + (to_string tableId) + ": " + (to_string totalSymbols) + " symbols")
        }
    }
}
