; JSXToEVG.rgr - Convert JSX AST nodes to EVG elements
; 
; This module takes the AST output from ts_parser (with JSX support)
; and converts it into EVG elements that can be laid out and rendered.

Import "../ts_parser/ts_parser_simple.rgr"
Import "../ts_parser/ts_lexer.rgr"
Import "../evg/EVGElement.rgr"
Import "../evg/EVGUnit.rgr"
Import "../evg/EVGColor.rgr"

class JSXToEVG {
    def parser:TSParserSimple
    def source:string ""
    def pageWidth:double 595.0
    def pageHeight:double 842.0
    
    Constructor () {
        parser = (new TSParserSimple())
        parser.tsxMode = true
    }
    
    ; Convert camelCase to kebab-case (e.g., "fontSize" -> "font-size")
    fn camelToKebab:string (name:string) {
        def result:string ""
        def i:int 0
        def len:int (strlen name)
        while (i < len) {
            def code:char (charAt name i)
            def codeInt:int code
            ; Check if uppercase A-Z (65-90)
            if ((codeInt >= 65) && (codeInt <= 90)) {
                if (i > 0) {
                    result = result + "-"
                }
                ; Convert to lowercase by adding 32
                def lowerCode:int (codeInt + 32)
                def lowerCh:string (strfromcode lowerCode)
                result = result + lowerCh
            } {
                def ch:string (strfromcode codeInt)
                result = result + ch
            }
            i = i + 1
        }
        return result
    }
    
    ; Parse a TSX file and return the root EVG element
    fn parseFile:EVGElement (dirPath:string fileName:string) {
        def fileContent:buffer (buffer_read_file dirPath fileName)
        def src:string (buffer_to_string fileContent)
        return (this.parse(src))
    }
    
    ; Parse TSX source string and return the root EVG element
    fn parse:EVGElement (src:string) {
        source = src
        
        ; Tokenize the source
        def lexer (new TSLexer(src))
        def tokens:[Token] (lexer.tokenize())
        
        ; Initialize parser with tokens
        parser.initParser(tokens)
        parser.tsxMode = true
        
        ; Parse the entire file
        def ast:TSNode (parser.parseProgram())
        
        ; Find the render function and get its JSX return value
        def jsxRoot:TSNode (this.findJSXRoot(ast))
        
        if (jsxRoot.nodeType == "") {
            print "Error: No JSX found in render() function"
            def empty (new EVGElement())
            return empty
        }
        
        ; Convert JSX tree to EVG elements
        return (this.convertNode(jsxRoot))
    }
    
    ; Find the JSX root in the AST (look for render function's return)
    fn findJSXRoot:TSNode (ast:TSNode) {
        ; Search for a function named "render" and get its return statement
        def result (this.searchForRenderFunction(ast))
        return result
    }
    
    fn searchForRenderFunction:TSNode (node:TSNode) {
        def empty (new TSNode())
        
        ; Check if this is a function declaration named "render"
        if (node.nodeType == "FunctionDeclaration") {
            if (node.name == "render") {
                ; Find the return statement
                return (this.findReturnJSX(node))
            }
        }
        
        ; Check function expression in variable declaration
        if (node.nodeType == "VariableDeclaration") {
            def i 0
            while (i < (array_length node.children)) {
                def child:TSNode (itemAt node.children i)
                if (child.name == "render") {
                    if child.right {
                        def rightNode:TSNode (unwrap child.right)
                        if (rightNode.nodeType == "FunctionExpression") {
                            return (this.findReturnJSX(rightNode))
                        }
                        if (rightNode.nodeType == "ArrowFunctionExpression") {
                            return (this.findReturnJSX(rightNode))
                        }
                    }
                }
                i = i + 1
            }
        }
        
        ; Recurse into children
        def i 0
        while (i < (array_length node.children)) {
            def child:TSNode (itemAt node.children i)
            def found:TSNode (this.searchForRenderFunction(child))
            if (found.nodeType != "") {
                return found
            }
            i = i + 1
        }
        
        ; Check left and right
        if node.left {
            def leftNode:TSNode (unwrap node.left)
            def found:TSNode (this.searchForRenderFunction(leftNode))
            if (found.nodeType != "") {
                return found
            }
        }
        if node.right {
            def rightNode:TSNode (unwrap node.right)
            def found:TSNode (this.searchForRenderFunction(rightNode))
            if (found.nodeType != "") {
                return found
            }
        }
        
        return empty
    }
    
    fn findReturnJSX:TSNode (funcNode:TSNode) {
        def empty (new TSNode())
        
        ; Check body property (FunctionDeclaration uses body for its block)
        if funcNode.body {
            def bodyNode:TSNode (unwrap funcNode.body)
            def found:TSNode (this.findReturnJSX(bodyNode))
            if (found.nodeType != "") {
                return found
            }
        }
        
        ; Search for ReturnStatement with JSX
        def i 0
        while (i < (array_length funcNode.children)) {
            def child:TSNode (itemAt funcNode.children i)
            
            if (child.nodeType == "ReturnStatement") {
                if child.left {
                    def leftNode:TSNode (unwrap child.left)
                    if ((leftNode.nodeType == "JSXElement") || (leftNode.nodeType == "JSXFragment")) {
                        return leftNode
                    }
                }
            }
            
            ; Check block statement
            if (child.nodeType == "BlockStatement") {
                def found:TSNode (this.findReturnJSX(child))
                if (found.nodeType != "") {
                    return found
                }
            }
            
            ; Arrow function might have direct JSX body
            if ((child.nodeType == "JSXElement") || (child.nodeType == "JSXFragment")) {
                return child
            }
            
            i = i + 1
        }
        
        ; Check right (for arrow functions with expression body)
        if funcNode.right {
            def rightNode:TSNode (unwrap funcNode.right)
            if ((rightNode.nodeType == "JSXElement") || (rightNode.nodeType == "JSXFragment")) {
                return rightNode
            }
        }
        
        return empty
    }
    
    ; Convert a JSX AST node to an EVG element
    fn convertNode:EVGElement (jsxNode:TSNode) {
        def element (new EVGElement())
        
        ; Handle different JSX node types
        if (jsxNode.nodeType == "JSXElement") {
            return (this.convertJSXElement(jsxNode))
        }
        
        if (jsxNode.nodeType == "JSXFragment") {
            ; Fragment - create a container div
            element.tagName = "div"
            this.convertChildren(element jsxNode)
            return element
        }
        
        if (jsxNode.nodeType == "JSXText") {
            element.tagName = "text"
            element.textContent = (this.trimText(jsxNode.value))
            return element
        }
        
        if (jsxNode.nodeType == "JSXExpressionContainer") {
            ; For now, just return the expression as text if it's a literal
            if jsxNode.left {
                if (jsxNode.left.nodeType == "StringLiteral") {
                    element.tagName = "text"
                    element.textContent = jsxNode.left.value
                    return element
                }
                if (jsxNode.left.nodeType == "NumericLiteral") {
                    element.tagName = "text"
                    element.textContent = jsxNode.left.value
                    return element
                }
            }
            ; Return empty for complex expressions (including comments like {/* ... */})
            element.tagName = ""
            return element
        }
        
        ; Default: return empty element (tagName = "" means skip)
        element.tagName = ""
        return element
    }
    
    fn convertJSXElement:EVGElement (jsxNode:TSNode) {
        def element (new EVGElement())
        
        ; Get tag name from opening element
        def tagName:string ""
        if jsxNode.left {
            tagName = jsxNode.left.name
        }
        
        ; Map JSX tags to EVG element types
        element.tagName = (this.mapTagName(tagName))
        
        ; Handle special tags
        if (tagName == "page") {
            element.tagName = "page"
        }
        if (tagName == "row") {
            element.tagName = "div"
            element.display = "flex"
            element.flexDirection = "row"
        }
        if (tagName == "column") {
            element.tagName = "div"
            element.display = "flex"
            element.flexDirection = "column"
        }
        if (tagName == "spacer") {
            element.tagName = "spacer"
        }
        if (tagName == "divider") {
            element.tagName = "divider"
        }
        
        ; Parse attributes from opening element
        if jsxNode.left {
            def leftNode:TSNode (unwrap jsxNode.left)
            this.parseAttributes(element leftNode)
        }
        
        ; For text elements (span, Label), collect text content from children
        if ((tagName == "span") || (tagName == "Label") || (tagName == "text")) {
            element.textContent = (this.collectTextContent(jsxNode))
        } {
            ; Convert children for non-text elements
            this.convertChildren(element jsxNode)
        }
        
        return element
    }
    
    ; Collect all text content from JSX children
    fn collectTextContent:string (jsxNode:TSNode) {
        def result:string ""
        def i 0
        while (i < (array_length jsxNode.children)) {
            def child:TSNode (itemAt jsxNode.children i)
            
            if (child.nodeType == "JSXText") {
                def text:string (this.trimText(child.value))
                if ((strlen text) > 0) {
                    if ((strlen result) > 0) {
                        result = result + " " + text
                    } {
                        result = text
                    }
                }
            }
            
            if (child.nodeType == "JSXExpressionContainer") {
                if child.left {
                    if (child.left.nodeType == "StringLiteral") {
                        def text:string (this.unquote(child.left.value))
                        if ((strlen result) > 0) {
                            result = result + " " + text
                        } {
                            result = text
                        }
                    }
                }
            }
            
            i = i + 1
        }
        return result
    }
    
    fn mapTagName:string (jsxTag:string) {
        ; EVG spec element names
        if (jsxTag == "View") {
            return "div"
        }
        if (jsxTag == "div") {
            return "div"
        }
        if (jsxTag == "span") {
            return "text"
        }
        if (jsxTag == "Label") {
            return "text"
        }
        if (jsxTag == "text") {
            return "text"
        }
        if (jsxTag == "img") {
            return "image"
        }
        if (jsxTag == "image") {
            return "image"
        }
        if (jsxTag == "Image") {
            return "image"
        }
        if (jsxTag == "box") {
            return "div"
        }
        if (jsxTag == "page") {
            return "page"
        }
        if (jsxTag == "row") {
            return "div"
        }
        if (jsxTag == "column") {
            return "div"
        }
        ; Default to div
        return "div"
    }
    
    fn parseAttributes:void (element:EVGElement openingNode:TSNode) {
        ; Attributes are in children of the opening element
        def i 0
        while (i < (array_length openingNode.children)) {
            def attr:TSNode (itemAt openingNode.children i)
            
            if (attr.nodeType == "JSXAttribute") {
                def rawAttrName:string attr.name
                ; Convert camelCase to kebab-case for CSS-like attributes
                def attrName:string (this.camelToKebab(rawAttrName))
                def attrValue:string (this.getAttributeValue(attr))
                
                print ("  Attr: " + rawAttrName + " -> " + attrName + " = " + attrValue)
                
                ; Handle id
                if (attrName == "id") {
                    element.id = attrValue
                }
                
                ; Handle className
                if (attrName == "className") {
                    element.className = attrValue
                }
                
                ; Handle src for images
                if (attrName == "src") {
                    element.src = attrValue
                }
                
                ; Handle alt for images
                if (attrName == "alt") {
                    element.alt = attrValue
                }
                
                ; Handle width/height - support both pixels and percentages
                if (attrName == "width") {
                    def unit:EVGUnit (EVGUnit.parse(attrValue))
                    element.width = unit
                    ; If it's a pixel value (unitType 0), also update pageWidth
                    if ((unit.unitType == 0) && (unit.pixels > 0.0)) {
                        pageWidth = unit.pixels
                    }
                }
                if (attrName == "height") {
                    def unit:EVGUnit (EVGUnit.parse(attrValue))
                    element.height = unit
                    ; If it's a pixel value (unitType 0), also update pageHeight
                    if ((unit.unitType == 0) && (unit.pixels > 0.0)) {
                        pageHeight = unit.pixels
                    }
                }
                
                ; Handle color for divider and text color
                if (attrName == "color") {
                    element.color = (EVGColor.parse(attrValue))
                }
                
                ; Handle style object
                if (attrName == "style") {
                    this.parseStyleAttribute(element attr)
                }
                
                ; Handle direct CSS-like attributes per EVG spec
                if (attrName == "padding") {
                    this.applyStyleProperty(element "padding" attrValue)
                }
                if (attrName == "margin") {
                    this.applyStyleProperty(element "margin" attrValue)
                }
                if (attrName == "margin-top") {
                    this.applyStyleProperty(element "marginTop" attrValue)
                }
                if (attrName == "margin-bottom") {
                    this.applyStyleProperty(element "marginBottom" attrValue)
                }
                if (attrName == "margin-left") {
                    this.applyStyleProperty(element "marginLeft" attrValue)
                }
                if (attrName == "margin-right") {
                    this.applyStyleProperty(element "marginRight" attrValue)
                }
                if (attrName == "font-size") {
                    this.applyStyleProperty(element "fontSize" attrValue)
                }
                if (attrName == "font-weight") {
                    this.applyStyleProperty(element "fontWeight" attrValue)
                }
                if (attrName == "font-family") {
                    this.applyStyleProperty(element "fontFamily" attrValue)
                }
                if (attrName == "background-color") {
                    print ("  Parsing background-color: " + attrValue)
                    this.applyStyleProperty(element "backgroundColor" attrValue)
                    def bgc:EVGColor (unwrap element.backgroundColor)
                    print ("  After parse: isSet=" + (to_string bgc.isSet) + " r=" + (to_string bgc.r))
                }
                if (attrName == "border-radius") {
                    this.applyStyleProperty(element "borderRadius" attrValue)
                }
                if (attrName == "border-width") {
                    this.applyStyleProperty(element "borderWidth" attrValue)
                }
                if (attrName == "line-height") {
                    this.applyStyleProperty(element "lineHeight" attrValue)
                }
                if (attrName == "text-align") {
                    this.applyStyleProperty(element "textAlign" attrValue)
                }
                if (attrName == "flex-direction") {
                    this.applyStyleProperty(element "flexDirection" attrValue)
                }
                if (attrName == "flex") {
                    this.applyStyleProperty(element "flex" attrValue)
                }
                if (attrName == "border-color") {
                    this.applyStyleProperty(element "borderColor" attrValue)
                }
            }
            
            i = i + 1
        }
    }
    
    fn getAttributeValue:string (attr:TSNode) {
        if attr.right {
            def rightNode:TSNode (unwrap attr.right)
            ; String literal
            if (rightNode.nodeType == "StringLiteral") {
                return (this.unquote(rightNode.value))
            }
            ; Expression container
            if (rightNode.nodeType == "JSXExpressionContainer") {
                if rightNode.left {
                    def exprNode:TSNode (unwrap rightNode.left)
                    return (this.extractExpressionValue(exprNode))
                }
            }
        }
        return ""
    }
    
    fn extractExpressionValue:string (exprNode:TSNode) {
        ; Handle simple literals
        if (exprNode.nodeType == "NumericLiteral") {
            return exprNode.value
        }
        if (exprNode.nodeType == "StringLiteral") {
            return (this.unquote(exprNode.value))
        }
        if (exprNode.nodeType == "Identifier") {
            return exprNode.name
        }
        
        ; For object expressions, return as-is for style parsing
        if (exprNode.nodeType == "ObjectExpression") {
            return "OBJECT"
        }
        
        return ""
    }
    
    fn parseStyleAttribute:void (element:EVGElement attr:TSNode) {
        ; Style is usually: style={{ property: "value" }}
        ; attr.right is JSXExpressionContainer
        ; attr.right.left is the outer expression (often another ObjectExpression)
        
        if attr.right {
            def rightNode:TSNode (unwrap attr.right)
            if (rightNode.nodeType == "JSXExpressionContainer") {
                if rightNode.left {
                    def styleExpr:TSNode (unwrap rightNode.left)
                    this.parseStyleObject(element styleExpr)
                }
            }
        }
    }
    
    fn parseStyleObject:void (element:EVGElement styleNode:TSNode) {
        ; styleNode should be an ObjectExpression
        if (styleNode.nodeType != "ObjectExpression") {
            return
        }
        
        ; Iterate over properties
        def i 0
        while (i < (array_length styleNode.children)) {
            def prop:TSNode (itemAt styleNode.children i)
            
            if (prop.nodeType == "Property") {
                def propName:string prop.name
                def propValue:string ""
                
                if prop.right {
                    def propRightNode:TSNode (unwrap prop.right)
                    propValue = (this.extractExpressionValue(propRightNode))
                    if (propRightNode.nodeType == "StringLiteral") {
                        propValue = (this.unquote(propRightNode.value))
                    }
                }
                
                ; Apply style property to element
                this.applyStyleProperty(element propName propValue)
            }
            
            i = i + 1
        }
    }
    
    fn applyStyleProperty:void (element:EVGElement name:string value:string) {
        ; Dimensions
        if (name == "width") {
            element.width = (EVGUnit.parse(value))
        }
        if (name == "height") {
            element.height = (EVGUnit.parse(value))
        }
        if (name == "minWidth") {
            element.minWidth = (EVGUnit.parse(value))
        }
        if (name == "maxWidth") {
            element.maxWidth = (EVGUnit.parse(value))
        }
        if (name == "minHeight") {
            element.minHeight = (EVGUnit.parse(value))
        }
        if (name == "maxHeight") {
            element.maxHeight = (EVGUnit.parse(value))
        }
        
        ; Margin - set on box model (like padding)
        if (name == "margin") {
            def unit:EVGUnit (EVGUnit.parse(value))
            element.box.marginTop = unit
            element.box.marginRight = unit
            element.box.marginBottom = unit
            element.box.marginLeft = unit
        }
        if (name == "marginTop") {
            element.box.marginTop = (EVGUnit.parse(value))
        }
        if (name == "marginRight") {
            element.box.marginRight = (EVGUnit.parse(value))
        }
        if (name == "marginBottom") {
            element.box.marginBottom = (EVGUnit.parse(value))
        }
        if (name == "marginLeft") {
            element.box.marginLeft = (EVGUnit.parse(value))
        }
        
        ; Padding - set on box model
        if (name == "padding") {
            def unit:EVGUnit (EVGUnit.parse(value))
            element.box.paddingTop = unit
            element.box.paddingRight = unit
            element.box.paddingBottom = unit
            element.box.paddingLeft = unit
        }
        if (name == "paddingTop") {
            element.box.paddingTop = (EVGUnit.parse(value))
        }
        if (name == "paddingRight") {
            element.box.paddingRight = (EVGUnit.parse(value))
        }
        if (name == "paddingBottom") {
            element.box.paddingBottom = (EVGUnit.parse(value))
        }
        if (name == "paddingLeft") {
            element.box.paddingLeft = (EVGUnit.parse(value))
        }
        
        ; Border
        if (name == "border") {
            element.box.borderWidth = (EVGUnit.parse(value))
        }
        if (name == "borderWidth") {
            element.borderWidth = (EVGUnit.parse(value))
        }
        if (name == "borderColor") {
            element.borderColor = (EVGColor.parse(value))
        }
        if (name == "borderTop") {
            element.borderTopWidth = (EVGUnit.parse(value))
        }
        if (name == "borderRight") {
            element.borderRightWidth = (EVGUnit.parse(value))
        }
        if (name == "borderBottom") {
            element.borderBottomWidth = (EVGUnit.parse(value))
        }
        if (name == "borderLeft") {
            element.borderLeftWidth = (EVGUnit.parse(value))
        }
        if (name == "borderRadius") {
            element.borderRadius = (EVGUnit.parse(value))
        }
        
        ; Layout
        if (name == "display") {
            element.display = value
        }
        if (name == "flexDirection") {
            element.flexDirection = value
        }
        if (name == "justifyContent") {
            element.justifyContent = value
        }
        if (name == "alignItems") {
            element.alignItems = value
        }
        if (name == "gap") {
            element.gap = (EVGUnit.parse(value))
        }
        if (name == "flex") {
            element.flex = (this.parseNumberValue(value))
        }
        
        ; Position
        if (name == "position") {
            element.position = value
        }
        if (name == "top") {
            element.top = (EVGUnit.parse(value))
        }
        if (name == "left") {
            element.left = (EVGUnit.parse(value))
        }
        if (name == "right") {
            element.right = (EVGUnit.parse(value))
        }
        if (name == "bottom") {
            element.bottom = (EVGUnit.parse(value))
        }
        
        ; Visual
        if (name == "backgroundColor") {
            element.backgroundColor = (EVGColor.parse(value))
        }
        if (name == "color") {
            element.color = (EVGColor.parse(value))
        }
        if (name == "opacity") {
            element.opacity = (this.parseNumberValue(value))
        }
        
        ; Text
        if (name == "fontSize") {
            element.fontSize = (EVGUnit.parse(value))
        }
        if (name == "fontFamily") {
            element.fontFamily = value
        }
        if (name == "fontWeight") {
            element.fontWeight = value
        }
        if (name == "textAlign") {
            element.textAlign = value
        }
        if (name == "lineHeight") {
            element.lineHeight = (this.parseNumberValue(value))
        }
    }
    
    fn convertChildren:void (element:EVGElement jsxNode:TSNode) {
        def i 0
        while (i < (array_length jsxNode.children)) {
            def childJsx:TSNode (itemAt jsxNode.children i)
            
            ; Skip non-content nodes
            if (childJsx.nodeType == "JSXOpeningElement") {
                i = i + 1
                continue
            }
            if (childJsx.nodeType == "JSXClosingElement") {
                i = i + 1
                continue
            }
            if (childJsx.nodeType == "JSXAttribute") {
                i = i + 1
                continue
            }
            
            ; Convert child
            def childElement:EVGElement (this.convertNode(childJsx))
            
            ; Only add non-empty elements
            if (childElement.tagName != "") {
                ; Skip whitespace-only text nodes that have no children
                if (childElement.tagName == "text") {
                    def hasContent:boolean false
                    if ((strlen childElement.textContent) > 0) {
                        hasContent = true
                    }
                    if ((childElement.getChildCount()) > 0) {
                        hasContent = true
                    }
                    if (hasContent == false) {
                        i = i + 1
                        continue
                    }
                }
                
                childElement.parent = element
                push element.children childElement
            }
            
            i = i + 1
        }
    }
    
    ; Helper functions
    fn unquote:string (s:string) {
        def len:int (strlen s)
        if (len < 2) {
            return s
        }
        def first:int (charAt s 0)
        def last:int (charAt s (len - 1))
        ; Check for quotes: " (34) or ' (39)
        if (((first == 34) || (first == 39)) && (first == last)) {
            return (substring s 1 (len - 1))
        }
        return s
    }
    
    fn trimText:string (s:string) {
        ; Trim and normalize whitespace - collapse multiple spaces/newlines to single space
        def len:int (strlen s)
        def result:string ""
        def lastWasSpace:boolean true  ; Start true to skip leading whitespace
        
        def i:int 0
        while (i < len) {
            def c:int (charAt s i)
            ; space=32, tab=9, newline=10, cr=13
            def isWhitespace:boolean ((c == 32) || (c == 9) || (c == 10) || (c == 13))
            
            if isWhitespace {
                if (lastWasSpace == false) {
                    result = result + " "
                    lastWasSpace = true
                }
            } {
                result = result + (strfromcode c)
                lastWasSpace = false
            }
            
            i = i + 1
        }
        
        ; Trim trailing space if present
        def resultLen:int (strlen result)
        if (resultLen > 0) {
            def lastChar:int (charAt result (resultLen - 1))
            if (lastChar == 32) {
                result = (substring result 0 (resultLen - 1))
            }
        }
        
        return result
    }
    
    fn parseNumberValue:double (s:string) {
        def result@(optional):double (to_double s)
        if result {
            return (unwrap result)
        }
        return 0.0
    }
    
    fn getPageWidth:double () {
        return pageWidth
    }
    
    fn getPageHeight:double () {
        return pageHeight
    }
}
