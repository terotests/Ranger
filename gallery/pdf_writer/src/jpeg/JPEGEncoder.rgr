; JPEGEncoder.rgr - JPEG encoder for Ranger
; Encodes ImageBuffer to baseline JPEG format

Import "../core/Buffer.rgr"
Import "ImageBuffer.rgr"

; Forward DCT class for encoding
class FDCT {
    ; Cosine table: cos((2*x+1) * u * pi / 16) * 1024
    def cosTable:int_buffer (int_buffer_alloc 64)
    
    ; Row-major to zigzag mapping
    def zigzagOrder:int_buffer (int_buffer_alloc 64)
    
    Constructor () {
        ; Same cosine values as IDCT - the table is symmetric
        ; Row x=0: u=0,1,2,3,4,5,6,7
        int_buffer_set cosTable 0 1024
        int_buffer_set cosTable 1 1004
        int_buffer_set cosTable 2 946
        int_buffer_set cosTable 3 851
        int_buffer_set cosTable 4 724
        int_buffer_set cosTable 5 569
        int_buffer_set cosTable 6 392
        int_buffer_set cosTable 7 200
        
        ; Row x=1
        int_buffer_set cosTable 8 1024
        int_buffer_set cosTable 9 851
        int_buffer_set cosTable 10 392
        int_buffer_set cosTable 11 -200
        int_buffer_set cosTable 12 -724
        int_buffer_set cosTable 13 -1004
        int_buffer_set cosTable 14 -946
        int_buffer_set cosTable 15 -569
        
        ; Row x=2
        int_buffer_set cosTable 16 1024
        int_buffer_set cosTable 17 569
        int_buffer_set cosTable 18 -392
        int_buffer_set cosTable 19 -1004
        int_buffer_set cosTable 20 -724
        int_buffer_set cosTable 21 200
        int_buffer_set cosTable 22 946
        int_buffer_set cosTable 23 851
        
        ; Row x=3
        int_buffer_set cosTable 24 1024
        int_buffer_set cosTable 25 200
        int_buffer_set cosTable 26 -946
        int_buffer_set cosTable 27 -569
        int_buffer_set cosTable 28 724
        int_buffer_set cosTable 29 851
        int_buffer_set cosTable 30 -392
        int_buffer_set cosTable 31 -1004
        
        ; Row x=4
        int_buffer_set cosTable 32 1024
        int_buffer_set cosTable 33 -200
        int_buffer_set cosTable 34 -946
        int_buffer_set cosTable 35 569
        int_buffer_set cosTable 36 724
        int_buffer_set cosTable 37 -851
        int_buffer_set cosTable 38 -392
        int_buffer_set cosTable 39 1004
        
        ; Row x=5
        int_buffer_set cosTable 40 1024
        int_buffer_set cosTable 41 -569
        int_buffer_set cosTable 42 -392
        int_buffer_set cosTable 43 1004
        int_buffer_set cosTable 44 -724
        int_buffer_set cosTable 45 -200
        int_buffer_set cosTable 46 946
        int_buffer_set cosTable 47 -851
        
        ; Row x=6
        int_buffer_set cosTable 48 1024
        int_buffer_set cosTable 49 -851
        int_buffer_set cosTable 50 392
        int_buffer_set cosTable 51 200
        int_buffer_set cosTable 52 -724
        int_buffer_set cosTable 53 1004
        int_buffer_set cosTable 54 -946
        int_buffer_set cosTable 55 569
        
        ; Row x=7
        int_buffer_set cosTable 56 1024
        int_buffer_set cosTable 57 -1004
        int_buffer_set cosTable 58 946
        int_buffer_set cosTable 59 -851
        int_buffer_set cosTable 60 724
        int_buffer_set cosTable 61 -569
        int_buffer_set cosTable 62 392
        int_buffer_set cosTable 63 -200
        
        ; Zigzag order (row-major index for each zigzag position)
        int_buffer_set zigzagOrder 0 0
        int_buffer_set zigzagOrder 1 1
        int_buffer_set zigzagOrder 2 8
        int_buffer_set zigzagOrder 3 16
        int_buffer_set zigzagOrder 4 9
        int_buffer_set zigzagOrder 5 2
        int_buffer_set zigzagOrder 6 3
        int_buffer_set zigzagOrder 7 10
        int_buffer_set zigzagOrder 8 17
        int_buffer_set zigzagOrder 9 24
        int_buffer_set zigzagOrder 10 32
        int_buffer_set zigzagOrder 11 25
        int_buffer_set zigzagOrder 12 18
        int_buffer_set zigzagOrder 13 11
        int_buffer_set zigzagOrder 14 4
        int_buffer_set zigzagOrder 15 5
        int_buffer_set zigzagOrder 16 12
        int_buffer_set zigzagOrder 17 19
        int_buffer_set zigzagOrder 18 26
        int_buffer_set zigzagOrder 19 33
        int_buffer_set zigzagOrder 20 40
        int_buffer_set zigzagOrder 21 48
        int_buffer_set zigzagOrder 22 41
        int_buffer_set zigzagOrder 23 34
        int_buffer_set zigzagOrder 24 27
        int_buffer_set zigzagOrder 25 20
        int_buffer_set zigzagOrder 26 13
        int_buffer_set zigzagOrder 27 6
        int_buffer_set zigzagOrder 28 7
        int_buffer_set zigzagOrder 29 14
        int_buffer_set zigzagOrder 30 21
        int_buffer_set zigzagOrder 31 28
        int_buffer_set zigzagOrder 32 35
        int_buffer_set zigzagOrder 33 42
        int_buffer_set zigzagOrder 34 49
        int_buffer_set zigzagOrder 35 56
        int_buffer_set zigzagOrder 36 57
        int_buffer_set zigzagOrder 37 50
        int_buffer_set zigzagOrder 38 43
        int_buffer_set zigzagOrder 39 36
        int_buffer_set zigzagOrder 40 29
        int_buffer_set zigzagOrder 41 22
        int_buffer_set zigzagOrder 42 15
        int_buffer_set zigzagOrder 43 23
        int_buffer_set zigzagOrder 44 30
        int_buffer_set zigzagOrder 45 37
        int_buffer_set zigzagOrder 46 44
        int_buffer_set zigzagOrder 47 51
        int_buffer_set zigzagOrder 48 58
        int_buffer_set zigzagOrder 49 59
        int_buffer_set zigzagOrder 50 52
        int_buffer_set zigzagOrder 51 45
        int_buffer_set zigzagOrder 52 38
        int_buffer_set zigzagOrder 53 31
        int_buffer_set zigzagOrder 54 39
        int_buffer_set zigzagOrder 55 46
        int_buffer_set zigzagOrder 56 53
        int_buffer_set zigzagOrder 57 60
        int_buffer_set zigzagOrder 58 61
        int_buffer_set zigzagOrder 59 54
        int_buffer_set zigzagOrder 60 47
        int_buffer_set zigzagOrder 61 55
        int_buffer_set zigzagOrder 62 62
        int_buffer_set zigzagOrder 63 63
    }
    
    fn dct1d:void (input:int_buffer startIdx:int stride:int output:int_buffer outIdx:int outStride:int) {
        ; 1D DCT: F(u) = C(u)/2 * sum over x of: f(x) * cos((2x+1)*u*pi/16)
        ; C(0) = 1/sqrt(2), C(u>0) = 1
        
        def u 0
        while (u < 8) {
            def sum:int 0
            def x 0
            while (x < 8) {
                def pixel:int (int_buffer_get input (startIdx + (x * stride)))
                def cosVal:int (int_buffer_get cosTable ((x * 8) + u))
                sum = sum + (pixel * cosVal)
                x = x + 1
            }
            ; Apply C(u) normalization: C(0) = 1/sqrt(2) ≈ 724/1024
            if (u == 0) {
                sum = (bit_shr (sum * 724) 10)
            }
            ; Scale down: cosTable is *1024, so shift right 10 bits
            ; Then divide by 2*sqrt(2) for proper DCT normalization ≈ shift 1 more
            int_buffer_set output (outIdx + (u * outStride)) (bit_shr sum 11)
            u = u + 1
        }
    }
    
    fn transform:int_buffer (pixels:int_buffer) {
        ; Perform 2D DCT on 8x8 block
        ; Level shift first: subtract 128
        def shifted:int_buffer (int_buffer_alloc 64)
        def i 0
        while (i < 64) {
            int_buffer_set shifted i ((int_buffer_get pixels i) - 128)
            i = i + 1
        }
        
        ; Temporary buffer
        def temp:int_buffer (int_buffer_alloc 64)
        
        ; First pass: 1D DCT on rows
        def row 0
        while (row < 8) {
            def rowStart:int (row * 8)
            this.dct1d(shifted rowStart 1 temp rowStart 1)
            row = row + 1
        }
        
        ; Output coefficients
        def coeffs:int_buffer (int_buffer_alloc 64)
        
        ; Second pass: 1D DCT on columns
        def col 0
        while (col < 8) {
            this.dct1d(temp col 8 coeffs col 8)
            col = col + 1
        }
        
        return coeffs
    }
    
    fn zigzag:int_buffer (block:int_buffer) {
        ; Convert from row-major to zigzag order
        def zigzagOut:int_buffer (int_buffer_alloc 64)
        def i 0
        while (i < 64) {
            def pos:int (int_buffer_get zigzagOrder i)
            int_buffer_set zigzagOut i (int_buffer_get block pos)
            i = i + 1
        }
        return zigzagOut
    }
}

; Bit writer for encoding - uses GrowableBuffer for unlimited size
class BitWriter {
    def buffer:GrowableBuffer (new GrowableBuffer())
    def bitBuffer:int 0
    def bitCount:int 0
    
    Constructor () {
        ; buffer already initialized
    }
    
    fn writeBit:void (bit:int) {
        bitBuffer = (bit_shl bitBuffer 1)
        bitBuffer = (bit_or bitBuffer (bit_and bit 1))
        bitCount = bitCount + 1
        
        if (bitCount == 8) {
            this.flushByte()
        }
    }
    
    fn writeBits:void (value:int numBits:int) {
        ; Write bits from MSB to LSB
        def i:int (numBits - 1)
        while (i >= 0) {
            def bit:int (bit_and (bit_shr value i) 1)
            this.writeBit(bit)
            i = i - 1
        }
    }
    
    fn flushByte:void () {
        if (bitCount > 0) {
            ; Pad remaining bits with 1s
            while (bitCount < 8) {
                bitBuffer = (bit_shl bitBuffer 1)
                bitBuffer = (bit_or bitBuffer 1)
                bitCount = bitCount + 1
            }
            
            ; Write byte and check for byte stuffing (0xFF needs 0x00 after it)
            buffer.writeByte(bitBuffer)
            
            if (bitBuffer == 255) {
                buffer.writeByte(0)
            }
            
            bitBuffer = 0
            bitCount = 0
        }
    }
    
    fn writeByte:void (b:int) {
        this.flushByte()
        buffer.writeByte(b)
    }
    
    fn writeWord:void (w:int) {
        ; Big endian
        this.writeByte((bit_shr w 8))
        this.writeByte((bit_and w 255))
    }
    
    fn getBuffer:buffer () {
        this.flushByte()
        return (buffer.toBuffer())
    }
    
    fn getLength:int () {
        return (buffer.size())
    }
}

; JPEG Encoder main class
class JPEGEncoder {
    def fdct:FDCT
    def quality:int 75
    
    ; Quantization tables
    def yQuantTable:[int]
    def cQuantTable:[int]
    
    ; Standard luminance quantization table
    def stdYQuant:[int]
    ; Standard chrominance quantization table
    def stdCQuant:[int]
    
    ; Huffman tables (simplified - using standard JPEG tables)
    ; DC luminance
    def dcYBits:[int]
    def dcYValues:[int]
    ; AC luminance
    def acYBits:[int]
    def acYValues:[int]
    ; DC chrominance
    def dcCBits:[int]
    def dcCValues:[int]
    ; AC chrominance
    def acCBits:[int]
    def acCValues:[int]
    
    ; Huffman encoding lookup tables
    def dcYCodes:[int]
    def dcYLengths:[int]
    def acYCodes:[int]
    def acYLengths:[int]
    def dcCCodes:[int]
    def dcCLengths:[int]
    def acCCodes:[int]
    def acCLengths:[int]
    
    ; Previous DC values for differential encoding
    def prevDCY:int 0
    def prevDCCb:int 0
    def prevDCCr:int 0
    
    Constructor () {
        fdct = (new FDCT())
        this.initQuantTables()
        this.initHuffmanTables()
    }
    
    fn initQuantTables:void () {
        ; Standard JPEG luminance quantization table
        push stdYQuant 16
        push stdYQuant 11
        push stdYQuant 10
        push stdYQuant 16
        push stdYQuant 24
        push stdYQuant 40
        push stdYQuant 51
        push stdYQuant 61
        push stdYQuant 12
        push stdYQuant 12
        push stdYQuant 14
        push stdYQuant 19
        push stdYQuant 26
        push stdYQuant 58
        push stdYQuant 60
        push stdYQuant 55
        push stdYQuant 14
        push stdYQuant 13
        push stdYQuant 16
        push stdYQuant 24
        push stdYQuant 40
        push stdYQuant 57
        push stdYQuant 69
        push stdYQuant 56
        push stdYQuant 14
        push stdYQuant 17
        push stdYQuant 22
        push stdYQuant 29
        push stdYQuant 51
        push stdYQuant 87
        push stdYQuant 80
        push stdYQuant 62
        push stdYQuant 18
        push stdYQuant 22
        push stdYQuant 37
        push stdYQuant 56
        push stdYQuant 68
        push stdYQuant 109
        push stdYQuant 103
        push stdYQuant 77
        push stdYQuant 24
        push stdYQuant 35
        push stdYQuant 55
        push stdYQuant 64
        push stdYQuant 81
        push stdYQuant 104
        push stdYQuant 113
        push stdYQuant 92
        push stdYQuant 49
        push stdYQuant 64
        push stdYQuant 78
        push stdYQuant 87
        push stdYQuant 103
        push stdYQuant 121
        push stdYQuant 120
        push stdYQuant 101
        push stdYQuant 72
        push stdYQuant 92
        push stdYQuant 95
        push stdYQuant 98
        push stdYQuant 112
        push stdYQuant 100
        push stdYQuant 103
        push stdYQuant 99
        
        ; Standard JPEG chrominance quantization table
        push stdCQuant 17
        push stdCQuant 18
        push stdCQuant 24
        push stdCQuant 47
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 18
        push stdCQuant 21
        push stdCQuant 26
        push stdCQuant 66
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 24
        push stdCQuant 26
        push stdCQuant 56
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 47
        push stdCQuant 66
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        push stdCQuant 99
        
        ; Scale tables based on quality
        this.scaleQuantTables(quality)
    }
    
    fn scaleQuantTables:void (q:int) {
        ; Scale factor: q < 50 => scale = 5000/q, q >= 50 => scale = 200 - 2*q
        def scale:int 0
        if (q < 50) {
            scale = (to_int (5000 / q))
        } {
            scale = 200 - (q * 2)
        }
        
        clear yQuantTable
        clear cQuantTable
        
        def i 0
        while (i < 64) {
            ; Y table
            def yVal:int (to_int (((at stdYQuant i) * scale + 50) / 100))
            if (yVal < 1) { yVal = 1 }
            if (yVal > 255) { yVal = 255 }
            push yQuantTable yVal
            
            ; C table
            def cVal:int (to_int (((at stdCQuant i) * scale + 50) / 100))
            if (cVal < 1) { cVal = 1 }
            if (cVal > 255) { cVal = 255 }
            push cQuantTable cVal
            
            i = i + 1
        }
    }
    
    fn initHuffmanTables:void () {
        ; Standard JPEG Huffman tables
        ; DC Luminance bits (number of codes of each length 1-16)
        push dcYBits 0
        push dcYBits 1
        push dcYBits 5
        push dcYBits 1
        push dcYBits 1
        push dcYBits 1
        push dcYBits 1
        push dcYBits 1
        push dcYBits 1
        push dcYBits 0
        push dcYBits 0
        push dcYBits 0
        push dcYBits 0
        push dcYBits 0
        push dcYBits 0
        push dcYBits 0
        
        ; DC Luminance values
        push dcYValues 0
        push dcYValues 1
        push dcYValues 2
        push dcYValues 3
        push dcYValues 4
        push dcYValues 5
        push dcYValues 6
        push dcYValues 7
        push dcYValues 8
        push dcYValues 9
        push dcYValues 10
        push dcYValues 11
        
        ; AC Luminance bits
        push acYBits 0
        push acYBits 2
        push acYBits 1
        push acYBits 3
        push acYBits 3
        push acYBits 2
        push acYBits 4
        push acYBits 3
        push acYBits 5
        push acYBits 5
        push acYBits 4
        push acYBits 4
        push acYBits 0
        push acYBits 0
        push acYBits 1
        push acYBits 125
        
        ; AC Luminance values (162 values total)
        push acYValues 1
        push acYValues 2
        push acYValues 3
        push acYValues 0
        push acYValues 4
        push acYValues 17
        push acYValues 5
        push acYValues 18
        push acYValues 33
        push acYValues 49
        push acYValues 65
        push acYValues 6
        push acYValues 19
        push acYValues 81
        push acYValues 97
        push acYValues 7
        push acYValues 34
        push acYValues 113
        push acYValues 20
        push acYValues 50
        push acYValues 129
        push acYValues 145
        push acYValues 161
        push acYValues 8
        push acYValues 35
        push acYValues 66
        push acYValues 177
        push acYValues 193
        push acYValues 21
        push acYValues 82
        push acYValues 209
        push acYValues 240
        push acYValues 36
        push acYValues 51
        push acYValues 98
        push acYValues 114
        push acYValues 130
        push acYValues 9
        push acYValues 10
        push acYValues 22
        push acYValues 23
        push acYValues 24
        push acYValues 25
        push acYValues 26
        push acYValues 37
        push acYValues 38
        push acYValues 39
        push acYValues 40
        push acYValues 41
        push acYValues 42
        push acYValues 52
        push acYValues 53
        push acYValues 54
        push acYValues 55
        push acYValues 56
        push acYValues 57
        push acYValues 58
        push acYValues 67
        push acYValues 68
        push acYValues 69
        push acYValues 70
        push acYValues 71
        push acYValues 72
        push acYValues 73
        push acYValues 74
        push acYValues 83
        push acYValues 84
        push acYValues 85
        push acYValues 86
        push acYValues 87
        push acYValues 88
        push acYValues 89
        push acYValues 90
        push acYValues 99
        push acYValues 100
        push acYValues 101
        push acYValues 102
        push acYValues 103
        push acYValues 104
        push acYValues 105
        push acYValues 106
        push acYValues 115
        push acYValues 116
        push acYValues 117
        push acYValues 118
        push acYValues 119
        push acYValues 120
        push acYValues 121
        push acYValues 122
        push acYValues 131
        push acYValues 132
        push acYValues 133
        push acYValues 134
        push acYValues 135
        push acYValues 136
        push acYValues 137
        push acYValues 138
        push acYValues 146
        push acYValues 147
        push acYValues 148
        push acYValues 149
        push acYValues 150
        push acYValues 151
        push acYValues 152
        push acYValues 153
        push acYValues 154
        push acYValues 162
        push acYValues 163
        push acYValues 164
        push acYValues 165
        push acYValues 166
        push acYValues 167
        push acYValues 168
        push acYValues 169
        push acYValues 170
        push acYValues 178
        push acYValues 179
        push acYValues 180
        push acYValues 181
        push acYValues 182
        push acYValues 183
        push acYValues 184
        push acYValues 185
        push acYValues 186
        push acYValues 194
        push acYValues 195
        push acYValues 196
        push acYValues 197
        push acYValues 198
        push acYValues 199
        push acYValues 200
        push acYValues 201
        push acYValues 202
        push acYValues 210
        push acYValues 211
        push acYValues 212
        push acYValues 213
        push acYValues 214
        push acYValues 215
        push acYValues 216
        push acYValues 217
        push acYValues 218
        push acYValues 225
        push acYValues 226
        push acYValues 227
        push acYValues 228
        push acYValues 229
        push acYValues 230
        push acYValues 231
        push acYValues 232
        push acYValues 233
        push acYValues 234
        push acYValues 241
        push acYValues 242
        push acYValues 243
        push acYValues 244
        push acYValues 245
        push acYValues 246
        push acYValues 247
        push acYValues 248
        push acYValues 249
        push acYValues 250
        
        ; DC Chrominance bits
        push dcCBits 0
        push dcCBits 3
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 1
        push dcCBits 0
        push dcCBits 0
        push dcCBits 0
        push dcCBits 0
        push dcCBits 0
        
        ; DC Chrominance values
        push dcCValues 0
        push dcCValues 1
        push dcCValues 2
        push dcCValues 3
        push dcCValues 4
        push dcCValues 5
        push dcCValues 6
        push dcCValues 7
        push dcCValues 8
        push dcCValues 9
        push dcCValues 10
        push dcCValues 11
        
        ; AC Chrominance bits
        push acCBits 0
        push acCBits 2
        push acCBits 1
        push acCBits 2
        push acCBits 4
        push acCBits 4
        push acCBits 3
        push acCBits 4
        push acCBits 7
        push acCBits 5
        push acCBits 4
        push acCBits 4
        push acCBits 0
        push acCBits 1
        push acCBits 2
        push acCBits 119
        
        ; AC Chrominance values (162 values total)
        push acCValues 0
        push acCValues 1
        push acCValues 2
        push acCValues 3
        push acCValues 17
        push acCValues 4
        push acCValues 5
        push acCValues 33
        push acCValues 49
        push acCValues 6
        push acCValues 18
        push acCValues 65
        push acCValues 81
        push acCValues 7
        push acCValues 97
        push acCValues 113
        push acCValues 19
        push acCValues 34
        push acCValues 50
        push acCValues 129
        push acCValues 8
        push acCValues 20
        push acCValues 66
        push acCValues 145
        push acCValues 161
        push acCValues 177
        push acCValues 193
        push acCValues 9
        push acCValues 35
        push acCValues 51
        push acCValues 82
        push acCValues 240
        push acCValues 21
        push acCValues 98
        push acCValues 114
        push acCValues 209
        push acCValues 10
        push acCValues 22
        push acCValues 36
        push acCValues 52
        push acCValues 225
        push acCValues 37
        push acCValues 241
        push acCValues 23
        push acCValues 24
        push acCValues 25
        push acCValues 26
        push acCValues 38
        push acCValues 39
        push acCValues 40
        push acCValues 41
        push acCValues 42
        push acCValues 53
        push acCValues 54
        push acCValues 55
        push acCValues 56
        push acCValues 57
        push acCValues 58
        push acCValues 67
        push acCValues 68
        push acCValues 69
        push acCValues 70
        push acCValues 71
        push acCValues 72
        push acCValues 73
        push acCValues 74
        push acCValues 83
        push acCValues 84
        push acCValues 85
        push acCValues 86
        push acCValues 87
        push acCValues 88
        push acCValues 89
        push acCValues 90
        push acCValues 99
        push acCValues 100
        push acCValues 101
        push acCValues 102
        push acCValues 103
        push acCValues 104
        push acCValues 105
        push acCValues 106
        push acCValues 115
        push acCValues 116
        push acCValues 117
        push acCValues 118
        push acCValues 119
        push acCValues 120
        push acCValues 121
        push acCValues 122
        push acCValues 130
        push acCValues 131
        push acCValues 132
        push acCValues 133
        push acCValues 134
        push acCValues 135
        push acCValues 136
        push acCValues 137
        push acCValues 138
        push acCValues 146
        push acCValues 147
        push acCValues 148
        push acCValues 149
        push acCValues 150
        push acCValues 151
        push acCValues 152
        push acCValues 153
        push acCValues 154
        push acCValues 162
        push acCValues 163
        push acCValues 164
        push acCValues 165
        push acCValues 166
        push acCValues 167
        push acCValues 168
        push acCValues 169
        push acCValues 170
        push acCValues 178
        push acCValues 179
        push acCValues 180
        push acCValues 181
        push acCValues 182
        push acCValues 183
        push acCValues 184
        push acCValues 185
        push acCValues 186
        push acCValues 194
        push acCValues 195
        push acCValues 196
        push acCValues 197
        push acCValues 198
        push acCValues 199
        push acCValues 200
        push acCValues 201
        push acCValues 202
        push acCValues 210
        push acCValues 211
        push acCValues 212
        push acCValues 213
        push acCValues 214
        push acCValues 215
        push acCValues 216
        push acCValues 217
        push acCValues 218
        push acCValues 226
        push acCValues 227
        push acCValues 228
        push acCValues 229
        push acCValues 230
        push acCValues 231
        push acCValues 232
        push acCValues 233
        push acCValues 234
        push acCValues 242
        push acCValues 243
        push acCValues 244
        push acCValues 245
        push acCValues 246
        push acCValues 247
        push acCValues 248
        push acCValues 249
        push acCValues 250
        
        ; Initialize lookup tables with 256 entries each
        def i 0
        while (i < 256) {
            push dcYCodes 0
            push dcYLengths 0
            push acYCodes 0
            push acYLengths 0
            push dcCCodes 0
            push dcCLengths 0
            push acCCodes 0
            push acCLengths 0
            i = i + 1
        }
        
        ; Build encoding lookup tables
        this.buildHuffmanCodes(dcYBits dcYValues dcYCodes dcYLengths)
        this.buildHuffmanCodes(acYBits acYValues acYCodes acYLengths)
        this.buildHuffmanCodes(dcCBits dcCValues dcCCodes dcCLengths)
        this.buildHuffmanCodes(acCBits acCValues acCCodes acCLengths)
    }
    
    fn buildHuffmanCodes:void (bits:[int] values:[int] codes:[int] lengths:[int]) {
        ; Build lookup table: codes[symbol] = huffman code, lengths[symbol] = code length
        ; NOTE: codes and lengths must be pre-initialized with 256 zeros
        
        ; Generate codes
        def code:int 0
        def valueIdx:int 0
        
        def bitLen 1
        while (bitLen <= 16) {
            def count:int (at bits (bitLen - 1))
            def j 0
            while (j < count) {
                def symbol:int (at values valueIdx)
                set codes symbol code
                set lengths symbol bitLen
                code = code + 1
                valueIdx = valueIdx + 1
                j = j + 1
            }
            code = (bit_shl code 1)
            bitLen = bitLen + 1
        }
    }
    
    fn getCategory:int (value:int) {
        ; Get the category (number of bits needed) for a value
        if (value < 0) {
            value = 0 - value
        }
        if (value == 0) { return 0 }
        
        def cat:int 0
        while (value > 0) {
            cat = cat + 1
            value = (bit_shr value 1)
        }
        return cat
    }
    
    fn encodeNumber:int (value:int category:int) {
        ; Encode a number in its category
        ; Positive numbers: just the value
        ; Negative numbers: value - 1 (complement)
        if (value < 0) {
            return value + ((bit_shl 1 category) - 1)
        }
        return value
    }
    
    fn encodeBlock:void (writer:BitWriter coeffs:int_buffer quantTable:[int] dcCodes:[int] dcLengths:[int] acCodes:[int] acLengths:[int] prevDC:int) {
        ; Quantize coefficients
        def quantized:int_buffer (int_buffer_alloc 64)
        def i 0
        while (i < 64) {
            def q:int (at quantTable i)
            def c:int (int_buffer_get coeffs i)
            ; Round to nearest integer during quantization
            def qVal:int 0
            if (c >= 0) {
                qVal = (to_int ((c + (bit_shr q 1)) / q))
            } {
                qVal = (to_int ((c - (bit_shr q 1)) / q))
            }
            int_buffer_set quantized i qVal
            i = i + 1
        }
        
        ; Zigzag reorder
        def zigzagged:int_buffer (fdct.zigzag(quantized))
        
        ; Encode DC coefficient (differential)
        def dc:int (int_buffer_get zigzagged 0)
        def dcDiff:int (dc - prevDC)
        def dcCat:int (this.getCategory(dcDiff))
        
        ; Write DC Huffman code
        def dcCode:int (at dcCodes dcCat)
        def dcLen:int (at dcLengths dcCat)
        writer.writeBits(dcCode dcLen)
        
        ; Write DC value if non-zero
        if (dcCat > 0) {
            def dcVal:int (this.encodeNumber(dcDiff dcCat))
            writer.writeBits(dcVal dcCat)
        }
        
        ; Encode AC coefficients
        def zeroRun:int 0
        def k 1
        while (k < 64) {
            def ac:int (int_buffer_get zigzagged k)
            
            if (ac == 0) {
                zeroRun = zeroRun + 1
            } {
                ; Write any ZRL (16 zeros) symbols needed
                while (zeroRun >= 16) {
                    ; ZRL = 0xF0
                    def zrlCode:int (at acCodes 240)
                    def zrlLen:int (at acLengths 240)
                    writer.writeBits(zrlCode zrlLen)
                    zeroRun = zeroRun - 16
                }
                
                ; Write run/category symbol
                def acCat:int (this.getCategory(ac))
                def runCat:int (bit_or (bit_shl zeroRun 4) acCat)
                def acHuffCode:int (at acCodes runCat)
                def acHuffLen:int (at acLengths runCat)
                writer.writeBits(acHuffCode acHuffLen)
                
                ; Write AC value
                def acVal:int (this.encodeNumber(ac acCat))
                writer.writeBits(acVal acCat)
                
                zeroRun = 0
            }
            k = k + 1
        }
        
        ; Write EOB if there are trailing zeros
        if (zeroRun > 0) {
            def eobCode:int (at acCodes 0)
            def eobLen:int (at acLengths 0)
            writer.writeBits(eobCode eobLen)
        }
    }
    
    fn rgbToYCbCr:void (r:int g:int b:int yOut:[int] cbOut:[int] crOut:[int]) {
        ; RGB to YCbCr conversion using integer arithmetic
        ; Y  =  0.299*R + 0.587*G + 0.114*B
        ; Cb = -0.169*R - 0.331*G + 0.500*B + 128
        ; Cr =  0.500*R - 0.419*G - 0.081*B + 128
        
        def y:int (bit_shr ((77 * r) + (150 * g) + (29 * b)) 8)
        def cb:int (bit_shr ((0 - (43 * r)) - (85 * g) + (128 * b)) 8) + 128
        def cr:int (bit_shr ((128 * r) - (107 * g) - (21 * b)) 8) + 128
        
        if (y < 0) { y = 0 }
        if (y > 255) { y = 255 }
        if (cb < 0) { cb = 0 }
        if (cb > 255) { cb = 255 }
        if (cr < 0) { cr = 0 }
        if (cr > 255) { cr = 255 }
        
        push yOut y
        push cbOut cb
        push crOut cr
    }
    
    fn extractBlock:int_buffer (img:ImageBuffer blockX:int blockY:int channel:int) {
        ; Extract 8x8 block of a channel (0=Y, 1=Cb, 2=Cr)
        def output:int_buffer (int_buffer_alloc 64)
        def idx 0
        
        def py 0
        while (py < 8) {
            def px 0
            while (px < 8) {
                def imgX:int (blockX + px)
                def imgY:int (blockY + py)
                
                ; Clamp to image bounds
                if (imgX >= img.width) { imgX = img.width - 1 }
                if (imgY >= img.height) { imgY = img.height - 1 }
                
                def c:Color (img.getPixel(imgX imgY))
                
                ; Convert to YCbCr on the fly
                def y:int (bit_shr ((77 * c.r) + (150 * c.g) + (29 * c.b)) 8)
                def cb:int (bit_shr ((0 - (43 * c.r)) - (85 * c.g) + (128 * c.b)) 8) + 128
                def cr:int (bit_shr ((128 * c.r) - (107 * c.g) - (21 * c.b)) 8) + 128
                
                if (channel == 0) {
                    int_buffer_set output idx y
                } 
                if (channel == 1) {
                    int_buffer_set output idx cb
                }
                if (channel == 2) {
                    int_buffer_set output idx cr
                }
                
                idx = idx + 1
                px = px + 1
            }
            py = py + 1
        }
        return output
    }
    
    fn writeMarkers:void (writer:BitWriter width:int height:int) {
        ; SOI - Start of Image
        writer.writeByte(255)
        writer.writeByte(216)
        
        ; APP0 - JFIF marker
        writer.writeByte(255)
        writer.writeByte(224)
        writer.writeWord(16)  ; Length
        writer.writeByte(74)  ; J
        writer.writeByte(70)  ; F
        writer.writeByte(73)  ; I
        writer.writeByte(70)  ; F
        writer.writeByte(0)   ; Null
        writer.writeByte(1)   ; Version major
        writer.writeByte(1)   ; Version minor
        writer.writeByte(0)   ; Units (0 = no units)
        writer.writeWord(1)   ; X density
        writer.writeWord(1)   ; Y density
        writer.writeByte(0)   ; Thumbnail width
        writer.writeByte(0)   ; Thumbnail height
        
        ; DQT - Quantization tables
        ; Table 0 (luminance)
        writer.writeByte(255)
        writer.writeByte(219)
        writer.writeWord(67)  ; Length = 2 + 1 + 64
        writer.writeByte(0)   ; Table ID 0, 8-bit precision
        def i 0
        while (i < 64) {
            writer.writeByte((at yQuantTable (int_buffer_get fdct.zigzagOrder i)))
            i = i + 1
        }
        
        ; Table 1 (chrominance)
        writer.writeByte(255)
        writer.writeByte(219)
        writer.writeWord(67)
        writer.writeByte(1)   ; Table ID 1
        i = 0
        while (i < 64) {
            writer.writeByte((at cQuantTable (int_buffer_get fdct.zigzagOrder i)))
            i = i + 1
        }
        
        ; SOF0 - Start of Frame (Baseline DCT)
        writer.writeByte(255)
        writer.writeByte(192)
        writer.writeWord(17)  ; Length = 8 + 3*components
        writer.writeByte(8)   ; Precision (8 bits)
        writer.writeWord(height)
        writer.writeWord(width)
        writer.writeByte(3)   ; Number of components
        ; Component 1: Y
        writer.writeByte(1)   ; Component ID
        writer.writeByte(17)  ; Sampling: 1x1 (0x11)
        writer.writeByte(0)   ; Quant table 0
        ; Component 2: Cb
        writer.writeByte(2)
        writer.writeByte(17)  ; 1x1
        writer.writeByte(1)   ; Quant table 1
        ; Component 3: Cr
        writer.writeByte(3)
        writer.writeByte(17)  ; 1x1
        writer.writeByte(1)   ; Quant table 1
        
        ; DHT - Huffman tables
        ; DC Luminance (table 0)
        writer.writeByte(255)
        writer.writeByte(196)
        writer.writeWord(31)  ; Length
        writer.writeByte(0)   ; DC table 0
        i = 0
        while (i < 16) {
            writer.writeByte((at dcYBits i))
            i = i + 1
        }
        i = 0
        while (i < 12) {
            writer.writeByte((at dcYValues i))
            i = i + 1
        }
        
        ; AC Luminance (table 0)
        writer.writeByte(255)
        writer.writeByte(196)
        writer.writeWord(181)  ; Length = 2 + 1 + 16 + 162
        writer.writeByte(16)   ; AC table 0
        i = 0
        while (i < 16) {
            writer.writeByte((at acYBits i))
            i = i + 1
        }
        i = 0
        while (i < 162) {
            writer.writeByte((at acYValues i))
            i = i + 1
        }
        
        ; DC Chrominance (table 1)
        writer.writeByte(255)
        writer.writeByte(196)
        writer.writeWord(31)
        writer.writeByte(1)   ; DC table 1
        i = 0
        while (i < 16) {
            writer.writeByte((at dcCBits i))
            i = i + 1
        }
        i = 0
        while (i < 12) {
            writer.writeByte((at dcCValues i))
            i = i + 1
        }
        
        ; AC Chrominance (table 1)
        writer.writeByte(255)
        writer.writeByte(196)
        writer.writeWord(181)
        writer.writeByte(17)  ; AC table 1
        i = 0
        while (i < 16) {
            writer.writeByte((at acCBits i))
            i = i + 1
        }
        i = 0
        while (i < 162) {
            writer.writeByte((at acCValues i))
            i = i + 1
        }
        
        ; SOS - Start of Scan
        writer.writeByte(255)
        writer.writeByte(218)
        writer.writeWord(12)  ; Length
        writer.writeByte(3)   ; Number of components
        ; Component 1: Y
        writer.writeByte(1)   ; Component ID
        writer.writeByte(0)   ; DC table 0, AC table 0
        ; Component 2: Cb
        writer.writeByte(2)
        writer.writeByte(17)  ; DC table 1, AC table 1
        ; Component 3: Cr
        writer.writeByte(3)
        writer.writeByte(17)  ; DC table 1, AC table 1
        writer.writeByte(0)   ; Spectral selection start
        writer.writeByte(63)  ; Spectral selection end
        writer.writeByte(0)   ; Successive approximation
    }
    
    fn encodeToBuffer:buffer (img:ImageBuffer) {
        ; Encode image to a buffer (for PDF embedding)
        def writer (new BitWriter())
        
        ; Write JPEG headers
        this.writeMarkers(writer img.width img.height)
        
        ; Calculate MCU grid
        def mcuWidth:int (to_int ((img.width + 7) / 8))
        def mcuHeight:int (to_int ((img.height + 7) / 8))
        
        ; Reset DC predictors
        prevDCY = 0
        prevDCCb = 0
        prevDCCr = 0
        
        ; Encode MCU by MCU
        def mcuY 0
        while (mcuY < mcuHeight) {
            def mcuX 0
            while (mcuX < mcuWidth) {
                def blockX:int (mcuX * 8)
                def blockY:int (mcuY * 8)
                
                ; Extract and encode Y block
                def yBlock:int_buffer (this.extractBlock(img blockX blockY 0))
                def yCoeffs:int_buffer (fdct.transform(yBlock))
                this.encodeBlock(writer yCoeffs yQuantTable dcYCodes dcYLengths acYCodes acYLengths prevDCY)
                
                ; Update DC predictor
                def yZig:int_buffer (fdct.zigzag(yCoeffs))
                def yQ:int (at yQuantTable 0)
                def yDC:int (int_buffer_get yZig 0)
                if (yDC >= 0) {
                    prevDCY = (to_int ((yDC + (bit_shr yQ 1)) / yQ))
                } {
                    prevDCY = (to_int ((yDC - (bit_shr yQ 1)) / yQ))
                }
                
                ; Extract and encode Cb block
                def cbBlock:int_buffer (this.extractBlock(img blockX blockY 1))
                def cbCoeffs:int_buffer (fdct.transform(cbBlock))
                this.encodeBlock(writer cbCoeffs cQuantTable dcCCodes dcCLengths acCCodes acCLengths prevDCCb)
                
                def cbZig:int_buffer (fdct.zigzag(cbCoeffs))
                def cbQ:int (at cQuantTable 0)
                def cbDC:int (int_buffer_get cbZig 0)
                if (cbDC >= 0) {
                    prevDCCb = (to_int ((cbDC + (bit_shr cbQ 1)) / cbQ))
                } {
                    prevDCCb = (to_int ((cbDC - (bit_shr cbQ 1)) / cbQ))
                }
                
                ; Extract and encode Cr block
                def crBlock:int_buffer (this.extractBlock(img blockX blockY 2))
                def crCoeffs:int_buffer (fdct.transform(crBlock))
                this.encodeBlock(writer crCoeffs cQuantTable dcCCodes dcCLengths acCCodes acCLengths prevDCCr)
                
                def crZig:int_buffer (fdct.zigzag(crCoeffs))
                def crQ:int (at cQuantTable 0)
                def crDC:int (int_buffer_get crZig 0)
                if (crDC >= 0) {
                    prevDCCr = (to_int ((crDC + (bit_shr crQ 1)) / crQ))
                } {
                    prevDCCr = (to_int ((crDC - (bit_shr crQ 1)) / crQ))
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
        
        ; Flush remaining bits
        writer.flushByte()
        
        ; Write EOI marker directly to buffer
        def outBuf:buffer (writer.getBuffer())
        def outLen:int (writer.getLength())
        
        ; Create final buffer with EOI
        def finalBuf:buffer (buffer_alloc (outLen + 2))
        def i 0
        while (i < outLen) {
            buffer_set finalBuf i (buffer_get outBuf i)
            i = i + 1
        }
        buffer_set finalBuf outLen 255
        buffer_set finalBuf (outLen + 1) 217
        
        return finalBuf
    }
    
    fn encode:void (img:ImageBuffer dirPath:string fileName:string) {
        print ("Encoding JPEG: " + fileName)
        print ("  Image size: " + (to_string img.width) + "x" + (to_string img.height))
        
        def writer (new BitWriter())
        
        ; Write JPEG headers
        this.writeMarkers(writer img.width img.height)
        
        ; Calculate MCU grid
        def mcuWidth:int (to_int ((img.width + 7) / 8))
        def mcuHeight:int (to_int ((img.height + 7) / 8))
        print ("  MCU grid: " + (to_string mcuWidth) + "x" + (to_string mcuHeight))
        
        ; Reset DC predictors
        prevDCY = 0
        prevDCCb = 0
        prevDCCr = 0
        
        ; Encode MCU by MCU
        def mcuY 0
        while (mcuY < mcuHeight) {
            def mcuX 0
            while (mcuX < mcuWidth) {
                def blockX:int (mcuX * 8)
                def blockY:int (mcuY * 8)
                
                ; Extract and encode Y block
                def yBlock:int_buffer (this.extractBlock(img blockX blockY 0))
                def yCoeffs:int_buffer (fdct.transform(yBlock))
                this.encodeBlock(writer yCoeffs yQuantTable dcYCodes dcYLengths acYCodes acYLengths prevDCY)
                
                ; Update DC predictor
                def yZig:int_buffer (fdct.zigzag(yCoeffs))
                def yQ:int (at yQuantTable 0)
                def yDC:int (int_buffer_get yZig 0)
                if (yDC >= 0) {
                    prevDCY = (to_int ((yDC + (bit_shr yQ 1)) / yQ))
                } {
                    prevDCY = (to_int ((yDC - (bit_shr yQ 1)) / yQ))
                }
                
                ; Extract and encode Cb block
                def cbBlock:int_buffer (this.extractBlock(img blockX blockY 1))
                def cbCoeffs:int_buffer (fdct.transform(cbBlock))
                this.encodeBlock(writer cbCoeffs cQuantTable dcCCodes dcCLengths acCCodes acCLengths prevDCCb)
                
                def cbZig:int_buffer (fdct.zigzag(cbCoeffs))
                def cbQ:int (at cQuantTable 0)
                def cbDC:int (int_buffer_get cbZig 0)
                if (cbDC >= 0) {
                    prevDCCb = (to_int ((cbDC + (bit_shr cbQ 1)) / cbQ))
                } {
                    prevDCCb = (to_int ((cbDC - (bit_shr cbQ 1)) / cbQ))
                }
                
                ; Extract and encode Cr block
                def crBlock:int_buffer (this.extractBlock(img blockX blockY 2))
                def crCoeffs:int_buffer (fdct.transform(crBlock))
                this.encodeBlock(writer crCoeffs cQuantTable dcCCodes dcCLengths acCCodes acCLengths prevDCCr)
                
                def crZig:int_buffer (fdct.zigzag(crCoeffs))
                def crQ:int (at cQuantTable 0)
                def crDC:int (int_buffer_get crZig 0)
                if (crDC >= 0) {
                    prevDCCr = (to_int ((crDC + (bit_shr crQ 1)) / crQ))
                } {
                    prevDCCr = (to_int ((crDC - (bit_shr crQ 1)) / crQ))
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
        
        ; Flush remaining bits
        writer.flushByte()
        
        ; Write EOI marker directly to buffer
        def outBuf:buffer (writer.getBuffer())
        def outLen:int (writer.getLength())
        
        ; Create final buffer with EOI
        def finalBuf:buffer (buffer_alloc (outLen + 2))
        def i 0
        while (i < outLen) {
            buffer_set finalBuf i (buffer_get outBuf i)
            i = i + 1
        }
        buffer_set finalBuf outLen 255
        buffer_set finalBuf (outLen + 1) 217
        
        ; Write to file
        buffer_write_file dirPath fileName finalBuf
        
        print ("  Encoded size: " + (to_string (outLen + 2)) + " bytes")
        print ("  Saved: " + dirPath + "/" + fileName)
    }
    
    fn setQuality:void (q:int) {
        quality = q
        this.scaleQuantTables(q)
    }
}
