; DCT.rgr - Inverse Discrete Cosine Transform for JPEG decoding
; Uses integer arithmetic with fixed-point scaling

class IDCT {
    ; Precomputed cosine table: cos((2*x+1) * u * pi / 16) * 1024
    ; For each (x, u) pair where x,u = 0..7
    ; Table layout: cosTable[x * 8 + u] = cos value
    def cosTable:[int]
    
    ; Zigzag order to row-major index mapping
    def zigzagMap:[int]
    
    Constructor () {
        ; Initialize full cosine table for IDCT
        ; cos((2*x+1) * u * pi / 16) * 1024 for x=0..7, u=0..7
        ; Row x=0: u=0,1,2,3,4,5,6,7
        push cosTable 1024  ; cos(1*0*pi/16) = 1.000
        push cosTable 1004  ; cos(1*1*pi/16) = 0.981
        push cosTable 946   ; cos(1*2*pi/16) = 0.924
        push cosTable 851   ; cos(1*3*pi/16) = 0.831
        push cosTable 724   ; cos(1*4*pi/16) = 0.707
        push cosTable 569   ; cos(1*5*pi/16) = 0.556
        push cosTable 392   ; cos(1*6*pi/16) = 0.383
        push cosTable 200   ; cos(1*7*pi/16) = 0.195
        
        ; Row x=1: cos((3)*u*pi/16)
        push cosTable 1024
        push cosTable 851
        push cosTable 392
        push cosTable -200
        push cosTable -724
        push cosTable -1004
        push cosTable -946
        push cosTable -569
        
        ; Row x=2: cos((5)*u*pi/16)
        push cosTable 1024
        push cosTable 569
        push cosTable -392
        push cosTable -1004
        push cosTable -724
        push cosTable 200
        push cosTable 946
        push cosTable 851
        
        ; Row x=3: cos((7)*u*pi/16)
        push cosTable 1024
        push cosTable 200
        push cosTable -946
        push cosTable -569
        push cosTable 724
        push cosTable 851
        push cosTable -392
        push cosTable -1004
        
        ; Row x=4: cos((9)*u*pi/16)
        push cosTable 1024
        push cosTable -200
        push cosTable -946
        push cosTable 569
        push cosTable 724
        push cosTable -851
        push cosTable -392
        push cosTable 1004
        
        ; Row x=5: cos((11)*u*pi/16)
        push cosTable 1024
        push cosTable -569
        push cosTable -392
        push cosTable 1004
        push cosTable -724
        push cosTable -200
        push cosTable 946
        push cosTable -851
        
        ; Row x=6: cos((13)*u*pi/16)
        push cosTable 1024
        push cosTable -851
        push cosTable 392
        push cosTable 200
        push cosTable -724
        push cosTable 1004
        push cosTable -946
        push cosTable 569
        
        ; Row x=7: cos((15)*u*pi/16)
        push cosTable 1024
        push cosTable -1004
        push cosTable 946
        push cosTable -851
        push cosTable 724
        push cosTable -569
        push cosTable 392
        push cosTable -200
        
        ; Zigzag to row-major mapping (JPEG standard zigzag order)
        push zigzagMap 0
        push zigzagMap 1
        push zigzagMap 8
        push zigzagMap 16
        push zigzagMap 9
        push zigzagMap 2
        push zigzagMap 3
        push zigzagMap 10
        
        push zigzagMap 17
        push zigzagMap 24
        push zigzagMap 32
        push zigzagMap 25
        push zigzagMap 18
        push zigzagMap 11
        push zigzagMap 4
        push zigzagMap 5
        
        push zigzagMap 12
        push zigzagMap 19
        push zigzagMap 26
        push zigzagMap 33
        push zigzagMap 40
        push zigzagMap 48
        push zigzagMap 41
        push zigzagMap 34
        
        push zigzagMap 27
        push zigzagMap 20
        push zigzagMap 13
        push zigzagMap 6
        push zigzagMap 7
        push zigzagMap 14
        push zigzagMap 21
        push zigzagMap 28
        
        push zigzagMap 35
        push zigzagMap 42
        push zigzagMap 49
        push zigzagMap 56
        push zigzagMap 57
        push zigzagMap 50
        push zigzagMap 43
        push zigzagMap 36
        
        push zigzagMap 29
        push zigzagMap 22
        push zigzagMap 15
        push zigzagMap 23
        push zigzagMap 30
        push zigzagMap 37
        push zigzagMap 44
        push zigzagMap 51
        
        push zigzagMap 58
        push zigzagMap 59
        push zigzagMap 52
        push zigzagMap 45
        push zigzagMap 38
        push zigzagMap 31
        push zigzagMap 39
        push zigzagMap 46
        
        push zigzagMap 53
        push zigzagMap 60
        push zigzagMap 61
        push zigzagMap 54
        push zigzagMap 47
        push zigzagMap 55
        push zigzagMap 62
        push zigzagMap 63
    }
    
    fn dezigzag:[int] (zigzag:[int]) {
        ; Convert from zigzag order to row-major 8x8 block
        ; Returns new 64-element array
        def block:[int]
        def i 0
        while (i < 64) {
            push block 0
            i = i + 1
        }
        
        i = 0
        while (i < 64) {
            def pos:int (at zigzagMap i)
            set block pos (at zigzag i)
            i = i + 1
        }
        return block
    }
    
    fn idct1d:void (input:[int] startIdx:int stride:int output:[int] outIdx:int outStride:int) {
        ; 1D IDCT: output[x] = sum over u of: C(u) * input[u] * cos((2x+1)*u*pi/16)
        ; C(0) = 1/sqrt(2), C(u>0) = 1
        ; cosTable is scaled by 1024
        
        def x 0
        while (x < 8) {
            def sum:int 0
            def u 0
            while (u < 8) {
                def coeff:int (at input (startIdx + (u * stride)))
                if (coeff != 0) {
                    def cosVal:int (at cosTable ((x * 8) + u))
                    def contrib:int (coeff * cosVal)
                    if (u == 0) {
                        ; C(0) = 1/sqrt(2) â‰ˆ 724/1024
                        contrib = (bit_shr (contrib * 724) 10)
                    }
                    sum = sum + contrib
                }
                u = u + 1
            }
            ; Scale down by 1024 (cosine table scale) and divide by 2 for IDCT normalization
            set output (outIdx + (x * outStride)) (bit_shr sum 11)
            x = x + 1
        }
    }
    
    fn transform:void (block:[int] output:[int]) {
        ; Perform 2D IDCT on 8x8 block using separable method
        ; 2D IDCT = 1D IDCT on rows, then 1D IDCT on columns
        
        ; Temporary buffer for row transform results
        def temp:[int]
        def i 0
        while (i < 64) {
            push temp 0
            i = i + 1
        }
        
        ; First pass: 1D IDCT on each row
        def row 0
        while (row < 8) {
            def rowStart:int (row * 8)
            this.idct1d(block rowStart 1 temp rowStart 1)
            row = row + 1
        }
        
        ; Second pass: 1D IDCT on each column
        def col 0
        while (col < 8) {
            this.idct1d(temp col 8 output col 8)
            col = col + 1
        }
        
        ; Level shift: add 128 and clamp to 0-255
        ; The 2D transform has normalization factor of 1/4 already included via two 1D transforms
        i = 0
        while (i < 64) {
            def val:int ((at output i) + 128)
            if (val < 0) { val = 0 }
            if (val > 255) { val = 255 }
            set output i val
            i = i + 1
        }
    }
    
    fn transformFast:void (coeffs:[int] output:[int]) {
        this.transform(coeffs output)
    }
}
