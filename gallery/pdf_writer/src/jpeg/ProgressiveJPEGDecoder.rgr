; ProgressiveJPEGDecoder.rgr - Progressive JPEG decoder
; Progressive JPEG uses multiple scans to refine image quality

Import "../core/Buffer.rgr"
Import "BitReader.rgr"
Import "HuffmanDecoder.rgr"
Import "DCT.rgr"
Import "ImageBuffer.rgr"
Import "JPEGDecoder.rgr"

; Wrapper class for coefficient array (to allow array of arrays)
class CoeffBuffer {
    def coeffs:[int]
    def numBlocks:int 0
    
    Constructor () {
    }
    
    fn init:void (blocks:int) {
        numBlocks = blocks
        clear coeffs
        def numCoeffs:int (blocks * 64)
        def i 0
        while (i < numCoeffs) {
            push coeffs 0
            i = i + 1
        }
    }
    
    fn get:int (blockIdx:int k:int) {
        def offset:int ((blockIdx * 64) + k)
        return (at coeffs offset)
    }
    
    fn setVal:void (blockIdx:int k:int value:int) {
        def offset:int ((blockIdx * 64) + k)
        set coeffs offset value
    }
}

class ProgressiveJPEGDecoder {
    def data:buffer (buffer_alloc 0)
    def dataLen:int 0
    
    ; Image properties
    def width:int 0
    def height:int 0
    def numComponents:int 0
    def precision:int 8
    def isProgressive:boolean false
    
    ; Components
    def components:[JPEGComponent]
    
    ; Quantization tables (up to 4)
    def quantTables:[QuantizationTable]
    
    ; Huffman decoder
    def huffman:HuffmanDecoder (new HuffmanDecoder())
    
    ; DCT transformer
    def idct:IDCT (new IDCT())
    
    ; MCU dimensions
    def mcuWidth:int 8
    def mcuHeight:int 8
    def mcusPerRow:int 0
    def mcusPerCol:int 0
    def maxHSamp:int 1
    def maxVSamp:int 1
    
    ; Progressive coefficient storage
    def coeffBuffers:[CoeffBuffer]
    
    ; Scan parameters
    def scanSs:int 0
    def scanSe:int 63
    def scanAh:int 0
    def scanAl:int 0
    
    ; EOBRUN for AC successive approximation
    def eobrun:int 0
    
    Constructor () {
        huffman = (new HuffmanDecoder())
        idct = (new IDCT())
        
        def i 0
        while (i < 4) {
            push quantTables (new QuantizationTable())
            i = i + 1
        }
    }
    
    fn readUint16BE:int (pos:int) {
        def high:int (buffer_get data pos)
        def low:int (buffer_get data (pos + 1))
        return ((high * 256) + low)
    }
    
    fn parseSOF:void (pos:int length:int sofType:int) {
        precision = (buffer_get data pos)
        height = (this.readUint16BE(pos + 1))
        width = (this.readUint16BE(pos + 3))
        numComponents = (buffer_get data (pos + 5))
        
        if (sofType == 2) {
            isProgressive = true
            print ("  Progressive JPEG: " + (to_string width) + "x" + (to_string height) + ", " + (to_string numComponents) + " components")
        } {
            isProgressive = false
            print ("  Baseline JPEG: " + (to_string width) + "x" + (to_string height) + ", " + (to_string numComponents) + " components")
        }
        
        clear components
        maxHSamp = 1
        maxVSamp = 1
        
        def i 0
        def offset:int (pos + 6)
        while (i < numComponents) {
            def comp (new JPEGComponent())
            comp.id = (buffer_get data offset)
            def sampling:int (buffer_get data (offset + 1))
            comp.hSamp = (bit_shr sampling 4)
            comp.vSamp = (bit_and sampling 15)
            comp.quantTableId = (buffer_get data (offset + 2))
            
            if (comp.hSamp > maxHSamp) { maxHSamp = comp.hSamp }
            if (comp.vSamp > maxVSamp) { maxVSamp = comp.vSamp }
            
            push components comp
            print ("    Component " + (to_string comp.id) + ": " + (to_string comp.hSamp) + "x" + (to_string comp.vSamp) + " sampling")
            
            offset = offset + 3
            i = i + 1
        }
        
        mcuWidth = maxHSamp * 8
        mcuHeight = maxVSamp * 8
        mcusPerRow = (to_int ((width + mcuWidth - 1) / mcuWidth))
        mcusPerCol = (to_int ((height + mcuHeight - 1) / mcuHeight))
        
        print ("  MCU grid: " + (to_string mcusPerRow) + "x" + (to_string mcusPerCol))
        
        this.allocateCoeffBuffers()
    }
    
    fn allocateCoeffBuffers:void () {
        clear coeffBuffers
        def totalMCUs:int (mcusPerRow * mcusPerCol)
        
        def c 0
        while (c < numComponents) {
            def comp:JPEGComponent (at components c)
            def blocksInComp:int (totalMCUs * comp.hSamp * comp.vSamp)
            
            def buf (new CoeffBuffer())
            buf.init(blocksInComp)
            push coeffBuffers buf
            
            c = c + 1
        }
    }
    
    fn parseDQT:void (pos:int length:int) {
        def endPos:int (pos + length)
        
        while (pos < endPos) {
            def info:int (buffer_get data pos)
            pos = pos + 1
            
            def prec:int (bit_shr info 4)
            def tableId:int (bit_and info 15)
            
            def table:QuantizationTable (at quantTables tableId)
            table.id = tableId
            clear table.values
            
            def i 0
            while (i < 64) {
                if (prec == 0) {
                    push table.values (buffer_get data pos)
                    pos = pos + 1
                } {
                    push table.values (this.readUint16BE(pos))
                    pos = pos + 2
                }
                i = i + 1
            }
            
            print ("  Quantization table " + (to_string tableId))
        }
    }
    
    fn parseSOS:int (pos:int length:int) {
        def numScanComponents:int (buffer_get data pos)
        pos = pos + 1
        
        def scanComponents:[int]
        
        def i 0
        while (i < numScanComponents) {
            def compId:int (buffer_get data pos)
            def tableSelect:int (buffer_get data (pos + 1))
            pos = pos + 2
            
            def j 0
            while (j < numComponents) {
                def comp:JPEGComponent (at components j)
                if (comp.id == compId) {
                    comp.dcTableId = (bit_shr tableSelect 4)
                    comp.acTableId = (bit_and tableSelect 15)
                    push scanComponents j
                }
                j = j + 1
            }
            
            i = i + 1
        }
        
        scanSs = (buffer_get data pos)
        scanSe = (buffer_get data (pos + 1))
        def approx:int (buffer_get data (pos + 2))
        scanAh = (bit_shr approx 4)
        scanAl = (bit_and approx 15)
        pos = pos + 3
        
        def scanType:string "data"
        if ((scanSs == 0) && (scanSe == 0)) {
            if (scanAh == 0) {
                scanType = "DC first"
            } {
                scanType = "DC refine"
            }
        } {
            if (scanAh == 0) {
                scanType = "AC first"
            } {
                scanType = "AC refine"
            }
        }
        
        ; Print scan details with component info
        def compList:string ""
        def si 0
        while (si < (array_length scanComponents)) {
            if (si > 0) { compList = compList + "," }
            compList = compList + (to_string (at scanComponents si))
            si = si + 1
        }
        print ("    Scan: comps=[" + compList + "] Ss=" + (to_string scanSs) + " Se=" + (to_string scanSe) + " Ah=" + (to_string scanAh) + " Al=" + (to_string scanAl) + " (" + scanType + ")")
        
        ; Find scan data end
        def scanStart:int pos
        def searchPos:int pos
        while (searchPos < (dataLen - 1)) {
            def b:int (buffer_get data searchPos)
            if (b == 255) {
                def nextB:int (buffer_get data (searchPos + 1))
                if ((nextB != 0) && (nextB != 255)) {
                    if ((nextB >= 208) && (nextB <= 215)) {
                        searchPos = searchPos + 2
                        continue
                    }
                    break
                }
            }
            searchPos = searchPos + 1
        }
        def scanLen:int (searchPos - scanStart)
        
        def reader (new BitReader())
        reader.init(data scanStart scanLen)
        
        eobrun = 0
        
        ; Reset DC predictors for DC-first scans
        if ((scanSs == 0) && (scanAh == 0)) {
            def c 0
            while (c < numComponents) {
                def comp:JPEGComponent (at components c)
                comp.prevDC = 0
                c = c + 1
            }
        }
        
        if (isProgressive) {
            this.decodeProgressiveScan(reader scanComponents)
        } {
            this.decodeBaselineScan(reader scanComponents)
        }
        
        return searchPos
    }
    
    fn decodeProgressiveScan:void (reader:BitReader scanComps:[int]) {
        def numScanComps:int (array_length scanComps)
        
        def isDCFirst:boolean ((scanSs == 0) && (scanSe == 0) && (scanAh == 0))
        def isDCRefine:boolean ((scanSs == 0) && (scanSe == 0) && (scanAh > 0))
        def isACFirst:boolean ((scanSs > 0) && (scanAh == 0))
        def isACRefine:boolean ((scanSs > 0) && (scanAh > 0))
        
        if (numScanComps > 1) {
            this.decodeInterleavedDC(reader scanComps isDCFirst isDCRefine)
        } {
            def compIdx:int (at scanComps 0)
            if (isDCFirst) {
                this.decodeDCFirst(reader compIdx)
            }
            if (isDCRefine) {
                this.decodeDCRefine(reader compIdx)
            }
            if (isACFirst) {
                this.decodeACFirst(reader compIdx)
            }
            if (isACRefine) {
                this.decodeACRefine(reader compIdx)
            }
        }
    }
    
    fn decodeInterleavedDC:void (reader:BitReader scanComps:[int] isDCFirst:boolean isDCRefine:boolean) {
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def sc 0
                def numScanComps:int (array_length scanComps)
                while (sc < numScanComps) {
                    def compIdx:int (at scanComps sc)
                    def comp:JPEGComponent (at components compIdx)
                    def buf:CoeffBuffer (at coeffBuffers compIdx)
                    
                    def bv 0
                    while (bv < comp.vSamp) {
                        def bh 0
                        while (bh < comp.hSamp) {
                            def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                            
                            if (isDCFirst) {
                                def dcTable:HuffmanTable (huffman.getDCTable(comp.dcTableId))
                                def dcCategory:int (dcTable.decode(reader))
                                def dcDiff:int (reader.receiveExtend(dcCategory))
                                def dcValue:int (comp.prevDC + dcDiff)
                                comp.prevDC = dcValue
                                buf.setVal(blockIdx 0 (bit_shl dcValue scanAl))
                            }
                            if (isDCRefine) {
                                def bit:int (reader.readBit())
                                def oldVal:int (buf.get(blockIdx 0))
                                buf.setVal(blockIdx 0 (bit_or oldVal (bit_shl bit scanAl)))
                            }
                            
                            bh = bh + 1
                        }
                        bv = bv + 1
                    }
                    
                    sc = sc + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn decodeDCFirst:void (reader:BitReader compIdx:int) {
        def comp:JPEGComponent (at components compIdx)
        def buf:CoeffBuffer (at coeffBuffers compIdx)
        
        def dcTable:HuffmanTable (huffman.getDCTable(comp.dcTableId))
        
        ; Non-interleaved: iterate by MCU position to get correct block order
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def bv 0
                while (bv < comp.vSamp) {
                    def bh 0
                    while (bh < comp.hSamp) {
                        def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                        
                        def dcCategory:int (dcTable.decode(reader))
                        def dcDiff:int (reader.receiveExtend(dcCategory))
                        def dcValue:int (comp.prevDC + dcDiff)
                        comp.prevDC = dcValue
                        
                        buf.setVal(blockIdx 0 (bit_shl dcValue scanAl))
                        
                        bh = bh + 1
                    }
                    bv = bv + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn decodeDCRefine:void (reader:BitReader compIdx:int) {
        def comp:JPEGComponent (at components compIdx)
        def buf:CoeffBuffer (at coeffBuffers compIdx)
        
        ; Non-interleaved: iterate by MCU position
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def bv 0
                while (bv < comp.vSamp) {
                    def bh 0
                    while (bh < comp.hSamp) {
                        def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                        
                        def bit:int (reader.readBit())
                        def oldVal:int (buf.get(blockIdx 0))
                        buf.setVal(blockIdx 0 (bit_or oldVal (bit_shl bit scanAl)))
                        
                        bh = bh + 1
                    }
                    bv = bv + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn decodeACFirst:void (reader:BitReader compIdx:int) {
        def comp:JPEGComponent (at components compIdx)
        def buf:CoeffBuffer (at coeffBuffers compIdx)
        def acTable:HuffmanTable (huffman.getACTable(comp.acTableId))
        
        ; Non-interleaved: iterate by MCU position
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def bv 0
                while (bv < comp.vSamp) {
                    def bh 0
                    while (bh < comp.hSamp) {
                        def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                        
                        if (eobrun > 0) {
                            eobrun = eobrun - 1
                        } {
                            def k:int scanSs
                            
                            while (k <= scanSe) {
                                def symbol:int (acTable.decode(reader))
                                def run:int (bit_shr symbol 4)
                                def size:int (bit_and symbol 15)
                                
                                if (size == 0) {
                                    if (run == 15) {
                                        k = k + 16
                                    } {
                                        if (run > 0) {
                                            eobrun = (bit_shl 1 run)
                                            eobrun = eobrun + (reader.readBits(run))
                                        } {
                                            eobrun = 1
                                        }
                                        eobrun = eobrun - 1
                                        k = 64
                                    }
                                } {
                                    k = k + run
                                    
                                    if (k <= scanSe) {
                                        def acValue:int (reader.receiveExtend(size))
                                        buf.setVal(blockIdx k (bit_shl acValue scanAl))
                                        k = k + 1
                                    }
                                }
                            }
                        }
                        
                        bh = bh + 1
                    }
                    bv = bv + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn decodeACRefine:void (reader:BitReader compIdx:int) {
        def comp:JPEGComponent (at components compIdx)
        def buf:CoeffBuffer (at coeffBuffers compIdx)
        def acTable:HuffmanTable (huffman.getACTable(comp.acTableId))
        
        ; Non-interleaved: iterate by MCU position
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def bv 0
                while (bv < comp.vSamp) {
                    def bh 0
                    while (bh < comp.hSamp) {
                        def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                        
                        this.decodeACRefineBlock(reader buf blockIdx acTable)
                        
                        bh = bh + 1
                    }
                    bv = bv + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn decodeACRefineBlock:void (reader:BitReader buf:CoeffBuffer blockIdx:int acTable:HuffmanTable) {
        def k:int scanSs
        
        if (eobrun > 0) {
            while (k <= scanSe) {
                def oldVal:int (buf.get(blockIdx k))
                if (oldVal != 0) {
                    def bit:int (reader.readBit())
                    if (bit != 0) {
                        if (oldVal > 0) {
                            buf.setVal(blockIdx k (bit_or oldVal (bit_shl 1 scanAl)))
                        } {
                            buf.setVal(blockIdx k (oldVal - (bit_shl 1 scanAl)))
                        }
                    }
                }
                k = k + 1
            }
            eobrun = eobrun - 1
            return
        }
        
        while (k <= scanSe) {
            def symbol:int (acTable.decode(reader))
            def run:int (bit_shr symbol 4)
            def size:int (bit_and symbol 15)
            
            if (size == 0) {
                if (run == 15) {
                    def zerosToSkip:int 16
                    while ((zerosToSkip > 0) && (k <= scanSe)) {
                        def oldVal:int (buf.get(blockIdx k))
                        if (oldVal != 0) {
                            def bit:int (reader.readBit())
                            if (bit != 0) {
                                if (oldVal > 0) {
                                    buf.setVal(blockIdx k (bit_or oldVal (bit_shl 1 scanAl)))
                                } {
                                    buf.setVal(blockIdx k (oldVal - (bit_shl 1 scanAl)))
                                }
                            }
                        } {
                            zerosToSkip = zerosToSkip - 1
                        }
                        k = k + 1
                    }
                } {
                    if (run > 0) {
                        eobrun = (bit_shl 1 run)
                        eobrun = eobrun + (reader.readBits(run))
                    } {
                        eobrun = 1
                    }
                    while (k <= scanSe) {
                        def oldVal:int (buf.get(blockIdx k))
                        if (oldVal != 0) {
                            def bit:int (reader.readBit())
                            if (bit != 0) {
                                if (oldVal > 0) {
                                    buf.setVal(blockIdx k (bit_or oldVal (bit_shl 1 scanAl)))
                                } {
                                    buf.setVal(blockIdx k (oldVal - (bit_shl 1 scanAl)))
                                }
                            }
                        }
                        k = k + 1
                    }
                    eobrun = eobrun - 1
                }
            } {
                ; size == 1: new non-zero coefficient after 'run' zeros
                ; First read the sign bit for the new coefficient
                def signBit:int (reader.readBit())
                def newCoeff:int (bit_shl 1 scanAl)
                if (signBit == 0) {
                    newCoeff = (0 - newCoeff)
                }
                
                def zerosToSkip:int run
                while (k <= scanSe) {
                    def oldVal:int (buf.get(blockIdx k))
                    if (oldVal != 0) {
                        ; Refine existing non-zero coefficient
                        def bit:int (reader.readBit())
                        if (bit != 0) {
                            if (oldVal > 0) {
                                buf.setVal(blockIdx k (bit_or oldVal (bit_shl 1 scanAl)))
                            } {
                                buf.setVal(blockIdx k (oldVal - (bit_shl 1 scanAl)))
                            }
                        }
                    } {
                        ; Zero position
                        if (zerosToSkip > 0) {
                            zerosToSkip = zerosToSkip - 1
                        } {
                            ; Found the position for new coefficient
                            buf.setVal(blockIdx k newCoeff)
                            k = k + 1
                            break
                        }
                    }
                    k = k + 1
                }
            }
        }
    }
    
    fn decodeBaselineScan:void (reader:BitReader scanComps:[int]) {
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                
                def sc 0
                def numScanComps:int (array_length scanComps)
                while (sc < numScanComps) {
                    def compIdx:int (at scanComps sc)
                    def comp:JPEGComponent (at components compIdx)
                    def quantTable:QuantizationTable (at quantTables comp.quantTableId)
                    def buf:CoeffBuffer (at coeffBuffers compIdx)
                    
                    def bv 0
                    while (bv < comp.vSamp) {
                        def bh 0
                        while (bh < comp.hSamp) {
                            def blockIdx:int (mcuIdx * comp.hSamp * comp.vSamp + bv * comp.hSamp + bh)
                            
                            ; Decode DC
                            def dcTable:HuffmanTable (huffman.getDCTable(comp.dcTableId))
                            def dcCategory:int (dcTable.decode(reader))
                            def dcDiff:int (reader.receiveExtend(dcCategory))
                            def dcValue:int (comp.prevDC + dcDiff)
                            comp.prevDC = dcValue
                            
                            def dcQuant:int (at quantTable.values 0)
                            buf.setVal(blockIdx 0 (dcValue * dcQuant))
                            
                            ; Decode AC
                            def acTable:HuffmanTable (huffman.getACTable(comp.acTableId))
                            def k 1
                            while (k < 64) {
                                def acSymbol:int (acTable.decode(reader))
                                
                                if (acSymbol == 0) {
                                    k = 64
                                } {
                                    def run:int (bit_shr acSymbol 4)
                                    def size:int (bit_and acSymbol 15)
                                    
                                    if (acSymbol == 240) {
                                        k = k + 16
                                    } {
                                        k = k + run
                                        if (k < 64) {
                                            def acValue:int (reader.receiveExtend(size))
                                            def acQuant:int (at quantTable.values k)
                                            buf.setVal(blockIdx k (acValue * acQuant))
                                            k = k + 1
                                        }
                                    }
                                }
                            }
                            
                            bh = bh + 1
                        }
                        bv = bv + 1
                    }
                    
                    sc = sc + 1
                }
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
    }
    
    fn parseMarkers:boolean () {
        def pos 0
        
        if (dataLen < 2) {
            print "Error: File too small"
            return false
        }
        
        def m1:int (buffer_get data 0)
        def m2:int (buffer_get data 1)
        if ((m1 != 255) || (m2 != 216)) {
            print "Error: Not a JPEG file"
            return false
        }
        
        pos = 2
        print "Parsing JPEG markers..."
        
        while (pos < (dataLen - 1)) {
            def marker1:int (buffer_get data pos)
            if (marker1 != 255) {
                pos = pos + 1
                continue
            }
            
            def marker2:int (buffer_get data (pos + 1))
            
            if (marker2 == 255) {
                pos = pos + 1
                continue
            }
            
            if (marker2 == 0) {
                pos = pos + 2
                continue
            }
            
            if (marker2 == 216) {
                pos = pos + 2
                continue
            }
            if (marker2 == 217) {
                print "  End of Image"
                return true
            }
            if ((marker2 >= 208) && (marker2 <= 215)) {
                pos = pos + 2
                continue
            }
            
            if ((pos + 4) > dataLen) {
                return true
            }
            def markerLen:int (this.readUint16BE(pos + 2))
            def dataStart:int (pos + 4)
            def markerDataLen:int (markerLen - 2)
            
            if (marker2 == 192) {
                print "  SOF0 (Baseline DCT)"
                this.parseSOF(dataStart markerDataLen 0)
            }
            if (marker2 == 193) {
                print "  SOF1 (Extended Sequential)"
                this.parseSOF(dataStart markerDataLen 1)
            }
            if (marker2 == 194) {
                print "  SOF2 (Progressive DCT)"
                this.parseSOF(dataStart markerDataLen 2)
            }
            if (marker2 == 196) {
                print "  DHT (Huffman Tables)"
                huffman.parseDHT(data dataStart markerDataLen)
            }
            if (marker2 == 219) {
                print "  DQT (Quantization Tables)"
                this.parseDQT(dataStart markerDataLen)
            }
            if (marker2 == 218) {
                print "  SOS (Start of Scan)"
                def nextPos:int (this.parseSOS(dataStart markerDataLen))
                pos = nextPos
                continue
            }
            if (marker2 == 224) {
                print "  APP0 (JFIF)"
            }
            if (marker2 == 225) {
                print "  APP1 (EXIF)"
            }
            
            pos = pos + 2 + markerLen
        }
        
        return true
    }
    
    fn dequantizeCoefficients:void () {
        def c 0
        while (c < numComponents) {
            def comp:JPEGComponent (at components c)
            def quantTable:QuantizationTable (at quantTables comp.quantTableId)
            def buf:CoeffBuffer (at coeffBuffers c)
            
            def blockIdx 0
            while (blockIdx < buf.numBlocks) {
                def k 0
                while (k < 64) {
                    def oldVal:int (buf.get(blockIdx k))
                    def quantVal:int (at quantTable.values k)
                    buf.setVal(blockIdx k (oldVal * quantVal))
                    k = k + 1
                }
                
                blockIdx = blockIdx + 1
            }
            
            c = c + 1
        }
    }
    
    fn buildImage:ImageBuffer () {
        if (isProgressive) {
            print "Dequantizing coefficients..."
            this.dequantizeCoefficients()
        }
        
        def img (new ImageBuffer())
        img.init(width height)
        
        print "Building image..."
        
        def mcuY 0
        while (mcuY < mcusPerCol) {
            def mcuX 0
            while (mcuX < mcusPerRow) {
                def mcuIdx:int ((mcuY * mcusPerRow) + mcuX)
                def baseX:int (mcuX * mcuWidth)
                def baseY:int (mcuY * mcuHeight)
                
                def comp0:JPEGComponent (at components 0)
                def yBuf:CoeffBuffer (at coeffBuffers 0)
                
                ; IDCT for Y blocks
                def yBlocksData:[int]
                def bv 0
                while (bv < comp0.vSamp) {
                    def bh 0
                    while (bh < comp0.hSamp) {
                        def blockIdx:int (mcuIdx * comp0.hSamp * comp0.vSamp + bv * comp0.hSamp + bh)
                        
                        def blockCoeffs:int_buffer (int_buffer_alloc 64)
                        def k 0
                        while (k < 64) {
                            int_buffer_set blockCoeffs k (yBuf.get(blockIdx k))
                            k = k + 1
                        }
                        
                        def tempBlock:int_buffer (idct.dezigzag(blockCoeffs))
                        
                        def blockPixels:int_buffer (int_buffer_alloc 64)
                        int_buffer_fill blockPixels 0 64 0
                        idct.transform(tempBlock blockPixels)
                        
                        k = 0
                        while (k < 64) {
                            push yBlocksData (int_buffer_get blockPixels k)
                            k = k + 1
                        }
                        
                        bh = bh + 1
                    }
                    bv = bv + 1
                }
                
                ; Cb/Cr blocks
                def cbBlock:[int]
                def crBlock:[int]
                
                if (numComponents >= 3) {
                    ; Cb
                    def cbBuf:CoeffBuffer (at coeffBuffers 1)
                    def cbBlockIdx:int (mcuIdx)
                    
                    def blockCoeffs:int_buffer (int_buffer_alloc 64)
                    def k 0
                    while (k < 64) {
                        int_buffer_set blockCoeffs k (cbBuf.get(cbBlockIdx k))
                        k = k + 1
                    }
                    
                    def tempBlock:int_buffer (idct.dezigzag(blockCoeffs))
                    def cbPixels:int_buffer (int_buffer_alloc 64)
                    int_buffer_fill cbPixels 0 64 0
                    idct.transform(tempBlock cbPixels)
                    k = 0
                    while (k < 64) {
                        push cbBlock (int_buffer_get cbPixels k)
                        k = k + 1
                    }
                    
                    ; Cr
                    def crBuf:CoeffBuffer (at coeffBuffers 2)
                    def crBlockIdx:int (mcuIdx)
                    
                    def crCoeffs:int_buffer (int_buffer_alloc 64)
                    k = 0
                    while (k < 64) {
                        int_buffer_set crCoeffs k (crBuf.get(crBlockIdx k))
                        k = k + 1
                    }
                    
                    def crTempBlock:int_buffer (idct.dezigzag(crCoeffs))
                    def crPixels:int_buffer (int_buffer_alloc 64)
                    int_buffer_fill crPixels 0 64 0
                    idct.transform(crTempBlock crPixels)
                    k = 0
                    while (k < 64) {
                        push crBlock (int_buffer_get crPixels k)
                        k = k + 1
                    }
                }
                
                this.writeMCU(img baseX baseY yBlocksData cbBlock crBlock)
                
                mcuX = mcuX + 1
            }
            mcuY = mcuY + 1
        }
        
        return img
    }
    
    fn writeMCU:void (img:ImageBuffer baseX:int baseY:int yBlocksData:[int] cbBlock:[int] crBlock:[int]) {
        def comp0:JPEGComponent (at components 0)
        
        if ((maxHSamp == 1) && (maxVSamp == 1)) {
            def py 0
            while (py < 8) {
                def px 0
                while (px < 8) {
                    def imgX:int (baseX + px)
                    def imgY:int (baseY + py)
                    
                    if ((imgX < width) && (imgY < height)) {
                        def idx:int ((py * 8) + px)
                        def y:int (at yBlocksData idx)
                        
                        def cb:int 128
                        def cr:int 128
                        if (numComponents >= 3) {
                            cb = (at cbBlock idx)
                            cr = (at crBlock idx)
                        }
                        
                        def r:int (y + (bit_shr (359 * (cr - 128)) 8))
                        def g:int (y - (bit_shr (88 * (cb - 128)) 8) - (bit_shr (183 * (cr - 128)) 8))
                        def b:int (y + (bit_shr (454 * (cb - 128)) 8))
                        
                        if (r < 0) { r = 0 }
                        if (r > 255) { r = 255 }
                        if (g < 0) { g = 0 }
                        if (g > 255) { g = 255 }
                        if (b < 0) { b = 0 }
                        if (b > 255) { b = 255 }
                        
                        img.setPixelRGB(imgX imgY r g b)
                    }
                    px = px + 1
                }
                py = py + 1
            }
            return
        }
        
        if ((maxHSamp == 2) && (maxVSamp == 2)) {
            def blockIdx 0
            def blockY 0
            while (blockY < 2) {
                def blockX 0
                while (blockX < 2) {
                    def yBlockOffset:int (blockIdx * 64)
                    
                    def py 0
                    while (py < 8) {
                        def px 0
                        while (px < 8) {
                            def imgX:int (baseX + (blockX * 8) + px)
                            def imgY:int (baseY + (blockY * 8) + py)
                            
                            if ((imgX < width) && (imgY < height)) {
                                def yIdx:int (yBlockOffset + (py * 8) + px)
                                def y:int (at yBlocksData yIdx)
                                
                                def chromaX:int ((blockX * 4) + (bit_shr px 1))
                                def chromaY:int ((blockY * 4) + (bit_shr py 1))
                                def chromaIdx:int ((chromaY * 8) + chromaX)
                                
                                def cb:int 128
                                def cr:int 128
                                if (numComponents >= 3) {
                                    cb = (at cbBlock chromaIdx)
                                    cr = (at crBlock chromaIdx)
                                }
                                
                                def r:int (y + (bit_shr (359 * (cr - 128)) 8))
                                def g:int (y - (bit_shr (88 * (cb - 128)) 8) - (bit_shr (183 * (cr - 128)) 8))
                                def b:int (y + (bit_shr (454 * (cb - 128)) 8))
                                
                                if (r < 0) { r = 0 }
                                if (r > 255) { r = 255 }
                                if (g < 0) { g = 0 }
                                if (g > 255) { g = 255 }
                                if (b < 0) { b = 0 }
                                if (b > 255) { b = 255 }
                                
                                img.setPixelRGB(imgX imgY r g b)
                            }
                            px = px + 1
                        }
                        py = py + 1
                    }
                    
                    blockIdx = blockIdx + 1
                    blockX = blockX + 1
                }
                blockY = blockY + 1
            }
            return
        }
        
        ; Fallback grayscale
        def yLen:int (array_length yBlocksData)
        if (yLen > 0) {
            def py 0
            while (py < 8) {
                def px 0
                while (px < 8) {
                    def imgX:int (baseX + px)
                    def imgY:int (baseY + py)
                    if ((imgX < width) && (imgY < height)) {
                        def y:int (at yBlocksData ((py * 8) + px))
                        img.setPixelRGB(imgX imgY y y y)
                    }
                    px = px + 1
                }
                py = py + 1
            }
        }
    }
    
    fn decode:ImageBuffer (dirPath:string fileName:string) {
        data = (buffer_read_file dirPath fileName)
        dataLen = (buffer_length data)
        
        print ("Decoding JPEG: " + fileName + " (" + (to_string dataLen) + " bytes)")
        
        def ok:boolean (this.parseMarkers())
        if (ok == false) {
            print "Error parsing JPEG markers"
            def errImg (new ImageBuffer())
            errImg.init(1 1)
            return errImg
        }
        
        if ((width == 0) || (height == 0)) {
            print "Error: Invalid image dimensions"
            def errImg (new ImageBuffer())
            errImg.init(1 1)
            return errImg
        }
        
        def img:ImageBuffer (this.buildImage())
        
        print "Decode complete!"
        return img
    }
}
