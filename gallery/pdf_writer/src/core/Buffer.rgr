; Buffer.rgr - A growable buffer system for Ranger
; Uses a linked list of fixed-size buffer chunks for efficient memory management

class BufferChunk {
    def data:buffer (buffer_alloc 0)
    def used:int 0
    def capacity:int 0
    def next@(optional):BufferChunk
    
    Constructor (size:int) {
        data = (buffer_alloc size)
        capacity = size
        used = 0
    }
    
    fn remaining:int () {
        return (capacity - used)
    }
    
    fn isFull:boolean () {
        return (used >= capacity)
    }
}

class GrowableBuffer {
    def firstChunk:BufferChunk (new BufferChunk(4096))
    def currentChunk:BufferChunk (new BufferChunk(4096))
    def chunkSize:int 4096       ; Default chunk size: 4KB
    def totalSize:int 0
    
    Constructor () {
        ; Create first chunk - reassign with proper size
        def chunk (new BufferChunk(chunkSize))
        firstChunk = chunk
        currentChunk = chunk
    }
    
    fn setChunkSize:void (size:int) {
        chunkSize = size
    }
    
    fn allocateNewChunk:void () {
        def newChunk (new BufferChunk(chunkSize))
        currentChunk.next = newChunk
        currentChunk = newChunk
    }
    
    fn writeByte:void (b:int) {
        if (currentChunk.isFull()) {
            this.allocateNewChunk()
        }
        def buf:buffer currentChunk.data
        def pos:int currentChunk.used
        buffer_set buf pos b
        currentChunk.used = pos + 1
        totalSize = totalSize + 1
    }
    
    fn writeBytes:void (src:buffer srcOffset:int length:int) {
        def i 0
        while (i < length) {
            def b:int (buffer_get src (srcOffset + i))
            this.writeByte(b)
            i = i + 1
        }
    }
    
    fn writeBuffer:void (src:buffer) {
        def len:int (buffer_length src)
        this.writeBytes(src 0 len)
    }
    
    fn writeString:void (s:string) {
        ; Convert string to bytes and write
        def len (strlen s)
        def i 0
        while (i < len) {
            def ch:int (charAt s i)
            this.writeByte(ch)
            i = i + 1
        }
    }
    
    fn writeInt16BE:void (value:int) {
        ; Write 16-bit big-endian integer
        def highD:double (value / 256)
        def high:int (to_int highD)
        def low:int (value - (high * 256))
        this.writeByte(high)
        this.writeByte(low)
    }
    
    fn writeInt32BE:void (value:int) {
        ; Write 32-bit big-endian integer
        def b1D:double (value / 16777216)
        def b1:int (to_int b1D)
        def rem1:int (value - (b1 * 16777216))
        def b2D:double (rem1 / 65536)
        def b2:int (to_int b2D)
        def rem2:int (rem1 - (b2 * 65536))
        def b3D:double (rem2 / 256)
        def b3:int (to_int b3D)
        def b4:int (rem2 - (b3 * 256))
        this.writeByte(b1)
        this.writeByte(b2)
        this.writeByte(b3)
        this.writeByte(b4)
    }
    
    fn size:int () {
        return totalSize
    }
    
    fn toBuffer:buffer () {
        ; Combine all chunks into a single buffer
        def allocSize:int totalSize
        def result:buffer (buffer_alloc allocSize)
        def pos 0
        def chunk:BufferChunk firstChunk
        def done:boolean false
        
        while (done == false) {
            def chunkData:buffer chunk.data
            def chunkUsed:int chunk.used
            def i 0
            while (i < chunkUsed) {
                def b:int (buffer_get chunkData i)
                buffer_set result pos b
                pos = pos + 1
                i = i + 1
            }
            if (null? chunk.next) {
                done = true
            } {
                chunk = (unwrap chunk.next)
            }
        }
        
        return result
    }
    
    fn toString:string () {
        ; Convert buffer content to string (for text-based content)
        def result ""
        def chunk:BufferChunk firstChunk
        def done:boolean false
        
        while (done == false) {
            def chunkData:buffer chunk.data
            def chunkUsed:int chunk.used
            def i 0
            while (i < chunkUsed) {
                def b:int (buffer_get chunkData i)
                result = result + (strfromcode b)
                i = i + 1
            }
            if (null? chunk.next) {
                done = true
            } {
                chunk = (unwrap chunk.next)
            }
        }
        
        return result
    }
    
    fn clear:void () {
        ; Reset buffer - reuse first chunk, discard others
        def chunk (new BufferChunk(chunkSize))
        firstChunk = chunk
        currentChunk = chunk
        totalSize = 0
    }
}
