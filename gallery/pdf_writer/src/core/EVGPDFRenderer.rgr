; EVGPDFRenderer.rgr - Render EVG elements to PDF
; 
; Takes EVG element tree with calculated positions and renders to PDF using PDFWriter.

Import "PDFWriter.rgr"
Import "../../../evg/EVGElement.rgr"
Import "../../../evg/EVGLayout.rgr"
Import "../../../evg/EVGTextMeasurer.rgr"
Import "../../../evg/EVGImageMeasurer.rgr"
Import "../../../evg/EVGUnit.rgr"
Import "../../../evg/EVGColor.rgr"
Import "../../../evg/SVGPathParser.rgr"
Import "Buffer.rgr"
Import "../fonts/FontManager.rgr"
Import "../jpeg/JPEGReader.rgr"
Import "../jpeg/JPEGMetadata.rgr"
Import "../jpeg/JPEGDecoder.rgr"
Import "../jpeg/JPEGEncoder.rgr"
Import "../jpeg/ImageBuffer.rgr"

; Helper class to track embedded fonts
class EmbeddedFont {
    def name:string ""
    def fontObjNum:int 0
    def fontDescObjNum:int 0
    def fontFileObjNum:int 0
    def pdfName:string ""
    def ttfFont:TrueTypeFont
    
    Constructor (n:string pn:string font:TrueTypeFont) {
        name = n
        pdfName = pn
        ttfFont = font
    }
}

; Helper class to track embedded images
class EmbeddedImage {
    def src:string ""
    def objNum:int 0
    def width:int 0
    def height:int 0
    def orientation:int 1
    def pdfName:string ""
    
    Constructor (s:string) {
        src = s
    }
}

; PDFImageMeasurer - Composition pattern to avoid passing 'this' to trait parameters
; This allows us to pass imageMeasurer (not 'this') to layout.setImageMeasurer
; Uses @(optional weak) to break the reference cycle with EVGPDFRenderer
class PDFImageMeasurer {
    Extends(EVGImageMeasurer)
    ; Use @(optional weak) - the renderer is set after construction
    ; weak reference prevents circular ownership in Rust
    def renderer@(optional weak):EVGPDFRenderer
    
    Constructor () {
    }
    
    fn setRenderer:void (r:EVGPDFRenderer) {
        renderer = r
    }
    
    fn getImageDimensions:EVGImageDimensions (src:string) {
        ; Delegate to renderer's loadImageDimensions method
        if (!null? renderer) {
            return ((unwrap renderer).loadImageDimensions(src))
        }
        ; Return empty dimensions if no renderer set
        def dims (new EVGImageDimensions())
        return dims
    }
}

class EVGPDFRenderer {
    ; Note: No longer extends EVGImageMeasurer - uses composition instead
    def imageMeasurer@(optional):PDFImageMeasurer
    def writer:PDFWriter
    def layout:EVGLayout
    def measurer:EVGTextMeasurer
    def streamBuffer:GrowableBuffer
    def pageWidth:double 595.0
    def pageHeight:double 842.0
    def nextObjNum:int 1
    def fontObjNum:int 0
    def pagesObjNum:int 0
    def contentObjNums:[int]
    def pageCount:int 1
    def debug:boolean false
    def fontManager:FontManager (new FontManager())
    def embeddedFonts:[EmbeddedFont]
    def usedFontNames:[string]
    def embeddedImages:[EmbeddedImage]
    def jpegReader:JPEGReader (new JPEGReader())
    def jpegDecoder:JPEGDecoder (new JPEGDecoder())
    def jpegEncoder:JPEGEncoder (new JPEGEncoder())
    def metadataParser:JPEGMetadataParser (new JPEGMetadataParser())
    def baseDir:string "./"
    def assetPaths:[string]  ; Multiple asset directories for image resolution
    def maxImageWidth:int 800
    def maxImageHeight:int 800
    def jpegQuality:int 75
    def imageDimensionsCache:[EVGImageDimensions]
    def imageDimensionsCacheKeys:[string]
    ; Temporary arrays for collecting elements (fixes Go slice parameter issue)
    def foundSections:[EVGElement]
    def foundPages:[EVGElement]
    
    Constructor () {
        def w (new PDFWriter())
        writer = w
        def lay (new EVGLayout())
        layout = lay
        def m (new SimpleTextMeasurer())
        measurer = m
        def buf (new GrowableBuffer())
        streamBuffer = buf
        def ef:[EmbeddedFont]
        embeddedFonts = ef
        def uf:[string]
        usedFontNames = uf
        def ei:[EmbeddedImage]
        embeddedImages = ei
        def idc:[EVGImageDimensions]
        imageDimensionsCache = idc
        def idck:[string]
        imageDimensionsCacheKeys = idck
        def ap:[string]
        assetPaths = ap
        def fs:[EVGElement]
        foundSections = fs
        def fp:[EVGElement]
        foundPages = fp
        ; Create the image measurer delegate
        def imgMeasurer (new PDFImageMeasurer())
        imageMeasurer = imgMeasurer
    }
    
    ; Initialize components that require 'this' reference
    ; Must be called after construction for C++ compatibility
    ; For Rust: selfRc must be the Rc<RefCell<Self>> that wraps this object
    fn init:void (selfRc:EVGPDFRenderer) {
        ; Set up the image measurer with reference to this renderer
        ; selfRc is passed in - in C++/JS/Go it's just 'this', in Rust it's the Rc
        def imgM:PDFImageMeasurer (unwrap imageMeasurer)
        imgM.setRenderer(selfRc)
        layout.setImageMeasurer(imgM)
    }
    
    fn setPageSize:void (width:double height:double) {
        pageWidth = width
        pageHeight = height
        layout.setPageSize(width height)
    }
    
    fn setBaseDir:void (dir:string) {
        baseDir = dir
    }
    
    ; Set multiple asset directories from semicolon-separated string
    ; Example: "./images;./assets/photos"
    fn setAssetPaths:void (paths:string) {
        ; Split by semicolon
        def start:int 0
        def i:int 0
        def len:int (strlen paths)
        while (i <= len) {
            def ch:string ""
            if (i < len) {
                ch = (substring paths i (i + 1))
            }
            if ((ch == ";") || (i == len)) {
                if (i > start) {
                    def part:string (substring paths start i)
                    push assetPaths part
                    print ("EVGPDFRenderer: Added asset path: " + part)
                }
                start = i + 1
            }
            i = i + 1
        }
    }
    
    ; Resolve an image path, searching asset directories
    fn resolveImagePath:string (src:string) {
        ; Remove leading "./" if present
        def imgSrc:string src
        if ((strlen src) > 2) {
            def prefix:string (substring src 0 2)
            if (prefix == "./") {
                imgSrc = (substring src 2 (strlen src))
            }
        }
        
        ; First try relative to baseDir
        def fullPath:string (baseDir + imgSrc)
        ; Could check file existence here and fall back to asset paths
        
        ; For now return baseDir-relative path
        ; In future, iterate assetPaths and check file existence
        return fullPath
    }
    
    fn setMeasurer:void (m:EVGTextMeasurer) {
        measurer = m
        layout.setMeasurer(m)
    }
    
    fn setFontManager:void (fm:FontManager) {
        fontManager = fm
    }
    
    fn setDebug:void (enabled:boolean) {
        layout.debug = enabled
        this.debug = enabled
    }
    
    ; Load image dimensions from file (not a trait method - uses caching)
    fn loadImageDimensions:EVGImageDimensions (src:string) {
        ; Check cache first
        def i:int 0
        while (i < (array_length imageDimensionsCacheKeys)) {
            def key:string (itemAt imageDimensionsCacheKeys i)
            if (key == src) {
                return (itemAt imageDimensionsCache i)
            }
            i = i + 1
        }
        
        ; Not in cache, load from file
        def dims (new EVGImageDimensions())
        
        ; Resolve the image path - handle relative paths like "./bin/image.jpg"
        def imgDir:string ""
        def imgFile:string ""
        def imgSrc:string src
        
        ; Remove leading "./" if present
        if ((strlen src) > 2) {
            def prefix:string (substring src 0 2)
            if (prefix == "./") {
                imgSrc = (substring src 2 (strlen src))
            }
        }
        
        ; Find last path separator
        def lastSlash:int (lastIndexOf imgSrc "/")
        def lastBackslash:int (lastIndexOf imgSrc "\\")
        def lastSep:int lastSlash
        if (lastBackslash > lastSep) {
            lastSep = lastBackslash
        }
        
        if (lastSep >= 0) {
            ; Combine baseDir with the path from imgSrc
            imgDir = baseDir + (substring imgSrc 0 (lastSep + 1))
            imgFile = (substring imgSrc (lastSep + 1) (strlen imgSrc))
        } {
            ; No path separator, use baseDir directly
            imgDir = baseDir
            imgFile = imgSrc
        }
        
        ; Read JPEG dimensions using JPEGReader
        def reader:JPEGReader (new JPEGReader())
        def jpegImage:JPEGImage (reader.readJPEG(imgDir imgFile))
        
        ; If file not found, try with ./assets/ prefix (same fallback as ResourceLoader)
        if (jpegImage.isValid == false) {
            def altDirPath:string ""
            if ((indexOf src "./") == 0) {
                ; ./images/photo.jpg -> ./assets/images/photo.jpg
                altDirPath = baseDir + "assets/" + (substring src 2 (strlen src))
            } {
                altDirPath = baseDir + "assets/" + src
            }
            ; Extract dir and file from altDirPath
            def altLastSlash:int (lastIndexOf altDirPath "/")
            if (altLastSlash >= 0) {
                imgDir = (substring altDirPath 0 (altLastSlash + 1))
                imgFile = (substring altDirPath (altLastSlash + 1) (strlen altDirPath))
            }
            print ("  Trying alternative: dir=" + imgDir + " file=" + imgFile)
            jpegImage = (reader.readJPEG(imgDir imgFile))
        }
        
        if jpegImage.isValid {
            ; Get EXIF orientation to determine final dimensions  
            def metaInfo:JPEGMetadataInfo (metadataParser.parseMetadata(imgDir imgFile))
            def orientation:int metaInfo.orientation
            
            def imgW:int jpegImage.width
            def imgH:int jpegImage.height
            
            ; Swap dimensions for 90/270 degree rotations
            if ((orientation == 5) || (orientation == 6) || (orientation == 7) || (orientation == 8)) {
                def tmp:int imgW
                imgW = imgH
                imgH = tmp
            }
            
            dims = (EVGImageDimensions.create(imgW imgH))
            print (("Image dimensions: " + src + " = " + (to_string imgW) + "x" + (to_string imgH) + " (orientation=" + (to_string orientation) + ")"))
        }
        
        ; Cache the result
        push imageDimensionsCacheKeys src
        push imageDimensionsCache dims
        
        return dims
    }
    
    fn getPdfFontName:string (fontFamily:string) {
        ; Get the PDF font name (F1, F2, etc.) for a font family
        def i:int 0
        while (i < (array_length usedFontNames)) {
            def name:string (itemAt usedFontNames i)
            if (name == fontFamily) {
                return ("/F" + (to_string (i + 1)))
            }
            i = i + 1
        }
        ; Not found, add it
        push usedFontNames fontFamily
        return ("/F" + (to_string (array_length usedFontNames)))
    }
    
    fn render:buffer (root:EVGElement) {
        ; Check if this is a multi-page document (print element)
        if (root.tagName == "print") {
            return (this.renderMultiPageToPDF(root))
        }
        
        ; Single page - Layout the tree first
        layout.layout(root)
        
        ; Render to PDF
        return (this.renderToPDF(root))
    }
    
    fn findPageElementsRecursive:void (el:EVGElement) {
        ; Recursively find all Page elements (stores in foundPages member)
        if (el.tagName == "page") {
            push foundPages el
        }
        def i:int 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            this.findPageElementsRecursive(child)
            i = i + 1
        }
    }
    
    fn findSectionElementsRecursive:void (el:EVGElement) {
        ; Find all Section elements (stores in foundSections member)
        def i:int 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            if (child.tagName == "section") {
                push foundSections child
            }
            i = i + 1
        }
    }
    
    fn getSectionPageWidth:double (section:EVGElement) {
        ; Get page width from section, default to A4
        if section.width.isSet {
            return section.width.pixels
        }
        return 595.0
    }
    
    fn getSectionPageHeight:double (section:EVGElement) {
        ; Get page height from section, default to A4
        if section.height.isSet {
            return section.height.pixels
        }
        return 842.0
    }
    
    fn getSectionMargin:double (section:EVGElement) {
        ; Get margin from section (use marginTop as the uniform margin)
        ; Check box.marginTop since that's where parsed margin values go
        def m:EVGUnit section.box.marginTop
        if m.isSet {
            return m.pixels
        }
        return 40.0
    }
    
    fn renderMultiPageToPDF:buffer (root:EVGElement) {
        ; Render a multi-page document with Print/Section/Page structure
        def pdf (new GrowableBuffer())
        nextObjNum = 1
        clear contentObjNums
        clear usedFontNames
        clear embeddedFonts
        clear embeddedImages
        
        ; Read image settings from Print element
        if (root.imageQuality > 0) {
            jpegQuality = root.imageQuality
            print ("Image quality: " + (to_string jpegQuality))
        }
        if (root.maxImageSize > 0) {
            maxImageWidth = root.maxImageSize
            maxImageHeight = root.maxImageSize
            print ("Max image size: " + (to_string maxImageWidth) + "px")
        }
        
        ; PDF header
        pdf.writeString("%PDF-1.5\n")
        pdf.writeByte(37)   ; %
        pdf.writeByte(226)  ; high-bit char
        pdf.writeByte(227)  ; high-bit char
        pdf.writeByte(207)  ; high-bit char
        pdf.writeByte(211)  ; high-bit char
        pdf.writeByte(10)   ; newline
        
        def objectOffsets:[int]
        
        ; Find all sections (uses class member foundSections)
        def emptyArr:[EVGElement]
        foundSections = emptyArr
        this.findSectionElementsRecursive(root)
        
        ; Collect all pages from all sections
        def allPages:[EVGElement]
        def allPageWidths:[double]
        def allPageHeights:[double]
        def allPageMargins:[double]
        
        def si:int 0
        while (si < (array_length foundSections)) {
            def section:EVGElement (itemAt foundSections si)
            def sectionWidth:double (this.getSectionPageWidth(section))
            def sectionHeight:double (this.getSectionPageHeight(section))
            def sectionMargin:double (this.getSectionMargin(section))
            
            ; Find pages within this section (uses class member foundPages)
            def emptyPages:[EVGElement]
            foundPages = emptyPages
            this.findPageElementsRecursive(section)
            
            def pi:int 0
            while (pi < (array_length foundPages)) {
                def pg:EVGElement (itemAt foundPages pi)
                push allPages pg
                push allPageWidths sectionWidth
                push allPageHeights sectionHeight
                push allPageMargins sectionMargin
                
                ; Set page dimensions for layout - this is the content area inside margins
                def contentWidth:double (sectionWidth - (sectionMargin * 2.0))
                def contentHeight:double (sectionHeight - (sectionMargin * 2.0))
                
                print ("Page " + (to_string (pi + 1)) + " content size: " + (to_string contentWidth) + " x " + (to_string contentHeight))
                
                ; Set the layout engine's page dimensions before layout
                layout.pageWidth = contentWidth
                layout.pageHeight = contentHeight
                
                ; Reset layout state for fresh layout
                pg.resetLayoutState()
                
                pg.width.pixels = contentWidth
                pg.width.value = contentWidth
                pg.width.unitType = 0  ; pixels
                pg.width.isSet = true
                pg.height.pixels = contentHeight
                pg.height.value = contentHeight
                pg.height.unitType = 0  ; pixels
                pg.height.isSet = true
                
                ; Layout each page independently
                layout.layout(pg)
                
                print ("  After layout: pg.calculatedWidth=" + (to_string pg.calculatedWidth) + " pg.calculatedHeight=" + (to_string pg.calculatedHeight))
                
                ; Check first child
                if ((pg.getChildCount()) > 0) {
                    def firstChild:EVGElement (pg.getChild(0))
                    print ("  First child: w=" + (to_string firstChild.calculatedWidth) + " h=" + (to_string firstChild.calculatedHeight))
                }
                
                pi = pi + 1
            }
            si = si + 1
        }
        
        ; If no sections found, treat the whole document as single page
        if ((array_length allPages) == 0) {
            layout.layout(root)
            push allPages root
            push allPageWidths pageWidth
            push allPageHeights pageHeight
            push allPageMargins 0.0
        }
        
        def numPages:int (array_length allPages)
        print ("Rendering " + (to_string numPages) + " pages")
        
        ; Build content streams for all pages (this collects fonts and images)
        def contentDataList:[buffer]
        def pgi:int 0
        while (pgi < numPages) {
            def pg:EVGElement (itemAt allPages pgi)
            def pgWidth:double (itemAt allPageWidths pgi)
            def pgHeight:double (itemAt allPageHeights pgi)
            def pgMargin:double (itemAt allPageMargins pgi)
            
            ; Store page height for Y coordinate flipping
            pageHeight = pgHeight
            
            streamBuffer.clear()
            ; Apply margin offset when rendering
            this.renderElement(pg pgMargin pgMargin)
            def contentData:buffer (streamBuffer.toBuffer())
            push contentDataList contentData
            
            print ("  Page " + (to_string (pgi + 1)) + ": " + (to_string (buffer_length contentData)) + " bytes")
            pgi = pgi + 1
        }
        
        ; Embed fonts
        def fontObjNums:[int]
        def fi:int 0
        while (fi < (array_length usedFontNames)) {
            def fontName:string (itemAt usedFontNames fi)
            def ttfFont:TrueTypeFont (fontManager.getFont(fontName))
            
            if (ttfFont.unitsPerEm > 0) {
                ; Embed TrueType font
                def fontFileData:buffer (ttfFont.getFontData())
                def fontFileLen:int (buffer_length fontFileData)
                
                ; Font file stream object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Length " + (to_string fontFileLen) + " /Length1 " + (to_string fontFileLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(fontFileData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def fontFileObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font descriptor object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /FontDescriptor")
                pdf.writeString(" /FontName /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /Flags 32")
                pdf.writeString(" /FontBBox [0 " + (to_string ttfFont.descender) + " 1000 " + (to_string ttfFont.ascender) + "]")
                pdf.writeString(" /ItalicAngle 0")
                pdf.writeString(" /Ascent " + (to_string ttfFont.ascender))
                pdf.writeString(" /Descent " + (to_string ttfFont.descender))
                pdf.writeString(" /CapHeight " + (to_string ttfFont.ascender))
                pdf.writeString(" /StemV 80")
                pdf.writeString(" /FontFile2 " + (to_string fontFileObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                def fontDescObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; ToUnicode CMap
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                def toUnicodeStream:string "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<00> <FF>\nendcodespacerange\n"
                toUnicodeStream = toUnicodeStream + "2 beginbfrange\n<20> <7E> <0020>\n<A0> <FF> <00A0>\nendbfrange\n"
                toUnicodeStream = toUnicodeStream + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"
                def toUnicodeLen:int (strlen toUnicodeStream)
                pdf.writeString("<< /Length " + (to_string toUnicodeLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeString(toUnicodeStream)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def toUnicodeObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font object (TrueType)
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font")
                pdf.writeString(" /Subtype /TrueType")
                pdf.writeString(" /BaseFont /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /FirstChar 32")
                pdf.writeString(" /LastChar 255")
                pdf.writeString(" /Widths [")
                def ch:int 32
                while (ch <= 255) {
                    def cw:int (ttfFont.getCharWidth(ch))
                    def scaledWd:double (((to_double cw) * 1000.0) / (to_double ttfFont.unitsPerEm))
                    def scaledW:int (to_int scaledWd)
                    pdf.writeString((to_string scaledW))
                    if (ch < 255) {
                        pdf.writeString(" ")
                    }
                    ch = ch + 1
                }
                pdf.writeString("]")
                pdf.writeString(" /FontDescriptor " + (to_string fontDescObjNum) + " 0 R")
                pdf.writeString(" /Encoding /WinAnsiEncoding")
                pdf.writeString(" /ToUnicode " + (to_string toUnicodeObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            } {
                ; Fallback to built-in Helvetica
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            }
            fi = fi + 1
        }
        
        ; Ensure at least one font exists
        if ((array_length fontObjNums) == 0) {
            push objectOffsets (pdf.size())
            pdf.writeString((to_string nextObjNum) + " 0 obj\n")
            pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
            pdf.writeString("endobj\n\n")
            push fontObjNums nextObjNum
            nextObjNum = nextObjNum + 1
        }
        
        ; Embed images
        def imgIdx:int 0
        while (imgIdx < (array_length embeddedImages)) {
            def embImg:EmbeddedImage (itemAt embeddedImages imgIdx)
            def imgSrc:string embImg.src
            def imgDir:string baseDir
            def imgFile:string imgSrc
            
            if ((strlen imgSrc) > 2) {
                def prefix:string (substring imgSrc 0 2)
                if (prefix == "./") {
                    imgSrc = (substring imgSrc 2 (strlen imgSrc))
                }
            }
            
            def lastSlash:int (lastIndexOf imgSrc "/")
            def lastBackslash:int (lastIndexOf imgSrc "\\")
            def lastSep:int lastSlash
            if (lastBackslash > lastSep) {
                lastSep = lastBackslash
            }
            
            if (lastSep >= 0) {
                imgDir = baseDir + (substring imgSrc 0 (lastSep + 1))
                imgFile = (substring imgSrc (lastSep + 1) (strlen imgSrc))
            } {
                imgDir = baseDir
                imgFile = imgSrc
            }
            
            print ("Loading image: dir=" + imgDir + " file=" + imgFile)
            
            def metaInfo:JPEGMetadataInfo (metadataParser.parseMetadata(imgDir imgFile))
            
            ; If file not found, try with ./assets/ prefix (same fallback as ResourceLoader)
            if (metaInfo.isValid == false) {
                def origImgSrc:string embImg.src
                def altDirPath:string ""
                if ((indexOf origImgSrc "./") == 0) {
                    ; ./images/photo.jpg -> ./assets/images/photo.jpg
                    altDirPath = baseDir + "assets/" + (substring origImgSrc 2 (strlen origImgSrc))
                } {
                    altDirPath = baseDir + "assets/" + origImgSrc
                }
                ; Extract dir and file from altDirPath
                def altLastSlash:int (lastIndexOf altDirPath "/")
                if (altLastSlash >= 0) {
                    imgDir = (substring altDirPath 0 (altLastSlash + 1))
                    imgFile = (substring altDirPath (altLastSlash + 1) (strlen altDirPath))
                }
                print ("  Trying alternative: dir=" + imgDir + " file=" + imgFile)
                metaInfo = (metadataParser.parseMetadata(imgDir imgFile))
            }
            
            embImg.orientation = metaInfo.orientation
            
            def imgBuffer:ImageBuffer (jpegDecoder.decode(imgDir imgFile))
            
            if ((imgBuffer.width > 1) && (imgBuffer.height > 1)) {
                if (metaInfo.orientation > 1) {
                    print ("  Applying EXIF orientation: " + (to_string metaInfo.orientation))
                    imgBuffer = (imgBuffer.applyExifOrientation(metaInfo.orientation))
                }
                
                def origW:int imgBuffer.width
                def origH:int imgBuffer.height
                def newW:int origW
                def newH:int origH
                
                if ((origW > maxImageWidth) || (origH > maxImageHeight)) {
                    def scaleW:double ((to_double maxImageWidth) / (to_double origW))
                    def scaleH:double ((to_double maxImageHeight) / (to_double origH))
                    def scale:double scaleW
                    if (scaleH < scaleW) {
                        scale = scaleH
                    }
                    newW = (to_int ((to_double origW) * scale))
                    newH = (to_int ((to_double origH) * scale))
                    
                    print ("  Resizing from " + (to_string origW) + "x" + (to_string origH) + " to " + (to_string newW) + "x" + (to_string newH))
                    imgBuffer = (imgBuffer.scaleToSize(newW newH))
                }
                
                jpegEncoder.setQuality(jpegQuality)
                def encodedData:buffer (jpegEncoder.encodeToBuffer(imgBuffer))
                def encodedLen:int (buffer_length encodedData)
                
                embImg.width = newW
                embImg.height = newH
                
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /XObject")
                pdf.writeString(" /Subtype /Image")
                pdf.writeString(" /Width " + (to_string newW))
                pdf.writeString(" /Height " + (to_string newH))
                pdf.writeString(" /ColorSpace /DeviceRGB")
                pdf.writeString(" /BitsPerComponent 8")
                pdf.writeString(" /Filter /DCTDecode")
                pdf.writeString(" /Length " + (to_string encodedLen))
                pdf.writeString(" >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(encodedData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                
                embImg.objNum = nextObjNum
                embImg.pdfName = "/Im" + (to_string (imgIdx + 1))
                nextObjNum = nextObjNum + 1
                
                print ("Embedded image: " + embImg.src + " (" + (to_string newW) + "x" + (to_string newH) + ")")
            } {
                print ("Failed to decode image: " + embImg.src)
            }
            
            imgIdx = imgIdx + 1
        }
        
        ; Write content streams for all pages
        def contentObjNumList:[int]
        def ci:int 0
        while (ci < numPages) {
            def contentData:buffer (itemAt contentDataList ci)
            def contentLen:int (buffer_length contentData)
            
            push objectOffsets (pdf.size())
            pdf.writeString((to_string nextObjNum) + " 0 obj\n")
            pdf.writeString("<< /Length " + (to_string contentLen) + " >>\n")
            pdf.writeString("stream\n")
            pdf.writeBuffer(contentData)
            pdf.writeString("\nendstream\n")
            pdf.writeString("endobj\n\n")
            push contentObjNumList nextObjNum
            nextObjNum = nextObjNum + 1
            ci = ci + 1
        }
        
        ; Write page objects
        def pageObjNumList:[int]
        def pagesRefNum:int (nextObjNum + numPages)  ; Calculate where Pages object will be
        
        def pi2:int 0
        while (pi2 < numPages) {
            def pgWidth:double (itemAt allPageWidths pi2)
            def pgHeight:double (itemAt allPageHeights pi2)
            def contentObjN:int (itemAt contentObjNumList pi2)
            
            push objectOffsets (pdf.size())
            pdf.writeString((to_string nextObjNum) + " 0 obj\n")
            pdf.writeString("<< /Type /Page /Parent " + (to_string pagesRefNum) + " 0 R")
            pdf.writeString(" /MediaBox [0 0 " + (this.formatNum(pgWidth)) + " " + (this.formatNum(pgHeight)) + "]")
            pdf.writeString(" /Contents " + (to_string contentObjN) + " 0 R")
            pdf.writeString(" /Resources <<")
            pdf.writeString(" /Font <<")
            def ffi:int 0
            while (ffi < (array_length fontObjNums)) {
                def fontObjN:int (itemAt fontObjNums ffi)
                pdf.writeString(" /F" + (to_string (ffi + 1)) + " " + (to_string fontObjN) + " 0 R")
                ffi = ffi + 1
            }
            pdf.writeString(" >>")
            if ((array_length embeddedImages) > 0) {
                pdf.writeString(" /XObject <<")
                def ii:int 0
                while (ii < (array_length embeddedImages)) {
                    def embImg:EmbeddedImage (itemAt embeddedImages ii)
                    if (embImg.objNum > 0) {
                        pdf.writeString(" /Im" + (to_string (ii + 1)) + " " + (to_string embImg.objNum) + " 0 R")
                    }
                    ii = ii + 1
                }
                pdf.writeString(" >>")
            }
            pdf.writeString(" >> >>\n")
            pdf.writeString("endobj\n\n")
            push pageObjNumList nextObjNum
            nextObjNum = nextObjNum + 1
            pi2 = pi2 + 1
        }
        
        ; Pages object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Pages /Kids [")
        def ki:int 0
        while (ki < numPages) {
            def pageObjN:int (itemAt pageObjNumList ki)
            pdf.writeString((to_string pageObjN) + " 0 R")
            if (ki < (numPages - 1)) {
                pdf.writeString(" ")
            }
            ki = ki + 1
        }
        pdf.writeString("] /Count " + (to_string numPages) + " >>\n")
        pdf.writeString("endobj\n\n")
        pagesObjNum = nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Catalog object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Catalog /Pages " + (to_string pagesObjNum) + " 0 R >>\n")
        pdf.writeString("endobj\n\n")
        def catalogObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Xref table
        def xrefOffset:int (pdf.size())
        pdf.writeString("xref\n")
        pdf.writeString("0 " + (to_string nextObjNum) + "\n")
        pdf.writeString("0000000000 65535 f \n")
        
        def xi:int 0
        while (xi < (array_length objectOffsets)) {
            def offset:int (itemAt objectOffsets xi)
            pdf.writeString((this.padLeft((to_string offset) 10 "0")) + " 00000 n \n")
            xi = xi + 1
        }
        
        ; Trailer
        pdf.writeString("trailer\n")
        pdf.writeString("<< /Size " + (to_string nextObjNum) + " /Root " + (to_string catalogObjNum) + " 0 R >>\n")
        pdf.writeString("startxref\n")
        pdf.writeString((to_string xrefOffset) + "\n")
        pdf.writeString("%%EOF\n")
        
        return (pdf.toBuffer())
    }
    
    fn renderToPDF:buffer (root:EVGElement) {
        ; Build PDF with the rendered content
        def pdf (new GrowableBuffer())
        nextObjNum = 1
        clear contentObjNums
        clear usedFontNames
        clear embeddedFonts
        clear embeddedImages
        
        ; PDF header (version 1.5 for TrueType embedding)
        pdf.writeString("%PDF-1.5\n")
        pdf.writeByte(37)   ; %
        pdf.writeByte(226)  ; high-bit char
        pdf.writeByte(227)  ; high-bit char
        pdf.writeByte(207)  ; high-bit char
        pdf.writeByte(211)  ; high-bit char
        pdf.writeByte(10)   ; newline
        
        ; Keep track of object offsets
        def objectOffsets:[int]
        
        ; Build content stream for the page (this also collects used fonts)
        streamBuffer.clear()
        this.renderElement(root 0.0 0.0)
        def contentData:buffer (streamBuffer.toBuffer())
        def contentLen:int (buffer_length contentData)
        
        ; Now embed fonts for each used font
        def fontObjNums:[int]
        def i:int 0
        while (i < (array_length usedFontNames)) {
            def fontName:string (itemAt usedFontNames i)
            def ttfFont:TrueTypeFont (fontManager.getFont(fontName))
            
            if (ttfFont.unitsPerEm > 0) {
                ; Embed TrueType font
                def fontFileData:buffer (ttfFont.getFontData())
                def fontFileLen:int (buffer_length fontFileData)
                
                ; Font file stream object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Length " + (to_string fontFileLen) + " /Length1 " + (to_string fontFileLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(fontFileData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def fontFileObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font descriptor object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /FontDescriptor")
                pdf.writeString(" /FontName /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /Flags 32")  ; Symbolic
                pdf.writeString(" /FontBBox [0 " + (to_string ttfFont.descender) + " 1000 " + (to_string ttfFont.ascender) + "]")
                pdf.writeString(" /ItalicAngle 0")
                pdf.writeString(" /Ascent " + (to_string ttfFont.ascender))
                pdf.writeString(" /Descent " + (to_string ttfFont.descender))
                pdf.writeString(" /CapHeight " + (to_string ttfFont.ascender))
                pdf.writeString(" /StemV 80")
                pdf.writeString(" /FontFile2 " + (to_string fontFileObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                def fontDescObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; ToUnicode CMap for proper character mapping
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                def toUnicodeStream:string "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<00> <FF>\nendcodespacerange\n"
                ; Map characters 32-255 to their Unicode code points (identity mapping for WinAnsi)
                toUnicodeStream = toUnicodeStream + "2 beginbfrange\n<20> <7E> <0020>\n<A0> <FF> <00A0>\nendbfrange\n"
                toUnicodeStream = toUnicodeStream + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"
                def toUnicodeLen:int (strlen toUnicodeStream)
                pdf.writeString("<< /Length " + (to_string toUnicodeLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeString(toUnicodeStream)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def toUnicodeObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font object (TrueType)
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font")
                pdf.writeString(" /Subtype /TrueType")
                pdf.writeString(" /BaseFont /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /FirstChar 32")
                pdf.writeString(" /LastChar 255")
                pdf.writeString(" /Widths [")
                ; Output widths for characters 32-255
                def ch:int 32
                while (ch <= 255) {
                    ; Use getCharWidth which properly maps char code -> glyph index -> width
                    def w:int (ttfFont.getCharWidth(ch))
                    ; Scale to 1000 units (standard PDF font units)
                    def scaledWd:double (((to_double w) * 1000.0) / (to_double ttfFont.unitsPerEm))
                    def scaledW:int (to_int scaledWd)
                    pdf.writeString((to_string scaledW))
                    if (ch < 255) {
                        pdf.writeString(" ")
                    }
                    ch = ch + 1
                }
                pdf.writeString("]")
                pdf.writeString(" /FontDescriptor " + (to_string fontDescObjNum) + " 0 R")
                pdf.writeString(" /Encoding /WinAnsiEncoding")
                pdf.writeString(" /ToUnicode " + (to_string toUnicodeObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            } {
                ; Fallback to built-in Helvetica
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            }
            i = i + 1
        }
        
        ; Ensure at least one font exists
        if ((array_length fontObjNums) == 0) {
            push objectOffsets (pdf.size())
            pdf.writeString((to_string nextObjNum) + " 0 obj\n")
            pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
            pdf.writeString("endobj\n\n")
            push fontObjNums nextObjNum
            nextObjNum = nextObjNum + 1
        }
        
        ; Embed images
        def imgIdx:int 0
        while (imgIdx < (array_length embeddedImages)) {
            def embImg:EmbeddedImage (itemAt embeddedImages imgIdx)
            
            ; Parse the src path to get directory and filename
            def imgSrc:string embImg.src
            def imgDir:string baseDir
            def imgFile:string imgSrc
            
            ; Handle relative paths starting with ./
            if ((strlen imgSrc) > 2) {
                def prefix:string (substring imgSrc 0 2)
                if (prefix == "./") {
                    imgSrc = (substring imgSrc 2 (strlen imgSrc))
                }
            }
            
            ; Check for path separators
            def lastSlash:int (lastIndexOf imgSrc "/")
            def lastBackslash:int (lastIndexOf imgSrc "\\")
            def lastSep:int lastSlash
            if (lastBackslash > lastSep) {
                lastSep = lastBackslash
            }
            
            if (lastSep >= 0) {
                ; Combine baseDir with the path from imgSrc
                imgDir = baseDir + (substring imgSrc 0 (lastSep + 1))
                imgFile = (substring imgSrc (lastSep + 1) (strlen imgSrc))
            } {
                ; No path separator, use baseDir directly
                imgDir = baseDir
                imgFile = imgSrc
            }
            
            print ("Loading image: dir=" + imgDir + " file=" + imgFile)
            
            ; Get EXIF orientation
            def metaInfo:JPEGMetadataInfo (metadataParser.parseMetadata(imgDir imgFile))
            
            ; If file not found, try with ./assets/ prefix (same fallback as ResourceLoader)
            if (metaInfo.isValid == false) {
                def origImgSrc:string embImg.src
                def altDirPath:string ""
                if ((indexOf origImgSrc "./") == 0) {
                    ; ./images/photo.jpg -> ./assets/images/photo.jpg
                    altDirPath = baseDir + "assets/" + (substring origImgSrc 2 (strlen origImgSrc))
                } {
                    altDirPath = baseDir + "assets/" + origImgSrc
                }
                ; Extract dir and file from altDirPath
                def altLastSlash:int (lastIndexOf altDirPath "/")
                if (altLastSlash >= 0) {
                    imgDir = (substring altDirPath 0 (altLastSlash + 1))
                    imgFile = (substring altDirPath (altLastSlash + 1) (strlen altDirPath))
                }
                print ("  Trying alternative: dir=" + imgDir + " file=" + imgFile)
                metaInfo = (metadataParser.parseMetadata(imgDir imgFile))
            }
            
            embImg.orientation = metaInfo.orientation
            
            ; Decode JPEG to ImageBuffer for processing
            def imgBuffer:ImageBuffer (jpegDecoder.decode(imgDir imgFile))
            
            if ((imgBuffer.width > 1) && (imgBuffer.height > 1)) {
                ; Apply EXIF orientation
                if (metaInfo.orientation > 1) {
                    print ("  Applying EXIF orientation: " + (to_string metaInfo.orientation))
                    imgBuffer = (imgBuffer.applyExifOrientation(metaInfo.orientation))
                }
                
                ; Calculate scaled dimensions to fit within maxImageWidth x maxImageHeight
                def origW:int imgBuffer.width
                def origH:int imgBuffer.height
                def newW:int origW
                def newH:int origH
                
                ; Check if resizing is needed
                if ((origW > maxImageWidth) || (origH > maxImageHeight)) {
                    def scaleW:double ((to_double maxImageWidth) / (to_double origW))
                    def scaleH:double ((to_double maxImageHeight) / (to_double origH))
                    def scale:double scaleW
                    if (scaleH < scaleW) {
                        scale = scaleH
                    }
                    newW = (to_int ((to_double origW) * scale))
                    newH = (to_int ((to_double origH) * scale))
                    
                    print ("  Resizing from " + (to_string origW) + "x" + (to_string origH) + " to " + (to_string newW) + "x" + (to_string newH))
                    imgBuffer = (imgBuffer.scaleToSize(newW newH))
                }
                
                ; Encode to JPEG buffer
                jpegEncoder.setQuality(jpegQuality)
                def encodedData:buffer (jpegEncoder.encodeToBuffer(imgBuffer))
                def encodedLen:int (buffer_length encodedData)
                
                embImg.width = newW
                embImg.height = newH
                
                ; Image XObject
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /XObject")
                pdf.writeString(" /Subtype /Image")
                pdf.writeString(" /Width " + (to_string newW))
                pdf.writeString(" /Height " + (to_string newH))
                pdf.writeString(" /ColorSpace /DeviceRGB")
                pdf.writeString(" /BitsPerComponent 8")
                pdf.writeString(" /Filter /DCTDecode")
                pdf.writeString(" /Length " + (to_string encodedLen))
                pdf.writeString(" >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(encodedData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                
                embImg.objNum = nextObjNum
                embImg.pdfName = "/Im" + (to_string (imgIdx + 1))
                nextObjNum = nextObjNum + 1
                
                print ("Embedded image: " + imgSrc + " (resized to " + (to_string newW) + "x" + (to_string newH) + ", " + (to_string encodedLen) + " bytes)")
            } {
                print ("Failed to decode image: " + imgSrc)
            }
            
            imgIdx = imgIdx + 1
        }
        
        ; Content stream object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Length " + (to_string contentLen) + " >>\n")
        pdf.writeString("stream\n")
        pdf.writeBuffer(contentData)
        pdf.writeString("\nendstream\n")
        pdf.writeString("endobj\n\n")
        def contentObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Page object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        def pagesRef:int (nextObjNum + 1)
        pdf.writeString("<< /Type /Page /Parent " + (to_string pagesRef) + " 0 R")
        pdf.writeString(" /MediaBox [0 0 " + (this.formatNum(pageWidth)) + " " + (this.formatNum(pageHeight)) + "]")
        pdf.writeString(" /Contents " + (to_string contentObjNum) + " 0 R")
        pdf.writeString(" /Resources <<")
        ; Add font references
        pdf.writeString(" /Font <<")
        def fi:int 0
        while (fi < (array_length fontObjNums)) {
            def fontObjN:int (itemAt fontObjNums fi)
            pdf.writeString(" /F" + (to_string (fi + 1)) + " " + (to_string fontObjN) + " 0 R")
            fi = fi + 1
        }
        pdf.writeString(" >>")
        ; Add image XObject references
        if ((array_length embeddedImages) > 0) {
            pdf.writeString(" /XObject <<")
            def ii:int 0
            while (ii < (array_length embeddedImages)) {
                def embImg:EmbeddedImage (itemAt embeddedImages ii)
                if (embImg.objNum > 0) {
                    pdf.writeString(" /Im" + (to_string (ii + 1)) + " " + (to_string embImg.objNum) + " 0 R")
                }
                ii = ii + 1
            }
            pdf.writeString(" >>")
        }
        pdf.writeString(" >> >>\n")
        pdf.writeString("endobj\n\n")
        def pageObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Object 6: Pages
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Pages /Kids [" + (to_string pageObjNum) + " 0 R] /Count 1 >>\n")
        pdf.writeString("endobj\n\n")
        pagesObjNum = nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Object 7: Catalog
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Catalog /Pages " + (to_string pagesObjNum) + " 0 R >>\n")
        pdf.writeString("endobj\n\n")
        def catalogObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Xref table
        def xrefOffset:int (pdf.size())
        pdf.writeString("xref\n")
        pdf.writeString("0 " + (to_string nextObjNum) + "\n")
        pdf.writeString("0000000000 65535 f \n")
        
        def i 0
        while (i < (array_length objectOffsets)) {
            def offset:int (itemAt objectOffsets i)
            pdf.writeString((this.padLeft((to_string offset) 10 "0")) + " 00000 n \n")
            i = i + 1
        }
        
        ; Trailer
        pdf.writeString("trailer\n")
        pdf.writeString("<< /Size " + (to_string nextObjNum) + " /Root " + (to_string catalogObjNum) + " 0 R >>\n")
        pdf.writeString("startxref\n")
        pdf.writeString((to_string xrefOffset) + "\n")
        pdf.writeString("%%EOF\n")
        
        return (pdf.toBuffer())
    }
    
    fn renderElement:void (el:EVGElement offsetX:double offsetY:double) {
        ; Get element position
        def x:double (el.calculatedX + offsetX)
        def y:double (el.calculatedY + offsetY)
        def w:double el.calculatedWidth
        def h:double el.calculatedHeight
        
        ; PDF uses bottom-left origin, flip Y
        def pdfY:double (pageHeight - y - h)
        
        ; Get border radius
        def borderRadius:double 0.0
        if el.box.borderRadius.isSet {
            borderRadius = el.box.borderRadius.pixels
        }
        
        ; Apply clip path if set
        def hasClipPath:boolean false
        if ((strlen el.clipPath) > 0) {
            hasClipPath = true
            streamBuffer.writeString("q\n")
            this.applyClipPath(el.clipPath x pdfY w h)
        }
        
        ; Render shadow first (behind everything) - but NOT for text elements
        ; Text elements get text-shadow which is handled in renderText
        if (el.tagName != "text") {
            this.renderShadow(el x pdfY w h borderRadius)
        }
        
        ; Render gradient background if set
        if ((strlen el.backgroundGradient) > 0) {
            this.renderGradientBackground(el x pdfY w h borderRadius)
        } {
            ; Render solid background if set (with border radius)
            def bgColor:EVGColor (unwrap el.backgroundColor)
            if this.debug {
                print ("  bg check: " + el.tagName + " isSet=" + (to_string bgColor.isSet) + " r=" + (to_string bgColor.r))
            }
            if bgColor.isSet {
                this.renderBackgroundWithRadius(x pdfY w h bgColor borderRadius)
            }
        }
        
        ; Render border (with border radius)
        this.renderBorderWithRadius(el x pdfY w h borderRadius)
        
        ; Render text content
        if (el.tagName == "text") {
            this.renderText(el x pdfY w h)
        }
        
        ; Handle divider element
        if (el.tagName == "divider") {
            this.renderDivider(el x pdfY w h)
        }
        
        ; Handle image element
        if (el.tagName == "image") {
            this.renderImage(el x pdfY w h)
        }
        
        ; Handle path element
        if (el.tagName == "path") {
            this.renderPath(el x pdfY w h)
        }
        
        ; Render children - children have absolute positions from layout engine
        ; so pass the same offset that was passed to this element
        def i 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            this.renderElement(child offsetX offsetY)
            i = i + 1
        }
        
        ; Restore state if clip path was applied
        if hasClipPath {
            streamBuffer.writeString("Q\n")
        }
    }
    
    fn getImagePdfName:string (src:string) {
        ; Find or create an embedded image entry and return its PDF name
        def i:int 0
        while (i < (array_length embeddedImages)) {
            def embImg:EmbeddedImage (itemAt embeddedImages i)
            if (embImg.src == src) {
                return ("/Im" + (to_string (i + 1)))
            }
            i = i + 1
        }
        ; Not found, add it
        def newImg (new EmbeddedImage(src))
        push embeddedImages newImg
        return ("/Im" + (to_string (array_length embeddedImages)))
    }
    
    fn renderImage:void (el:EVGElement x:double y:double w:double h:double) {
        def src:string el.src
        if ((strlen src) == 0) {
            return
        }
        
        ; Register the image for embedding
        def imgName:string (this.getImagePdfName(src))
        
        ; Draw the image (orientation already applied during JPEG processing)
        ; PDF transformation matrix: [a b c d e f] cm
        ; where: a=scaleX, d=scaleY, e=translateX, f=translateY
        streamBuffer.writeString("q\n")
        streamBuffer.writeString((this.formatNum(w)) + " 0 0 " + (this.formatNum(h)) + " " + (this.formatNum(x)) + " " + (this.formatNum(y)) + " cm\n")
        streamBuffer.writeString(imgName + " Do\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderPath:void (el:EVGElement x:double y:double w:double h:double) {
        def pathData:string el.svgPath
        if ((strlen pathData) == 0) {
            return
        }
        
        ; Parse SVG path
        def parser (new SVGPathParser())
        parser.parse(pathData)
        
        ; Get scaled commands
        def commands:[PathCommand] (parser.getScaledCommands(w h))
        
        ; Determine fill and stroke colors
        def fillColor:EVGColor el.fillColor
        def strokeColor:EVGColor el.strokeColor
        
        ; Default to backgroundColor if fill not set
        if (fillColor.isSet == false) {
            fillColor = el.backgroundColor
        }
        
        ; Start path
        streamBuffer.writeString("q\n")
        
        ; Translate to element position
        streamBuffer.writeString("1 0 0 1 " + (this.formatNum(x)) + " " + (this.formatNum(y)) + " cm\n")
        
        ; Flip Y axis for path coordinates (SVG uses top-left, PDF uses bottom-left)
        streamBuffer.writeString("1 0 0 -1 0 " + (this.formatNum(h)) + " cm\n")
        
        ; Build path commands
        def i:int 0
        while (i < (array_length commands)) {
            def cmd:PathCommand (itemAt commands i)
            
            if (cmd.type == "M") {
                ; Move to
                streamBuffer.writeString((this.formatNum(cmd.x)) + " " + (this.formatNum(cmd.y)) + " m\n")
            }
            
            if (cmd.type == "L") {
                ; Line to
                streamBuffer.writeString((this.formatNum(cmd.x)) + " " + (this.formatNum(cmd.y)) + " l\n")
            }
            
            if (cmd.type == "C") {
                ; Cubic Bezier curve
                streamBuffer.writeString((this.formatNum(cmd.x1)) + " " + (this.formatNum(cmd.y1)) + " " + (this.formatNum(cmd.x2)) + " " + (this.formatNum(cmd.y2)) + " " + (this.formatNum(cmd.x)) + " " + (this.formatNum(cmd.y)) + " c\n")
            }
            
            if (cmd.type == "Q") {
                ; Quadratic Bezier - convert to cubic
                ; Control point is at 2/3 between current and q control point
                ; For simplicity, approximate with cubic
                streamBuffer.writeString((this.formatNum(cmd.x1)) + " " + (this.formatNum(cmd.y1)) + " " + (this.formatNum(cmd.x1)) + " " + (this.formatNum(cmd.y1)) + " " + (this.formatNum(cmd.x)) + " " + (this.formatNum(cmd.y)) + " c\n")
            }
            
            if (cmd.type == "Z") {
                ; Close path
                streamBuffer.writeString("h\n")
            }
            
            i = i + 1
        }
        
        ; Apply fill and/or stroke
        if ((fillColor.isSet) && (strokeColor.isSet)) {
            ; Set fill color
            def r:double (fillColor.r / 255.0)
            def g:double (fillColor.g / 255.0)
            def b:double (fillColor.b / 255.0)
            streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
            ; Set stroke color
            def sr:double (strokeColor.r / 255.0)
            def sg:double (strokeColor.g / 255.0)
            def sb:double (strokeColor.b / 255.0)
            streamBuffer.writeString((this.formatNum(sr)) + " " + (this.formatNum(sg)) + " " + (this.formatNum(sb)) + " RG\n")
            ; Set stroke width
            if (el.strokeWidth > 0.0) {
                streamBuffer.writeString((this.formatNum(el.strokeWidth)) + " w\n")
            }
            ; Fill and stroke
            streamBuffer.writeString("B\n")
        } {
            if fillColor.isSet {
                ; Set fill color
                def r:double (fillColor.r / 255.0)
                def g:double (fillColor.g / 255.0)
                def b:double (fillColor.b / 255.0)
                streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
                ; Fill
                streamBuffer.writeString("f\n")
            } {
                if strokeColor.isSet {
                    ; Set stroke color
                    def sr:double (strokeColor.r / 255.0)
                    def sg:double (strokeColor.g / 255.0)
                    def sb:double (strokeColor.b / 255.0)
                    streamBuffer.writeString((this.formatNum(sr)) + " " + (this.formatNum(sg)) + " " + (this.formatNum(sb)) + " RG\n")
                    ; Set stroke width
                    if (el.strokeWidth > 0.0) {
                        streamBuffer.writeString((this.formatNum(el.strokeWidth)) + " w\n")
                    }
                    ; Stroke
                    streamBuffer.writeString("S\n")
                }
            }
        }
        
        streamBuffer.writeString("Q\n")
    }
    
    fn applyClipPath:void (pathData:string x:double y:double w:double h:double) {
        ; Parse and scale the path, then use it as clipping
        def parser (new SVGPathParser())
        parser.parse(pathData)
        
        ; Get scaled commands
        def commands:[PathCommand] (parser.getScaledCommands(w h))
        
        ; Build path directly in page coordinates
        ; Note: x, y are already in PDF coordinates (y from bottom)
        ; SVG path has Y going down, PDF has Y going up
        ; So we need to flip Y: pdfY = y + h - svgY
        def i:int 0
        while (i < (array_length commands)) {
            def cmd:PathCommand (itemAt commands i)
            
            ; Transform: pageX = x + cmd.x, pageY = y + h - cmd.y
            def px:double (x + cmd.x)
            def py:double (y + h - cmd.y)
            def px1:double (x + cmd.x1)
            def py1:double (y + h - cmd.y1)
            def px2:double (x + cmd.x2)
            def py2:double (y + h - cmd.y2)
            
            if (cmd.type == "M") {
                streamBuffer.writeString((this.formatNum(px)) + " " + (this.formatNum(py)) + " m\n")
            }
            if (cmd.type == "L") {
                streamBuffer.writeString((this.formatNum(px)) + " " + (this.formatNum(py)) + " l\n")
            }
            if (cmd.type == "C") {
                streamBuffer.writeString((this.formatNum(px1)) + " " + (this.formatNum(py1)) + " " + (this.formatNum(px2)) + " " + (this.formatNum(py2)) + " " + (this.formatNum(px)) + " " + (this.formatNum(py)) + " c\n")
            }
            if (cmd.type == "Q") {
                ; Convert quadratic to cubic bezier
                streamBuffer.writeString((this.formatNum(px1)) + " " + (this.formatNum(py1)) + " " + (this.formatNum(px1)) + " " + (this.formatNum(py1)) + " " + (this.formatNum(px)) + " " + (this.formatNum(py)) + " c\n")
            }
            if (cmd.type == "Z") {
                streamBuffer.writeString("h\n")
            }
            
            i = i + 1
        }
        
        ; Apply as clipping path (W = set clipping, n = end path without fill/stroke)
        streamBuffer.writeString("W n\n")
    }
    
    ; Draw a rounded rectangle path (does not fill or stroke - just defines the path)
    ; Uses Bzier curves for the corners
    fn drawRoundedRectPath:void (x:double y:double w:double h:double radius:double) {
        ; Clamp radius to half of smallest dimension
        def maxRadius:double (w / 2.0)
        if ((h / 2.0) < maxRadius) {
            maxRadius = (h / 2.0)
        }
        def r:double radius
        if (r > maxRadius) {
            r = maxRadius
        }
        if (r <= 0.0) {
            ; No radius, use regular rectangle
            streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(y)) + " " + (this.formatNum(w)) + " " + (this.formatNum(h)) + " re\n")
            return
        }
        
        ; Bzier control point offset (approximation of circle with cubic Bzier)
        ; k = 4 * (sqrt(2) - 1) / 3  0.5523
        def k:double 0.5523
        def c:double (r * k)
        
        ; Start at bottom-left, just after the corner radius
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum((y + r))) + " m\n")
        
        ; Bottom-left corner (curve from left edge to bottom edge)
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum((y + r - c))) + " " + (this.formatNum((x + r - c))) + " " + (this.formatNum(y)) + " " + (this.formatNum((x + r))) + " " + (this.formatNum(y)) + " c\n")
        
        ; Bottom edge
        streamBuffer.writeString((this.formatNum((x + w - r))) + " " + (this.formatNum(y)) + " l\n")
        
        ; Bottom-right corner
        streamBuffer.writeString((this.formatNum((x + w - r + c))) + " " + (this.formatNum(y)) + " " + (this.formatNum((x + w))) + " " + (this.formatNum((y + r - c))) + " " + (this.formatNum((x + w))) + " " + (this.formatNum((y + r))) + " c\n")
        
        ; Right edge
        streamBuffer.writeString((this.formatNum((x + w))) + " " + (this.formatNum((y + h - r))) + " l\n")
        
        ; Top-right corner
        streamBuffer.writeString((this.formatNum((x + w))) + " " + (this.formatNum((y + h - r + c))) + " " + (this.formatNum((x + w - r + c))) + " " + (this.formatNum((y + h))) + " " + (this.formatNum((x + w - r))) + " " + (this.formatNum((y + h))) + " c\n")
        
        ; Top edge
        streamBuffer.writeString((this.formatNum((x + r))) + " " + (this.formatNum((y + h))) + " l\n")
        
        ; Top-left corner
        streamBuffer.writeString((this.formatNum((x + r - c))) + " " + (this.formatNum((y + h))) + " " + (this.formatNum(x)) + " " + (this.formatNum((y + h - r + c))) + " " + (this.formatNum(x)) + " " + (this.formatNum((y + h - r))) + " c\n")
        
        ; Left edge back to start
        streamBuffer.writeString("h\n")
    }
    
    ; Render a shadow behind an element
    fn renderShadow:void (el:EVGElement x:double y:double w:double h:double radius:double) {
        ; Check if shadow is set
        if (el.shadowRadius.isSet == false) {
            if (el.shadowColor.isSet == false) {
                return
            }
        }
        
        ; Get shadow properties
        def offsetX:double 0.0
        def offsetY:double 0.0
        if el.shadowOffsetX.isSet {
            offsetX = el.shadowOffsetX.pixels
        }
        if el.shadowOffsetY.isSet {
            ; PDF Y is flipped, so negate the Y offset
            offsetY = (0.0 - el.shadowOffsetY.pixels)
        }
        
        def blur:double 0.0
        if el.shadowRadius.isSet {
            blur = el.shadowRadius.pixels
        }
        
        ; Get shadow color (default semi-transparent black)
        def shadowColor:EVGColor el.shadowColor
        if (shadowColor.isSet == false) {
            shadowColor = (EVGColor.rgba(0 0 0 0.5))
        }
        
        ; For PDF shadow simulation, we draw multiple increasingly larger and lighter shapes
        ; starting from outside and working in, with the innermost being cut out
        ; This creates a blur effect around the element
        
        def numLayers:int 8
        if (blur < 5.0) {
            numLayers = 5
        }
        if (blur < 2.0) {
            numLayers = 3
        }
        
        ; Base alpha per layer (total should approximate shadow alpha)
        def baseAlpha:double (shadowColor.a / 255.0)
        def alphaPerLayer:double (baseAlpha / (to_double numLayers))
        
        ; Draw layers from outside to inside
        def i:int 0
        while (i < numLayers) {
            ; Calculate the spread for this layer (outermost = full blur, innermost = 0)
            def layerRatio:double ((to_double (numLayers - i)) / (to_double numLayers))
            def spread:double (blur * layerRatio)
            
            ; Alpha increases towards center for Gaussian-like falloff
            def layerAlpha:double (alphaPerLayer * (1.0 + (layerRatio * 0.5)))
            
            streamBuffer.writeString("q\n")
            
            ; Set fill color with calculated alpha (approximated by using lighter color)
            def r:double (shadowColor.r / 255.0)
            def g:double (shadowColor.g / 255.0)
            def b:double (shadowColor.b / 255.0)
            
            ; Blend towards background (assuming white/light background)
            def blendFactor:double (1.0 - layerAlpha)
            def blendedR:double ((r * layerAlpha) + (1.0 * blendFactor))
            def blendedG:double ((g * layerAlpha) + (1.0 * blendFactor))
            def blendedB:double ((b * layerAlpha) + (1.0 * blendFactor))
            
            ; Clamp to valid range
            if (blendedR > 1.0) {
                blendedR = 1.0
            }
            if (blendedG > 1.0) {
                blendedG = 1.0
            }
            if (blendedB > 1.0) {
                blendedB = 1.0
            }
            
            streamBuffer.writeString((this.formatNum(blendedR)) + " " + (this.formatNum(blendedG)) + " " + (this.formatNum(blendedB)) + " rg\n")
            
            ; Draw shadow shape at offset position with spread
            def sx:double (x + offsetX - spread)
            def sy:double (y + offsetY - spread)
            def sw:double (w + (spread * 2.0))
            def sh:double (h + (spread * 2.0))
            def sr:double (radius + spread)
            
            ; Draw outer rounded rect
            this.drawRoundedRectPath(sx sy sw sh sr)
            
            ; Cut out the inner area (next layer's area) using even-odd fill rule
            ; This creates a ring/halo effect
            if (i < (numLayers - 1)) {
                def nextRatio:double ((to_double (numLayers - i - 1)) / (to_double numLayers))
                def nextSpread:double (blur * nextRatio)
                def nx:double (x + offsetX - nextSpread)
                def ny:double (y + offsetY - nextSpread)
                def nw:double (w + (nextSpread * 2.0))
                def nh:double (h + (nextSpread * 2.0))
                def nr:double (radius + nextSpread)
                this.drawRoundedRectPath(nx ny nw nh nr)
            }
            
            ; Use even-odd fill rule to create the ring
            streamBuffer.writeString("f*\n")
            streamBuffer.writeString("Q\n")
            
            i = i + 1
        }
    }
    
    fn renderBackgroundWithRadius:void (x:double y:double w:double h:double color:EVGColor radius:double) {
        streamBuffer.writeString("q\n")
        ; Set fill color
        def r:double (color.r / 255.0)
        def g:double (color.g / 255.0)
        def b:double (color.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
        ; Draw rounded rectangle
        this.drawRoundedRectPath(x y w h radius)
        streamBuffer.writeString("f\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderBackground:void (x:double y:double w:double h:double color:EVGColor) {
        this.renderBackgroundWithRadius(x y w h color 0.0)
    }
    
    ; Render a gradient background by drawing multiple thin strips
    ; Parses CSS gradient syntax: linear-gradient(angle, color1, color2, ...)
    fn renderGradientBackground:void (el:EVGElement x:double y:double w:double h:double radius:double) {
        def gradient:string el.backgroundGradient
        
        ; Parse gradient type and angle
        def isLinear:boolean (contains gradient "linear-gradient")
        def isRadial:boolean (contains gradient "radial-gradient")
        
        if (isLinear == false) {
            if (isRadial == false) {
                return
            }
        }
        
        ; Extract colors from gradient string
        ; Format: linear-gradient(90deg, #ff0000, #0000ff)
        ; or: radial-gradient(circle, #ff0000, #0000ff)
        
        ; Find the opening parenthesis
        def parenStart:int (indexOf gradient "(")
        if (parenStart < 0) {
            return
        }
        
        ; Find the closing parenthesis
        def parenEnd:int (lastIndexOf gradient ")")
        if (parenEnd < 0) {
            return
        }
        
        ; Extract content inside parentheses
        def content:string (substring gradient (parenStart + 1) parenEnd)
        
        ; Split by comma
        def parts:[string] (strsplit content ",")
        if ((array_length parts) < 2) {
            return
        }
        
        ; First part is angle (for linear) or shape (for radial)
        def firstPart:string (trim (itemAt parts 0))
        def angle:double 180.0
        
        if isLinear {
            ; Parse angle (e.g., "90deg", "45deg", "180deg")
            if (contains firstPart "deg") {
                def angleStr:string (replace firstPart "deg" "")
                def angleVal@(optional):double (to_double angleStr)
                if angleVal {
                    angle = (unwrap angleVal)
                }
            }
        }
        
        ; Collect colors (remaining parts)
        def colors:[EVGColor]
        def i:int 1
        while (i < (array_length parts)) {
            def colorStr:string (trim (itemAt parts i))
            def color:EVGColor (EVGColor.parse(colorStr))
            if color.isSet {
                push colors color
            }
            i = i + 1
        }
        
        if ((array_length colors) < 2) {
            ; Not enough colors, just use first color as solid
            if ((array_length colors) == 1) {
                def c:EVGColor (itemAt colors 0)
                this.renderBackgroundWithRadius(x y w h c radius)
            }
            return
        }
        
        ; Clip to the rounded rectangle shape first
        streamBuffer.writeString("q\n")
        if (radius > 0.0) {
            this.drawRoundedRectPath(x y w h radius)
            streamBuffer.writeString("W n\n")
        }
        
        ; Calculate gradient direction
        def numSteps:int 50
        def radians:double ((angle * 3.14159265) / 180.0)
        
        ; Determine if horizontal, vertical, or diagonal
        def isHorizontal:boolean false
        def isVertical:boolean false
        
        ; Normalize angle to 0-360
        while (angle < 0.0) {
            angle = angle + 360.0
        }
        while (angle >= 360.0) {
            angle = angle - 360.0
        }
        
        ; Approximate angle to major directions for simpler rendering
        if ((angle >= 45.0) && (angle < 135.0)) {
            ; Right (90 deg)
            isHorizontal = true
        }
        if ((angle >= 135.0) && (angle < 225.0)) {
            ; Down (180 deg)
            isVertical = true
        }
        if ((angle >= 225.0) && (angle < 315.0)) {
            ; Left (270 deg)
            isHorizontal = true
        }
        if ((angle >= 315.0) || (angle < 45.0)) {
            ; Up (0 deg or 360 deg)
            isVertical = true
        }
        
        ; Draw gradient strips
        def stepIdx:int 0
        while (stepIdx < numSteps) {
            def t:double ((to_double stepIdx) / (to_double (numSteps - 1)))
            
            ; Interpolate color
            def colorIdx:double (t * (to_double ((array_length colors) - 1)))
            def idx1:int (to_int colorIdx)
            def idx2:int (idx1 + 1)
            if (idx2 >= (array_length colors)) {
                idx2 = ((array_length colors) - 1)
            }
            def localT:double (colorIdx - (to_double idx1))
            
            def c1:EVGColor (itemAt colors idx1)
            def c2:EVGColor (itemAt colors idx2)
            
            ; Linear interpolation of RGB
            def r:double (((c1.r * (1.0 - localT)) + (c2.r * localT)) / 255.0)
            def g:double (((c1.g * (1.0 - localT)) + (c2.g * localT)) / 255.0)
            def b:double (((c1.b * (1.0 - localT)) + (c2.b * localT)) / 255.0)
            
            streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
            
            ; Draw a strip
            if isHorizontal {
                def stripW:double (w / (to_double numSteps))
                def stripX:double x
                if ((angle >= 225.0) && (angle < 315.0)) {
                    ; Left direction - reverse
                    stripX = (x + w - (stripW * (to_double (stepIdx + 1))))
                } {
                    stripX = (x + (stripW * (to_double stepIdx)))
                }
                streamBuffer.writeString((this.formatNum(stripX)) + " " + (this.formatNum(y)) + " " + (this.formatNum((stripW + 0.5))) + " " + (this.formatNum(h)) + " re\n")
            } {
                def stripH:double (h / (to_double numSteps))
                def stripY:double y
                if ((angle >= 135.0) && (angle < 225.0)) {
                    ; Down direction
                    stripY = (y + h - (stripH * (to_double (stepIdx + 1))))
                } {
                    ; Up direction - reverse
                    stripY = (y + (stripH * (to_double stepIdx)))
                }
                streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(stripY)) + " " + (this.formatNum(w)) + " " + (this.formatNum((stripH + 0.5))) + " re\n")
            }
            streamBuffer.writeString("f\n")
            
            stepIdx = stepIdx + 1
        }
        
        streamBuffer.writeString("Q\n")
    }
    
    fn renderBorderWithRadius:void (el:EVGElement x:double y:double w:double h:double radius:double) {
        ; Get border width from box
        def borderWidth:double el.box.borderWidth.pixels
        if (borderWidth <= 0.0) {
            return
        }
        
        ; Get border color
        def borderColor:EVGColor (unwrap el.box.borderColor)
        if (borderColor.isSet == false) {
            borderColor = (EVGColor.black())
        }
        
        streamBuffer.writeString("q\n")
        ; Set stroke color
        def r:double (borderColor.r / 255.0)
        def g:double (borderColor.g / 255.0)
        def b:double (borderColor.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " RG\n")
        ; Set line width
        streamBuffer.writeString((this.formatNum(borderWidth)) + " w\n")
        ; Draw rounded rectangle outline
        this.drawRoundedRectPath(x y w h radius)
        streamBuffer.writeString("S\n")
        streamBuffer.writeString("Q\n")
    }

    fn renderBorder:void (el:EVGElement x:double y:double w:double h:double) {
        ; Get border width from box
        def borderWidth:double el.box.borderWidth.pixels
        if (borderWidth <= 0.0) {
            return
        }
        
        ; Get border color
        def borderColor:EVGColor (unwrap el.box.borderColor)
        if (borderColor.isSet == false) {
            borderColor = (EVGColor.black())
        }
        
        streamBuffer.writeString("q\n")
        ; Set stroke color
        def r:double (borderColor.r / 255.0)
        def g:double (borderColor.g / 255.0)
        def b:double (borderColor.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " RG\n")
        ; Set line width
        streamBuffer.writeString((this.formatNum(borderWidth)) + " w\n")
        ; Draw rectangle outline
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(y)) + " " + (this.formatNum(w)) + " " + (this.formatNum(h)) + " re\n")
        streamBuffer.writeString("S\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderText:void (el:EVGElement x:double y:double w:double h:double) {
        ; Get text content (scan children for text nodes)
        def text:string (this.getTextContent(el))
        if ((strlen text) == 0) {
            return
        }
        
        ; Get font size
        def fontSize:double 14.0
        if el.fontSize.isSet {
            fontSize = el.fontSize.pixels
        }
        
        ; Get text color
        def color:EVGColor el.color
        if (color.isSet == false) {
            color = (EVGColor.black())
        }
        
        ; Get line height
        def lineHeight:double el.lineHeight
        if (lineHeight <= 0.0) {
            lineHeight = 1.2
        }
        def lineSpacing:double (fontSize * lineHeight)
        
        ; Get font family
        def fontFamily:string el.fontFamily
        if ((strlen fontFamily) == 0) {
            fontFamily = "Helvetica"
        }
        
        ; Wrap text to fit width using correct font
        def lines:[string] (this.wrapText(text w fontSize fontFamily))
        
        ; Get PDF font name
        def fontName:string (this.getPdfFontName(fontFamily))
        
        ; Check for text shadow
        def hasShadow:boolean false
        def shadowOffsetX:double 0.0
        def shadowOffsetY:double 0.0
        def shadowBlur:double 0.0
        def shadowColor:EVGColor (EVGColor.rgba(0 0 0 0.5))
        
        if (el.shadowRadius.isSet || el.shadowColor.isSet) {
            hasShadow = true
            if el.shadowOffsetX.isSet {
                shadowOffsetX = el.shadowOffsetX.pixels
            }
            if el.shadowOffsetY.isSet {
                ; PDF Y is flipped
                shadowOffsetY = (0.0 - el.shadowOffsetY.pixels)
            }
            if el.shadowRadius.isSet {
                shadowBlur = el.shadowRadius.pixels
            }
            if el.shadowColor.isSet {
                shadowColor = (unwrap el.shadowColor)
            }
        }
        
        ; Render each line (shadow first if present, then text)
        def lineY:double (y + h - fontSize)
        def i:int 0
        while (i < (array_length lines)) {
            def line:string (itemAt lines i)
            
            ; Calculate text X position based on alignment
            def textX:double x
            if (el.textAlign == "center") {
                def textWidth:double (measurer.measureTextWidth(line fontFamily fontSize))
                textX = x + ((w - textWidth) / 2.0)
            }
            if (el.textAlign == "right") {
                def textWidth:double (measurer.measureTextWidth(line fontFamily fontSize))
                textX = x + w - textWidth
            }
            
            ; Render shadow text first (if shadow is set)
            if hasShadow {
                ; For blur effect, render multiple slightly offset shadow copies
                def numPasses:int 1
                if (shadowBlur > 1.0) {
                    numPasses = 3
                }
                
                def pass:int 0
                while (pass < numPasses) {
                    def blurOffset:double 0.0
                    if (numPasses > 1) {
                        blurOffset = (shadowBlur * 0.3 * (to_double pass))
                    }
                    
                    ; Calculate shadow color (blend towards background for blur effect)
                    def shadowAlpha:double ((shadowColor.a / 255.0) / (to_double numPasses))
                    def blendFactor:double (1.0 - shadowAlpha)
                    def sr:double (((shadowColor.r / 255.0) * shadowAlpha) + (1.0 * blendFactor))
                    def sg:double (((shadowColor.g / 255.0) * shadowAlpha) + (1.0 * blendFactor))
                    def sb:double (((shadowColor.b / 255.0) * shadowAlpha) + (1.0 * blendFactor))
                    
                    streamBuffer.writeString("BT\n")
                    streamBuffer.writeString(fontName + " " + (this.formatNum(fontSize)) + " Tf\n")
                    streamBuffer.writeString((this.formatNum(sr)) + " " + (this.formatNum(sg)) + " " + (this.formatNum(sb)) + " rg\n")
                    
                    def shadowX:double (textX + shadowOffsetX + blurOffset)
                    def shadowY:double (lineY + shadowOffsetY - blurOffset)
                    streamBuffer.writeString((this.formatNum(shadowX)) + " " + (this.formatNum(shadowY)) + " Td\n")
                    streamBuffer.writeString("(" + (this.escapeText(line)) + ") Tj\n")
                    streamBuffer.writeString("ET\n")
                    
                    pass = pass + 1
                }
            }
            
            ; Render actual text
            streamBuffer.writeString("BT\n")
            streamBuffer.writeString(fontName + " " + (this.formatNum(fontSize)) + " Tf\n")
            
            ; Set text color
            def r:double (color.r / 255.0)
            def g:double (color.g / 255.0)
            def b:double (color.b / 255.0)
            streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
            
            streamBuffer.writeString((this.formatNum(textX)) + " " + (this.formatNum(lineY)) + " Td\n")
            streamBuffer.writeString("(" + (this.escapeText(line)) + ") Tj\n")
            streamBuffer.writeString("ET\n")
            
            lineY = lineY - lineSpacing
            i = i + 1
        }
    }
    
    fn wrapText:[string] (text:string maxWidth:double fontSize:double fontFamily:string) {
        ; Word wrap text to fit within maxWidth
        def lines:[string]
        def words:[string] (strsplit text " ")
        def currentLine:string ""
        
        def i:int 0
        while (i < (array_length words)) {
            def word:string (itemAt words i)
            def testLine:string ""
            if ((strlen currentLine) == 0) {
                testLine = word
            } {
                testLine = currentLine + " " + word
            }
            
            def testWidth:double (measurer.measureTextWidth(testLine fontFamily fontSize))
            if ((testWidth > maxWidth) && ((strlen currentLine) > 0)) {
                ; Line is too long, push current and start new
                push lines currentLine
                currentLine = word
            } {
                currentLine = testLine
            }
            
            i = i + 1
        }
        
        ; Push final line
        if ((strlen currentLine) > 0) {
            push lines currentLine
        }
        
        return lines
    }
    
    fn renderDivider:void (el:EVGElement x:double y:double w:double h:double) {
        ; Render a horizontal line
        def color:EVGColor el.color
        if (color.isSet == false) {
            color = (EVGColor.rgb(200 200 200))
        }
        
        def lineY:double (y + (h / 2.0))
        
        streamBuffer.writeString("q\n")
        def r:double (color.r / 255.0)
        def g:double (color.g / 255.0)
        def b:double (color.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " RG\n")
        streamBuffer.writeString("1 w\n")
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(lineY)) + " m\n")
        streamBuffer.writeString((this.formatNum((x + w))) + " " + (this.formatNum(lineY)) + " l\n")
        streamBuffer.writeString("S\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn getTextContent:string (el:EVGElement) {
        ; If element has textContent property, use it
        if ((strlen el.textContent) > 0) {
            return el.textContent
        }
        
        ; Otherwise, collect text from all child text nodes
        def result:string ""
        def i:int 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            if (child.tagName == "text") {
                def childText:string child.textContent
                if ((strlen childText) > 0) {
                    ; Add space between text nodes if needed
                    if ((strlen result) > 0) {
                        def lastChar:int (charAt result ((strlen result) - 1))
                        def firstChar:int (charAt childText 0)
                        ; Add space if neither ends/starts with whitespace
                        if ((lastChar != 32) && (firstChar != 32)) {
                            result = result + " "
                        }
                    }
                    result = result + childText
                }
            }
            i = i + 1
        }
        return result
    }
    
    fn estimateTextWidth:double (text:string fontSize:double) {
        ; Use the same text measurer as layout for consistent results
        return (measurer.measureTextWidth(text "Helvetica" fontSize))
    }
    
    fn toOctalEscape:string (ch:int) {
        ; Convert a byte value (0-255) to PDF octal escape format \NNN
        ; e.g., 196 () becomes \304
        def d0:int (ch % 8)
        def t1:int (floor (ch / 8))
        def d1:int (t1 % 8)
        def d2:int (floor (t1 / 8))
        return ("\\" + (to_string d2) + (to_string d1) + (to_string d0))
    }
    
    fn escapeText:string (text:string) {
        ; Escape parentheses and backslashes for PDF
        ; Also handle Unicode characters outside WinAnsi range
        ; For high-byte characters (128-255), use PDF octal escape \NNN
        ; because Go strings are UTF-8 and can't represent raw bytes 128-255 directly
        def result:string ""
        def len:int (strlen text)
        def i 0
        while (i < len) {
            def ch:int (charAt text i)
            if (ch == 40) {  ; (
                result = result + "\\("
            } {
                if (ch == 41) {  ; )
                    result = result + "\\)"
                } {
                    if (ch == 92) {  ; \
                        result = result + "\\\\"
                    } {
                        if (ch < 32) {
                            ; Control characters - skip or use octal
                            result = result + " "
                        } {
                            if (ch < 128) {
                                ; ASCII range - safe to use directly
                                result = result + (strfromcode ch)
                            } {
                                if (ch <= 255) {
                                    ; High-byte WinAnsi characters (128-255)
                                    ; Must use PDF octal escape \NNN
                                    result = result + (this.toOctalEscape(ch))
                                } {
                                    ; Unicode character outside WinAnsi - use placeholder
                                    result = result + "?"
                                }
                            }
                        }
                    }
                }
            }
            i = i + 1
        }
        return result
    }
    
    fn formatNum:string (n:double) {
        ; Format number for PDF - simple conversion
        ; PDF doesn't need high precision for most values
        def result:string (to_string n)
        return result
    }
    
    fn padLeft:string (s:string len:int padChar:string) {
        def result:string s
        while ((strlen result) < len) {
            result = padChar + result
        }
        return result
    }
    
    fn sanitizeFontName:string (name:string) {
        ; Remove spaces and special characters from font name for PDF
        def result:string ""
        def len:int (strlen name)
        def i 0
        while (i < len) {
            def ch:int (charAt name i)
            ; Only allow alphanumeric characters
            if (((ch >= 65) && (ch <= 90)) || ((ch >= 97) && (ch <= 122)) || ((ch >= 48) && (ch <= 57))) {
                result = result + (strfromcode ch)
            }
            i = i + 1
        }
        return result
    }
}
