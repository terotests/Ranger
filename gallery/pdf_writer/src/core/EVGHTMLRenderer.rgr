; EVGHTMLRenderer.rgr - Render EVG elements to HTML/CSS
; 
; Takes EVG element tree with calculated positions and renders to HTML.
; Used for:
; - Unit testing (verify layout output)
; - Fast preview (instant browser preview)
; - Development iteration (no PDF generation overhead)

Import "../../../evg/EVGElement.rgr"
Import "../../../evg/EVGLayout.rgr"
Import "../../../evg/EVGTextMeasurer.rgr"
Import "../../../evg/EVGUnit.rgr"
Import "../../../evg/EVGColor.rgr"
Import "EVGResourceLoader.rgr"

class EVGHTMLRenderer {
    def layout:EVGLayout
    def measurer:EVGTextMeasurer
    def resourceLoader:EVGResourceLoader
    def pageWidth:double 595.0
    def pageHeight:double 842.0
    def debug:boolean false
    def indentLevel:int 0
    def indentString:string "  "
    def usedFontFamilies:[string]
    def fontBasePath:string "./fonts/"
    def imageBasePath:string "./"
    def outputMode:string "inline"  ; "inline" | "stylesheet" | "both"
    def prettyPrint:boolean true
    def elementCounter:int 0
    def title:string "EVG Preview"
    def baseDir:string "./"
    def embedAssets:boolean false
    ; For tracking server URL prefix for images and fonts
    def imageServerUrl:string ""
    ; Temporary arrays for collecting elements (like PDF renderer)
    def foundSections:[EVGElement]
    def foundPages:[EVGElement]
    
    Constructor () {
        def lay (new EVGLayout())
        layout = lay
        def m (new SimpleTextMeasurer())
        measurer = m
        def rl (new EVGResourceLoader())
        resourceLoader = rl
        def uf:[string]
        usedFontFamilies = uf
        def fs:[EVGElement]
        foundSections = fs
        def fp:[EVGElement]
        foundPages = fp
    }
    
    fn setPageSize:void (width:double height:double) {
        pageWidth = width
        pageHeight = height
        layout.setPageSize(width height)
    }
    
    fn setMeasurer:void (m:EVGTextMeasurer) {
        measurer = m
        layout.setMeasurer(m)
    }
    
    fn setDebug:void (enabled:boolean) {
        layout.debug = enabled
        this.debug = enabled
        resourceLoader.debug = enabled
    }
    
    fn setFontBasePath:void (path:string) {
        fontBasePath = path
    }
    
    fn setImageBasePath:void (path:string) {
        imageBasePath = path
    }
    
    fn setTitle:void (t:string) {
        title = t
    }
    
    fn setBaseDir:void (dir:string) {
        baseDir = dir
        imageBasePath = dir
    }
    
    fn setEmbedAssets:void (embed:boolean) {
        embedAssets = embed
    }
    
    ; Resolve an image path, removing leading "./" if present
    fn resolveImagePath:string (src:string) {
        def imgSrc:string src
        if ((strlen src) > 2) {
            def prefix:string (substring src 0 2)
            if (prefix == "./") {
                imgSrc = (substring src 2 (strlen src))
            }
        }
        return imgSrc
    }

    ; =========================================================================
    ; Main render entry point
    ; =========================================================================
    
    fn render:string (root:EVGElement) {
        ; Reset state
        elementCounter = 0
        def uf:[string]
        usedFontFamilies = uf
        
        ; STEP 1: Load resource metadata (image dimensions)
        ; This must happen BEFORE layout calculation
        resourceLoader.setBasePath(baseDir)
        resourceLoader.loadResources(root)
        
        ; STEP 2: Run layout to calculate positions
        ; Now layout engine knows image dimensions for proper flexbox calculation
        layout.layout(root)
        
        ; Collect used fonts
        this.collectFonts(root)
        
        ; Generate HTML document
        def html:string ""
        html = html + "<!DOCTYPE html>\n"
        html = html + "<html>\n"
        html = html + "<head>\n"
        html = html + "  <meta charset=\"UTF-8\">\n"
        html = html + "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n"
        html = html + "  <title>" + title + "</title>\n"
        html = html + (this.generateStyleBlock())
        html = html + "</head>\n"
        html = html + "<body>\n"
        
        ; Add page container with visual boundaries
        html = html + "  <div class=\"evg-page-container\">\n"
        html = html + (this.renderElement(root 2))
        html = html + "  </div>\n"
        
        html = html + "</body>\n"
        html = html + "</html>\n"
        
        return html
    }
    
    ; Render a single page (for multi-page documents)
    fn renderPage:string (root:EVGElement pageNum:int) {
        ; Reset state
        elementCounter = 0
        
        ; STEP 1: Load resource metadata
        resourceLoader.setBasePath(baseDir)
        resourceLoader.loadResources(root)
        
        ; STEP 2: Run layout
        layout.layout(root)
        
        ; Render only elements on specified page
        def html:string ""
        html = html + (this.renderElementForPage(root pageNum 1))
        
        return html
    }
    
    ; =========================================================================
    ; Style generation
    ; =========================================================================
    
    fn generateStyleBlock:string () {
        def css:string "  <style>\n"
        
        ; Reset styles
        css = css + "    * { margin: 0; padding: 0; box-sizing: border-box; }\n"
        css = css + "    body { \n"
        css = css + "      background: #b0b0b0; \n"
        css = css + "      padding: 40px; \n"
        css = css + "      min-height: 100vh;\n"
        css = css + "      display: flex;\n"
        css = css + "      justify-content: center;\n"
        css = css + "    }\n"
        
        ; Font-face declarations (with embedded base64 if enabled)
        def i:int 0
        while (i < (array_length usedFontFamilies)) {
            def fontFamily:string (itemAt usedFontFamilies i)
            css = css + (this.generateFontFace(fontFamily))
            i = i + 1
        }
        
        ; Page container - visualizes actual page boundaries
        css = css + "    .evg-page-container {\n"
        css = css + "      width: " + (to_string (to_int pageWidth)) + "px;\n"
        css = css + "      height: " + (to_string (to_int pageHeight)) + "px;\n"
        css = css + "      background: white;\n"
        css = css + "      box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);\n"
        css = css + "      position: relative;\n"
        css = css + "      overflow: hidden;\n"
        css = css + "      flex-shrink: 0;\n"
        css = css + "    }\n"
        
        ; Legacy page style (for Section/Page elements)
        css = css + "    .evg-page {\n"
        css = css + "      background: white;\n"
        css = css + "      box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n"
        css = css + "      margin: 0 auto 20px auto;\n"
        css = css + "      position: relative;\n"
        css = css + "      overflow: hidden;\n"
        css = css + "    }\n"
        
        ; Common element styles
        css = css + "    .evg-view { position: relative; }\n"
        css = css + "    .evg-label { display: block; }\n"
        css = css + "    .evg-image { display: block; }\n"
        
        css = css + "  </style>\n"
        
        return css
    }
    
    fn generateFontFace:string (fontFamily:string) {
        ; Generate @font-face for a font family
        ; Convert font family name to filename
        def fileName:string (this.fontFamilyToFileName(fontFamily))
        def fontPath:string fontBasePath
        
        def css:string ""
        css = css + "    @font-face {\n"
        css = css + "      font-family: '" + fontFamily + "';\n"
        
        ; Only try to embed fonts that have valid paths (contain /)
        ; System fonts like Helvetica.ttf won't be embedded
        def canEmbed:boolean false
        if embedAssets {
            if ((indexOf fileName "/") >= 0) {
                canEmbed = true
            }
        }
        
        if canEmbed {
            ; Try to embed font as base64 data URI
            def resolvedPath:string (this.resolveImagePath(fileName))
            def buf:buffer (buffer_read_file fontPath resolvedPath)
            def len:int (buffer_length buf)
            if (len > 0) {
                def base64:string (buffer_to_base64 buf)
                css = css + "      src: url('data:font/ttf;base64," + base64 + "');\n"
            } {
                ; Fallback to URL if file not found
                css = css + "      src: url('" + fontPath + fileName + "');\n"
            }
        } {
            css = css + "      src: url('" + fontPath + fileName + "');\n"
        }
        css = css + "    }\n"
        
        return css
    }
    
    fn fontFamilyToFileName:string (fontFamily:string) {
        ; Map font family names to actual font file paths
        ; Fonts are stored in FolderName/FileName.ttf structure
        if (fontFamily == "Noto Sans") {
            return "Noto_Sans/NotoSans-Regular.ttf"
        }
        if (fontFamily == "Noto Sans Bold") {
            return "Noto_Sans/NotoSans-Bold.ttf"
        }
        if (fontFamily == "Helvetica") {
            return "Helvetica/Helvetica.ttf"
        }
        ; Google Fonts mappings
        if (fontFamily == "Amatic SC") {
            return "Amatic_SC/AmaticSC-Regular.ttf"
        }
        if (fontFamily == "Amatic SC Bold") {
            return "Amatic_SC/AmaticSC-Bold.ttf"
        }
        if (fontFamily == "Gloria Hallelujah") {
            return "Gloria_Hallelujah/GloriaHallelujah.ttf"
        }
        if (fontFamily == "Josefin Slab") {
            return "Josefin_Slab/JosefinSlab-Regular.ttf"
        }
        if (fontFamily == "Josefin Slab Bold") {
            return "Josefin_Slab/JosefinSlab-Bold.ttf"
        }
        if (fontFamily == "Katibeh") {
            return "Katibeh/Katibeh-Regular.ttf"
        }
        if (fontFamily == "Alike Angular") {
            return "Alike_Angular/AlikeAngular-Regular.ttf"
        }
        ; Default: remove spaces and add .ttf
        def result:string ""
        def i:int 0
        while (i < (strlen fontFamily)) {
            def ch:string (substring fontFamily i (i + 1))
            if (ch != " ") {
                result = result + ch
            }
            i = i + 1
        }
        return (result + ".ttf")
    }
    
    ; =========================================================================
    ; Element rendering
    ; =========================================================================
    
    fn renderElement:string (el:EVGElement depth:int) {
        ; Render with parent position 0,0 (root level)
        return (this.renderElementWithParent(el depth 0.0 0.0))
    }
    
    fn renderElementWithParent:string (el:EVGElement depth:int parentX:double parentY:double) {
        elementCounter = elementCounter + 1
        def elementId:string ("evg-" + (to_string elementCounter))
        
        ; Generate element based on type (check both cases for JSX/EVG compatibility)
        if ((el.tagName == "Print") || (el.tagName == "print")) {
            return (this.renderPrint(el depth))
        }
        if ((el.tagName == "Section") || (el.tagName == "section")) {
            return (this.renderSection(el depth))
        }
        if ((el.tagName == "Page") || (el.tagName == "page")) {
            return (this.renderPage_Element(el depth))
        }
        if ((el.tagName == "View") || (el.tagName == "div") || (el.tagName == "layer") || (el.tagName == "Layer")) {
            return (this.renderViewWithParent(el elementId depth parentX parentY))
        }
        if ((el.tagName == "Label") || (el.tagName == "span") || (el.tagName == "text")) {
            return (this.renderLabelWithParent(el elementId depth parentX parentY))
        }
        if ((el.tagName == "Image") || (el.tagName == "img") || (el.tagName == "image")) {
            return (this.renderImageWithParent(el elementId depth parentX parentY))
        }
        if ((el.tagName == "Path") || (el.tagName == "path")) {
            return (this.renderPathWithParent(el elementId depth parentX parentY))
        }
        if ((el.tagName == "Rect") || (el.tagName == "rect")) {
            return (this.renderViewWithParent(el elementId depth parentX parentY))
        }
        
        ; Unknown element - render as div with children
        return (this.renderViewWithParent(el elementId depth parentX parentY))
    }
    
    fn renderElementForPage:string (el:EVGElement pageNum:int depth:int) {
        ; Only render elements on the specified page
        if (el.calculatedPage != pageNum) {
            ; Check children - they might be on the target page
            def childHtml:string ""
            def i:int 0
            while (i < (array_length el.children)) {
                def child:EVGElement (itemAt el.children i)
                childHtml = childHtml + (this.renderElementForPage(child pageNum depth))
                i = i + 1
            }
            return childHtml
        }
        return (this.renderElement(el depth))
    }
    
    ; =========================================================================
    ; Print/Section/Page rendering (document structure)
    ; =========================================================================
    
    fn renderPrint:string (el:EVGElement depth:int) {
        ; Print is the root document container
        ; Update renderer page dimensions from Print element
        if (el.pageWidth > 0.0) {
            pageWidth = el.pageWidth
        }
        if (el.pageHeight > 0.0) {
            pageHeight = el.pageHeight
        }
        
        def html:string ""
        html = html + (this.indent(depth)) + "<div class=\"evg-document\">\n"
        
        ; Render children (Sections or Pages)
        def i:int 0
        while (i < (array_length el.children)) {
            def child:EVGElement (itemAt el.children i)
            html = html + (this.renderElement(child (depth + 1)))
            i = i + 1
        }
        
        html = html + (this.indent(depth)) + "</div>\n"
        return html
    }
    
    fn renderSection:string (el:EVGElement depth:int) {
        ; Section groups pages with common settings
        def html:string ""
        html = html + (this.indent(depth)) + "<div class=\"evg-section\">\n"
        
        ; Render children (Pages)
        def i:int 0
        while (i < (array_length el.children)) {
            def child:EVGElement (itemAt el.children i)
            html = html + (this.renderElement(child (depth + 1)))
            i = i + 1
        }
        
        html = html + (this.indent(depth)) + "</div>\n"
        return html
    }
    
    fn renderPage_Element:string (el:EVGElement depth:int) {
        ; Page is a fixed-size container
        def w:double el.calculatedWidth
        def h:double el.calculatedHeight
        if (w <= 0.0) {
            w = pageWidth
        }
        if (h <= 0.0) {
            h = pageHeight
        }
        
        def html:string ""
        html = html + (this.indent(depth)) + "<div class=\"evg-page\" style=\""
        html = html + "width: " + (this.formatPx(w)) + "; "
        html = html + "height: " + (this.formatPx(h)) + "; "
        
        ; Add padding if set
        def pt:double (this.getResolvedPadding(el "top"))
        def pr:double (this.getResolvedPadding(el "right"))
        def pb:double (this.getResolvedPadding(el "bottom"))
        def pl:double (this.getResolvedPadding(el "left"))
        if ((pt > 0.0) || (pr > 0.0) || (pb > 0.0) || (pl > 0.0)) {
            html = html + "padding: " + (this.formatPx(pt)) + " " + (this.formatPx(pr)) + " " + (this.formatPx(pb)) + " " + (this.formatPx(pl)) + "; "
        }
        
        html = html + "\">\n"
        
        ; Render children - pass page position so children render relative to page
        def i:int 0
        while (i < (array_length el.children)) {
            def child:EVGElement (itemAt el.children i)
            html = html + (this.renderElementWithParent(child (depth + 1) el.calculatedX el.calculatedY))
            i = i + 1
        }
        
        html = html + (this.indent(depth)) + "</div>\n"
        return html
    }
    
    ; =========================================================================
    ; View rendering
    ; =========================================================================
    
    fn renderView:string (el:EVGElement elementId:string depth:int) {
        return (this.renderViewWithParent(el elementId depth 0.0 0.0))
    }
    
    fn renderViewWithParent:string (el:EVGElement elementId:string depth:int parentX:double parentY:double) {
        def html:string ""
        html = html + (this.indent(depth)) + "<div"
        
        ; Add id if element has one
        if ((strlen el.id) > 0) {
            html = html + " id=\"" + el.id + "\""
        }
        
        ; Add class - use evg-layer for layer elements
        if ((el.tagName == "layer") || (el.tagName == "Layer")) {
            html = html + " class=\"evg-layer\""
        } {
            html = html + " class=\"evg-view\""
        }
        
        ; Add inline styles - calculate position relative to parent
        ; For absolute elements, calculatedX/Y are already relative to parent
        ; For flow elements, we need to subtract parent's absolute position
        def relX:double 0.0
        def relY:double 0.0
        if el.isAbsolute {
            relX = el.calculatedX
            relY = el.calculatedY
        } {
            relX = (el.calculatedX - parentX)
            relY = (el.calculatedY - parentY)
        }
        
        html = html + " style=\""
        html = html + (this.generateViewStylesRelative(el relX relY))
        html = html + "\""
        
        html = html + ">\n"
        
        ; Render children with this element's position as parent
        def i:int 0
        while (i < (array_length el.children)) {
            def child:EVGElement (itemAt el.children i)
            html = html + (this.renderElementWithParent(child (depth + 1) el.calculatedX el.calculatedY))
            i = i + 1
        }
        
        html = html + (this.indent(depth)) + "</div>\n"
        return html
    }
    
    fn generateViewStylesRelative:string (el:EVGElement relX:double relY:double) {
        def css:string ""
        
        ; Layer elements overlay parent with inset: 0
        if ((el.tagName == "layer") || (el.tagName == "Layer")) {
            css = css + "position: absolute; "
            css = css + "inset: 0; "
            css = css + "pointer-events: none; "  ; Allow clicks through to elements below
        } {
            ; Regular positioning from layout calculation
            css = css + "position: absolute; "
            css = css + "left: " + (this.formatPx(relX)) + "; "
            css = css + "top: " + (this.formatPx(relY)) + "; "
            
            ; Regular dimensions from layout calculation
            if (el.calculatedWidth > 0.0) {
                css = css + "width: " + (this.formatPx(el.calculatedWidth)) + "; "
            }
            if (el.calculatedHeight > 0.0) {
                css = css + "height: " + (this.formatPx(el.calculatedHeight)) + "; "
            }
        }
        
        ; Display and flexbox (for reference, though we use absolute positioning)
        if (el.display == "flex") {
            css = css + "display: flex; "
            css = css + "flex-direction: " + el.flexDirection + "; "
            if ((strlen el.justifyContent) > 0) {
                css = css + "justify-content: " + el.justifyContent + "; "
            }
            if ((strlen el.alignItems) > 0) {
                css = css + "align-items: " + el.alignItems + "; "
            }
            if (el.gap.isSet) {
                css = css + "gap: " + (this.formatPx(el.gap.pixels)) + "; "
            }
        }
        
        ; Background (gradient takes precedence over color)
        if ((strlen el.backgroundGradient) > 0) {
            css = css + "background: " + el.backgroundGradient + "; "
        } {
            if el.backgroundColor.isSet {
                css = css + "background-color: " + (el.backgroundColor.toCSSString()) + "; "
            }
        }
        
        ; Border
        def bw:double 0.0
        if el.box.borderWidth.isSet {
            bw = el.box.borderWidth.pixels
        }
        if (bw > 0.0) {
            css = css + "border-width: " + (this.formatPx(bw)) + "; "
            css = css + "border-style: solid; "
            if el.box.borderColor.isSet {
                css = css + "border-color: " + (el.box.borderColor.toCSSString()) + "; "
            }
        }
        
        ; Border radius
        if el.box.borderRadius.isSet {
            css = css + "border-radius: " + (this.formatPx(el.box.borderRadius.pixels)) + "; "
        }
        
        ; Padding
        def pt:double (this.getResolvedPadding(el "top"))
        def pr:double (this.getResolvedPadding(el "right"))
        def pb:double (this.getResolvedPadding(el "bottom"))
        def pl:double (this.getResolvedPadding(el "left"))
        if ((pt > 0.0) || (pr > 0.0) || (pb > 0.0) || (pl > 0.0)) {
            css = css + "padding: " + (this.formatPx(pt)) + " " + (this.formatPx(pr)) + " " + (this.formatPx(pb)) + " " + (this.formatPx(pl)) + "; "
        }
        
        ; Note: We do NOT output CSS margin for absolute-positioned elements
        ; because the layout engine has already calculated positions (left, top)
        ; with margins taken into account, and width/height adjusted accordingly.
        ; CSS margin on position:absolute elements would add extra unwanted offset.
        
        ; Overflow
        if (el.overflow == "hidden") {
            css = css + "overflow: hidden; "
        }
        
        ; Opacity
        if (el.opacity < 1.0) {
            css = css + "opacity: " + (to_string el.opacity) + "; "
        }
        
        ; Box shadow
        css = css + (this.generateBoxShadow(el))
        
        return css
    }
    
    ; Generate CSS box-shadow from EVG shadow properties
    fn generateBoxShadow:string (el:EVGElement) {
        ; Shadow requires at least shadowRadius or shadowColor to be set
        if (el.shadowRadius.isSet == false) {
            if (el.shadowColor.isSet == false) {
                return ""
            }
        }
        
        def css:string ""
        
        ; Get shadow offset (default 0)
        def offsetX:double 0.0
        def offsetY:double 0.0
        if el.shadowOffsetX.isSet {
            offsetX = el.shadowOffsetX.pixels
        }
        if el.shadowOffsetY.isSet {
            offsetY = el.shadowOffsetY.pixels
        }
        
        ; Get blur radius (shadowRadius)
        def blur:double 0.0
        if el.shadowRadius.isSet {
            blur = el.shadowRadius.pixels
        }
        
        ; Get shadow color (default rgba(0,0,0,0.5))
        def shadowColorStr:string "rgba(0, 0, 0, 0.5)"
        if el.shadowColor.isSet {
            shadowColorStr = (el.shadowColor.toCSSString())
        }
        
        ; CSS format: box-shadow: offsetX offsetY blur color
        css = css + "box-shadow: " + (this.formatPx(offsetX)) + " " + (this.formatPx(offsetY)) + " " + (this.formatPx(blur)) + " " + shadowColorStr + "; "
        
        return css
    }
    
    ; =========================================================================
    ; Label (text) rendering
    ; =========================================================================
    
    fn renderLabel:string (el:EVGElement elementId:string depth:int) {
        return (this.renderLabelWithParent(el elementId depth 0.0 0.0))
    }
    
    fn renderLabelWithParent:string (el:EVGElement elementId:string depth:int parentX:double parentY:double) {
        def html:string ""
        html = html + (this.indent(depth)) + "<span"
        
        ; Add id if element has one
        if ((strlen el.id) > 0) {
            html = html + " id=\"" + el.id + "\""
        }
        
        ; Add class
        html = html + " class=\"evg-label\""
        
        ; Calculate position relative to parent
        ; For absolute elements, calculatedX/Y are already relative to parent
        ; For flow elements, we need to subtract parent's absolute position
        def relX:double 0.0
        def relY:double 0.0
        if el.isAbsolute {
            relX = el.calculatedX
            relY = el.calculatedY
        } {
            relX = (el.calculatedX - parentX)
            relY = (el.calculatedY - parentY)
        }
        
        ; Add inline styles
        html = html + " style=\""
        html = html + (this.generateLabelStylesRelative(el relX relY))
        html = html + "\""
        
        html = html + ">"
        
        ; Add text content (escape HTML)
        html = html + (this.escapeHtml(el.textContent))
        
        ; Render any children (nested text)
        def i:int 0
        while (i < (array_length el.children)) {
            def child:EVGElement (itemAt el.children i)
            html = html + (this.renderElementWithParent(child (depth + 1) el.calculatedX el.calculatedY))
            i = i + 1
        }
        
        html = html + "</span>\n"
        return html
    }
    
    fn generateLabelStylesRelative:string (el:EVGElement relX:double relY:double) {
        def css:string ""
        
        ; Always use absolute positioning since EVG calculates exact positions
        css = css + "position: absolute; "
        ; If the calculated relative coordinates end up outside the parent's padding
        ; (negative due to layout ordering quirks), clamp them to parent's padding
        ; to ensure text stays inside the padded content area.
        def px:double relX
        def py:double relY
        if (px < el.parent.box.paddingLeftPx) {
            px = el.parent.box.paddingLeftPx
        }
        if (py < el.parent.box.paddingTopPx) {
            py = el.parent.box.paddingTopPx
        }
        css = css + "left: " + (this.formatPx(px)) + "; "
        css = css + "top: " + (this.formatPx(py)) + "; "
        
        ; Font properties
        if ((strlen el.fontFamily) > 0) {
            css = css + "font-family: '" + el.fontFamily + "', sans-serif; "
        }
        
        if el.fontSize.isSet {
            css = css + "font-size: " + (this.formatPx(el.fontSize.pixels)) + "; "
        }
        
        if ((strlen el.fontWeight) > 0) {
            css = css + "font-weight: " + el.fontWeight + "; "
        }
        
        ; Text color
        if el.color.isSet {
            css = css + "color: " + (el.color.toCSSString()) + "; "
        }
        
        ; Text alignment
        if ((strlen el.textAlign) > 0) {
            css = css + "text-align: " + el.textAlign + "; "
        }
        
        ; Line height
        if (el.lineHeight > 0.0) {
            css = css + "line-height: " + (to_string el.lineHeight) + "; "
        }
        
        ; Dimensions (if set)
        if (el.calculatedWidth > 0.0) {
            css = css + "width: " + (this.formatPx(el.calculatedWidth)) + "; "
        }
        
        ; Text shadow
        css = css + (this.generateTextShadow(el))
        
        return css
    }
    
    ; Generate CSS text-shadow from EVG shadow properties (for text elements)
    fn generateTextShadow:string (el:EVGElement) {
        ; Shadow requires at least shadowRadius or shadowColor to be set
        if (el.shadowRadius.isSet == false) {
            if (el.shadowColor.isSet == false) {
                return ""
            }
        }
        
        def css:string ""
        
        ; Get shadow offset (default 0)
        def offsetX:double 0.0
        def offsetY:double 0.0
        if el.shadowOffsetX.isSet {
            offsetX = el.shadowOffsetX.pixels
        }
        if el.shadowOffsetY.isSet {
            offsetY = el.shadowOffsetY.pixels
        }
        
        ; Get blur radius (shadowRadius)
        def blur:double 0.0
        if el.shadowRadius.isSet {
            blur = el.shadowRadius.pixels
        }
        
        ; Get shadow color (default rgba(0,0,0,0.5))
        def shadowColorStr:string "rgba(0, 0, 0, 0.5)"
        if el.shadowColor.isSet {
            shadowColorStr = (el.shadowColor.toCSSString())
        }
        
        ; CSS format: text-shadow: offsetX offsetY blur color
        css = css + "text-shadow: " + (this.formatPx(offsetX)) + " " + (this.formatPx(offsetY)) + " " + (this.formatPx(blur)) + " " + shadowColorStr + "; "
        
        return css
    }
    
    ; =========================================================================
    ; Image rendering
    ; =========================================================================
    
    fn renderImage:string (el:EVGElement elementId:string depth:int) {
        return (this.renderImageWithParent(el elementId depth 0.0 0.0))
    }
    
    fn renderImageWithParent:string (el:EVGElement elementId:string depth:int parentX:double parentY:double) {
        def html:string ""
        
        ; Calculate position relative to parent
        ; For absolute elements, calculatedX/Y are already relative to parent
        ; For flow elements, we need to subtract parent's absolute position
        def relX:double 0.0
        def relY:double 0.0
        if el.isAbsolute {
            relX = el.calculatedX
            relY = el.calculatedY
        } {
            relX = (el.calculatedX - parentX)
            relY = (el.calculatedY - parentY)
        }
        
        ; If imageViewBox is set, use special viewBox rendering
        if el.imageViewBoxSet {
            return (this.renderImageWithViewBox(el elementId depth relX relY))
        }
        
        ; Get container dimensions
        def containerW:double el.calculatedWidth
        def containerH:double el.calculatedHeight
        
        ; Get parent's available height for clipping (use parent's calculatedHeight if available)
        def parentAvailableH:double el.parent.calculatedHeight
        ; Account for padding if parent has it
        if (el.parent.box.paddingTopPx > 0.0) {
            parentAvailableH = parentAvailableH - el.parent.box.paddingTopPx - el.parent.box.paddingBottomPx
        }
        
        ; If containerH is 0 but we have source dimensions and containerW, 
        ; calculate height from aspect ratio to preserve image proportions
        if ((containerH <= 0.0) && (containerW > 0.0) && (el.sourceWidth > 0.0) && (el.sourceHeight > 0.0)) {
            def imageAspect:double (el.sourceWidth / el.sourceHeight)
            containerH = (containerW / imageAspect)
            if debug {
                print ("Image: calculated containerH from aspect ratio: " + (to_string containerH))
            }
        }
        
        ; Clip containerH to parent's available height if needed
        if ((parentAvailableH > 0.0) && (containerH > parentAvailableH)) {
            if debug {
                print ("Image: clipping containerH from " + (to_string containerH) + " to parent height " + (to_string parentAvailableH))
            }
            containerH = parentAvailableH
        }
        
        ; Always use wrapper div + absolute positioned img to preserve aspect ratio
        ; This ensures PDF and HTML render identically - NO object-fit CSS
        ; We calculate the exact image dimensions and position manually
        
        ; Wrapper div with overflow:hidden
        html = html + (this.indent(depth)) + "<div"
        
        ; Add id if element has one
        if ((strlen el.id) > 0) {
            html = html + " id=\"" + el.id + "\""
        }
        
        html = html + " class=\"evg-image-container\" style=\""
        html = html + "position: absolute; "
        html = html + "left: " + (this.formatPx(relX)) + "; "
        html = html + "top: " + (this.formatPx(relY)) + "; "
        if (containerW > 0.0) {
            html = html + "width: " + (this.formatPx(containerW)) + "; "
        }
        if (containerH > 0.0) {
            html = html + "height: " + (this.formatPx(containerH)) + "; "
        }
        html = html + "overflow: hidden; "
        
        ; Border radius on wrapper
        if el.box.borderRadius.isSet {
            html = html + "border-radius: " + (this.formatPx(el.box.borderRadius.pixels)) + "; "
        }
        html = html + "\">\n"
        
        ; Calculate image size and position to cover container while preserving aspect ratio
        ; For cover: scale image to fill container completely, center, clip excess
        ; For contain: scale image to fit entirely, center, may have letterbox
        
        ; Get actual image dimensions if available (from sourceWidth/sourceHeight)
        def imgW:double el.sourceWidth
        def imgH:double el.sourceHeight
        
        ; If we don't have source dimensions, use container dimensions
        ; (image will be centered at 100% size)
        if (imgW <= 0.0) {
            imgW = containerW
        }
        if (imgH <= 0.0) {
            imgH = containerH
        }
        
        ; Calculate aspect ratios
        def containerRatio:double 1.0
        def imageRatio:double 1.0
        if (containerH > 0.0) {
            containerRatio = (containerW / containerH)
        }
        if (imgH > 0.0) {
            imageRatio = (imgW / imgH)
        }
        
        ; Calculate scaled image dimensions and offset based on objectFit mode
        def scaledW:double containerW
        def scaledH:double containerH
        def offsetX:double 0.0
        def offsetY:double 0.0
        
        def fitMode:string el.objectFit
        if ((strlen fitMode) == 0) {
            fitMode = "cover"
        }
        
        if (fitMode == "cover") {
            ; Cover: image fills container completely, may be cropped
            if (imageRatio > containerRatio) {
                ; Image is wider - fit height, crop width
                scaledH = containerH
                scaledW = (containerH * imageRatio)
                offsetX = ((containerW - scaledW) / 2.0)
                offsetY = 0.0
            } {
                ; Image is taller - fit width, crop height
                scaledW = containerW
                scaledH = (containerW / imageRatio)
                offsetX = 0.0
                offsetY = ((containerH - scaledH) / 2.0)
            }
        }
        if (fitMode == "contain") {
            ; Contain: entire image visible, may have letterbox
            if (imageRatio > containerRatio) {
                ; Image is wider - fit width, letterbox top/bottom
                scaledW = containerW
                scaledH = (containerW / imageRatio)
                offsetX = 0.0
                offsetY = ((containerH - scaledH) / 2.0)
            } {
                ; Image is taller - fit height, letterbox left/right
                scaledH = containerH
                scaledW = (containerH * imageRatio)
                offsetX = ((containerW - scaledW) / 2.0)
                offsetY = 0.0
            }
        }
        if (fitMode == "fill") {
            ; Fill: stretch to fill container (distorts aspect ratio)
            scaledW = containerW
            scaledH = containerH
            offsetX = 0.0
            offsetY = 0.0
        }
        
        ; Apply user-specified imageOffset adjustments
        ; Percentage is relative to the OVERFLOW (how much image extends beyond container)
        ; This way 0% = image at start, 50% = centered, 100% = image at end
        ; For cover mode, the overflow is (scaledSize - containerSize)
        if el.imageOffsetX.isSet {
            if (el.imageOffsetX.unitType == 1) {
                ; Percentage - offset relative to horizontal overflow
                def overflowX:double (scaledW - containerW)
                if (overflowX < 0.0) {
                    overflowX = 0.0
                }
                ; 0% = left edge, 50% = centered, 100% = right edge
                ; Default center is at 50%, so we adjust from there
                def targetOffsetX:double ((overflowX * el.imageOffsetX.value) / 100.0)
                offsetX = (0.0 - targetOffsetX)
            } {
                ; Pixels - add directly
                offsetX = offsetX + el.imageOffsetX.pixels
            }
        }
        if el.imageOffsetY.isSet {
            if (el.imageOffsetY.unitType == 1) {
                ; Percentage - offset relative to vertical overflow
                def overflowY:double (scaledH - containerH)
                if (overflowY < 0.0) {
                    overflowY = 0.0
                }
                ; 0% = top edge, 50% = centered, 100% = bottom edge
                def targetOffsetY:double ((overflowY * el.imageOffsetY.value) / 100.0)
                offsetY = (0.0 - targetOffsetY)
            } {
                ; Pixels - add directly
                offsetY = offsetY + el.imageOffsetY.pixels
            }
        }
        
        ; Image inside - position absolutely with calculated dimensions
        html = html + (this.indent((depth + 1))) + "<img"
        html = html + " class=\"evg-image\""
        
        ; Add src
        def imgSrc:string el.src
        if ((strlen imgSrc) > 0) {
            if embedAssets {
                def dataUri:string (this.getImageDataUri(imgSrc))
                if ((strlen dataUri) > 0) {
                    html = html + " src=\"" + dataUri + "\""
                } {
                    html = html + " src=\"" + (this.transformImagePath(imgSrc)) + "\""
                }
            } {
                html = html + " src=\"" + (this.transformImagePath(imgSrc)) + "\""
            }
        }
        
        ; Add alt
        if ((strlen el.alt) > 0) {
            html = html + " alt=\"" + (this.escapeHtml(el.alt)) + "\""
        } {
            html = html + " alt=\"\""
        }
        
        ; Image styles - use calculated position and size, NO object-fit
        html = html + " style=\""
        html = html + "position: absolute; "
        html = html + "left: " + (this.formatPx(offsetX)) + "; "
        html = html + "top: " + (this.formatPx(offsetY)) + "; "
        html = html + "width: " + (this.formatPx(scaledW)) + "; "
        html = html + "height: " + (this.formatPx(scaledH)) + "; "
        html = html + "display: block; "
        html = html + "\">\n"
        
        ; Close wrapper
        html = html + (this.indent(depth)) + "</div>\n"
        
        return html
    }
    
    ; Render image with viewBox cropping using wrapper div
    fn renderImageWithViewBox:string (el:EVGElement elementId:string depth:int relX:double relY:double) {
        def html:string ""
        
        ; viewBox defines: x%, y%, width%, height% of the source image to show
        ; Example: "25% 25% 50% 50%" means show the center 50% of the image
        
        ; Calculate scale factor: if viewBox width is 50%, image needs to be 200% to fill container
        def scaleX:double 1.0
        def scaleY:double 1.0
        if (el.imageViewBoxW > 0.0) {
            scaleX = (1.0 / el.imageViewBoxW)
        }
        if (el.imageViewBoxH > 0.0) {
            scaleY = (1.0 / el.imageViewBoxH)
        }
        
        ; Use the larger scale to maintain aspect ratio with cover behavior
        def scale:double scaleX
        if (scaleY > scaleX) {
            scale = scaleY
        }
        
        ; Calculate image offset (negative) to position the viewBox region
        ; offsetX = viewBoxX * imageWidth = viewBoxX * (containerWidth * scale)
        def offsetXPercent:double ((el.imageViewBoxX * scale) * 100.0)
        def offsetYPercent:double ((el.imageViewBoxY * scale) * 100.0)
        
        ; Wrapper div with overflow:hidden
        html = html + (this.indent(depth)) + "<div class=\"evg-image-crop\" style=\""
        html = html + "position: absolute; "
        html = html + "left: " + (this.formatPx(relX)) + "; "
        html = html + "top: " + (this.formatPx(relY)) + "; "
        if (el.calculatedWidth > 0.0) {
            html = html + "width: " + (this.formatPx(el.calculatedWidth)) + "; "
        }
        if (el.calculatedHeight > 0.0) {
            html = html + "height: " + (this.formatPx(el.calculatedHeight)) + "; "
        }
        html = html + "overflow: hidden; "
        
        ; Border radius on wrapper
        if el.box.borderRadius.isSet {
            html = html + "border-radius: " + (this.formatPx(el.box.borderRadius.pixels)) + "; "
        }
        html = html + "\">\n"
        
        ; Image inside wrapper - scaled and positioned
        html = html + (this.indent((depth + 1))) + "<img"
        
        ; Add class
        html = html + " class=\"evg-image\""
        
        ; Add src
        def imgSrc:string el.src
        if ((strlen imgSrc) > 0) {
            if embedAssets {
                def dataUri:string (this.getImageDataUri(imgSrc))
                if ((strlen dataUri) > 0) {
                    html = html + " src=\"" + dataUri + "\""
                } {
                    html = html + " src=\"" + (this.transformImagePath(imgSrc)) + "\""
                }
            } {
                html = html + " src=\"" + (this.transformImagePath(imgSrc)) + "\""
            }
        }
        
        html = html + " alt=\"\""
        
        ; Image styles: scaled and offset
        html = html + " style=\""
        html = html + "position: absolute; "
        html = html + "width: " + (to_string (scale * 100.0)) + "%; "
        html = html + "height: " + (to_string (scale * 100.0)) + "%; "
        html = html + "left: -" + (to_string offsetXPercent) + "%; "
        html = html + "top: -" + (to_string offsetYPercent) + "%; "
        html = html + "object-fit: cover; "
        html = html + "\">\n"
        
        ; Close wrapper
        html = html + (this.indent(depth)) + "</div>\n"
        
        return html
    }
    
    fn generateImageStylesRelative:string (el:EVGElement relX:double relY:double) {
        def css:string ""
        
        ; Always use absolute positioning since EVG calculates exact positions
        css = css + "position: absolute; "
        css = css + "left: " + (this.formatPx(relX)) + "; "
        css = css + "top: " + (this.formatPx(relY)) + "; "
        
        ; Dimensions
        if (el.calculatedWidth > 0.0) {
            css = css + "width: " + (this.formatPx(el.calculatedWidth)) + "; "
        }
        if (el.calculatedHeight > 0.0) {
            css = css + "height: " + (this.formatPx(el.calculatedHeight)) + "; "
        }
        
        ; Object fit - use element's objectFit property
        if ((strlen el.objectFit) > 0) {
            css = css + "object-fit: " + el.objectFit + "; "
        } {
            css = css + "object-fit: cover; "
        }
        
        ; Image position offset using CSS object-position
        ; Default is center (50% 50%), offsets move from there
        ; imageOffsetX/Y can be pixels or percentages (negative values supported)
        def hasOffset:boolean false
        def posX:string "50%"
        def posY:string "50%"
        
        if el.imageOffsetX.isSet {
            hasOffset = true
            ; For percentages, add to 50%, for pixels use calc()
            if (el.imageOffsetX.unitType == 1) {
                ; Percentage - add to center
                def offsetPct:double (50.0 + el.imageOffsetX.value)
                posX = (to_string offsetPct) + "%"
            } {
                ; Pixels - use calc()
                posX = "calc(50% + " + (this.formatPx(el.imageOffsetX.pixels)) + ")"
            }
        }
        
        if el.imageOffsetY.isSet {
            hasOffset = true
            if (el.imageOffsetY.unitType == 1) {
                def offsetPct:double (50.0 + el.imageOffsetY.value)
                posY = (to_string offsetPct) + "%"
            } {
                posY = "calc(50% + " + (this.formatPx(el.imageOffsetY.pixels)) + ")"
            }
        }
        
        ; Legacy imageViewBox support
        if el.imageViewBoxSet {
            hasOffset = true
            ; viewBox x,y define where to start showing the image
            def vbX:double (el.imageViewBoxX * 100.0)
            def vbY:double (el.imageViewBoxY * 100.0)
            posX = (to_string vbX) + "%"
            posY = (to_string vbY) + "%"
        }
        
        if hasOffset {
            css = css + "object-position: " + posX + " " + posY + "; "
        }
        
        ; Border radius
        if el.box.borderRadius.isSet {
            css = css + "border-radius: " + (this.formatPx(el.box.borderRadius.pixels)) + "; "
        }
        
        return css
    }
    
    ; =========================================================================
    ; SVG Path rendering
    ; =========================================================================
    
    fn renderPath:string (el:EVGElement elementId:string depth:int) {
        return (this.renderPathWithParent(el elementId depth 0.0 0.0))
    }
    
    fn renderPathWithParent:string (el:EVGElement elementId:string depth:int parentX:double parentY:double) {
        def html:string ""
        
        def w:double el.calculatedWidth
        def h:double el.calculatedHeight
        if (w <= 0.0) {
            w = 24.0  ; Default icon size
        }
        if (h <= 0.0) {
            h = 24.0
        }
        
        ; Calculate position relative to parent
        ; Use the same logic as View elements
        def relX:double 0.0
        def relY:double 0.0
        if el.isAbsolute {
            relX = el.calculatedX
            relY = el.calculatedY
        } {
            relX = (el.calculatedX - parentX)
            relY = (el.calculatedY - parentY)
        }
        
        html = html + (this.indent(depth)) + "<svg"
        
        ; Add id if element has one
        if ((strlen el.id) > 0) {
            html = html + " id=\"" + el.id + "\""
        }
        
        ; Add class
        html = html + " class=\"evg-path\""
        
        ; Add dimensions
        html = html + " width=\"" + (to_string w) + "\""
        html = html + " height=\"" + (to_string h) + "\""
        
        ; Add viewBox if set
        if ((strlen el.viewBox) > 0) {
            html = html + " viewBox=\"" + el.viewBox + "\""
        }
        
        ; Add position styles - use relative position
        html = html + " style=\""
        html = html + "position: absolute; "
        html = html + "left: " + (this.formatPx(relX)) + "; "
        html = html + "top: " + (this.formatPx(relY)) + "; "
        html = html + "\""
        
        html = html + ">\n"
        
        ; Add path element
        html = html + (this.indent(depth + 1)) + "<path d=\"" + el.svgPath + "\""
        
        ; Fill color
        if el.fillColor.isSet {
            html = html + " fill=\"" + (el.fillColor.toCSSString()) + "\""
        } {
            if el.backgroundColor.isSet {
                html = html + " fill=\"" + (el.backgroundColor.toCSSString()) + "\""
            } {
                html = html + " fill=\"currentColor\""
            }
        }
        
        ; Stroke
        if el.strokeColor.isSet {
            html = html + " stroke=\"" + (el.strokeColor.toCSSString()) + "\""
            if (el.strokeWidth > 0.0) {
                html = html + " stroke-width=\"" + (to_string el.strokeWidth) + "\""
            }
        }
        
        html = html + "/>\n"
        
        html = html + (this.indent(depth)) + "</svg>\n"
        return html
    }
    
    ; =========================================================================
    ; Rect rendering
    ; =========================================================================
    
    fn renderRect:string (el:EVGElement elementId:string depth:int) {
        ; Rect is essentially a View with no children
        return (this.renderView(el elementId depth))
    }
    
    ; =========================================================================
    ; Helper functions
    ; =========================================================================
    
    fn indent:string (depth:int) {
        if (prettyPrint == false) {
            return ""
        }
        def result:string ""
        def i:int 0
        while (i < depth) {
            result = result + indentString
            i = i + 1
        }
        return result
    }
    
    fn formatPx:string (value:double) {
        ; Format a pixel value, removing unnecessary decimals
        def intVal:int (to_int value)
        def diff:double (value - (to_double intVal))
        if ((diff < 0.01) && (diff > -0.01)) {
            return ((to_string intVal) + "px")
        }
        return ((to_string value) + "px")
    }
    
    fn escapeHtml:string (text:string) {
        ; Escape HTML special characters
        def result:string ""
        def i:int 0
        while (i < (strlen text)) {
            def ch:string (substring text i (i + 1))
            if (ch == "<") {
                result = result + "&lt;"
            } {
                if (ch == ">") {
                    result = result + "&gt;"
                } {
                    if (ch == "&") {
                        result = result + "&amp;"
                    } {
                        if (ch == "\"") {
                            result = result + "&quot;"
                        } {
                            result = result + ch
                        }
                    }
                }
            }
            i = i + 1
        }
        return result
    }
    
    fn getMimeType:string (filename:string) {
        ; Get MIME type based on file extension
        ; Only JPEG/JPG is currently supported
        def lower:string (to_lowercase filename)
        if ((indexOf lower ".jpg") >= 0) {
            return "image/jpeg"
        }
        if ((indexOf lower ".jpeg") >= 0) {
            return "image/jpeg"
        }
        ; Unsupported format
        return ""
    }
    
    fn getImageDataUri:string (imagePath:string) {
        ; Read image file and convert to data URI
        ; Returns empty string if file cannot be read or format unsupported
        def mimeType:string (this.getMimeType(imagePath))
        if ((strlen mimeType) == 0) {
            ; Unsupported format
            return ""
        }
        def basePath:string baseDir
        def resolvedPath:string (this.resolveImagePath(imagePath))
        def buf:buffer (buffer_read_file basePath resolvedPath)
        def len:int (buffer_length buf)
        if (len == 0) {
            return ""
        }
        def base64:string (buffer_to_base64 buf)
        return ("data:" + mimeType + ";base64," + base64)
    }
    
    fn getResolvedPadding:double (el:EVGElement side:string) {
        if (side == "top") {
            if el.box.paddingTop.isSet {
                return el.box.paddingTop.pixels
            }
        }
        if (side == "right") {
            if el.box.paddingRight.isSet {
                return el.box.paddingRight.pixels
            }
        }
        if (side == "bottom") {
            if el.box.paddingBottom.isSet {
                return el.box.paddingBottom.pixels
            }
        }
        if (side == "left") {
            if el.box.paddingLeft.isSet {
                return el.box.paddingLeft.pixels
            }
        }
        return 0.0
    }
    
    fn getResolvedMargin:double (el:EVGElement side:string) {
        if (side == "top") {
            if el.box.marginTop.isSet {
                return el.box.marginTop.pixels
            }
        }
        if (side == "right") {
            if el.box.marginRight.isSet {
                return el.box.marginRight.pixels
            }
        }
        if (side == "bottom") {
            if el.box.marginBottom.isSet {
                return el.box.marginBottom.pixels
            }
        }
        if (side == "left") {
            if el.box.marginLeft.isSet {
                return el.box.marginLeft.pixels
            }
        }
        return 0.0
    }
    
    ; =========================================================================
    ; Live Preview Support
    ; =========================================================================
    
    ; Helper functions for finding sections and pages (like PDF renderer)
    fn findPageElementsRecursive:void (el:EVGElement) {
        ; Recursively find all Page elements (stores in foundPages member)
        if ((el.tagName == "page") || (el.tagName == "Page")) {
            push foundPages el
        }
        def i:int 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            this.findPageElementsRecursive(child)
            i = i + 1
        }
    }
    
    fn findSectionElementsRecursive:void (el:EVGElement) {
        ; Find all Section elements (stores in foundSections member)
        def i:int 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            if ((child.tagName == "section") || (child.tagName == "Section")) {
                push foundSections child
            }
            i = i + 1
        }
    }
    
    fn getSectionPageWidth:double (section:EVGElement) {
        ; Get page width from section, default to A4
        if section.width.isSet {
            return section.width.pixels
        }
        return pageWidth
    }
    
    fn getSectionPageHeight:double (section:EVGElement) {
        ; Get page height from section, default to A4
        if section.height.isSet {
            return section.height.pixels
        }
        return pageHeight
    }
    
    fn getSectionMargin:double (section:EVGElement) {
        ; Get margin from section (use marginTop as the uniform margin)
        def m:EVGUnit section.box.marginTop
        if m.isSet {
            return m.pixels
        }
        return 0.0
    }
    
    ; Render just the document content (no html/head/body wrapper)
    ; Used for live preview where shell HTML is served separately
    fn renderContent:string (root:EVGElement) {
        ; Reset state
        elementCounter = 0
        def uf:[string]
        usedFontFamilies = uf
        
        ; STEP 1: Load resource metadata (image dimensions) BEFORE any layout
        ; This is critical - layout engine needs image sizes for proper flexbox calculation
        resourceLoader.setBasePath(baseDir)
        resourceLoader.loadResources(root)
        
        ; Check if it's a multi-page document (Print/Section/Page structure)
        def isMultiPage:boolean false
        if ((root.tagName == "Print") || (root.tagName == "print") || (root.tagName == "Section") || (root.tagName == "section")) {
            isMultiPage = true
        }
        
        if isMultiPage {
            ; Multi-page document - set up page dimensions like PDF renderer
            ; Find all sections
            def emptyArr:[EVGElement]
            foundSections = emptyArr
            this.findSectionElementsRecursive(root)
            
            ; Process each section and its pages
            def si:int 0
            while (si < (array_length foundSections)) {
                def section:EVGElement (itemAt foundSections si)
                def sectionWidth:double (this.getSectionPageWidth(section))
                def sectionHeight:double (this.getSectionPageHeight(section))
                def sectionMargin:double (this.getSectionMargin(section))
                
                ; Find pages within this section
                def emptyPages:[EVGElement]
                foundPages = emptyPages
                this.findPageElementsRecursive(section)
                
                def pi:int 0
                while (pi < (array_length foundPages)) {
                    def pg:EVGElement (itemAt foundPages pi)
                    
                    ; Set page dimensions for layout - this is the content area inside margins
                    def contentWidth:double (sectionWidth - (sectionMargin * 2.0))
                    def contentHeight:double (sectionHeight - (sectionMargin * 2.0))
                    
                    ; Set the layout engine's page dimensions before layout
                    layout.pageWidth = contentWidth
                    layout.pageHeight = contentHeight
                    
                    ; Reset layout state for fresh layout
                    pg.resetLayoutState()
                    
                    ; Explicitly set Page dimensions (like PDF renderer does)
                    pg.width.pixels = contentWidth
                    pg.width.value = contentWidth
                    pg.width.unitType = 0  ; pixels
                    pg.width.isSet = true
                    pg.height.pixels = contentHeight
                    pg.height.value = contentHeight
                    pg.height.unitType = 0  ; pixels
                    pg.height.isSet = true
                    
                    ; Layout each page independently
                    layout.layout(pg)
                    
                    pi = pi + 1
                }
                si = si + 1
            }
            
            ; If no sections found, try default layout
            if ((array_length foundSections) == 0) {
                layout.layout(root)
            }
        } {
            ; Single-page view - just run layout normally
            layout.layout(root)
        }
        
        ; Collect used fonts (for getUsedFonts())
        this.collectFonts(root)
        
        def result:string ""
        if isMultiPage {
            ; Multi-page: render directly (Print/Section/Page handle their own structure)
            result = (this.renderElement(root 0))
        } {
            ; Single-page: wrap in a page container
            result = "<div class=\"evg-page-container\">\n"
            result = result + (this.renderElement(root 1))
            result = result + "</div>\n"
        }
        return result
    }
    
    ; Get list of font families used in the document
    ; Call after render() or renderContent()
    fn getUsedFonts:[string] () {
        return usedFontFamilies
    }
    
    ; Generate CSS @font-face rules pointing to server URLs
    ; serverUrl should be like "http://localhost:3000"
    fn generateServerFontFaceCSS:string (serverUrl:string) {
        def css:string ""
        def i:int 0
        while (i < (array_length usedFontFamilies)) {
            def fontFamily:string (itemAt usedFontFamilies i)
            def fontFileName:string (this.fontFamilyToFileName(fontFamily))
            
            ; Regular weight - fonts are in assets/fonts/ folder
            css = css + "@font-face {\n"
            css = css + "    font-family: '" + fontFamily + "';\n"
            css = css + "    src: url('" + serverUrl + "/assets/fonts/" + fontFileName + "') format('truetype');\n"
            css = css + "    font-weight: 400;\n"
            css = css + "    font-style: normal;\n"
            css = css + "}\n"
            
            i = i + 1
        }
        return css
    }
    
    ; Transform an image path for server mode
    ; Converts ../assets/images/x.jpg to /assets/images/x.jpg
    fn transformImagePath:string (imgSrc:string) {
        ; If image path starts with ../assets/, transform to /assets/
        if ((strlen imgSrc) >= 10) {
            def prefix:string (substring imgSrc 0 10)
            if (prefix == "../assets/") {
                ; Strip "../assets/" and replace with server url + "/assets/"
                def relativePath:string (substring imgSrc 10 (strlen imgSrc))
                return imageBasePath + relativePath
            }
        }
        ; Otherwise, return as-is with base path
        return imageBasePath + imgSrc
    }
    
    ; Set server URL prefix for images
    ; When set, image paths are prefixed with this URL
    ; Example: setImageServer("http://localhost:3000") 
    ; Then "../assets/images/x.jpg" becomes "http://localhost:3000/assets/images/x.jpg"
    fn setImageServer:void (serverUrl:string) {
        imageBasePath = serverUrl + "/assets/"
    }
    
    ; Generate the shell HTML for live preview
    ; This is served once and cached by the browser
    fn generateShellHTML:string (serverUrl:string) {
        def html:string ""
        html = html + "<!DOCTYPE html>\n"
        html = html + "<html>\n"
        html = html + "<head>\n"
        html = html + "    <meta charset=\"UTF-8\">\n"
        html = html + "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n"
        html = html + "    <title>" + title + " - Live Preview</title>\n"
        html = html + "    <style>\n"
        html = html + "        * { margin: 0; padding: 0; box-sizing: border-box; }\n"
        html = html + "        body {\n"
        html = html + "            background: #b0b0b0;\n"
        html = html + "            padding: 40px;\n"
        html = html + "            min-height: 100vh;\n"
        html = html + "        }\n"
        html = html + "        /* Document container - centers pages */\n"
        html = html + "        .evg-document-container {\n"
        html = html + "            display: flex;\n"
        html = html + "            flex-direction: column;\n"
        html = html + "            align-items: center;\n"
        html = html + "            gap: 40px;\n"
        html = html + "        }\n"
        html = html + "        /* Page wrapper for single-page content */\n"
        html = html + "        .evg-page-container {\n"
        html = html + "            width: " + (to_string (to_int pageWidth)) + "px;\n"
        html = html + "            min-height: " + (to_string (to_int pageHeight)) + "px;\n"
        html = html + "            background: white;\n"
        html = html + "            box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);\n"
        html = html + "            position: relative;\n"
        html = html + "            overflow: hidden;\n"
        html = html + "            flex-shrink: 0;\n"
        html = html + "        }\n"
        html = html + "        /* Individual pages in multi-page docs */\n"
        html = html + "        .evg-page {\n"
        html = html + "            width: " + (to_string (to_int pageWidth)) + "px;\n"
        html = html + "            height: " + (to_string (to_int pageHeight)) + "px;\n"
        html = html + "            background: white;\n"
        html = html + "            box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);\n"
        html = html + "            position: relative;\n"
        html = html + "            overflow: hidden;\n"
        html = html + "            flex-shrink: 0;\n"
        html = html + "        }\n"
        html = html + "        /* Section groups pages */\n"
        html = html + "        .evg-section {\n"
        html = html + "            display: flex;\n"
        html = html + "            flex-direction: column;\n"
        html = html + "            align-items: center;\n"
        html = html + "            gap: 40px;\n"
        html = html + "        }\n"
        html = html + "        /* Document wrapper */\n"
        html = html + "        .evg-document {\n"
        html = html + "            display: flex;\n"
        html = html + "            flex-direction: column;\n"
        html = html + "            align-items: center;\n"
        html = html + "            gap: 40px;\n"
        html = html + "        }\n"
        html = html + "        /* Book spread view - two pages side by side */\n"
        html = html + "        .evg-spread {\n"
        html = html + "            display: flex;\n"
        html = html + "            flex-direction: row;\n"
        html = html + "            gap: 4px;\n"
        html = html + "            background: #888;\n"
        html = html + "            padding: 4px;\n"
        html = html + "            border-radius: 2px;\n"
        html = html + "            box-shadow: 0 8px 30px rgba(0,0,0,0.4);\n"
        html = html + "        }\n"
        html = html + "        .evg-spread .evg-page {\n"
        html = html + "            box-shadow: none;\n"
        html = html + "        }\n"
        html = html + "        /* Cover page - single centered */\n"
        html = html + "        .evg-cover {\n"
        html = html + "            box-shadow: 0 8px 30px rgba(0,0,0,0.4);\n"
        html = html + "        }\n"
        html = html + "        /* Page number labels */\n"
        html = html + "        .evg-page-label {\n"
        html = html + "            position: absolute;\n"
        html = html + "            bottom: -25px;\n"
        html = html + "            left: 50%;\n"
        html = html + "            transform: translateX(-50%);\n"
        html = html + "            font-family: system-ui, sans-serif;\n"
        html = html + "            font-size: 12px;\n"
        html = html + "            color: #666;\n"
        html = html + "        }\n"
        html = html + "        .evg-status {\n"
        html = html + "            position: fixed;\n"
        html = html + "            bottom: 10px;\n"
        html = html + "            right: 10px;\n"
        html = html + "            padding: 5px 10px;\n"
        html = html + "            background: #333;\n"
        html = html + "            color: #0f0;\n"
        html = html + "            font-family: monospace;\n"
        html = html + "            font-size: 12px;\n"
        html = html + "            border-radius: 4px;\n"
        html = html + "            opacity: 0.8;\n"
        html = html + "        }\n"
        html = html + "        .evg-view { position: relative; }\n"
        html = html + "        .evg-label { display: block; }\n"
        html = html + "        .evg-image { display: block; }\n"
        html = html + "    </style>\n"
        html = html + "    <style id=\"evg-fonts\">\n"
        html = html + "        /* Font faces loaded dynamically */\n"
        html = html + "    </style>\n"
        html = html + "</head>\n"
        html = html + "<body>\n"
        html = html + "    <div class=\"evg-document-container\" id=\"evg-content\">\n"
        html = html + "        <div class=\"evg-page-container\" style=\"padding: 20px; color: #666;\">Loading...</div>\n"
        html = html + "    </div>\n"
        html = html + "    <div class=\"evg-status\" id=\"evg-status\">Connecting...</div>\n"
        html = html + "    <script>\n"
        html = html + "        const serverUrl = '" + serverUrl + "';\n"
        html = html + "        const contentEl = document.getElementById('evg-content');\n"
        html = html + "        const statusEl = document.getElementById('evg-status');\n"
        html = html + "        const fontsEl = document.getElementById('evg-fonts');\n"
        html = html + "        \n"
        html = html + "        // Arrange pages as book spreads: cover alone, then pairs\n"
        html = html + "        function arrangeAsBookSpreads() {\n"
        html = html + "            const pages = Array.from(contentEl.querySelectorAll('.evg-page'));\n"
        html = html + "            // Only arrange as book if there are multiple pages\n"
        html = html + "            if (pages.length <= 1) return;\n"
        html = html + "            \n"
        html = html + "            // Find the section or document container\n"
        html = html + "            const section = contentEl.querySelector('.evg-section') || contentEl.querySelector('.evg-document') || contentEl;\n"
        html = html + "            if (!section) return;\n"
        html = html + "            \n"
        html = html + "            // Clone pages before clearing to avoid DOM issues\n"
        html = html + "            const pageClones = pages.map(p => p.cloneNode(true));\n"
        html = html + "            \n"
        html = html + "            // Clear the section\n"
        html = html + "            section.innerHTML = '';\n"
        html = html + "            \n"
        html = html + "            // First page is cover - show alone\n"
        html = html + "            const cover = pageClones[0];\n"
        html = html + "            cover.classList.add('evg-cover');\n"
        html = html + "            const coverWrapper = document.createElement('div');\n"
        html = html + "            coverWrapper.style.position = 'relative';\n"
        html = html + "            coverWrapper.style.marginBottom = '20px';\n"
        html = html + "            coverWrapper.appendChild(cover);\n"
        html = html + "            const coverLabel = document.createElement('div');\n"
        html = html + "            coverLabel.className = 'evg-page-label';\n"
        html = html + "            coverLabel.textContent = 'Kansi';\n"
        html = html + "            coverWrapper.appendChild(coverLabel);\n"
        html = html + "            section.appendChild(coverWrapper);\n"
        html = html + "            \n"
        html = html + "            // Remaining pages in pairs (spreads)\n"
        html = html + "            for (let i = 1; i < pageClones.length; i += 2) {\n"
        html = html + "                const spread = document.createElement('div');\n"
        html = html + "                spread.className = 'evg-spread';\n"
        html = html + "                spread.style.position = 'relative';\n"
        html = html + "                spread.style.marginBottom = '20px';\n"
        html = html + "                \n"
        html = html + "                // Left page\n"
        html = html + "                spread.appendChild(pageClones[i]);\n"
        html = html + "                \n"
        html = html + "                // Right page (if exists)\n"
        html = html + "                if (i + 1 < pageClones.length) {\n"
        html = html + "                    spread.appendChild(pageClones[i + 1]);\n"
        html = html + "                }\n"
        html = html + "                \n"
        html = html + "                // Add spread label\n"
        html = html + "                const spreadLabel = document.createElement('div');\n"
        html = html + "                spreadLabel.className = 'evg-page-label';\n"
        html = html + "                if (i + 1 < pages.length) {\n"
        html = html + "                    spreadLabel.textContent = 'Sivut ' + (i + 1) + '-' + (i + 2);\n"
        html = html + "                } else {\n"
        html = html + "                    spreadLabel.textContent = 'Sivu ' + (i + 1) + ' (takakansi)';\n"
        html = html + "                }\n"
        html = html + "                spread.appendChild(spreadLabel);\n"
        html = html + "                \n"
        html = html + "                section.appendChild(spread);\n"
        html = html + "            }\n"
        html = html + "        }\n"
        html = html + "        \n"
        html = html + "        // Load content from server\n"
        html = html + "        async function loadContent() {\n"
        html = html + "            try {\n"
        html = html + "                const response = await fetch(serverUrl + '/content');\n"
        html = html + "                const html = await response.text();\n"
        html = html + "                contentEl.innerHTML = html;\n"
        html = html + "                arrangeAsBookSpreads();\n"
        html = html + "                statusEl.textContent = 'Connected';\n"
        html = html + "                statusEl.style.color = '#0f0';\n"
        html = html + "            } catch (err) {\n"
        html = html + "                statusEl.textContent = 'Error: ' + err.message;\n"
        html = html + "                statusEl.style.color = '#f00';\n"
        html = html + "            }\n"
        html = html + "        }\n"
        html = html + "        \n"
        html = html + "        // Load fonts CSS\n"
        html = html + "        async function loadFonts() {\n"
        html = html + "            try {\n"
        html = html + "                const response = await fetch(serverUrl + '/fonts.css');\n"
        html = html + "                const css = await response.text();\n"
        html = html + "                fontsEl.textContent = css;\n"
        html = html + "            } catch (err) {\n"
        html = html + "                console.error('Failed to load fonts:', err);\n"
        html = html + "            }\n"
        html = html + "        }\n"
        html = html + "        \n"
        html = html + "        // Set up SSE for live updates\n"
        html = html + "        function connectSSE() {\n"
        html = html + "            const evtSource = new EventSource(serverUrl + '/events');\n"
        html = html + "            \n"
        html = html + "            evtSource.addEventListener('update', function(e) {\n"
        html = html + "                console.log('EVG: Content updated');\n"
        html = html + "                loadContent();\n"
        html = html + "            });\n"
        html = html + "            \n"
        html = html + "            evtSource.addEventListener('fonts', function(e) {\n"
        html = html + "                console.log('EVG: Fonts updated');\n"
        html = html + "                loadFonts();\n"
        html = html + "            });\n"
        html = html + "            \n"
        html = html + "            evtSource.onopen = function() {\n"
        html = html + "                console.log('EVG: Connected to preview server');\n"
        html = html + "                statusEl.textContent = 'Connected';\n"
        html = html + "                statusEl.style.color = '#0f0';\n"
        html = html + "            };\n"
        html = html + "            \n"
        html = html + "            evtSource.onerror = function() {\n"
        html = html + "                statusEl.textContent = 'Disconnected';\n"
        html = html + "                statusEl.style.color = '#f00';\n"
        html = html + "            };\n"
        html = html + "        }\n"
        html = html + "        \n"
        html = html + "        // Initialize\n"
        html = html + "        loadFonts();\n"
        html = html + "        loadContent();\n"
        html = html + "        connectSSE();\n"
        html = html + "    </script>\n"
        html = html + "</body>\n"
        html = html + "</html>\n"
        
        return html
    }
    
    fn collectFonts:void (el:EVGElement) {
        ; Collect unique font families used in the document
        if ((strlen el.fontFamily) > 0) {
            def found:boolean false
            def i:int 0
            while (i < (array_length usedFontFamilies)) {
                if ((itemAt usedFontFamilies i) == el.fontFamily) {
                    found = true
                }
                i = i + 1
            }
            if (found == false) {
                push usedFontFamilies el.fontFamily
            }
        }
        
        ; Recurse to children
        def j:int 0
        while (j < (array_length el.children)) {
            def child:EVGElement (itemAt el.children j)
            this.collectFonts(child)
            j = j + 1
        }
    }
}
