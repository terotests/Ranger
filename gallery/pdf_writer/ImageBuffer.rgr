; ImageBuffer.rgr - Raw RGBA pixel buffer for image manipulation
; Provides a simple interface for pixel operations
;
; Note: JPEG decoding/encoding requires complex algorithms (DCT, Huffman, quantization).
; This module works with raw pixel data and uses PPM format for I/O (simple, uncompressed).

Import "Buffer.rgr"

class Color {
    def r:int 0
    def g:int 0
    def b:int 0
    def a:int 255
    
    Constructor () {
    }
    
    fn setRGB:void (red:int green:int blue:int) {
        r = red
        g = green
        b = blue
        a = 255
    }
    
    fn setRGBA:void (red:int green:int blue:int alpha:int) {
        r = red
        g = green
        b = blue
        a = alpha
    }
    
    fn clamp:int (val:int) {
        if (val < 0) { return 0 }
        if (val > 255) { return 255 }
        return val
    }
    
    fn set:void (red:int green:int blue:int) {
        r = (this.clamp(red))
        g = (this.clamp(green))
        b = (this.clamp(blue))
    }
    
    fn grayscale:int () {
        ; Luminance formula: 0.299*R + 0.587*G + 0.114*B
        ; Using integer approximation: (77*R + 150*G + 29*B) >> 8
        return (bit_shr ((r * 77) + (g * 150) + (b * 29)) 8)
    }
    
    fn toGrayscale:void () {
        def gray:int (this.grayscale())
        r = gray
        g = gray
        b = gray
    }
    
    fn invert:void () {
        r = 255 - r
        g = 255 - g
        b = 255 - b
    }
    
    fn adjustBrightness:void (amount:int) {
        r = (this.clamp(r + amount))
        g = (this.clamp(g + amount))
        b = (this.clamp(b + amount))
    }
}

class ImageBuffer {
    def width:int 0
    def height:int 0
    def pixels:buffer (buffer_alloc 0)
    
    Constructor () {
    }
    
    fn init:void (w:int h:int) {
        width = w
        height = h
        ; RGBA = 4 bytes per pixel
        def size:int (w * h * 4)
        pixels = (buffer_alloc size)
        ; Initialize to white
        this.fill(255 255 255 255)
    }
    
    fn getPixelOffset:int (x:int y:int) {
        return ((y * width) + x) * 4
    }
    
    fn isValidCoord:boolean (x:int y:int) {
        if (x < 0) { return false }
        if (y < 0) { return false }
        if (x >= width) { return false }
        if (y >= height) { return false }
        return true
    }
    
    fn getPixel:Color (x:int y:int) {
        def c (new Color())
        if (this.isValidCoord(x y)) {
            def off:int (this.getPixelOffset(x y))
            c.r = (buffer_get pixels off)
            c.g = (buffer_get pixels (off + 1))
            c.b = (buffer_get pixels (off + 2))
            c.a = (buffer_get pixels (off + 3))
        }
        return c
    }
    
    fn setPixel:void (x:int y:int c:Color) {
        if (this.isValidCoord(x y)) {
            def off:int (this.getPixelOffset(x y))
            buffer_set pixels off c.r
            buffer_set pixels (off + 1) c.g
            buffer_set pixels (off + 2) c.b
            buffer_set pixels (off + 3) c.a
        }
    }
    
    fn setPixelRGB:void (x:int y:int r:int g:int b:int) {
        if (this.isValidCoord(x y)) {
            def off:int (this.getPixelOffset(x y))
            buffer_set pixels off r
            buffer_set pixels (off + 1) g
            buffer_set pixels (off + 2) b
            buffer_set pixels (off + 3) 255
        }
    }
    
    fn fill:void (r:int g:int b:int a:int) {
        def size:int (width * height * 4)
        def i 0
        while (i < size) {
            buffer_set pixels i r
            buffer_set pixels (i + 1) g
            buffer_set pixels (i + 2) b
            buffer_set pixels (i + 3) a
            i = i + 4
        }
    }
    
    fn fillRect:void (x:int y:int w:int h:int c:Color) {
        def endX:int (x + w)
        def endY:int (y + h)
        def py:int y
        while (py < endY) {
            def px:int x
            while (px < endX) {
                this.setPixel(px py c)
                px = px + 1
            }
            py = py + 1
        }
    }
    
    ; Image operations
    
    fn invert:void () {
        def size:int (width * height)
        def i 0
        while (i < size) {
            def off:int (i * 4)
            def r:int (buffer_get pixels off)
            def g:int (buffer_get pixels (off + 1))
            def b:int (buffer_get pixels (off + 2))
            buffer_set pixels off (255 - r)
            buffer_set pixels (off + 1) (255 - g)
            buffer_set pixels (off + 2) (255 - b)
            i = i + 1
        }
    }
    
    fn grayscale:void () {
        def size:int (width * height)
        def i 0
        while (i < size) {
            def off:int (i * 4)
            def r:int (buffer_get pixels off)
            def g:int (buffer_get pixels (off + 1))
            def b:int (buffer_get pixels (off + 2))
            ; Luminance: (77*R + 150*G + 29*B) >> 8
            def gray:int (bit_shr ((r * 77) + (g * 150) + (b * 29)) 8)
            buffer_set pixels off gray
            buffer_set pixels (off + 1) gray
            buffer_set pixels (off + 2) gray
            i = i + 1
        }
    }
    
    fn adjustBrightness:void (amount:int) {
        def size:int (width * height)
        def i 0
        while (i < size) {
            def off:int (i * 4)
            def r:int (buffer_get pixels off)
            def g:int (buffer_get pixels (off + 1))
            def b:int (buffer_get pixels (off + 2))
            r = r + amount
            g = g + amount
            b = b + amount
            if (r < 0) { r = 0 }
            if (r > 255) { r = 255 }
            if (g < 0) { g = 0 }
            if (g > 255) { g = 255 }
            if (b < 0) { b = 0 }
            if (b > 255) { b = 255 }
            buffer_set pixels off r
            buffer_set pixels (off + 1) g
            buffer_set pixels (off + 2) b
            i = i + 1
        }
    }
    
    fn threshold:void (level:int) {
        ; Convert to black and white based on threshold
        def size:int (width * height)
        def i 0
        while (i < size) {
            def off:int (i * 4)
            def r:int (buffer_get pixels off)
            def g:int (buffer_get pixels (off + 1))
            def b:int (buffer_get pixels (off + 2))
            def gray:int (bit_shr ((r * 77) + (g * 150) + (b * 29)) 8)
            def val:int 0
            if (gray >= level) {
                val = 255
            }
            buffer_set pixels off val
            buffer_set pixels (off + 1) val
            buffer_set pixels (off + 2) val
            i = i + 1
        }
    }
    
    fn sepia:void () {
        ; Sepia tone effect
        def size:int (width * height)
        def i 0
        while (i < size) {
            def off:int (i * 4)
            def r:int (buffer_get pixels off)
            def g:int (buffer_get pixels (off + 1))
            def b:int (buffer_get pixels (off + 2))
            ; Sepia formula (integer approximation)
            def newR:int (bit_shr ((r * 101) + (g * 197) + (b * 48)) 8)
            def newG:int (bit_shr ((r * 89) + (g * 175) + (b * 43)) 8)
            def newB:int (bit_shr ((r * 70) + (g * 137) + (b * 33)) 8)
            if (newR > 255) { newR = 255 }
            if (newG > 255) { newG = 255 }
            if (newB > 255) { newB = 255 }
            buffer_set pixels off newR
            buffer_set pixels (off + 1) newG
            buffer_set pixels (off + 2) newB
            i = i + 1
        }
    }
    
    fn flipHorizontal:void () {
        def y 0
        while (y < height) {
            def x 0
            def halfW:int (bit_shr width 1)
            while (x < halfW) {
                def x2:int ((width - 1) - x)
                def off1:int (this.getPixelOffset(x y))
                def off2:int (this.getPixelOffset(x2 y))
                ; Swap pixels
                def r1:int (buffer_get pixels off1)
                def g1:int (buffer_get pixels (off1 + 1))
                def b1:int (buffer_get pixels (off1 + 2))
                def a1:int (buffer_get pixels (off1 + 3))
                def r2:int (buffer_get pixels off2)
                def g2:int (buffer_get pixels (off2 + 1))
                def b2:int (buffer_get pixels (off2 + 2))
                def a2:int (buffer_get pixels (off2 + 3))
                buffer_set pixels off1 r2
                buffer_set pixels (off1 + 1) g2
                buffer_set pixels (off1 + 2) b2
                buffer_set pixels (off1 + 3) a2
                buffer_set pixels off2 r1
                buffer_set pixels (off2 + 1) g1
                buffer_set pixels (off2 + 2) b1
                buffer_set pixels (off2 + 3) a1
                x = x + 1
            }
            y = y + 1
        }
    }
    
    fn flipVertical:void () {
        def y 0
        def halfH:int (bit_shr height 1)
        while (y < halfH) {
            def y2:int ((height - 1) - y)
            def x 0
            while (x < width) {
                def off1:int (this.getPixelOffset(x y))
                def off2:int (this.getPixelOffset(x y2))
                ; Swap pixels
                def r1:int (buffer_get pixels off1)
                def g1:int (buffer_get pixels (off1 + 1))
                def b1:int (buffer_get pixels (off1 + 2))
                def a1:int (buffer_get pixels (off1 + 3))
                def r2:int (buffer_get pixels off2)
                def g2:int (buffer_get pixels (off2 + 1))
                def b2:int (buffer_get pixels (off2 + 2))
                def a2:int (buffer_get pixels (off2 + 3))
                buffer_set pixels off1 r2
                buffer_set pixels (off1 + 1) g2
                buffer_set pixels (off1 + 2) b2
                buffer_set pixels (off1 + 3) a2
                buffer_set pixels off2 r1
                buffer_set pixels (off2 + 1) g1
                buffer_set pixels (off2 + 2) b1
                buffer_set pixels (off2 + 3) a1
                x = x + 1
            }
            y = y + 1
        }
    }
    
    ; Drawing primitives
    
    fn drawLine:void (x1:int y1:int x2:int y2:int c:Color) {
        ; Bresenham's line algorithm
        def dx:int (x2 - x1)
        def dy:int (y2 - y1)
        if (dx < 0) { dx = 0 - dx }
        if (dy < 0) { dy = 0 - dy }
        
        def sx:int 1
        if (x1 > x2) { sx = -1 }
        def sy:int 1
        if (y1 > y2) { sy = -1 }
        
        def err:int (dx - dy)
        def x:int x1
        def y:int y1
        
        def done:boolean false
        while (done == false) {
            this.setPixel(x y c)
            if ((x == x2) && (y == y2)) {
                done = true
            } {
                def e2:int (err * 2)
                if (e2 > (0 - dy)) {
                    err = err - dy
                    x = x + sx
                }
                if (e2 < dx) {
                    err = err + dx
                    y = y + sy
                }
            }
        }
    }
    
    fn drawRect:void (x:int y:int w:int h:int c:Color) {
        this.drawLine(x y (x + w - 1) y c)
        this.drawLine((x + w - 1) y (x + w - 1) (y + h - 1) c)
        this.drawLine((x + w - 1) (y + h - 1) x (y + h - 1) c)
        this.drawLine(x (y + h - 1) x y c)
    }
    
    fn scale:ImageBuffer (factor:int) {
        ; Scale image by integer factor (nearest neighbor)
        def newW:int (width * factor)
        def newH:int (height * factor)
        def result (new ImageBuffer())
        result.init(newW newH)
        
        def destY 0
        while (destY < newH) {
            def srcY:int (to_int (destY / factor))
            def destX 0
            while (destX < newW) {
                def srcX:int (to_int (destX / factor))
                ; Read source pixel
                def srcOff:int (((srcY * width) + srcX) * 4)
                def r:int (buffer_get pixels srcOff)
                def g:int (buffer_get pixels (srcOff + 1))
                def b:int (buffer_get pixels (srcOff + 2))
                def a:int (buffer_get pixels (srcOff + 3))
                ; Write to destination
                def destOff:int (((destY * newW) + destX) * 4)
                buffer_set result.pixels destOff r
                buffer_set result.pixels (destOff + 1) g
                buffer_set result.pixels (destOff + 2) b
                buffer_set result.pixels (destOff + 3) a
                destX = destX + 1
            }
            destY = destY + 1
        }
        
        return result
    }
}
