; EVGPDFRenderer.rgr - Render EVG elements to PDF
; 
; Takes EVG element tree with calculated positions and renders to PDF using PDFWriter.

Import "PDFWriter.rgr"
Import "../evg/EVGElement.rgr"
Import "../evg/EVGLayout.rgr"
Import "../evg/EVGTextMeasurer.rgr"
Import "../evg/EVGImageMeasurer.rgr"
Import "../evg/EVGUnit.rgr"
Import "../evg/EVGColor.rgr"
Import "Buffer.rgr"
Import "FontManager.rgr"
Import "JPEGReader.rgr"
Import "JPEGMetadata.rgr"
Import "JPEGDecoder.rgr"
Import "JPEGEncoder.rgr"
Import "ImageBuffer.rgr"

; Helper class to track embedded fonts
class EmbeddedFont {
    def name:string ""
    def fontObjNum:int 0
    def fontDescObjNum:int 0
    def fontFileObjNum:int 0
    def pdfName:string ""
    def ttfFont:TrueTypeFont
    
    Constructor (n:string pn:string font:TrueTypeFont) {
        name = n
        pdfName = pn
        ttfFont = font
    }
}

; Helper class to track embedded images
class EmbeddedImage {
    def src:string ""
    def objNum:int 0
    def width:int 0
    def height:int 0
    def orientation:int 1
    def pdfName:string ""
    
    Constructor (s:string) {
        src = s
    }
}

class EVGPDFRenderer {
    Extends(EVGImageMeasurer)
    def writer:PDFWriter
    def layout:EVGLayout
    def measurer:EVGTextMeasurer
    def streamBuffer:GrowableBuffer
    def pageWidth:double 595.0
    def pageHeight:double 842.0
    def nextObjNum:int 1
    def fontObjNum:int 0
    def pagesObjNum:int 0
    def contentObjNums:[int]
    def pageCount:int 1
    def debug:boolean false
    def fontManager:FontManager (new FontManager())
    def embeddedFonts:[EmbeddedFont]
    def usedFontNames:[string]
    def embeddedImages:[EmbeddedImage]
    def jpegReader:JPEGReader (new JPEGReader())
    def jpegDecoder:JPEGDecoder (new JPEGDecoder())
    def jpegEncoder:JPEGEncoder (new JPEGEncoder())
    def metadataParser:JPEGMetadataParser (new JPEGMetadataParser())
    def baseDir:string "./"
    def maxImageWidth:int 800
    def maxImageHeight:int 800
    def jpegQuality:int 75
    def imageDimensionsCache:[EVGImageDimensions]
    def imageDimensionsCacheKeys:[string]
    
    Constructor () {
        def w (new PDFWriter())
        writer = w
        def lay (new EVGLayout())
        layout = lay
        def m (new SimpleTextMeasurer())
        measurer = m
        def buf (new GrowableBuffer())
        streamBuffer = buf
        def ef:[EmbeddedFont]
        embeddedFonts = ef
        def uf:[string]
        usedFontNames = uf
        def ei:[EmbeddedImage]
        embeddedImages = ei
        def idc:[EVGImageDimensions]
        imageDimensionsCache = idc
        def idck:[string]
        imageDimensionsCacheKeys = idck
        ; Set this renderer as the image measurer for layout
        layout.setImageMeasurer(this)
    }
    
    fn setPageSize:void (width:double height:double) {
        pageWidth = width
        pageHeight = height
        layout.setPageSize(width height)
    }
    
    fn setBaseDir:void (dir:string) {
        baseDir = dir
    }
    
    fn setMeasurer:void (m:EVGTextMeasurer) {
        measurer = m
        layout.setMeasurer(m)
    }
    
    fn setFontManager:void (fm:FontManager) {
        fontManager = fm
    }
    
    fn setDebug:void (enabled:boolean) {
        layout.debug = enabled
        this.debug = enabled
    }
    
    fn getImageDimensions:EVGImageDimensions (src:string) {
        ; Check cache first
        def i:int 0
        while (i < (array_length imageDimensionsCacheKeys)) {
            def key:string (itemAt imageDimensionsCacheKeys i)
            if (key == src) {
                return (itemAt imageDimensionsCache i)
            }
            i = i + 1
        }
        
        ; Not in cache, load from file
        def dims (new EVGImageDimensions())
        
        ; Resolve the image path - handle relative paths like "./bin/image.jpg"
        def imgDir:string ""
        def imgFile:string ""
        def imgSrc:string src
        
        ; Remove leading "./" if present
        if ((strlen src) > 2) {
            def prefix:string (substring src 0 2)
            if (prefix == "./") {
                imgSrc = (substring src 2 (strlen src))
            }
        }
        
        ; Find last path separator
        def lastSlash:int (lastIndexOf imgSrc "/")
        def lastBackslash:int (lastIndexOf imgSrc "\\")
        def lastSep:int lastSlash
        if (lastBackslash > lastSep) {
            lastSep = lastBackslash
        }
        
        if (lastSep >= 0) {
            ; Combine baseDir with the path from imgSrc
            imgDir = baseDir + (substring imgSrc 0 (lastSep + 1))
            imgFile = (substring imgSrc (lastSep + 1) (strlen imgSrc))
        } {
            ; No path separator, use baseDir directly
            imgDir = baseDir
            imgFile = imgSrc
        }
        
        ; Read JPEG dimensions using JPEGReader
        def reader:JPEGReader (new JPEGReader())
        def jpegImage:JPEGImage (reader.readJPEG(imgDir imgFile))
        
        if jpegImage.isValid {
            ; Get EXIF orientation to determine final dimensions  
            def metaInfo:JPEGMetadataInfo (metadataParser.parseMetadata(imgDir imgFile))
            def orientation:int metaInfo.orientation
            
            def imgW:int jpegImage.width
            def imgH:int jpegImage.height
            
            ; Swap dimensions for 90/270 degree rotations
            if ((orientation == 5) || (orientation == 6) || (orientation == 7) || (orientation == 8)) {
                def tmp:int imgW
                imgW = imgH
                imgH = tmp
            }
            
            dims = (EVGImageDimensions.create(imgW imgH))
            print (("Image dimensions: " + src + " = " + (to_string imgW) + "x" + (to_string imgH) + " (orientation=" + (to_string orientation) + ")"))
        }
        
        ; Cache the result
        push imageDimensionsCacheKeys src
        push imageDimensionsCache dims
        
        return dims
    }
    
    fn getPdfFontName:string (fontFamily:string) {
        ; Get the PDF font name (F1, F2, etc.) for a font family
        def i:int 0
        while (i < (array_length usedFontNames)) {
            def name:string (itemAt usedFontNames i)
            if (name == fontFamily) {
                return ("/F" + (to_string (i + 1)))
            }
            i = i + 1
        }
        ; Not found, add it
        push usedFontNames fontFamily
        return ("/F" + (to_string (array_length usedFontNames)))
    }
    
    fn render:buffer (root:EVGElement) {
        ; Layout the tree first
        layout.layout(root)
        
        ; Render to PDF
        return (this.renderToPDF(root))
    }
    
    fn renderToPDF:buffer (root:EVGElement) {
        ; Build PDF with the rendered content
        def pdf (new GrowableBuffer())
        nextObjNum = 1
        clear contentObjNums
        clear usedFontNames
        clear embeddedFonts
        clear embeddedImages
        
        ; PDF header (version 1.5 for TrueType embedding)
        pdf.writeString("%PDF-1.5\n")
        pdf.writeByte(37)   ; %
        pdf.writeByte(226)  ; high-bit char
        pdf.writeByte(227)  ; high-bit char
        pdf.writeByte(207)  ; high-bit char
        pdf.writeByte(211)  ; high-bit char
        pdf.writeByte(10)   ; newline
        
        ; Keep track of object offsets
        def objectOffsets:[int]
        
        ; Build content stream for the page (this also collects used fonts)
        streamBuffer.clear()
        this.renderElement(root 0.0 0.0)
        def contentData:buffer (streamBuffer.toBuffer())
        def contentLen:int (buffer_length contentData)
        
        ; Now embed fonts for each used font
        def fontObjNums:[int]
        def i:int 0
        while (i < (array_length usedFontNames)) {
            def fontName:string (itemAt usedFontNames i)
            def ttfFont:TrueTypeFont (fontManager.getFont(fontName))
            
            if (ttfFont.unitsPerEm > 0) {
                ; Embed TrueType font
                def fontFileData:buffer (ttfFont.getFontData())
                def fontFileLen:int (buffer_length fontFileData)
                
                ; Font file stream object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Length " + (to_string fontFileLen) + " /Length1 " + (to_string fontFileLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(fontFileData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def fontFileObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font descriptor object
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /FontDescriptor")
                pdf.writeString(" /FontName /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /Flags 32")  ; Symbolic
                pdf.writeString(" /FontBBox [0 " + (to_string ttfFont.descender) + " 1000 " + (to_string ttfFont.ascender) + "]")
                pdf.writeString(" /ItalicAngle 0")
                pdf.writeString(" /Ascent " + (to_string ttfFont.ascender))
                pdf.writeString(" /Descent " + (to_string ttfFont.descender))
                pdf.writeString(" /CapHeight " + (to_string ttfFont.ascender))
                pdf.writeString(" /StemV 80")
                pdf.writeString(" /FontFile2 " + (to_string fontFileObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                def fontDescObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; ToUnicode CMap for proper character mapping
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                def toUnicodeStream:string "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<00> <FF>\nendcodespacerange\n"
                ; Map characters 32-255 to their Unicode code points (identity mapping for WinAnsi)
                toUnicodeStream = toUnicodeStream + "2 beginbfrange\n<20> <7E> <0020>\n<A0> <FF> <00A0>\nendbfrange\n"
                toUnicodeStream = toUnicodeStream + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"
                def toUnicodeLen:int (strlen toUnicodeStream)
                pdf.writeString("<< /Length " + (to_string toUnicodeLen) + " >>\n")
                pdf.writeString("stream\n")
                pdf.writeString(toUnicodeStream)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                def toUnicodeObjNum:int nextObjNum
                nextObjNum = nextObjNum + 1
                
                ; Font object (TrueType)
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font")
                pdf.writeString(" /Subtype /TrueType")
                pdf.writeString(" /BaseFont /" + (this.sanitizeFontName(ttfFont.fontFamily)))
                pdf.writeString(" /FirstChar 32")
                pdf.writeString(" /LastChar 255")
                pdf.writeString(" /Widths [")
                ; Output widths for characters 32-255
                def ch:int 32
                while (ch <= 255) {
                    ; Use getCharWidth which properly maps char code -> glyph index -> width
                    def w:int (ttfFont.getCharWidth(ch))
                    ; Scale to 1000 units (standard PDF font units)
                    def scaledWd:double (((to_double w) * 1000.0) / (to_double ttfFont.unitsPerEm))
                    def scaledW:int (to_int scaledWd)
                    pdf.writeString((to_string scaledW))
                    if (ch < 255) {
                        pdf.writeString(" ")
                    }
                    ch = ch + 1
                }
                pdf.writeString("]")
                pdf.writeString(" /FontDescriptor " + (to_string fontDescObjNum) + " 0 R")
                pdf.writeString(" /Encoding /WinAnsiEncoding")
                pdf.writeString(" /ToUnicode " + (to_string toUnicodeObjNum) + " 0 R")
                pdf.writeString(" >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            } {
                ; Fallback to built-in Helvetica
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
                pdf.writeString("endobj\n\n")
                push fontObjNums nextObjNum
                nextObjNum = nextObjNum + 1
            }
            i = i + 1
        }
        
        ; Ensure at least one font exists
        if ((array_length fontObjNums) == 0) {
            push objectOffsets (pdf.size())
            pdf.writeString((to_string nextObjNum) + " 0 obj\n")
            pdf.writeString("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\n")
            pdf.writeString("endobj\n\n")
            push fontObjNums nextObjNum
            nextObjNum = nextObjNum + 1
        }
        
        ; Embed images
        def imgIdx:int 0
        while (imgIdx < (array_length embeddedImages)) {
            def embImg:EmbeddedImage (itemAt embeddedImages imgIdx)
            
            ; Parse the src path to get directory and filename
            def imgSrc:string embImg.src
            def imgDir:string baseDir
            def imgFile:string imgSrc
            
            ; Handle relative paths starting with ./
            if ((strlen imgSrc) > 2) {
                def prefix:string (substring imgSrc 0 2)
                if (prefix == "./") {
                    imgSrc = (substring imgSrc 2 (strlen imgSrc))
                }
            }
            
            ; Check for path separators
            def lastSlash:int (lastIndexOf imgSrc "/")
            def lastBackslash:int (lastIndexOf imgSrc "\\")
            def lastSep:int lastSlash
            if (lastBackslash > lastSep) {
                lastSep = lastBackslash
            }
            
            if (lastSep >= 0) {
                ; Combine baseDir with the path from imgSrc
                imgDir = baseDir + (substring imgSrc 0 (lastSep + 1))
                imgFile = (substring imgSrc (lastSep + 1) (strlen imgSrc))
            } {
                ; No path separator, use baseDir directly
                imgDir = baseDir
                imgFile = imgSrc
            }
            
            print ("Loading image: dir=" + imgDir + " file=" + imgFile)
            
            ; Get EXIF orientation
            def metaInfo:JPEGMetadataInfo (metadataParser.parseMetadata(imgDir imgFile))
            embImg.orientation = metaInfo.orientation
            
            ; Decode JPEG to ImageBuffer for processing
            def imgBuffer:ImageBuffer (jpegDecoder.decode(imgDir imgFile))
            
            if ((imgBuffer.width > 1) && (imgBuffer.height > 1)) {
                ; Apply EXIF orientation
                if (metaInfo.orientation > 1) {
                    print ("  Applying EXIF orientation: " + (to_string metaInfo.orientation))
                    imgBuffer = (imgBuffer.applyExifOrientation(metaInfo.orientation))
                }
                
                ; Calculate scaled dimensions to fit within maxImageWidth x maxImageHeight
                def origW:int imgBuffer.width
                def origH:int imgBuffer.height
                def newW:int origW
                def newH:int origH
                
                ; Check if resizing is needed
                if ((origW > maxImageWidth) || (origH > maxImageHeight)) {
                    def scaleW:double ((to_double maxImageWidth) / (to_double origW))
                    def scaleH:double ((to_double maxImageHeight) / (to_double origH))
                    def scale:double scaleW
                    if (scaleH < scaleW) {
                        scale = scaleH
                    }
                    newW = (to_int ((to_double origW) * scale))
                    newH = (to_int ((to_double origH) * scale))
                    
                    print ("  Resizing from " + (to_string origW) + "x" + (to_string origH) + " to " + (to_string newW) + "x" + (to_string newH))
                    imgBuffer = (imgBuffer.scaleToSize(newW newH))
                }
                
                ; Encode to JPEG buffer
                jpegEncoder.setQuality(jpegQuality)
                def encodedData:buffer (jpegEncoder.encodeToBuffer(imgBuffer))
                def encodedLen:int (buffer_length encodedData)
                
                embImg.width = newW
                embImg.height = newH
                
                ; Image XObject
                push objectOffsets (pdf.size())
                pdf.writeString((to_string nextObjNum) + " 0 obj\n")
                pdf.writeString("<< /Type /XObject")
                pdf.writeString(" /Subtype /Image")
                pdf.writeString(" /Width " + (to_string newW))
                pdf.writeString(" /Height " + (to_string newH))
                pdf.writeString(" /ColorSpace /DeviceRGB")
                pdf.writeString(" /BitsPerComponent 8")
                pdf.writeString(" /Filter /DCTDecode")
                pdf.writeString(" /Length " + (to_string encodedLen))
                pdf.writeString(" >>\n")
                pdf.writeString("stream\n")
                pdf.writeBuffer(encodedData)
                pdf.writeString("\nendstream\n")
                pdf.writeString("endobj\n\n")
                
                embImg.objNum = nextObjNum
                embImg.pdfName = "/Im" + (to_string (imgIdx + 1))
                nextObjNum = nextObjNum + 1
                
                print ("Embedded image: " + imgSrc + " (resized to " + (to_string newW) + "x" + (to_string newH) + ", " + (to_string encodedLen) + " bytes)")
            } {
                print ("Failed to decode image: " + imgSrc)
            }
            
            imgIdx = imgIdx + 1
        }
        
        ; Content stream object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Length " + (to_string contentLen) + " >>\n")
        pdf.writeString("stream\n")
        pdf.writeBuffer(contentData)
        pdf.writeString("\nendstream\n")
        pdf.writeString("endobj\n\n")
        def contentObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Page object
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        def pagesRef:int (nextObjNum + 1)
        pdf.writeString("<< /Type /Page /Parent " + (to_string pagesRef) + " 0 R")
        pdf.writeString(" /MediaBox [0 0 " + (this.formatNum(pageWidth)) + " " + (this.formatNum(pageHeight)) + "]")
        pdf.writeString(" /Contents " + (to_string contentObjNum) + " 0 R")
        pdf.writeString(" /Resources <<")
        ; Add font references
        pdf.writeString(" /Font <<")
        def fi:int 0
        while (fi < (array_length fontObjNums)) {
            def fontObjN:int (itemAt fontObjNums fi)
            pdf.writeString(" /F" + (to_string (fi + 1)) + " " + (to_string fontObjN) + " 0 R")
            fi = fi + 1
        }
        pdf.writeString(" >>")
        ; Add image XObject references
        if ((array_length embeddedImages) > 0) {
            pdf.writeString(" /XObject <<")
            def ii:int 0
            while (ii < (array_length embeddedImages)) {
                def embImg:EmbeddedImage (itemAt embeddedImages ii)
                if (embImg.objNum > 0) {
                    pdf.writeString(" /Im" + (to_string (ii + 1)) + " " + (to_string embImg.objNum) + " 0 R")
                }
                ii = ii + 1
            }
            pdf.writeString(" >>")
        }
        pdf.writeString(" >> >>\n")
        pdf.writeString("endobj\n\n")
        def pageObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Object 6: Pages
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Pages /Kids [" + (to_string pageObjNum) + " 0 R] /Count 1 >>\n")
        pdf.writeString("endobj\n\n")
        pagesObjNum = nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Object 7: Catalog
        push objectOffsets (pdf.size())
        pdf.writeString((to_string nextObjNum) + " 0 obj\n")
        pdf.writeString("<< /Type /Catalog /Pages " + (to_string pagesObjNum) + " 0 R >>\n")
        pdf.writeString("endobj\n\n")
        def catalogObjNum:int nextObjNum
        nextObjNum = nextObjNum + 1
        
        ; Xref table
        def xrefOffset:int (pdf.size())
        pdf.writeString("xref\n")
        pdf.writeString("0 " + (to_string nextObjNum) + "\n")
        pdf.writeString("0000000000 65535 f \n")
        
        def i 0
        while (i < (array_length objectOffsets)) {
            def offset:int (itemAt objectOffsets i)
            pdf.writeString((this.padLeft((to_string offset) 10 "0")) + " 00000 n \n")
            i = i + 1
        }
        
        ; Trailer
        pdf.writeString("trailer\n")
        pdf.writeString("<< /Size " + (to_string nextObjNum) + " /Root " + (to_string catalogObjNum) + " 0 R >>\n")
        pdf.writeString("startxref\n")
        pdf.writeString((to_string xrefOffset) + "\n")
        pdf.writeString("%%EOF\n")
        
        return (pdf.toBuffer())
    }
    
    fn renderElement:void (el:EVGElement offsetX:double offsetY:double) {
        ; Get element position
        def x:double (el.calculatedX + offsetX)
        def y:double (el.calculatedY + offsetY)
        def w:double el.calculatedWidth
        def h:double el.calculatedHeight
        
        ; PDF uses bottom-left origin, flip Y
        def pdfY:double (pageHeight - y - h)
        
        ; Render background if set
        def bgColor:EVGColor (unwrap el.backgroundColor)
        if this.debug {
            print ("  bg check: " + el.tagName + " isSet=" + (to_string bgColor.isSet) + " r=" + (to_string bgColor.r))
        }
        if bgColor.isSet {
            this.renderBackground(x pdfY w h bgColor)
        }
        
        ; Render border
        this.renderBorder(el x pdfY w h)
        
        ; Render text content
        if (el.tagName == "text") {
            this.renderText(el x pdfY w h)
        }
        
        ; Handle divider element
        if (el.tagName == "divider") {
            this.renderDivider(el x pdfY w h)
        }
        
        ; Handle image element
        if (el.tagName == "image") {
            this.renderImage(el x pdfY w h)
        }
        
        ; Render children - children have absolute positions from layout engine
        ; so pass the same offset that was passed to this element
        def i 0
        def childCount:int (el.getChildCount())
        while (i < childCount) {
            def child:EVGElement (el.getChild(i))
            this.renderElement(child offsetX offsetY)
            i = i + 1
        }
    }
    
    fn getImagePdfName:string (src:string) {
        ; Find or create an embedded image entry and return its PDF name
        def i:int 0
        while (i < (array_length embeddedImages)) {
            def embImg:EmbeddedImage (itemAt embeddedImages i)
            if (embImg.src == src) {
                return ("/Im" + (to_string (i + 1)))
            }
            i = i + 1
        }
        ; Not found, add it
        def newImg (new EmbeddedImage(src))
        push embeddedImages newImg
        return ("/Im" + (to_string (array_length embeddedImages)))
    }
    
    fn renderImage:void (el:EVGElement x:double y:double w:double h:double) {
        def src:string el.src
        if ((strlen src) == 0) {
            return
        }
        
        ; Register the image for embedding
        def imgName:string (this.getImagePdfName(src))
        
        ; Draw the image (orientation already applied during JPEG processing)
        ; PDF transformation matrix: [a b c d e f] cm
        ; where: a=scaleX, d=scaleY, e=translateX, f=translateY
        streamBuffer.writeString("q\n")
        streamBuffer.writeString((this.formatNum(w)) + " 0 0 " + (this.formatNum(h)) + " " + (this.formatNum(x)) + " " + (this.formatNum(y)) + " cm\n")
        streamBuffer.writeString(imgName + " Do\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderBackground:void (x:double y:double w:double h:double color:EVGColor) {
        streamBuffer.writeString("q\n")
        ; Set fill color
        def r:double (color.r / 255.0)
        def g:double (color.g / 255.0)
        def b:double (color.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
        ; Draw rectangle
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(y)) + " " + (this.formatNum(w)) + " " + (this.formatNum(h)) + " re\n")
        streamBuffer.writeString("f\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderBorder:void (el:EVGElement x:double y:double w:double h:double) {
        ; Get border width from box
        def borderWidth:double el.box.borderWidth.pixels
        if (borderWidth <= 0.0) {
            return
        }
        
        ; Get border color
        def borderColor:EVGColor (unwrap el.box.borderColor)
        if (borderColor.isSet == false) {
            borderColor = (EVGColor.black())
        }
        
        streamBuffer.writeString("q\n")
        ; Set stroke color
        def r:double (borderColor.r / 255.0)
        def g:double (borderColor.g / 255.0)
        def b:double (borderColor.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " RG\n")
        ; Set line width
        streamBuffer.writeString((this.formatNum(borderWidth)) + " w\n")
        ; Draw rectangle outline
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(y)) + " " + (this.formatNum(w)) + " " + (this.formatNum(h)) + " re\n")
        streamBuffer.writeString("S\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn renderText:void (el:EVGElement x:double y:double w:double h:double) {
        ; Get text content (scan children for text nodes)
        def text:string (this.getTextContent(el))
        if ((strlen text) == 0) {
            return
        }
        
        ; Get font size
        def fontSize:double 14.0
        if el.fontSize.isSet {
            fontSize = el.fontSize.pixels
        }
        
        ; Get text color
        def color:EVGColor el.color
        if (color.isSet == false) {
            color = (EVGColor.black())
        }
        
        ; Get line height
        def lineHeight:double el.lineHeight
        if (lineHeight <= 0.0) {
            lineHeight = 1.2
        }
        def lineSpacing:double (fontSize * lineHeight)
        
        ; Get font family
        def fontFamily:string el.fontFamily
        if ((strlen fontFamily) == 0) {
            fontFamily = "Helvetica"
        }
        
        ; Wrap text to fit width using correct font
        def lines:[string] (this.wrapText(text w fontSize fontFamily))
        
        ; Get PDF font name
        def fontName:string (this.getPdfFontName(fontFamily))
        
        ; Render each line
        def lineY:double (y + h - fontSize)
        def i:int 0
        while (i < (array_length lines)) {
            def line:string (itemAt lines i)
            
            streamBuffer.writeString("BT\n")
            streamBuffer.writeString(fontName + " " + (this.formatNum(fontSize)) + " Tf\n")
            
            ; Set text color
            def r:double (color.r / 255.0)
            def g:double (color.g / 255.0)
            def b:double (color.b / 255.0)
            streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " rg\n")
            
            ; Position text
            def textX:double x
            
            ; Handle text alignment
            if (el.textAlign == "center") {
                def textWidth:double (measurer.measureTextWidth(line fontFamily fontSize))
                textX = x + ((w - textWidth) / 2.0)
            }
            if (el.textAlign == "right") {
                def textWidth:double (measurer.measureTextWidth(line fontFamily fontSize))
                textX = x + w - textWidth
            }
            
            streamBuffer.writeString((this.formatNum(textX)) + " " + (this.formatNum(lineY)) + " Td\n")
            streamBuffer.writeString("(" + (this.escapeText(line)) + ") Tj\n")
            streamBuffer.writeString("ET\n")
            
            lineY = lineY - lineSpacing
            i = i + 1
        }
    }
    
    fn wrapText:[string] (text:string maxWidth:double fontSize:double fontFamily:string) {
        ; Word wrap text to fit within maxWidth
        def lines:[string]
        def words:[string] (strsplit text " ")
        def currentLine:string ""
        
        def i:int 0
        while (i < (array_length words)) {
            def word:string (itemAt words i)
            def testLine:string ""
            if ((strlen currentLine) == 0) {
                testLine = word
            } {
                testLine = currentLine + " " + word
            }
            
            def testWidth:double (measurer.measureTextWidth(testLine fontFamily fontSize))
            if ((testWidth > maxWidth) && ((strlen currentLine) > 0)) {
                ; Line is too long, push current and start new
                push lines currentLine
                currentLine = word
            } {
                currentLine = testLine
            }
            
            i = i + 1
        }
        
        ; Push final line
        if ((strlen currentLine) > 0) {
            push lines currentLine
        }
        
        return lines
    }
    
    fn renderDivider:void (el:EVGElement x:double y:double w:double h:double) {
        ; Render a horizontal line
        def color:EVGColor el.color
        if (color.isSet == false) {
            color = (EVGColor.rgb(200 200 200))
        }
        
        def lineY:double (y + (h / 2.0))
        
        streamBuffer.writeString("q\n")
        def r:double (color.r / 255.0)
        def g:double (color.g / 255.0)
        def b:double (color.b / 255.0)
        streamBuffer.writeString((this.formatNum(r)) + " " + (this.formatNum(g)) + " " + (this.formatNum(b)) + " RG\n")
        streamBuffer.writeString("1 w\n")
        streamBuffer.writeString((this.formatNum(x)) + " " + (this.formatNum(lineY)) + " m\n")
        streamBuffer.writeString((this.formatNum((x + w))) + " " + (this.formatNum(lineY)) + " l\n")
        streamBuffer.writeString("S\n")
        streamBuffer.writeString("Q\n")
    }
    
    fn getTextContent:string (el:EVGElement) {
        ; Get text content from element's textContent property
        ; This is set by the JSX parser for span/Label/text elements
        return el.textContent
    }
    
    fn estimateTextWidth:double (text:string fontSize:double) {
        ; Use the same text measurer as layout for consistent results
        return (measurer.measureTextWidth(text "Helvetica" fontSize))
    }
    
    fn escapeText:string (text:string) {
        ; Escape parentheses and backslashes for PDF
        def result:string ""
        def len:int (strlen text)
        def i 0
        while (i < len) {
            def ch:int (charAt text i)
            if (ch == 40) {  ; (
                result = result + "\\("
            } {
                if (ch == 41) {  ; )
                    result = result + "\\)"
                } {
                    if (ch == 92) {  ; \
                        result = result + "\\\\"
                    } {
                        result = result + (strfromcode ch)
                    }
                }
            }
            i = i + 1
        }
        return result
    }
    
    fn formatNum:string (n:double) {
        ; Format number for PDF - simple conversion
        ; PDF doesn't need high precision for most values
        def result:string (to_string n)
        return result
    }
    
    fn padLeft:string (s:string len:int padChar:string) {
        def result:string s
        while ((strlen result) < len) {
            result = padChar + result
        }
        return result
    }
    
    fn sanitizeFontName:string (name:string) {
        ; Remove spaces and special characters from font name for PDF
        def result:string ""
        def len:int (strlen name)
        def i 0
        while (i < len) {
            def ch:int (charAt name i)
            ; Only allow alphanumeric characters
            if (((ch >= 65) && (ch <= 90)) || ((ch >= 97) && (ch <= 122)) || ((ch >= 48) && (ch <= 57))) {
                result = result + (strfromcode ch)
            }
            i = i + 1
        }
        return result
    }
}
