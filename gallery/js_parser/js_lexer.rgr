; JavaScript ES5 Lexer
Import "js_token.rgr"

class Lexer {
    def source:string ""
    def pos:int 0
    def line:int 1
    def col:int 1
    def len:int 0

    Constructor (src:string) {
        source = src
        len = (strlen src)
    }

    fn peek:string () {
        if (pos >= len) {
            return ""
        }
        return (at source pos)
    }

    fn peekAt:string (offset:int) {
        def idx (pos + offset)
        if (idx >= len) {
            return ""
        }
        return (at source idx)
    }

    fn advance:string () {
        if (pos >= len) {
            return ""
        }
        def ch:string (at source pos)
        pos = pos + 1
        if ((ch == "\n") || (ch == "\r\n")) {
            line = line + 1
            col = 1
        } {
            col = col + 1
        }
        return ch
    }

    fn isDigit:boolean (ch:string) {
        if (ch == "0") { return true }
        if (ch == "1") { return true }
        if (ch == "2") { return true }
        if (ch == "3") { return true }
        if (ch == "4") { return true }
        if (ch == "5") { return true }
        if (ch == "6") { return true }
        if (ch == "7") { return true }
        if (ch == "8") { return true }
        if (ch == "9") { return true }
        return false
    }

    fn isAlpha:boolean (ch:string) {
        if ((strlen ch) == 0) { return false }
        def code:int (charAt source pos)
        ; a-z: 97-122, A-Z: 65-90
        if (code >= 97) {
            if (code <= 122) {
                return true
            }
        }
        if (code >= 65) {
            if (code <= 90) {
                return true
            }
        }
        if (ch == "_") { return true }
        if (ch == "$") { return true }
        return false
    }

    fn isAlphaNumCh:boolean (ch:string) {
        if (this.isDigit(ch)) { return true }
        if (ch == "_") { return true }
        if (ch == "$") { return true }
        if ((strlen ch) == 0) { return false }
        def code:int (charAt source pos)
        if (code >= 97) {
            if (code <= 122) {
                return true
            }
        }
        if (code >= 65) {
            if (code <= 90) {
                return true
            }
        }
        return false
    }

    fn isWhitespace:boolean (ch:string) {
        if (ch == " ") { return true }
        if (ch == "\t") { return true }
        if (ch == "\n") { return true }
        if (ch == "\r") { return true }
        if (ch == "\r\n") { return true }
        return false
    }

    fn skipWhitespace:void () {
        while (pos < len) {
            def ch:string (this.peek())
            if (this.isWhitespace(ch)) {
                this.advance()
            } {
                return
            }
        }
    }

    fn readLineComment:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        this.advance() ; consume first /
        this.advance() ; consume second /
        def value:string ""
        while (pos < len) {
            def ch:string (this.peek())
            if (ch == "\n") {
                return (this.makeToken("LineComment" value startPos startLine startCol))
            }
            ; Handle CRLF as single grapheme cluster in Swift
            if (ch == "\r\n") {
                return (this.makeToken("LineComment" value startPos startLine startCol))
            }
            value = value + (this.advance())
        }
        return (this.makeToken("LineComment" value startPos startLine startCol))
    }

    fn readBlockComment:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        this.advance() ; consume /
        this.advance() ; consume *
        def value:string ""
        def isJSDoc:boolean false
        
        ; Check if this is a JSDoc comment (starts with /**)
        if ((this.peek()) == "*") {
            def nextCh:string (this.peekAt(1))
            if (nextCh != "/") {
                isJSDoc = true
            }
        }
        
        while (pos < len) {
            def ch:string (this.peek())
            if (ch == "*") {
                if ((this.peekAt(1)) == "/") {
                    this.advance() ; consume *
                    this.advance() ; consume /
                    if (isJSDoc) {
                        return (this.makeToken("JSDocComment" value startPos startLine startCol))
                    }
                    return (this.makeToken("BlockComment" value startPos startLine startCol))
                }
            }
            value = value + (this.advance())
        }
        ; Unterminated comment - return what we have
        if (isJSDoc) {
            return (this.makeToken("JSDocComment" value startPos startLine startCol))
        }
        return (this.makeToken("BlockComment" value startPos startLine startCol))
    }

    fn makeToken:Token (tokType:string value:string startPos:int startLine:int startCol:int) {
        def tok (new Token())
        tok.tokenType = tokType
        tok.value = value
        tok.start = startPos
        tok.end = pos
        tok.line = startLine
        tok.col = startCol
        return tok
    }

    fn readString:Token (quote:string) {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        this.advance() ; consume opening quote
        def value:string ""
        while (pos < len) {
            def ch:string (this.peek())
            if (ch == quote) {
                this.advance()
                return (this.makeToken("String" value startPos startLine startCol))
            }
            if (ch == "\\") {
                this.advance()
                def esc:string (this.advance())
                if (esc == "n") { 
                    value = value + "\n" 
                } {
                    if (esc == "t") { 
                        value = value + "\t" 
                    } {
                        if (esc == "r") { 
                            value = value + "\r" 
                        } {
                            if (esc == "\\") { 
                                value = value + "\\" 
                            } {
                                if (esc == quote) { 
                                    value = value + quote 
                                } {
                                    ; Unknown escape - keep the escaped character
                                    value = value + esc
                                }
                            }
                        }
                    }
                }
            } {
                value = value + (this.advance())
            }
        }
        return (this.makeToken("String" value startPos startLine startCol))
    }

    ; Template literal reader - returns TemplateLiteral token
    ; For simplicity, we tokenize the entire template as one token
    ; A more complete implementation would handle ${} expressions
    fn readTemplateLiteral:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        this.advance() ; consume opening backtick
        def value:string ""
        def hasExpressions:boolean false
        
        while (pos < len) {
            def ch:string (this.peek())
            
            if (ch == "`") {
                this.advance()
                if (hasExpressions) {
                    return (this.makeToken("TemplateLiteral" value startPos startLine startCol))
                } {
                    return (this.makeToken("TemplateLiteral" value startPos startLine startCol))
                }
            }
            
            if (ch == "\\") {
                this.advance()
                def esc:string (this.advance())
                if (esc == "n") { value = value + "\n" }
                if (esc == "t") { value = value + "\t" }
                if (esc == "r") { value = value + "\r" }
                if (esc == "\\") { value = value + "\\" }
                if (esc == "`") { value = value + "`" }
                if (esc == "$") { value = value + "$" }
            } {
                if (ch == "$") {
                    if ((this.peekAt(1)) == "{") {
                        ; Found ${, mark that we have expressions
                        hasExpressions = true
                        value = value + (this.advance())
                        value = value + (this.advance())
                    } {
                        value = value + (this.advance())
                    }
                } {
                    value = value + (this.advance())
                }
            }
        }
        return (this.makeToken("TemplateLiteral" value startPos startLine startCol))
    }

    fn readNumber:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        def value:string ""
        while (pos < len) {
            def ch:string (this.peek())
            if (this.isDigit(ch)) {
                value = value + (this.advance())
            } {
                if (ch == ".") {
                    value = value + (this.advance())
                } {
                    return (this.makeToken("Number" value startPos startLine startCol))
                }
            }
        }
        return (this.makeToken("Number" value startPos startLine startCol))
    }

    fn readIdentifier:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        def value:string ""
        while (pos < len) {
            def ch:string (this.peek())
            if (this.isAlphaNumCh(ch)) {
                value = value + (this.advance())
            } {
                return (this.makeToken((this.identType(value)) value startPos startLine startCol))
            }
        }
        return (this.makeToken((this.identType(value)) value startPos startLine startCol))
    }

    fn identType:string (value:string) {
        ; Keywords
        if (value == "var") { return "Keyword" }
        if (value == "let") { return "Keyword" }
        if (value == "const") { return "Keyword" }
        if (value == "function") { return "Keyword" }
        if (value == "return") { return "Keyword" }
        if (value == "if") { return "Keyword" }
        if (value == "else") { return "Keyword" }
        if (value == "while") { return "Keyword" }
        if (value == "for") { return "Keyword" }
        if (value == "in") { return "Keyword" }
        if (value == "of") { return "Keyword" }
        if (value == "switch") { return "Keyword" }
        if (value == "case") { return "Keyword" }
        if (value == "default") { return "Keyword" }
        if (value == "break") { return "Keyword" }
        if (value == "continue") { return "Keyword" }
        if (value == "try") { return "Keyword" }
        if (value == "catch") { return "Keyword" }
        if (value == "finally") { return "Keyword" }
        if (value == "throw") { return "Keyword" }
        if (value == "new") { return "Keyword" }
        if (value == "typeof") { return "Keyword" }
        if (value == "instanceof") { return "Keyword" }
        if (value == "this") { return "Keyword" }
        if (value == "class") { return "Keyword" }
        if (value == "extends") { return "Keyword" }
        if (value == "static") { return "Keyword" }
        if (value == "get") { return "Keyword" }
        if (value == "set") { return "Keyword" }
        if (value == "super") { return "Keyword" }
        if (value == "async") { return "Keyword" }
        if (value == "await") { return "Keyword" }
        if (value == "yield") { return "Keyword" }
        ; ES6 Modules
        if (value == "import") { return "Keyword" }
        if (value == "export") { return "Keyword" }
        if (value == "from") { return "Keyword" }
        if (value == "as") { return "Keyword" }
        if (value == "true") { return "Boolean" }
        if (value == "false") { return "Boolean" }
        if (value == "null") { return "Null" }
        return "Identifier"
    }

    fn nextToken:Token () {
        this.skipWhitespace()
        
        if (pos >= len) {
            return (this.makeToken("EOF" "" pos line col))
        }

        def ch:string (this.peek())
        def startPos:int pos
        def startLine:int line
        def startCol:int col

        ; Comments - now return tokens instead of skipping
        if (ch == "/") {
            def next:string (this.peekAt(1))
            if (next == "/") {
                return (this.readLineComment())
            }
            if (next == "*") {
                return (this.readBlockComment())
            }
        }

        ; Strings
        if (ch == "\"") { return (this.readString("\"")) }
        if (ch == "'") { return (this.readString("'")) }
        
        ; Template literals
        if (ch == "`") { return (this.readTemplateLiteral()) }

        ; Numbers
        if (this.isDigit(ch)) { return (this.readNumber()) }

        ; Identifiers and keywords
        if (this.isAlpha(ch)) { return (this.readIdentifier()) }

        ; Multi-char punctuators
        def next:string (this.peekAt(1))
        
        ; ===, !==
        if (ch == "=") {
            if (next == "=") {
                if ((this.peekAt(2)) == "=") {
                    this.advance()
                    this.advance()
                    this.advance()
                    return (this.makeToken("Punctuator" "===" startPos startLine startCol))
                }
            }
        }
        if (ch == "!") {
            if (next == "=") {
                if ((this.peekAt(2)) == "=") {
                    this.advance()
                    this.advance()
                    this.advance()
                    return (this.makeToken("Punctuator" "!==" startPos startLine startCol))
                }
            }
        }

        ; =>
        if (ch == "=") {
            if (next == ">") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "=>" startPos startLine startCol))
            }
        }
        
        ; ==, !=, <=, >=, &&, ||, ++, --
        if (ch == "=") {
            if (next == "=") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "==" startPos startLine startCol))
            }
        }
        if (ch == "!") {
            if (next == "=") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "!=" startPos startLine startCol))
            }
        }
        if (ch == "<") {
            if (next == "=") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "<=" startPos startLine startCol))
            }
        }
        if (ch == ">") {
            if (next == "=") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" ">=" startPos startLine startCol))
            }
        }
        if (ch == "&") {
            if (next == "&") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "&&" startPos startLine startCol))
            }
        }
        if (ch == "|") {
            if (next == "|") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "||" startPos startLine startCol))
            }
        }
        ; Nullish coalescing ??
        if (ch == "?") {
            if (next == "?") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "??" startPos startLine startCol))
            }
            ; Optional chaining ?.
            if (next == ".") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "?." startPos startLine startCol))
            }
        }
        if (ch == "+") {
            if (next == "+") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "++" startPos startLine startCol))
            }
        }
        if (ch == "-") {
            if (next == "-") {
                this.advance()
                this.advance()
                return (this.makeToken("Punctuator" "--" startPos startLine startCol))
            }
        }
        
        ; Spread operator ...
        if (ch == ".") {
            if (next == ".") {
                if ((this.peekAt(2)) == ".") {
                    this.advance()
                    this.advance()
                    this.advance()
                    return (this.makeToken("Punctuator" "..." startPos startLine startCol))
                }
            }
        }

        ; Single char punctuators
        this.advance()
        return (this.makeToken("Punctuator" ch startPos startLine startCol))
    }

    ; Read a regex literal starting at the current position
    ; Called by the parser when it knows we're in an expression context
    fn readRegexLiteral:Token () {
        def startPos:int pos
        def startLine:int line
        def startCol:int col
        
        ; Consume the opening /
        this.advance()
        
        def pattern:string ""
        def inCharClass:boolean false
        
        ; Read the pattern until closing /
        while (pos < len) {
            def ch:string (this.peek())
            
            ; Handle character classes - / inside [] doesn't end the regex
            if (ch == "[") {
                inCharClass = true
                pattern = pattern + (this.advance())
            } {
                if (ch == "]") {
                    inCharClass = false
                    pattern = pattern + (this.advance())
                } {
                    if (ch == "\\") {
                        ; Escape sequence - include both backslash and next char
                        pattern = pattern + (this.advance())
                        if (pos < len) {
                            pattern = pattern + (this.advance())
                        }
                    } {
                        if ((ch == "/") && (inCharClass == false)) {
                            ; End of pattern
                            this.advance()
                            break
                        } {
                            if ((ch == "\n") || (ch == "\r") || (ch == "\r\n")) {
                                ; Unterminated regex
                                return (this.makeToken("RegexLiteral" pattern startPos startLine startCol))
                            } {
                                pattern = pattern + (this.advance())
                            }
                        }
                    }
                }
            }
        }
        
        ; Read flags (g, i, m, s, u, y)
        def flags:string ""
        while (pos < len) {
            def ch:string (this.peek())
            if ((ch == "g") || (ch == "i") || (ch == "m") || (ch == "s") || (ch == "u") || (ch == "y")) {
                flags = flags + (this.advance())
            } {
                break
            }
        }
        
        ; Store pattern in value, flags in a combined format: pattern + "/" + flags
        def fullValue:string (pattern + "/" + flags)
        return (this.makeToken("RegexLiteral" fullValue startPos startLine startCol))
    }

    fn tokenize:[Token] () {
        def tokens:[Token]
        while (true) {
            def tok:Token (this.nextToken())
            push tokens tok
            if (tok.tokenType == "EOF") {
                return tokens
            }
        }
        return tokens
    }
}
