; AST Printer - outputs the AST as indented text

Import "js_ast.rgr"

class ASTPrinter {
  def indent:int 0
  
  fn getIndent:string () {
    def s ""
    def i 0
    while (i < this.indent) {
      s = s + "  "
      i = i + 1
    }
    return s
  }
  
  fn printNode:void (node:ASTNode) {
    def prefix (this.getIndent())
    
    ; Check node type and print accordingly
    def nodeType node.type
    
    if (nodeType == "Program") {
      print prefix + "Program"
      this.indent = this.indent + 1
      ; Cast and print children - we'll do dynamic dispatch
      this.printProgram(node)
      this.indent = this.indent - 1
      return
    }
    
    if (nodeType == "VariableDeclaration") {
      this.printVariableDeclaration(node)
      return
    }
    
    if (nodeType == "VariableDeclarator") {
      this.printVariableDeclarator(node)
      return
    }
    
    if (nodeType == "FunctionDeclaration") {
      this.printFunctionDeclaration(node)
      return
    }
    
    if (nodeType == "FunctionExpression") {
      this.printFunctionExpression(node)
      return
    }
    
    if (nodeType == "BlockStatement") {
      this.printBlockStatement(node)
      return
    }
    
    if (nodeType == "ReturnStatement") {
      this.printReturnStatement(node)
      return
    }
    
    if (nodeType == "IfStatement") {
      this.printIfStatement(node)
      return
    }
    
    if (nodeType == "WhileStatement") {
      this.printWhileStatement(node)
      return
    }
    
    if (nodeType == "ForStatement") {
      this.printForStatement(node)
      return
    }
    
    if (nodeType == "ExpressionStatement") {
      this.printExpressionStatement(node)
      return
    }
    
    if (nodeType == "EmptyStatement") {
      print prefix + "EmptyStatement"
      return
    }
    
    if (nodeType == "Identifier") {
      this.printIdentifier(node)
      return
    }
    
    if (nodeType == "Literal") {
      this.printLiteral(node)
      return
    }
    
    if (nodeType == "BinaryExpression") {
      this.printBinaryExpression(node)
      return
    }
    
    if (nodeType == "UnaryExpression") {
      this.printUnaryExpression(node)
      return
    }
    
    if (nodeType == "UpdateExpression") {
      this.printUpdateExpression(node)
      return
    }
    
    if (nodeType == "AssignmentExpression") {
      this.printAssignmentExpression(node)
      return
    }
    
    if (nodeType == "LogicalExpression") {
      this.printLogicalExpression(node)
      return
    }
    
    if (nodeType == "ConditionalExpression") {
      this.printConditionalExpression(node)
      return
    }
    
    if (nodeType == "CallExpression") {
      this.printCallExpression(node)
      return
    }
    
    if (nodeType == "MemberExpression") {
      this.printMemberExpression(node)
      return
    }
    
    if (nodeType == "ArrayExpression") {
      this.printArrayExpression(node)
      return
    }
    
    if (nodeType == "ObjectExpression") {
      this.printObjectExpression(node)
      return
    }
    
    if (nodeType == "Property") {
      this.printProperty(node)
      return
    }
    
    if (nodeType == "ThisExpression") {
      print prefix + "ThisExpression [" + node.line + ":" + node.col + "]"
      return
    }
    
    if (nodeType == "NewExpression") {
      this.printNewExpression(node)
      return
    }
    
    ; Fallback
    print prefix + nodeType + " [" + node.line + ":" + node.col + "]"
  }
  
  fn printProgram:void (node:ASTNode) {
    ; Need to cast - for now we access via dynamic
    ; This is a workaround since Ranger doesn't have runtime casting
  }
  
  fn printProgramBody:void (body:[ASTNode]) {
    for body stmt:ASTNode i {
      this.printNode(stmt)
    }
  }
  
  fn printVariableDeclaration:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "VariableDeclaration [" + node.line + ":" + node.col + "]"
  }
  
  fn printVariableDeclarator:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "VariableDeclarator [" + node.line + ":" + node.col + "]"
  }
  
  fn printFunctionDeclaration:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "FunctionDeclaration [" + node.line + ":" + node.col + "]"
  }
  
  fn printFunctionExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "FunctionExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printBlockStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "BlockStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printReturnStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ReturnStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printIfStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "IfStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printWhileStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "WhileStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printForStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ForStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printExpressionStatement:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ExpressionStatement [" + node.line + ":" + node.col + "]"
  }
  
  fn printIdentifier:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "Identifier [" + node.line + ":" + node.col + "]"
  }
  
  fn printLiteral:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "Literal [" + node.line + ":" + node.col + "]"
  }
  
  fn printBinaryExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "BinaryExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printUnaryExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "UnaryExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printUpdateExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "UpdateExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printAssignmentExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "AssignmentExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printLogicalExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "LogicalExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printConditionalExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ConditionalExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printCallExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "CallExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printMemberExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "MemberExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printArrayExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ArrayExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printObjectExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "ObjectExpression [" + node.line + ":" + node.col + "]"
  }
  
  fn printProperty:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "Property [" + node.line + ":" + node.col + "]"
  }
  
  fn printNewExpression:void (node:ASTNode) {
    def prefix (this.getIndent())
    print prefix + "NewExpression [" + node.line + ":" + node.col + "]"
  }
}
