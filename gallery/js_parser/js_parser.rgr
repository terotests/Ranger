; JavaScript ES5 Parser - Main entry point
Import "js_lexer.rgr"
Import "js_parser_impl.rgr"

class JSParser {
    sfn m@(main):void () {
        ; Test code with various constructs
        def code:string "var x = 123;
var y = 'hello';
function add(a, b) {
    return a + b;
}
var result = add(1, 2);
if (x > 100) {
    y = 'big';
} else {
    y = 'small';
}
var arr = [1, 2, 3];
var obj = { name: 'test', value: 42 };
"
        
        print "=== JavaScript ES5 Parser ==="
        print ""
        print "Input:"
        print code
        print ""
        
        ; Tokenize
        print "--- Tokens ---"
        def lexer:Lexer (new Lexer(code))
        def tokens:[Token] (lexer.tokenize())
        
        for tokens tok:Token i {
            def output:string (tok.tokenType + ": " + tok.value + " [" + tok.line + ":" + tok.col + "]")
            print output
        }
        
        ; Parse
        print ""
        print "--- AST ---"
        def parser:Parser (new Parser(tokens))
        def program:Program (parser.parseProgram())
        
        print "Program with " + (array_length program.body) + " statements:"
        print ""
        
        ; Print each statement in the program
        for program.body stmt:ASTNode idx {
            this.printAST(stmt 0)
        }
    }
    
    ; Simple AST printer
    sfn printAST:void (node:ASTNode depth:int) {
        def indent ""
        def i 0
        while (i < depth) {
            indent = indent + "  "
            i = i + 1
        }
        
        def nodeType node.nodeType
        def loc "[" + node.line + ":" + node.col + "]"
        
        ; Handle different node types
        if (nodeType == "VariableDeclaration") {
            print indent + "VariableDeclaration " + loc
            ; Access declarations via casting workaround
            def decl:VariableDeclaration node
            for decl.declarations declarator:VariableDeclarator di {
                this.printAST(declarator (depth + 1))
            }
            return
        }
        
        if (nodeType == "VariableDeclarator") {
            def declarator:VariableDeclarator node
            def id (unwrap declarator.id)
            print indent + "VariableDeclarator: " + id.name + " " + loc
            if (!null? declarator.varInit) {
                this.printAST((unwrap declarator.varInit) (depth + 1))
            }
            return
        }
        
        if (nodeType == "FunctionDeclaration") {
            def func:FunctionDeclaration node
            def funcId (unwrap func.id)
            def paramNames ""
            for func.params p:Identifier pi {
                if (pi > 0) {
                    paramNames = paramNames + ", "
                }
                paramNames = paramNames + p.name
            }
            print indent + "FunctionDeclaration: " + funcId.name + "(" + paramNames + ") " + loc
            if (!null? func.body) {
                this.printAST((unwrap func.body) (depth + 1))
            }
            return
        }
        
        if (nodeType == "BlockStatement") {
            def block:BlockStatement node
            print indent + "BlockStatement " + loc
            for block.body stmt:ASTNode si {
                this.printAST(stmt (depth + 1))
            }
            return
        }
        
        if (nodeType == "ReturnStatement") {
            def ret:ReturnStatement node
            print indent + "ReturnStatement " + loc
            if (!null? ret.argument) {
                this.printAST((unwrap ret.argument) (depth + 1))
            }
            return
        }
        
        if (nodeType == "IfStatement") {
            def ifStmt:IfStatement node
            print indent + "IfStatement " + loc
            print indent + "  test:"
            if (!null? ifStmt.test) {
                this.printAST((unwrap ifStmt.test) (depth + 2))
            }
            print indent + "  consequent:"
            if (!null? ifStmt.consequent) {
                this.printAST((unwrap ifStmt.consequent) (depth + 2))
            }
            if (!null? ifStmt.alternate) {
                print indent + "  alternate:"
                this.printAST((unwrap ifStmt.alternate) (depth + 2))
            }
            return
        }
        
        if (nodeType == "ExpressionStatement") {
            def exprStmt:ExpressionStatement node
            print indent + "ExpressionStatement " + loc
            if (!null? exprStmt.expression) {
                this.printAST((unwrap exprStmt.expression) (depth + 1))
            }
            return
        }
        
        if (nodeType == "AssignmentExpression") {
            def assign:AssignmentExpression node
            print indent + "AssignmentExpression: " + assign.operator + " " + loc
            print indent + "  left:"
            if (!null? assign.left) {
                this.printAST((unwrap assign.left) (depth + 2))
            }
            print indent + "  right:"
            if (!null? assign.right) {
                this.printAST((unwrap assign.right) (depth + 2))
            }
            return
        }
        
        if (nodeType == "BinaryExpression") {
            def binary:BinaryExpression node
            print indent + "BinaryExpression: " + binary.operator + " " + loc
            print indent + "  left:"
            if (!null? binary.left) {
                this.printAST((unwrap binary.left) (depth + 2))
            }
            print indent + "  right:"
            if (!null? binary.right) {
                this.printAST((unwrap binary.right) (depth + 2))
            }
            return
        }
        
        if (nodeType == "CallExpression") {
            def call:CallExpression node
            print indent + "CallExpression " + loc
            print indent + "  callee:"
            if (!null? call.callee) {
                this.printAST((unwrap call.callee) (depth + 2))
            }
            if ((array_length call.arguments) > 0) {
                print indent + "  arguments:"
                for call.arguments arg:ASTNode ai {
                    this.printAST(arg (depth + 2))
                }
            }
            return
        }
        
        if (nodeType == "Identifier") {
            def id:Identifier node
            print indent + "Identifier: " + id.name + " " + loc
            return
        }
        
        if (nodeType == "Literal") {
            def lit:Literal node
            print indent + "Literal: " + lit.value + " (" + lit.litType + ") " + loc
            return
        }
        
        if (nodeType == "ArrayExpression") {
            def arr:ArrayExpression node
            print indent + "ArrayExpression " + loc
            for arr.elements elem:ASTNode ei {
                this.printAST(elem (depth + 1))
            }
            return
        }
        
        if (nodeType == "ObjectExpression") {
            def obj:ObjectExpression node
            print indent + "ObjectExpression " + loc
            for obj.properties prop:ASTNode pi {
                this.printAST(prop (depth + 1))
            }
            return
        }
        
        if (nodeType == "Property") {
            def prop:Property node
            print indent + "Property " + loc
            print indent + "  key:"
            if (!null? prop.key) {
                this.printAST((unwrap prop.key) (depth + 2))
            }
            print indent + "  value:"
            if (!null? prop.value) {
                this.printAST((unwrap prop.value) (depth + 2))
            }
            return
        }
        
        ; Default fallback
        print indent + nodeType + " " + loc
    }
}
