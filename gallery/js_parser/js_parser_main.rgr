; JavaScript ES6 Parser - Main entry point
; Usage: node js_parser.js [options]
;   -h, --help     Show this help message
;   -d             Run built-in test suite (default demo)
;   -i <file>      Input JavaScript file to parse
;   -o <file>      Output file for pretty-printed JavaScript

Import "js_parser_core.rgr"
Import "js_printer.rgr"

class JSParserMain {
  sfn m@(main):void () {
    def argCnt:int (shell_arg_cnt)
    
    if (argCnt == 0) {
      ; No arguments - show help
      JSParserMain.showHelp()
      return
    }
    
    ; Parse command line arguments
    def inputFile:string ""
    def outputFile:string ""
    def runDefault:boolean false
    def showAst:boolean false
    
    def i:int 0
    while (i < argCnt) {
      def arg:string (shell_arg i)
      
      if ((arg == "--help") || (arg == "-h")) {
        JSParserMain.showHelp()
        return
      }
      
      if (arg == "-d") {
        runDefault = true
        i = i + 1
      } {
        if (arg == "-i") {
          i = i + 1
          if (i < argCnt) {
            inputFile = (shell_arg i)
          }
          i = i + 1
        } {
          if (arg == "-o") {
            i = i + 1
            if (i < argCnt) {
              outputFile = (shell_arg i)
            }
            i = i + 1
          } {
            if (arg == "--ast") {
              showAst = true
              i = i + 1
            } {
              ; Unknown argument - skip
              i = i + 1
            }
          }
        }
      }
    }
    
    ; Run default demo
    if (runDefault) {
      JSParserMain.runDemo()
      return
    }
    
    ; Process input/output files
    if ((strlen inputFile) > 0) {
      if ((strlen outputFile) > 0) {
        ; Parse input and write pretty-printed output
        JSParserMain.processFile(inputFile outputFile)
      } {
        ; Parse input and print AST to console
        JSParserMain.parseFile(inputFile)
      }
      return
    }
    
    ; No valid arguments
    JSParserMain.showHelp()
  }
  
  sfn showHelp:void () {
    print "JavaScript ES6 Parser and Pretty Printer"
    print ""
    print "Usage: node js_parser.js [options]"
    print ""
    print "Options:"
    print "  -h, --help     Show this help message"
    print "  -d             Run built-in demo/test suite"
    print "  -i <file>      Input JavaScript file to parse"
    print "  -o <file>      Output file for pretty-printed JavaScript"
    print "  --ast          Show AST instead of pretty-printed output (with -i)"
    print ""
    print "Examples:"
    print "  node js_parser.js -d                        Run the demo"
    print "  node js_parser.js -i script.js              Parse and show AST"
    print "  node js_parser.js -i script.js -o out.js    Parse and pretty-print to file"
    print "  node js_parser.js -i src/app.js -o dist/app.js"
  }
  
  sfn processFile:void (inputFile:string outputFile:string) {
    def codeOpt@(optional):string (read_file "." inputFile)
    
    if (null? codeOpt) {
      print "Error: Could not read file: " + inputFile
      return
    }
    
    def code:string (unwrap codeOpt)
    
    ; Tokenize
    def lexer:Lexer (new Lexer(code))
    def tokens:[Token] (lexer.tokenize())
    
    ; Parse
    def parser:SimpleParser (new SimpleParser())
    parser.initParserWithSource(tokens code)
    def program:JSNode (parser.parseProgram())
    
    ; Check for errors
    if (parser.hasErrors()) {
      print "=== Parse Errors ==="
      for parser.errors err:string ei {
        print err
      }
      print ""
    }
    
    ; Pretty print
    def printer:JSPrinter (new JSPrinter())
    def output:string (printer.print(program))
    
    ; Write to output file
    write_file "." outputFile output
    print "Parsed " + inputFile + " -> " + outputFile
    print "  " + (array_length program.children) + " statements processed"
  }
  
  sfn parseFile:void (filename:string) {
    def codeOpt@(optional):string (read_file "." filename)
    
    if (null? codeOpt) {
      print "Error: Could not read file: " + filename
      return
    }
    
    def code:string (unwrap codeOpt)
    
    ; Tokenize
    def lexer:Lexer (new Lexer(code))
    def tokens:[Token] (lexer.tokenize())
    
    ; Parse
    def parser:SimpleParser (new SimpleParser())
    parser.initParserWithSource(tokens code)
    def program:JSNode (parser.parseProgram())
    
    ; Check for errors
    if (parser.hasErrors()) {
      print "=== Parse Errors ==="
      for parser.errors err:string ei {
        print err
      }
      print ""
    }
    
    ; Print AST
    print "Program with " + (array_length program.children) + " statements:"
    print ""
    
    for program.children stmt:JSNode idx {
      ASTPrinter.printNode(stmt 0)
    }
  }
  
  sfn runDemo:void () {
    def code:string "// Variable declarations
var y = 'hello';

// Function declaration
function add(a, b) {
    return a + b;
}

// While loop
var i = 0;
while (i < 10) {
    i = i + 1;
}

// Do-while loop
do {
    i = i - 1;
} while (i > 0);

// For loop
for (var j = 0; j < 5; j = j + 1) {
    x = x + j;
}

// Switch statement
switch (x) {
    case 1:
        y = 'one';
        break;
    case 2:
        y = 'two';
        break;
    default:
        y = 'other';
}

// Try-catch-finally
try {
    throw 'error';
} catch (e) {
    y = e;
} finally {
    x = 0;
}

// If-else
if (x > 100) {
    y = 'big';
} else {
    y = 'small';
}

var arr = [1, 2, 3];
var obj = { name: 'test', value: 42 };

// Unary expressions
var negNum = -42;
var posNum = +5;
var notTrue = !true;
var notFalse = !false;
var doubleNot = !!x;
var negExpr = -(a + b);

// Logical expressions
var andResult = true && false;
var orResult = true || false;
var complexLogic = (a > 0) && (b < 10) || (c == 5);
var shortCircuit = x && y && z;
var orChain = a || b || c;

// Ternary expressions
var ternResult = x > 0 ? 'positive' : 'non-positive';
var nestedTern = a > b ? (b > c ? 'a>b>c' : 'a>b, b<=c') : 'a<=b';
var ternInExpr = 1 + (x ? 2 : 3);

// Operator precedence tests
var prec1 = 1 + 2 * 3;
var prec2 = (1 + 2) * 3;
var prec3 = 1 + 2 + 3 + 4;
var prec4 = 2 * 3 + 4 * 5;
var prec5 = 1 < 2 && 3 > 1;
var prec6 = !x && y || z;
var prec7 = a == b && c != d;
var prec8 = -x + y * -z;

// Comparison operators
var cmp1 = a == b;
var cmp2 = a != b;
var cmp3 = a < b;
var cmp4 = a <= b;
var cmp5 = a > b;
var cmp6 = a >= b;

// === ES6 Features ===

// let and const
let count = 0;
const PI = 3.14159;

// Arrow functions
const add = (a, b) => a + b;
const double = x => x * 2;
const greet = (name) => {
    return 'Hello, ' + name;
};
const multiLine = (a, b) => {
    let sum = a + b;
    return sum * 2;
};

// Template literals
let name = 'World';
let greeting = `Hello, ${name}!`;
let multi = `Line 1
Line 2`;

// Class syntax
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return this.name + ' makes a sound';
    }
    
    static create(name) {
        return new Animal(name);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    speak() {
        return this.name + ' barks';
    }
}

// Generator functions
function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

function* delegateGenerator() {
    yield* numberGenerator();
    yield 4;
}

// Async/await
async function fetchData() {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
}

async function processItems(items) {
    for (const item of items) {
        await processItem(item);
    }
}

// Async arrow functions
const asyncArrow = async (x) => {
    const result = await doSomething(x);
    return result * 2;
};

const asyncFetch = async (url) => await fetch(url);

// Async generator (ES2018)
async function* asyncGenerator() {
    yield await fetch('/api/1');
    yield await fetch('/api/2');
}

// === for...of and for...in loops ===

// For-of loop
for (const item of items) {
    console.log(item);
}

// For-in loop
for (const key in obj) {
    console.log(key);
}

// For-of with array destructuring
for (const [index, value] of entries) {
    console.log(index, value);
}

// === Spread operator ===

// Array spread
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];
const combined = [...arr1, ...arr2];

// Object spread
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 };
const merged = { ...obj1, ...obj2 };

// Spread in function call
console.log(...args);

// === Rest parameters ===

function sum(...numbers) {
    return numbers.reduce((a, b) => a + b);
}

function firstAndRest(first, ...rest) {
    return { first, rest };
}

// === Destructuring ===

// Array destructuring
const [x, y, z] = [1, 2, 3];
const [first, ...others] = arr1;
let [a, b] = [b, a];

// Object destructuring
const { name, age } = person;
const { x: newX, y: newY } = point;
const { a: { b: nested } } = deep;

// Destructuring with default (parsed as identifier for now)
const { foo, bar } = obj;

// Nested destructuring
const { user: { name: userName } } = data;
const [{ id }, { id: id2 }] = items;

// Shorthand properties
const shorthand = { x, y, z };
"
    
    print "=== JavaScript ES6 Parser ==="
    print ""
    print "Input:"
    print code
    print ""
    
    ; Tokenize
    def lexer:Lexer (new Lexer(code))
    def tokens:[Token] (lexer.tokenize())
    
    print "--- Tokens: " + (array_length tokens) + " ---"
    print ""
    
    ; Parse
    def parser:SimpleParser (new SimpleParser())
    parser.initParserWithSource(tokens code)
    def program:JSNode (parser.parseProgram())
    
    ; Check for errors
    if (parser.hasErrors()) {
      print "=== Parse Errors ==="
      for parser.errors err:string ei {
        print err
      }
      print ""
    }
    
    print "Program with " + (array_length program.children) + " statements:"
    print ""
    
    ; Print AST
    print "--- AST ---"
    for program.children stmt:JSNode idx {
      ASTPrinter.printNode(stmt 0)
    }
    
    ; Pretty print
    print ""
    print "--- Pretty Printed Output ---"
    def printer:JSPrinter (new JSPrinter())
    def output:string (printer.print(program))
    print output
  }
}
