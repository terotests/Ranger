; JavaScript ES5 Parser - Core module
; Contains JSNode, SimpleParser, and AST printing utilities

Import "js_token.rgr"
Import "js_lexer.rgr"

; Unified AST node - all node types use this
class JSNode {
  def nodeType:string ""
  def start:int 0
  def end:int 0
  def line:int 0
  def col:int 0
  
  ; Generic value fields
  def strValue:string ""      ; for identifiers, literals, operators
  def strValue2:string ""     ; secondary string (e.g., literal type)
  
  ; Child nodes
  def children:[JSNode]
  def left@(optional):JSNode
  def right@(optional):JSNode
  def test@(optional):JSNode
  def body@(optional):JSNode
  def alternate@(optional):JSNode
}

class SimpleParser {
  def tokens:[Token]
  def pos:int 0
  def currentToken@(optional):Token
  def errors:[string]
  
  fn initParser:void (toks:[Token]) {
    this.tokens = toks
    this.pos = 0
    if ((array_length toks) > 0) {
      this.currentToken = (itemAt toks 0)
    }
  }
  
  fn peek:Token () {
    return (unwrap this.currentToken)
  }
  
  fn peekType:string () {
    if (null? this.currentToken) {
      return "EOF"
    }
    def tok (unwrap this.currentToken)
    return tok.type
  }
  
  fn peekValue:string () {
    if (null? this.currentToken) {
      return ""
    }
    def tok (unwrap this.currentToken)
    return tok.value
  }
  
  fn advance:void () {
    this.pos = this.pos + 1
    if (this.pos < (array_length this.tokens)) {
      this.currentToken = (itemAt this.tokens this.pos)
    } {
      def eof (new Token())
      eof.type = "EOF"
      eof.value = ""
      this.currentToken = eof
    }
  }
  
  fn addError:void (msg:string) {
    push this.errors msg
  }
  
  fn expect:Token (expectedType:string) {
    def tok (this.peek())
    if (tok.type != expectedType) {
      def err "Parse error at line " + tok.line + ":" + tok.col + ": expected " + expectedType + " but got " + tok.type
      this.addError(err)
    }
    this.advance()
    return tok
  }
  
  fn expectValue:Token (expectedValue:string) {
    def tok (this.peek())
    if (tok.value != expectedValue) {
      def err "Parse error at line " + tok.line + ":" + tok.col + ": expected '" + expectedValue + "' but got '" + tok.value + "'"
      this.addError(err)
    }
    this.advance()
    return tok
  }
  
  fn isAtEnd:boolean () {
    def t (this.peekType())
    return (t == "EOF")
  }
  
  fn matchType:boolean (tokenType:string) {
    def t (this.peekType())
    return (t == tokenType)
  }
  
  fn matchValue:boolean (value:string) {
    def v (this.peekValue())
    return (v == value)
  }
  
  fn hasErrors:boolean () {
    return ((array_length this.errors) > 0)
  }
  
  ; === Parse Program ===
  
  fn parseProgram:JSNode () {
    def prog (new JSNode())
    prog.nodeType = "Program"
    
    while ((this.isAtEnd()) == false) {
      def stmt (this.parseStatement())
      push prog.children stmt
    }
    
    return prog
  }
  
  ; === Parse Statement ===
  
  fn parseStatement:JSNode () {
    def tokVal (this.peekValue())
    
    if (tokVal == "var") {
      return (this.parseVarDecl())
    }
    
    if (tokVal == "let") {
      return (this.parseLetDecl())
    }
    
    if (tokVal == "const") {
      return (this.parseConstDecl())
    }
    
    if (tokVal == "function") {
      return (this.parseFuncDecl())
    }
    
    if (tokVal == "async") {
      return (this.parseAsyncFuncDecl())
    }
    
    if (tokVal == "class") {
      return (this.parseClass())
    }
    
    if (tokVal == "return") {
      return (this.parseReturn())
    }
    
    if (tokVal == "if") {
      return (this.parseIf())
    }
    
    if (tokVal == "while") {
      return (this.parseWhile())
    }
    
    if (tokVal == "do") {
      return (this.parseDoWhile())
    }
    
    if (tokVal == "for") {
      return (this.parseFor())
    }
    
    if (tokVal == "switch") {
      return (this.parseSwitch())
    }
    
    if (tokVal == "try") {
      return (this.parseTry())
    }
    
    if (tokVal == "throw") {
      return (this.parseThrow())
    }
    
    if (tokVal == "break") {
      return (this.parseBreak())
    }
    
    if (tokVal == "continue") {
      return (this.parseContinue())
    }
    
    if (tokVal == "{") {
      return (this.parseBlock())
    }
    
    if (tokVal == ";") {
      this.advance()
      def empty (new JSNode())
      empty.nodeType = "EmptyStatement"
      return empty
    }
    
    ; Expression statement
    return (this.parseExprStmt())
  }
  
  ; === Variable Declaration ===
  
  fn parseVarDecl:JSNode () {
    def decl (new JSNode())
    decl.nodeType = "VariableDeclaration"
    def startTok (this.peek())
    decl.start = startTok.start
    decl.line = startTok.line
    decl.col = startTok.col
    
    this.expectValue("var")
    
    def first true
    while (first || (this.matchValue(","))) {
      if (first == false) {
        this.advance()
      }
      first = false
      
      def declarator (new JSNode())
      declarator.nodeType = "VariableDeclarator"
      
      def idTok (this.expect("Identifier"))
      def id (new JSNode())
      id.nodeType = "Identifier"
      id.strValue = idTok.value
      id.start = idTok.start
      id.line = idTok.line
      id.col = idTok.col
      declarator.left = id
      declarator.start = idTok.start
      declarator.line = idTok.line
      declarator.col = idTok.col
      
      if (this.matchValue("=")) {
        this.advance()
        def initExpr (this.parseAssignment())
        declarator.right = initExpr
      }
      
      push decl.children declarator
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return decl
  }
  
  ; === Let Declaration (ES6) ===
  
  fn parseLetDecl:JSNode () {
    def decl (new JSNode())
    decl.nodeType = "VariableDeclaration"
    decl.strValue = "let"
    def startTok (this.peek())
    decl.start = startTok.start
    decl.line = startTok.line
    decl.col = startTok.col
    
    this.expectValue("let")
    
    def first true
    while (first || (this.matchValue(","))) {
      if (first == false) {
        this.advance()
      }
      first = false
      
      def declarator (new JSNode())
      declarator.nodeType = "VariableDeclarator"
      
      def idTok (this.expect("Identifier"))
      def id (new JSNode())
      id.nodeType = "Identifier"
      id.strValue = idTok.value
      id.start = idTok.start
      id.line = idTok.line
      id.col = idTok.col
      declarator.left = id
      declarator.start = idTok.start
      declarator.line = idTok.line
      declarator.col = idTok.col
      
      if (this.matchValue("=")) {
        this.advance()
        def initExpr (this.parseAssignment())
        declarator.right = initExpr
      }
      
      push decl.children declarator
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return decl
  }
  
  ; === Const Declaration (ES6) ===
  
  fn parseConstDecl:JSNode () {
    def decl (new JSNode())
    decl.nodeType = "VariableDeclaration"
    decl.strValue = "const"
    def startTok (this.peek())
    decl.start = startTok.start
    decl.line = startTok.line
    decl.col = startTok.col
    
    this.expectValue("const")
    
    def first true
    while (first || (this.matchValue(","))) {
      if (first == false) {
        this.advance()
      }
      first = false
      
      def declarator (new JSNode())
      declarator.nodeType = "VariableDeclarator"
      
      def idTok (this.expect("Identifier"))
      def id (new JSNode())
      id.nodeType = "Identifier"
      id.strValue = idTok.value
      id.start = idTok.start
      id.line = idTok.line
      id.col = idTok.col
      declarator.left = id
      declarator.start = idTok.start
      declarator.line = idTok.line
      declarator.col = idTok.col
      
      if (this.matchValue("=")) {
        this.advance()
        def initExpr (this.parseAssignment())
        declarator.right = initExpr
      }
      
      push decl.children declarator
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return decl
  }
  
  ; === Function Declaration ===
  
  fn parseFuncDecl:JSNode () {
    def func (new JSNode())
    func.nodeType = "FunctionDeclaration"
    def startTok (this.peek())
    func.start = startTok.start
    func.line = startTok.line
    func.col = startTok.col
    
    this.expectValue("function")
    
    ; Check for generator: function*
    if (this.matchValue("*")) {
      func.strValue2 = "generator"
      this.advance()
    }
    
    def idTok (this.expect("Identifier"))
    func.strValue = idTok.value
    
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length func.children) > 0) {
        this.expectValue(",")
      }
      if ((this.matchValue(")")) || (this.isAtEnd())) {
        break
      }
      def paramTok (this.expect("Identifier"))
      def param (new JSNode())
      param.nodeType = "Identifier"
      param.strValue = paramTok.value
      param.start = paramTok.start
      param.line = paramTok.line
      param.col = paramTok.col
      push func.children param
    }
    this.expectValue(")")
    
    def body (this.parseBlock())
    func.body = body
    
    return func
  }
  
  ; === Async Function Declaration (ES6+) ===
  
  fn parseAsyncFuncDecl:JSNode () {
    def func (new JSNode())
    func.nodeType = "FunctionDeclaration"
    def startTok (this.peek())
    func.start = startTok.start
    func.line = startTok.line
    func.col = startTok.col
    func.strValue2 = "async"
    
    this.expectValue("async")
    this.expectValue("function")
    
    ; Check for async generator: async function*
    if (this.matchValue("*")) {
      func.strValue2 = "async-generator"
      this.advance()
    }
    
    def idTok (this.expect("Identifier"))
    func.strValue = idTok.value
    
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length func.children) > 0) {
        this.expectValue(",")
      }
      if ((this.matchValue(")")) || (this.isAtEnd())) {
        break
      }
      def paramTok (this.expect("Identifier"))
      def param (new JSNode())
      param.nodeType = "Identifier"
      param.strValue = paramTok.value
      param.start = paramTok.start
      param.line = paramTok.line
      param.col = paramTok.col
      push func.children param
    }
    this.expectValue(")")
    
    def body (this.parseBlock())
    func.body = body
    
    return func
  }
  
  ; === Class Declaration (ES6) ===
  
  fn parseClass:JSNode () {
    def classNode (new JSNode())
    classNode.nodeType = "ClassDeclaration"
    def startTok (this.peek())
    classNode.start = startTok.start
    classNode.line = startTok.line
    classNode.col = startTok.col
    
    this.expectValue("class")
    
    ; Class name
    def idTok (this.expect("Identifier"))
    classNode.strValue = idTok.value
    
    ; Optional extends
    if (this.matchValue("extends")) {
      this.advance()
      def superTok (this.expect("Identifier"))
      def superClass (new JSNode())
      superClass.nodeType = "Identifier"
      superClass.strValue = superTok.value
      superClass.start = superTok.start
      superClass.line = superTok.line
      superClass.col = superTok.col
      classNode.left = superClass
    }
    
    ; Class body
    def body (new JSNode())
    body.nodeType = "ClassBody"
    def bodyStart (this.peek())
    body.start = bodyStart.start
    body.line = bodyStart.line
    body.col = bodyStart.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def method (this.parseClassMethod())
      push body.children method
    }
    
    this.expectValue("}")
    
    classNode.body = body
    return classNode
  }
  
  fn parseClassMethod:JSNode () {
    def method (new JSNode())
    method.nodeType = "MethodDefinition"
    def startTok (this.peek())
    method.start = startTok.start
    method.line = startTok.line
    method.col = startTok.col
    
    ; Check for static keyword
    def isStatic:boolean false
    if (this.matchValue("static")) {
      isStatic = true
      method.strValue2 = "static"
      this.advance()
    }
    
    ; Check for getter/setter
    def kind:string "method"
    if (this.matchValue("get")) {
      def nextTok (this.peekAt(1))
      if (nextTok != "(") {
        kind = "get"
        this.advance()
      }
    }
    if (this.matchValue("set")) {
      def nextTok (this.peekAt(1))
      if (nextTok != "(") {
        kind = "set"
        this.advance()
      }
    }
    
    ; Method name
    def nameTok (this.expect("Identifier"))
    method.strValue = nameTok.value
    
    if (nameTok.value == "constructor") {
      kind = "constructor"
    }
    
    ; Parse function
    def func (new JSNode())
    func.nodeType = "FunctionExpression"
    func.start = nameTok.start
    func.line = nameTok.line
    func.col = nameTok.col
    
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length func.children) > 0) {
        this.expectValue(",")
      }
      if ((this.matchValue(")")) || (this.isAtEnd())) {
        break
      }
      def paramTok (this.expect("Identifier"))
      def param (new JSNode())
      param.nodeType = "Identifier"
      param.strValue = paramTok.value
      param.start = paramTok.start
      param.line = paramTok.line
      param.col = paramTok.col
      push func.children param
    }
    this.expectValue(")")
    
    def funcBody (this.parseBlock())
    func.body = funcBody
    
    method.body = func
    return method
  }
  
  ; Helper to peek at next token value
  fn peekAt:string (offset:int) {
    def targetPos (this.pos + offset)
    if (targetPos >= (array_length this.tokens)) {
      return ""
    }
    def tok (itemAt this.tokens targetPos)
    return tok.value
  }
  
  ; === Block Statement ===
  
  fn parseBlock:JSNode () {
    def block (new JSNode())
    block.nodeType = "BlockStatement"
    def startTok (this.peek())
    block.start = startTok.start
    block.line = startTok.line
    block.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def stmt (this.parseStatement())
      push block.children stmt
    }
    
    this.expectValue("}")
    
    return block
  }
  
  ; === Return Statement ===
  
  fn parseReturn:JSNode () {
    def ret (new JSNode())
    ret.nodeType = "ReturnStatement"
    def startTok (this.peek())
    ret.start = startTok.start
    ret.line = startTok.line
    ret.col = startTok.col
    
    this.expectValue("return")
    
    if (((this.matchValue(";")) == false) && ((this.isAtEnd()) == false)) {
      def arg (this.parseExpr())
      ret.left = arg
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return ret
  }
  
  ; === If Statement ===
  
  fn parseIf:JSNode () {
    def ifStmt (new JSNode())
    ifStmt.nodeType = "IfStatement"
    def startTok (this.peek())
    ifStmt.start = startTok.start
    ifStmt.line = startTok.line
    ifStmt.col = startTok.col
    
    this.expectValue("if")
    this.expectValue("(")
    def test (this.parseExpr())
    ifStmt.test = test
    this.expectValue(")")
    
    def consequent (this.parseStatement())
    ifStmt.body = consequent
    
    if (this.matchValue("else")) {
      this.advance()
      def alt (this.parseStatement())
      ifStmt.alternate = alt
    }
    
    return ifStmt
  }
  
  ; === While Statement ===
  
  fn parseWhile:JSNode () {
    def whileStmt (new JSNode())
    whileStmt.nodeType = "WhileStatement"
    def startTok (this.peek())
    whileStmt.start = startTok.start
    whileStmt.line = startTok.line
    whileStmt.col = startTok.col
    
    this.expectValue("while")
    this.expectValue("(")
    def test (this.parseExpr())
    whileStmt.test = test
    this.expectValue(")")
    
    def body (this.parseStatement())
    whileStmt.body = body
    
    return whileStmt
  }
  
  ; === Do-While Statement ===
  
  fn parseDoWhile:JSNode () {
    def doWhileStmt (new JSNode())
    doWhileStmt.nodeType = "DoWhileStatement"
    def startTok (this.peek())
    doWhileStmt.start = startTok.start
    doWhileStmt.line = startTok.line
    doWhileStmt.col = startTok.col
    
    this.expectValue("do")
    def body (this.parseStatement())
    doWhileStmt.body = body
    
    this.expectValue("while")
    this.expectValue("(")
    def test (this.parseExpr())
    doWhileStmt.test = test
    this.expectValue(")")
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return doWhileStmt
  }
  
  ; === For Statement ===
  
  fn parseFor:JSNode () {
    def forStmt (new JSNode())
    forStmt.nodeType = "ForStatement"
    def startTok (this.peek())
    forStmt.start = startTok.start
    forStmt.line = startTok.line
    forStmt.col = startTok.col
    
    this.expectValue("for")
    this.expectValue("(")
    
    ; Init part
    if ((this.matchValue(";")) == false) {
      if (this.matchValue("var")) {
        def varDecl (this.parseVarDecl())
        forStmt.left = varDecl
      } {
        def initExpr (this.parseExpr())
        forStmt.left = initExpr
        if (this.matchValue(";")) {
          this.advance()
        }
      }
    } {
      this.advance()
    }
    
    ; Test part
    if ((this.matchValue(";")) == false) {
      def test (this.parseExpr())
      forStmt.test = test
    }
    if (this.matchValue(";")) {
      this.advance()
    }
    
    ; Update part
    if ((this.matchValue(")")) == false) {
      def update (this.parseExpr())
      forStmt.right = update
    }
    
    this.expectValue(")")
    
    def body (this.parseStatement())
    forStmt.body = body
    
    return forStmt
  }
  
  ; === Switch Statement ===
  
  fn parseSwitch:JSNode () {
    def switchStmt (new JSNode())
    switchStmt.nodeType = "SwitchStatement"
    def startTok (this.peek())
    switchStmt.start = startTok.start
    switchStmt.line = startTok.line
    switchStmt.col = startTok.col
    
    this.expectValue("switch")
    this.expectValue("(")
    def discriminant (this.parseExpr())
    switchStmt.test = discriminant
    this.expectValue(")")
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def caseNode (new JSNode())
      
      if (this.matchValue("case")) {
        caseNode.nodeType = "SwitchCase"
        def caseTok (this.peek())
        caseNode.start = caseTok.start
        caseNode.line = caseTok.line
        caseNode.col = caseTok.col
        
        this.advance()
        def testExpr (this.parseExpr())
        caseNode.test = testExpr
        this.expectValue(":")
        
        ; Parse case body statements
        while (((this.matchValue("case")) == false) && ((this.matchValue("default")) == false) && ((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
          def stmt (this.parseStatement())
          push caseNode.children stmt
        }
        
        push switchStmt.children caseNode
      } {
        if (this.matchValue("default")) {
          caseNode.nodeType = "SwitchCase"
          caseNode.strValue = "default"
          def defTok (this.peek())
          caseNode.start = defTok.start
          caseNode.line = defTok.line
          caseNode.col = defTok.col
          
          this.advance()
          this.expectValue(":")
          
          ; Parse default body statements
          while (((this.matchValue("case")) == false) && ((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
            def stmt (this.parseStatement())
            push caseNode.children stmt
          }
          
          push switchStmt.children caseNode
        } {
          ; Unexpected token, skip
          this.advance()
        }
      }
    }
    
    this.expectValue("}")
    
    return switchStmt
  }
  
  ; === Try Statement ===
  
  fn parseTry:JSNode () {
    def tryStmt (new JSNode())
    tryStmt.nodeType = "TryStatement"
    def startTok (this.peek())
    tryStmt.start = startTok.start
    tryStmt.line = startTok.line
    tryStmt.col = startTok.col
    
    this.expectValue("try")
    def block (this.parseBlock())
    tryStmt.body = block
    
    ; Catch clause
    if (this.matchValue("catch")) {
      def catchNode (new JSNode())
      catchNode.nodeType = "CatchClause"
      def catchTok (this.peek())
      catchNode.start = catchTok.start
      catchNode.line = catchTok.line
      catchNode.col = catchTok.col
      
      this.advance()
      this.expectValue("(")
      def paramTok (this.expect("Identifier"))
      catchNode.strValue = paramTok.value
      this.expectValue(")")
      
      def catchBody (this.parseBlock())
      catchNode.body = catchBody
      
      tryStmt.left = catchNode
    }
    
    ; Finally clause
    if (this.matchValue("finally")) {
      this.advance()
      def finallyBlock (this.parseBlock())
      tryStmt.right = finallyBlock
    }
    
    return tryStmt
  }
  
  ; === Throw Statement ===
  
  fn parseThrow:JSNode () {
    def throwStmt (new JSNode())
    throwStmt.nodeType = "ThrowStatement"
    def startTok (this.peek())
    throwStmt.start = startTok.start
    throwStmt.line = startTok.line
    throwStmt.col = startTok.col
    
    this.expectValue("throw")
    def arg (this.parseExpr())
    throwStmt.left = arg
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return throwStmt
  }
  
  ; === Break Statement ===
  
  fn parseBreak:JSNode () {
    def breakStmt (new JSNode())
    breakStmt.nodeType = "BreakStatement"
    def startTok (this.peek())
    breakStmt.start = startTok.start
    breakStmt.line = startTok.line
    breakStmt.col = startTok.col
    
    this.expectValue("break")
    
    ; Optional label
    if (this.matchType("Identifier")) {
      def labelTok (this.peek())
      breakStmt.strValue = labelTok.value
      this.advance()
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return breakStmt
  }
  
  ; === Continue Statement ===
  
  fn parseContinue:JSNode () {
    def contStmt (new JSNode())
    contStmt.nodeType = "ContinueStatement"
    def startTok (this.peek())
    contStmt.start = startTok.start
    contStmt.line = startTok.line
    contStmt.col = startTok.col
    
    this.expectValue("continue")
    
    ; Optional label
    if (this.matchType("Identifier")) {
      def labelTok (this.peek())
      contStmt.strValue = labelTok.value
      this.advance()
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return contStmt
  }
  
  ; === Expression Statement ===
  
  fn parseExprStmt:JSNode () {
    def stmt (new JSNode())
    stmt.nodeType = "ExpressionStatement"
    def startTok (this.peek())
    stmt.start = startTok.start
    stmt.line = startTok.line
    stmt.col = startTok.col
    
    def expr (this.parseExpr())
    stmt.left = expr
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return stmt
  }
  
  ; === Expression Parsing ===
  
  fn parseExpr:JSNode () {
    return (this.parseAssignment())
  }
  
  fn parseAssignment:JSNode () {
    def left (this.parseTernary())
    
    def tokVal (this.peekValue())
    if (tokVal == "=") {
      def opTok (this.peek())
      this.advance()
      def right (this.parseAssignment())
      
      def assign (new JSNode())
      assign.nodeType = "AssignmentExpression"
      assign.strValue = opTok.value
      assign.left = left
      assign.right = right
      assign.start = left.start
      assign.line = left.line
      assign.col = left.col
      return assign
    }
    
    return left
  }
  
  fn parseTernary:JSNode () {
    def condition (this.parseLogicalOr())
    
    if (this.matchValue("?")) {
      this.advance()
      def consequent (this.parseAssignment())
      this.expectValue(":")
      def alternate (this.parseAssignment())
      
      def ternary (new JSNode())
      ternary.nodeType = "ConditionalExpression"
      ternary.left = condition
      ternary.body = consequent
      ternary.right = alternate
      ternary.start = condition.start
      ternary.line = condition.line
      ternary.col = condition.col
      return ternary
    }
    
    return condition
  }
  
  fn parseLogicalOr:JSNode () {
    def left (this.parseLogicalAnd())
    
    while (this.matchValue("||")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseLogicalAnd())
      
      def binary (new JSNode())
      binary.nodeType = "LogicalExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
    }
    
    return left
  }
  
  fn parseLogicalAnd:JSNode () {
    def left (this.parseEquality())
    
    while (this.matchValue("&&")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseEquality())
      
      def binary (new JSNode())
      binary.nodeType = "LogicalExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
    }
    
    return left
  }
  
  fn parseEquality:JSNode () {
    def left (this.parseComparison())
    
    def tokVal (this.peekValue())
    while ((tokVal == "==") || (tokVal == "!=") || (tokVal == "===") || (tokVal == "!==")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseComparison())
      
      def binary (new JSNode())
      binary.nodeType = "BinaryExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  fn parseComparison:JSNode () {
    def left (this.parseAdditive())
    
    def tokVal (this.peekValue())
    while ((tokVal == "<") || (tokVal == ">") || (tokVal == "<=") || (tokVal == ">=")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseAdditive())
      
      def binary (new JSNode())
      binary.nodeType = "BinaryExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  fn parseAdditive:JSNode () {
    def left (this.parseMultiplicative())
    
    def tokVal (this.peekValue())
    while ((tokVal == "+") || (tokVal == "-")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseMultiplicative())
      
      def binary (new JSNode())
      binary.nodeType = "BinaryExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  fn parseMultiplicative:JSNode () {
    def left (this.parseUnary())
    
    def tokVal (this.peekValue())
    while ((tokVal == "*") || (tokVal == "/") || (tokVal == "%")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseUnary())
      
      def binary (new JSNode())
      binary.nodeType = "BinaryExpression"
      binary.strValue = opTok.value
      binary.left = left
      binary.right = right
      binary.start = left.start
      binary.line = left.line
      binary.col = left.col
      left = binary
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  fn parseUnary:JSNode () {
    def tokVal (this.peekValue())
    
    if ((tokVal == "!") || (tokVal == "-") || (tokVal == "+")) {
      def opTok (this.peek())
      this.advance()
      def arg (this.parseUnary())
      
      def unary (new JSNode())
      unary.nodeType = "UnaryExpression"
      unary.strValue = opTok.value
      unary.left = arg
      unary.start = opTok.start
      unary.line = opTok.line
      unary.col = opTok.col
      return unary
    }
    
    ; yield expression (generator)
    if (tokVal == "yield") {
      def yieldTok (this.peek())
      this.advance()
      
      def yieldExpr (new JSNode())
      yieldExpr.nodeType = "YieldExpression"
      yieldExpr.start = yieldTok.start
      yieldExpr.line = yieldTok.line
      yieldExpr.col = yieldTok.col
      
      ; Check for yield*
      if (this.matchValue("*")) {
        yieldExpr.strValue = "delegate"
        this.advance()
      }
      
      ; yield can have optional argument
      def nextVal (this.peekValue())
      if ((nextVal != ";") && (nextVal != "}") && (nextVal != ",") && (nextVal != ")")) {
        def arg (this.parseAssignment())
        yieldExpr.left = arg
      }
      
      return yieldExpr
    }
    
    ; await expression (async)
    if (tokVal == "await") {
      def awaitTok (this.peek())
      this.advance()
      def arg (this.parseUnary())
      
      def awaitExpr (new JSNode())
      awaitExpr.nodeType = "AwaitExpression"
      awaitExpr.left = arg
      awaitExpr.start = awaitTok.start
      awaitExpr.line = awaitTok.line
      awaitExpr.col = awaitTok.col
      return awaitExpr
    }
    
    return (this.parseCallMember())
  }
  
  fn parseCallMember:JSNode () {
    def object (this.parsePrimary())
    
    def cont true
    while (cont) {
      def tokVal (this.peekValue())
      
      if (tokVal == ".") {
        this.advance()
        def propTok (this.expect("Identifier"))
        
        def member (new JSNode())
        member.nodeType = "MemberExpression"
        member.left = object
        member.strValue = propTok.value
        member.strValue2 = "dot"
        member.start = object.start
        member.line = object.line
        member.col = object.col
        object = member
      } {
        if (tokVal == "[") {
          this.advance()
          def propExpr (this.parseExpr())
          this.expectValue("]")
          
          def member (new JSNode())
          member.nodeType = "MemberExpression"
          member.left = object
          member.right = propExpr
          member.strValue2 = "bracket"
          member.start = object.start
          member.line = object.line
          member.col = object.col
          object = member
        } {
          if (tokVal == "(") {
            this.advance()
            
            def call (new JSNode())
            call.nodeType = "CallExpression"
            call.left = object
            call.start = object.start
            call.line = object.line
            call.col = object.col
            
            while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
              if ((array_length call.children) > 0) {
                this.expectValue(",")
              }
              if ((this.matchValue(")")) || (this.isAtEnd())) {
                break
              }
              def arg (this.parseAssignment())
              push call.children arg
            }
            this.expectValue(")")
            
            object = call
          } {
            cont = false
          }
        }
      }
    }
    
    return object
  }
  
  fn parsePrimary:JSNode () {
    def tokType (this.peekType())
    def tokVal (this.peekValue())
    def tok (this.peek())
    
    ; Check for async arrow function: async () => ... or async x => ...
    if (tokVal == "async") {
      def nextVal (this.peekAt(1))
      def nextNext (this.peekAt(2))
      ; async (params) => ... or async x => ...
      if ((nextVal == "(") || (nextNext == "=>")) {
        return (this.parseAsyncArrowFunction())
      }
    }
    
    ; Check for arrow function: identifier => ...
    if (tokType == "Identifier") {
      def nextVal (this.peekAt(1))
      if (nextVal == "=>") {
        return (this.parseArrowFunction())
      }
      this.advance()
      def id (new JSNode())
      id.nodeType = "Identifier"
      id.strValue = tok.value
      id.start = tok.start
      id.end = tok.end
      id.line = tok.line
      id.col = tok.col
      return id
    }
    
    if (tokType == "Number") {
      this.advance()
      def lit (new JSNode())
      lit.nodeType = "Literal"
      lit.strValue = tok.value
      lit.strValue2 = "number"
      lit.start = tok.start
      lit.end = tok.end
      lit.line = tok.line
      lit.col = tok.col
      return lit
    }
    
    if (tokType == "String") {
      this.advance()
      def lit (new JSNode())
      lit.nodeType = "Literal"
      lit.strValue = tok.value
      lit.strValue2 = "string"
      lit.start = tok.start
      lit.end = tok.end
      lit.line = tok.line
      lit.col = tok.col
      return lit
    }
    
    if ((tokVal == "true") || (tokVal == "false")) {
      this.advance()
      def lit (new JSNode())
      lit.nodeType = "Literal"
      lit.strValue = tok.value
      lit.strValue2 = "boolean"
      lit.start = tok.start
      lit.end = tok.end
      lit.line = tok.line
      lit.col = tok.col
      return lit
    }
    
    if (tokVal == "null") {
      this.advance()
      def lit (new JSNode())
      lit.nodeType = "Literal"
      lit.strValue = "null"
      lit.strValue2 = "null"
      lit.start = tok.start
      lit.end = tok.end
      lit.line = tok.line
      lit.col = tok.col
      return lit
    }
    
    ; Template literal
    if (tokType == "TemplateLiteral") {
      this.advance()
      def tmpl (new JSNode())
      tmpl.nodeType = "TemplateLiteral"
      tmpl.strValue = tok.value
      tmpl.start = tok.start
      tmpl.end = tok.end
      tmpl.line = tok.line
      tmpl.col = tok.col
      return tmpl
    }
    
    if (tokVal == "(") {
      ; Could be arrow function: (a, b) => ... or grouped expression
      if (this.isArrowFunction()) {
        return (this.parseArrowFunction())
      }
      this.advance()
      def expr (this.parseExpr())
      this.expectValue(")")
      return expr
    }
    
    if (tokVal == "[") {
      return (this.parseArray())
    }
    
    if (tokVal == "{") {
      return (this.parseObject())
    }
    
    ; Fallback
    this.advance()
    def fallback (new JSNode())
    fallback.nodeType = "Identifier"
    fallback.strValue = tok.value
    fallback.start = tok.start
    fallback.end = tok.end
    fallback.line = tok.line
    fallback.col = tok.col
    return fallback
  }
  
  fn parseArray:JSNode () {
    def arr (new JSNode())
    arr.nodeType = "ArrayExpression"
    def startTok (this.peek())
    arr.start = startTok.start
    arr.line = startTok.line
    arr.col = startTok.col
    
    this.expectValue("[")
    
    while (((this.matchValue("]")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length arr.children) > 0) {
        this.expectValue(",")
      }
      if ((this.matchValue("]")) || (this.isAtEnd())) {
        break
      }
      def elem (this.parseAssignment())
      push arr.children elem
    }
    
    this.expectValue("]")
    
    return arr
  }
  
  fn parseObject:JSNode () {
    def obj (new JSNode())
    obj.nodeType = "ObjectExpression"
    def startTok (this.peek())
    obj.start = startTok.start
    obj.line = startTok.line
    obj.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length obj.children) > 0) {
        this.expectValue(",")
      }
      if ((this.matchValue("}")) || (this.isAtEnd())) {
        break
      }
      
      def prop (new JSNode())
      prop.nodeType = "Property"
      
      def keyTok (this.peek())
      def keyType (this.peekType())
      
      if ((keyType == "Identifier") || (keyType == "String") || (keyType == "Number")) {
        this.advance()
        prop.strValue = keyTok.value
        prop.start = keyTok.start
        prop.line = keyTok.line
        prop.col = keyTok.col
        
        this.expectValue(":")
        def val (this.parseAssignment())
        prop.left = val
        push obj.children prop
      } {
        ; Unexpected token in object - skip it to avoid infinite loop
        def err "Parse error at line " + keyTok.line + ":" + keyTok.col + ": unexpected token '" + keyTok.value + "' in object literal"
        this.addError(err)
        this.advance()
      }
    }
    
    this.expectValue("}")
    
    return obj
  }
  
  ; === Arrow Function Parsing (ES6) ===
  
  ; Check if current position starts an arrow function
  fn isArrowFunction:boolean () {
    if ((this.matchValue("(")) == false) {
      return false
    }
    ; Scan ahead to find matching ) and check if followed by =>
    def depth 1
    def scanPos 1
    while (depth > 0) {
      def scanVal (this.peekAt(scanPos))
      if (scanVal == "") {
        return false
      }
      if (scanVal == "(") {
        depth = depth + 1
      }
      if (scanVal == ")") {
        depth = depth - 1
      }
      scanPos = scanPos + 1
    }
    ; Check if token after closing ) is =>
    def afterParen (this.peekAt(scanPos))
    return (afterParen == "=>")
  }
  
  fn parseArrowFunction:JSNode () {
    def arrow (new JSNode())
    arrow.nodeType = "ArrowFunctionExpression"
    def startTok (this.peek())
    arrow.start = startTok.start
    arrow.line = startTok.line
    arrow.col = startTok.col
    
    ; Parse parameters
    if (this.matchValue("(")) {
      ; Multiple parameters: (a, b) => ...
      this.advance()
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length arrow.children) > 0) {
          this.expectValue(",")
        }
        if ((this.matchValue(")")) || (this.isAtEnd())) {
          break
        }
        def paramTok (this.expect("Identifier"))
        def param (new JSNode())
        param.nodeType = "Identifier"
        param.strValue = paramTok.value
        param.start = paramTok.start
        param.line = paramTok.line
        param.col = paramTok.col
        push arrow.children param
      }
      this.expectValue(")")
    } {
      ; Single parameter: x => ...
      def paramTok (this.expect("Identifier"))
      def param (new JSNode())
      param.nodeType = "Identifier"
      param.strValue = paramTok.value
      param.start = paramTok.start
      param.line = paramTok.line
      param.col = paramTok.col
      push arrow.children param
    }
    
    ; Expect =>
    this.expectValue("=>")
    
    ; Parse body - could be expression or block
    if (this.matchValue("{")) {
      def body (this.parseBlock())
      arrow.body = body
    } {
      ; Expression body
      def expr (this.parseAssignment())
      arrow.body = expr
    }
    
    return arrow
  }
  
  ; === Async Arrow Function (ES6+) ===
  
  fn parseAsyncArrowFunction:JSNode () {
    def arrow (new JSNode())
    arrow.nodeType = "ArrowFunctionExpression"
    arrow.strValue2 = "async"
    def startTok (this.peek())
    arrow.start = startTok.start
    arrow.line = startTok.line
    arrow.col = startTok.col
    
    this.expectValue("async")
    
    ; Parse parameters
    if (this.matchValue("(")) {
      ; Multiple parameters: async (a, b) => ...
      this.advance()
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length arrow.children) > 0) {
          this.expectValue(",")
        }
        if ((this.matchValue(")")) || (this.isAtEnd())) {
          break
        }
        def paramTok (this.expect("Identifier"))
        def param (new JSNode())
        param.nodeType = "Identifier"
        param.strValue = paramTok.value
        param.start = paramTok.start
        param.line = paramTok.line
        param.col = paramTok.col
        push arrow.children param
      }
      this.expectValue(")")
    } {
      ; Single parameter: async x => ...
      def paramTok (this.expect("Identifier"))
      def param (new JSNode())
      param.nodeType = "Identifier"
      param.strValue = paramTok.value
      param.start = paramTok.start
      param.line = paramTok.line
      param.col = paramTok.col
      push arrow.children param
    }
    
    ; Expect =>
    this.expectValue("=>")
    
    ; Parse body - could be expression or block
    if (this.matchValue("{")) {
      def body (this.parseBlock())
      arrow.body = body
    } {
      ; Expression body
      def expr (this.parseAssignment())
      arrow.body = expr
    }
    
    return arrow
  }
}

; AST Printer utility class
class ASTPrinter {
  sfn printNode:void (node:JSNode depth:int) {
    def indent ""
    def i 0
    while (i < depth) {
      indent = indent + "  "
      i = i + 1
    }
    
    def nodeType node.nodeType
    def loc "[" + node.line + ":" + node.col + "]"
    
    if (nodeType == "VariableDeclaration") {
      def kind node.strValue
      if ((strlen kind) > 0) {
        print indent + "VariableDeclaration (" + kind + ") " + loc
      } {
        print indent + "VariableDeclaration " + loc
      }
      for node.children child:JSNode ci {
        ASTPrinter.printNode(child (depth + 1))
      }
      return
    }
    
    if (nodeType == "VariableDeclarator") {
      if (!null? node.left) {
        def id (unwrap node.left)
        print indent + "VariableDeclarator: " + id.strValue + " " + loc
      } {
        print indent + "VariableDeclarator " + loc
      }
      if (!null? node.right) {
        ASTPrinter.printNode((unwrap node.right) (depth + 1))
      }
      return
    }
    
    if (nodeType == "FunctionDeclaration") {
      def params ""
      for node.children p:JSNode pi {
        if (pi > 0) {
          params = params + ", "
        }
        params = params + p.strValue
      }
      def kind node.strValue2
      def prefix ""
      if (kind == "async") {
        prefix = "async "
      }
      if (kind == "generator") {
        prefix = "function* "
      }
      if (kind == "async-generator") {
        prefix = "async function* "
      }
      if ((strlen prefix) > 0) {
        print indent + "FunctionDeclaration: " + prefix + node.strValue + "(" + params + ") " + loc
      } {
        print indent + "FunctionDeclaration: " + node.strValue + "(" + params + ") " + loc
      }
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 1))
      }
      return
    }
    
    ; ES6 Class
    if (nodeType == "ClassDeclaration") {
      def output indent + "ClassDeclaration: " + node.strValue
      if (!null? node.left) {
        def superClass (unwrap node.left)
        output = output + " extends " + superClass.strValue
      }
      print output + " " + loc
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 1))
      }
      return
    }
    
    if (nodeType == "ClassBody") {
      print indent + "ClassBody " + loc
      for node.children method:JSNode mi {
        ASTPrinter.printNode(method (depth + 1))
      }
      return
    }
    
    if (nodeType == "MethodDefinition") {
      def staticStr ""
      if (node.strValue2 == "static") {
        staticStr = "static "
      }
      print indent + "MethodDefinition: " + staticStr + node.strValue + " " + loc
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 1))
      }
      return
    }
    
    ; ES6 Arrow function
    if (nodeType == "ArrowFunctionExpression") {
      def params ""
      for node.children p:JSNode pi {
        if (pi > 0) {
          params = params + ", "
        }
        params = params + p.strValue
      }
      def asyncStr ""
      if (node.strValue2 == "async") {
        asyncStr = "async "
      }
      print indent + "ArrowFunctionExpression: " + asyncStr + "(" + params + ") => " + loc
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 1))
      }
      return
    }
    
    ; Yield expression (generator)
    if (nodeType == "YieldExpression") {
      def delegateStr ""
      if (node.strValue == "delegate") {
        delegateStr = "*"
      }
      print indent + "YieldExpression" + delegateStr + " " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    ; Await expression (async)
    if (nodeType == "AwaitExpression") {
      print indent + "AwaitExpression " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    ; Template literal
    if (nodeType == "TemplateLiteral") {
      print indent + "TemplateLiteral: `" + node.strValue + "` " + loc
      return
    }
    
    if (nodeType == "BlockStatement") {
      print indent + "BlockStatement " + loc
      for node.children child:JSNode ci {
        ASTPrinter.printNode(child (depth + 1))
      }
      return
    }
    
    if (nodeType == "ReturnStatement") {
      print indent + "ReturnStatement " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    if (nodeType == "IfStatement") {
      print indent + "IfStatement " + loc
      print indent + "  test:"
      if (!null? node.test) {
        ASTPrinter.printNode((unwrap node.test) (depth + 2))
      }
      print indent + "  consequent:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      if (!null? node.alternate) {
        print indent + "  alternate:"
        ASTPrinter.printNode((unwrap node.alternate) (depth + 2))
      }
      return
    }
    
    if (nodeType == "ExpressionStatement") {
      print indent + "ExpressionStatement " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    if (nodeType == "AssignmentExpression") {
      print indent + "AssignmentExpression: " + node.strValue + " " + loc
      if (!null? node.left) {
        print indent + "  left:"
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      if (!null? node.right) {
        print indent + "  right:"
        ASTPrinter.printNode((unwrap node.right) (depth + 2))
      }
      return
    }
    
    if ((nodeType == "BinaryExpression") || (nodeType == "LogicalExpression")) {
      print indent + nodeType + ": " + node.strValue + " " + loc
      if (!null? node.left) {
        print indent + "  left:"
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      if (!null? node.right) {
        print indent + "  right:"
        ASTPrinter.printNode((unwrap node.right) (depth + 2))
      }
      return
    }
    
    if (nodeType == "UnaryExpression") {
      print indent + "UnaryExpression: " + node.strValue + " " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    if (nodeType == "ConditionalExpression") {
      print indent + "ConditionalExpression " + loc
      print indent + "  test:"
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      print indent + "  consequent:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      print indent + "  alternate:"
      if (!null? node.right) {
        ASTPrinter.printNode((unwrap node.right) (depth + 2))
      }
      return
    }
    
    if (nodeType == "CallExpression") {
      print indent + "CallExpression " + loc
      if (!null? node.left) {
        print indent + "  callee:"
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      if ((array_length node.children) > 0) {
        print indent + "  arguments:"
        for node.children arg:JSNode ai {
          ASTPrinter.printNode(arg (depth + 2))
        }
      }
      return
    }
    
    if (nodeType == "MemberExpression") {
      if (node.strValue2 == "dot") {
        print indent + "MemberExpression: ." + node.strValue + " " + loc
      } {
        print indent + "MemberExpression: [computed] " + loc
      }
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      if (!null? node.right) {
        ASTPrinter.printNode((unwrap node.right) (depth + 1))
      }
      return
    }
    
    if (nodeType == "Identifier") {
      print indent + "Identifier: " + node.strValue + " " + loc
      return
    }
    
    if (nodeType == "Literal") {
      print indent + "Literal: " + node.strValue + " (" + node.strValue2 + ") " + loc
      return
    }
    
    if (nodeType == "ArrayExpression") {
      print indent + "ArrayExpression " + loc
      for node.children elem:JSNode ei {
        ASTPrinter.printNode(elem (depth + 1))
      }
      return
    }
    
    if (nodeType == "ObjectExpression") {
      print indent + "ObjectExpression " + loc
      for node.children prop:JSNode pi {
        ASTPrinter.printNode(prop (depth + 1))
      }
      return
    }
    
    if (nodeType == "Property") {
      print indent + "Property: " + node.strValue + " " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    if (nodeType == "WhileStatement") {
      print indent + "WhileStatement " + loc
      print indent + "  test:"
      if (!null? node.test) {
        ASTPrinter.printNode((unwrap node.test) (depth + 2))
      }
      print indent + "  body:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      return
    }
    
    if (nodeType == "DoWhileStatement") {
      print indent + "DoWhileStatement " + loc
      print indent + "  body:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      print indent + "  test:"
      if (!null? node.test) {
        ASTPrinter.printNode((unwrap node.test) (depth + 2))
      }
      return
    }
    
    if (nodeType == "ForStatement") {
      print indent + "ForStatement " + loc
      if (!null? node.left) {
        print indent + "  init:"
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      if (!null? node.test) {
        print indent + "  test:"
        ASTPrinter.printNode((unwrap node.test) (depth + 2))
      }
      if (!null? node.right) {
        print indent + "  update:"
        ASTPrinter.printNode((unwrap node.right) (depth + 2))
      }
      print indent + "  body:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      return
    }
    
    if (nodeType == "SwitchStatement") {
      print indent + "SwitchStatement " + loc
      print indent + "  discriminant:"
      if (!null? node.test) {
        ASTPrinter.printNode((unwrap node.test) (depth + 2))
      }
      print indent + "  cases:"
      for node.children caseNode:JSNode ci {
        ASTPrinter.printNode(caseNode (depth + 2))
      }
      return
    }
    
    if (nodeType == "SwitchCase") {
      if (node.strValue == "default") {
        print indent + "SwitchCase: default " + loc
      } {
        print indent + "SwitchCase " + loc
        if (!null? node.test) {
          print indent + "  test:"
          ASTPrinter.printNode((unwrap node.test) (depth + 2))
        }
      }
      if ((array_length node.children) > 0) {
        print indent + "  consequent:"
        for node.children stmt:JSNode si {
          ASTPrinter.printNode(stmt (depth + 2))
        }
      }
      return
    }
    
    if (nodeType == "TryStatement") {
      print indent + "TryStatement " + loc
      print indent + "  block:"
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 2))
      }
      if (!null? node.left) {
        print indent + "  handler:"
        ASTPrinter.printNode((unwrap node.left) (depth + 2))
      }
      if (!null? node.right) {
        print indent + "  finalizer:"
        ASTPrinter.printNode((unwrap node.right) (depth + 2))
      }
      return
    }
    
    if (nodeType == "CatchClause") {
      print indent + "CatchClause: " + node.strValue + " " + loc
      if (!null? node.body) {
        ASTPrinter.printNode((unwrap node.body) (depth + 1))
      }
      return
    }
    
    if (nodeType == "ThrowStatement") {
      print indent + "ThrowStatement " + loc
      if (!null? node.left) {
        ASTPrinter.printNode((unwrap node.left) (depth + 1))
      }
      return
    }
    
    if (nodeType == "BreakStatement") {
      if ((strlen node.strValue) > 0) {
        print indent + "BreakStatement: " + node.strValue + " " + loc
      } {
        print indent + "BreakStatement " + loc
      }
      return
    }
    
    if (nodeType == "ContinueStatement") {
      if ((strlen node.strValue) > 0) {
        print indent + "ContinueStatement: " + node.strValue + " " + loc
      } {
        print indent + "ContinueStatement " + loc
      }
      return
    }
    
    ; Default
    print indent + nodeType + " " + loc
  }
}
