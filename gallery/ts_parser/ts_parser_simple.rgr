; TypeScript Parser - Using unified node approach
; All AST nodes use a single TSNode class to avoid type issues

Import "ts_token.rgr"
Import "ts_lexer.rgr"

; Unified AST node - all node types use this
class TSNode {
  def nodeType:string ""
  def start:int 0
  def end:int 0
  def line:int 0
  def col:int 0
  
  ; Generic value fields
  def name:string ""          ; identifier names, type names
  def value:string ""         ; literal values, operators
  def kind:string ""          ; declaration kind (let/const), method kind (get/set/init)
  
  ; Flags
  def optional:boolean false
  def readonly:boolean false
  
  ; ESTree Property flags (ES2015)
  def shorthand:boolean false ; { x } shorthand property
  def computed:boolean false  ; { [expr]: value } computed property
  def method:boolean false    ; { foo() {} } method shorthand
  def generator:boolean false ; function* generators
  def async:boolean false     ; async functions
  def delegate:boolean false  ; yield* delegation
  def await:boolean false     ; for-await-of loops
  
  ; Child nodes
  def children:[TSNode]       ; statements, members, types in union
  def params:[TSNode]         ; function params, type params
  def decorators:[TSNode]     ; decorators on classes/methods/properties
  def left@(optional):TSNode
  def right@(optional):TSNode
  def body@(optional):TSNode
  def init@(optional):TSNode
  def typeAnnotation@(optional):TSNode
  
  ; ConditionalExpression fields (ESTree compatible)
  def test@(optional):TSNode      ; condition in ternary
  def consequent@(optional):TSNode ; true branch in ternary
  def alternate@(optional):TSNode  ; false branch in ternary
}

class TSParserSimple {
  def tokens:[Token]
  def pos:int 0
  def currentToken@(optional):Token
  def quiet:boolean false   ; suppress error messages
  def tsxMode:boolean false ; enable JSX/TSX parsing
  
  fn initParser:void (toks:[Token]) {
    this.tokens = toks
    this.pos = 0
    this.quiet = false
    if ((array_length toks) > 0) {
      this.currentToken = (itemAt toks 0)
    }
  }
  
  fn setQuiet:void (q:boolean) {
    this.quiet = q
  }
  
  fn setTsxMode:void (enabled:boolean) {
    this.tsxMode = enabled
  }
  
  fn peek:Token () {
    return (unwrap this.currentToken)
  }
  
  fn peekType:string () {
    if (null? this.currentToken) {
      return "EOF"
    }
    def tok (unwrap this.currentToken)
    return tok.tokenType
  }
  
  fn peekValue:string () {
    if (null? this.currentToken) {
      return ""
    }
    def tok (unwrap this.currentToken)
    return tok.value
  }
  
  fn advance:void () {
    this.pos = this.pos + 1
    if (this.pos < (array_length this.tokens)) {
      this.currentToken = (itemAt this.tokens this.pos)
    } {
      def eof (new Token())
      eof.tokenType = "EOF"
      eof.value = ""
      this.currentToken = eof
    }
  }
  
  fn expect:Token (expectedType:string) {
    def tok (this.peek())
    if (tok.tokenType != expectedType) {
      if (this.quiet == false) {
        print "Parse error: expected " + expectedType + " but got " + tok.tokenType
      }
    }
    this.advance()
    return tok
  }
  
  fn expectValue:Token (expectedValue:string) {
    def tok (this.peek())
    if (tok.value != expectedValue) {
      if (this.quiet == false) {
        print "Parse error: expected '" + expectedValue + "' but got '" + tok.value + "'"
      }
    }
    this.advance()
    return tok
  }
  
  fn isAtEnd:boolean () {
    def t (this.peekType())
    return (t == "EOF")
  }
  
  fn matchType:boolean (tokenType:string) {
    def t (this.peekType())
    return (t == tokenType)
  }
  
  fn matchValue:boolean (value:string) {
    def v (this.peekValue())
    return (v == value)
  }
  
  ; === Parse Program ===
  
  fn parseProgram:TSNode () {
    def prog (new TSNode())
    prog.nodeType = "Program"
    
    while ((this.isAtEnd()) == false) {
      def stmt (this.parseStatement())
      push prog.children stmt
    }
    
    return prog
  }
  
  ; === Parse Statement ===
  
  fn parseStatement:TSNode () {
    def tokVal (this.peekValue())
    
    ; Decorators - collect them before class
    if (tokVal == "@") {
      def decorators:[TSNode]
      while (this.matchValue("@")) {
        def dec (this.parseDecorator())
        push decorators dec
      }
      ; Now parse the decorated statement (class)
      def decorated (this.parseStatement())
      decorated.decorators = decorators
      return decorated
    }
    
    ; Declare keyword for ambient declarations
    if (tokVal == "declare") {
      return (this.parseDeclare())
    }
    
    ; Import/Export statements
    if (tokVal == "import") {
      return (this.parseImport())
    }
    
    if (tokVal == "export") {
      return (this.parseExport())
    }
    
    if (tokVal == "interface") {
      return (this.parseInterface()))
    }
    
    if (tokVal == "type") {
      return (this.parseTypeAlias()))
    }
    
    if (tokVal == "class") {
      return (this.parseClass())
    }
    
    if (tokVal == "abstract") {
      def nextVal:string (this.peekNextValue())
      if (nextVal == "class") {
        return (this.parseClass())
      }
    }
    
    if (tokVal == "enum") {
      return (this.parseEnum())
    }
    
    if (tokVal == "namespace") {
      return (this.parseNamespace())
    }
    
    if (tokVal == "const") {
      def nextVal:string (this.peekNextValue())
      if (nextVal == "enum") {
        return (this.parseEnum())
      }
    }
    
    if ((tokVal == "let") || (tokVal == "const")) {
      return (this.parseVarDecl())
    }
    
    if (tokVal == "function") {
      return (this.parseFuncDecl(false))
    }
    
    ; async function declarations
    if (tokVal == "async") {
      def nextVal:string (this.peekNextValue())
      if (nextVal == "function") {
        this.advance()  ; consume async
        return (this.parseFuncDecl(true))
      }
    }
    
    if (tokVal == "return") {
      return (this.parseReturn())
    }
    
    if (tokVal == "throw") {
      return (this.parseThrow())
    }
    
    if (tokVal == "if") {
      return (this.parseIfStatement())
    }
    
    if (tokVal == "while") {
      return (this.parseWhileStatement())
    }
    
    if (tokVal == "do") {
      return (this.parseDoWhileStatement())
    }
    
    if (tokVal == "for") {
      return (this.parseForStatement())
    }
    
    if (tokVal == "switch") {
      return (this.parseSwitchStatement())
    }
    
    if (tokVal == "try") {
      return (this.parseTryStatement())
    }
    
    if (tokVal == "{") {
      return (this.parseBlock())
    }
    
    if (tokVal == ";") {
      this.advance()
      def empty (new TSNode())
      empty.nodeType = "EmptyStatement"
      return empty
    }
    
    ; Check for labeled statement: identifier :
    def tokType (this.peekType())
    if (tokType == "Identifier") {
      def nextVal (this.peekNextValue())
      if (nextVal == ":") {
        return (this.parseLabeledStatement())
      }
    }
    
    return (this.parseExprStmt())
  }
  
  ; === Labeled Statement ===
  
  fn parseLabeledStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "LabeledStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    def labelTok (this.expect("Identifier"))
    node.name = labelTok.value
    
    this.expectValue(":")
    
    def body (this.parseStatement())
    node.body = body
    
    return node
  }
  
  ; === Helper: peek next token value ===
  
  fn peekNextValue:string () {
    def nextPos (this.pos + 1)
    if (nextPos < (array_length this.tokens)) {
      def nextTok:Token (itemAt this.tokens nextPos)
      return nextTok.value
    }
    return ""
  }
  
  ; === Return Statement ===
  
  fn parseReturn:TSNode () {
    def node (new TSNode())
    node.nodeType = "ReturnStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("return")
    
    ; Check for return value
    def v (this.peekValue())
    if ((v != ";") && ((this.isAtEnd()) == false)) {
      def arg (this.parseExpr())
      node.left = arg
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  ; === Import Declaration ===
  
  fn parseImport:TSNode () {
    def node (new TSNode())
    node.nodeType = "ImportDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("import")
    
    ; Check for type-only import
    if (this.matchValue("type")) {
      this.advance()
      node.kind = "type"
    }
    
    ; Check what kind of import
    def v (this.peekValue())
    
    ; import { foo, bar } from "module"
    if (v == "{") {
      this.advance()
      def specifiers:[TSNode]
      
      while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
        def spec (new TSNode())
        spec.nodeType = "ImportSpecifier"
        
        ; Check for type modifier on individual specifier
        if (this.matchValue("type")) {
          this.advance()
          spec.kind = "type"
        }
        
        def importedName (this.expect("Identifier"))
        spec.name = importedName.value
        
        ; Check for 'as' alias
        if (this.matchValue("as")) {
          this.advance()
          def localName (this.expect("Identifier"))
          spec.value = localName.value  ; local name in value
        } {
          spec.value = importedName.value
        }
        
        push specifiers spec
        
        if (this.matchValue(",")) {
          this.advance()
        }
      }
      this.expectValue("}")
      node.children = specifiers
    }
    
    ; import * as name from "module"
    if (v == "*") {
      this.advance()
      this.expectValue("as")
      def namespaceName (this.expect("Identifier"))
      
      def nsSpec (new TSNode())
      nsSpec.nodeType = "ImportNamespaceSpecifier"
      nsSpec.name = namespaceName.value
      push node.children nsSpec
    }
    
    ; import defaultExport from "module"
    if (this.matchType("Identifier")) {
      def defaultSpec (new TSNode())
      defaultSpec.nodeType = "ImportDefaultSpecifier"
      def defaultName (this.expect("Identifier"))
      defaultSpec.name = defaultName.value
      push node.children defaultSpec
      
      ; Could be followed by , { named } or , * as ns
      if (this.matchValue(",")) {
        this.advance()
        if (this.matchValue("{")) {
          this.advance()
          while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
            def spec (new TSNode())
            spec.nodeType = "ImportSpecifier"
            def importedName (this.expect("Identifier"))
            spec.name = importedName.value
            if (this.matchValue("as")) {
              this.advance()
              def localName (this.expect("Identifier"))
              spec.value = localName.value
            } {
              spec.value = importedName.value
            }
            push node.children spec
            if (this.matchValue(",")) {
              this.advance()
            }
          }
          this.expectValue("}")
        }
      }
    }
    
    ; Parse 'from' clause
    if (this.matchValue("from")) {
      this.advance()
      def sourceStr (this.expect("String"))
      def source (new TSNode())
      source.nodeType = "StringLiteral"
      source.value = sourceStr.value
      node.left = source
    }
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  ; === Export Declaration ===
  
  fn parseExport:TSNode () {
    def node (new TSNode())
    node.nodeType = "ExportNamedDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("export")
    
    ; Check for type-only export
    if (this.matchValue("type")) {
      def nextV (this.peekNextValue())
      ; Could be 'export type { ... }' or 'export type Foo = ...'
      if (nextV == "{") {
        this.advance()
        node.kind = "type"
      }
    }
    
    def v (this.peekValue())
    
    ; export default
    if (v == "default") {
      node.nodeType = "ExportDefaultDeclaration"
      this.advance()
      
      def nextVal (this.peekValue())
      if ((nextVal == "class") || (nextVal == "function") || (nextVal == "interface")) {
        def decl (this.parseStatement())
        node.left = decl
      } {
        def expr (this.parseExpr())
        node.left = expr
      }
      
      if (this.matchValue(";")) {
        this.advance()
      }
      return node
    }
    
    ; export { foo, bar }
    if (v == "{") {
      this.advance()
      def specifiers:[TSNode]
      
      while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
        def spec (new TSNode())
        spec.nodeType = "ExportSpecifier"
        
        def localName (this.expect("Identifier"))
        spec.name = localName.value
        
        ; Check for 'as' alias
        if (this.matchValue("as")) {
          this.advance()
          def exportedName (this.expect("Identifier"))
          spec.value = exportedName.value
        } {
          spec.value = localName.value
        }
        
        push specifiers spec
        
        if (this.matchValue(",")) {
          this.advance()
        }
      }
      this.expectValue("}")
      node.children = specifiers
      
      ; Optional 'from' for re-exports
      if (this.matchValue("from")) {
        this.advance()
        def sourceStr (this.expect("String"))
        def source (new TSNode())
        source.nodeType = "StringLiteral"
        source.value = sourceStr.value
        node.left = source
      }
      
      if (this.matchValue(";")) {
        this.advance()
      }
      return node
    }
    
    ; export * from "module"
    if (v == "*") {
      node.nodeType = "ExportAllDeclaration"
      this.advance()
      
      ; export * as name from "module"
      if (this.matchValue("as")) {
        this.advance()
        def exportName (this.expect("Identifier"))
        node.name = exportName.value
      }
      
      this.expectValue("from")
      def sourceStr (this.expect("String"))
      def source (new TSNode())
      source.nodeType = "StringLiteral"
      source.value = sourceStr.value
      node.left = source
      
      if (this.matchValue(";")) {
        this.advance()
      }
      return node
    }
    
    ; export declaration (function, class, interface, type, const, let, enum)
    if ((v == "function") || (v == "class") || (v == "interface") || (v == "type") || (v == "const") || (v == "let") || (v == "enum") || (v == "abstract")) {
      def decl (this.parseStatement())
      node.left = decl
      return node
    }
    
    ; export async function
    if (v == "async") {
      def decl (this.parseStatement())
      node.left = decl
      return node
    }
    
    return node
  }
  
  ; === Interface Declaration ===
  
  fn parseInterface:TSNode () {
    def node (new TSNode())
    node.nodeType = "TSInterfaceDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("interface")
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Parse generic type parameters <T, U>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      node.params = typeParams
    }
    
    ; Parse extends clause
    if (this.matchValue("extends")) {
      this.advance()
      def extendsList:[TSNode]
      def extendsType (this.parseType())
      push extendsList extendsType
      while (this.matchValue(",")) {
        this.advance()
        def nextType (this.parseType())
        push extendsList nextType
      }
      ; Store in children for extends
      for extendsList ext:TSNode i {
        def wrapper (new TSNode())
        wrapper.nodeType = "TSExpressionWithTypeArguments"
        wrapper.left = ext
        push node.children wrapper
      }
    }
    
    ; Parse body
    def body (this.parseInterfaceBody())
    node.body = body
    
    return node
  }
  
  fn parseInterfaceBody:TSNode () {
    def body (new TSNode())
    body.nodeType = "TSInterfaceBody"
    def startTok (this.peek())
    body.start = startTok.start
    body.line = startTok.line
    body.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def prop (this.parsePropertySig())
      push body.children prop
      
      if ((this.matchValue(";")) || (this.matchValue(","))) {
        this.advance()
      }
    }
    
    this.expectValue("}")
    return body
  }
  
  ; === Generic Type Parameters <T, U extends Base> ===
  
  fn parseTypeParams:[TSNode] () {
    def params:[TSNode]
    
    this.expectValue("<")
    
    while (((this.matchValue(">")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length params) > 0) {
        this.expectValue(",")
      }
      
      def param (new TSNode())
      param.nodeType = "TSTypeParameter"
      def nameTok (this.expect("Identifier"))
      param.name = nameTok.value
      param.start = nameTok.start
      param.line = nameTok.line
      param.col = nameTok.col
      
      ; extends constraint: T extends Base
      if (this.matchValue("extends")) {
        this.advance()
        def constraint (this.parseType())
        param.typeAnnotation = constraint
      }
      
      ; default type: T = DefaultType
      if (this.matchValue("=")) {
        this.advance()
        def defaultType (this.parseType())
        param.init = defaultType
      }
      
      push params param
    }
    
    this.expectValue(">")
    return params
  }
  
  fn parsePropertySig:TSNode () {
    def startTok (this.peek())
    def startPos startTok.start
    def startLine startTok.line
    def startCol startTok.col
    
    ; Optional readonly
    def isReadonly false
    if (this.matchValue("readonly")) {
      isReadonly = true
      this.advance()
    }
    
    ; Check for index signature [key: type]: type
    if (this.matchValue("[")) {
      this.advance() ; consume [
      def paramTok (this.expect("Identifier"))
      return (this.parseIndexSignatureRest(isReadonly paramTok startPos startLine startCol))
    }
    
    ; Check for call signature (params): returnType
    if (this.matchValue("(")) {
      return (this.parseCallSignature(startPos startLine startCol))
    }
    
    ; Check for construct signature new (params): returnType
    if (this.matchValue("new")) {
      return (this.parseConstructSignature(startPos startLine startCol))
    }
    
    def prop (new TSNode())
    prop.nodeType = "TSPropertySignature"
    prop.start = startPos
    prop.line = startLine
    prop.col = startCol
    prop.readonly = isReadonly
    
    ; Property name
    def nameTok (this.expect("Identifier"))
    prop.name = nameTok.value
    
    ; Optional marker
    if (this.matchValue("?")) {
      prop.optional = true
      this.advance()
    }
    
    ; Type annotation
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      prop.typeAnnotation = typeAnnot
    }
    
    return prop
  }
  
  ; === Call Signature (for interface) ===
  
  fn parseCallSignature:TSNode (startPos:int startLine:int startCol:int) {
    def sig (new TSNode())
    sig.nodeType = "TSCallSignatureDeclaration"
    sig.start = startPos
    sig.line = startLine
    sig.col = startCol
    
    ; Parse type parameters <T>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      sig.params = typeParams
    }
    
    ; Parse parameters
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length sig.children) > 0) {
        this.expectValue(",")
      }
      def param (this.parseParam())
      push sig.children param
    }
    this.expectValue(")")
    
    ; Return type
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      sig.typeAnnotation = typeAnnot
    }
    
    return sig
  }
  
  ; === Construct Signature (for interface) ===
  
  fn parseConstructSignature:TSNode (startPos:int startLine:int startCol:int) {
    def sig (new TSNode())
    sig.nodeType = "TSConstructSignatureDeclaration"
    sig.start = startPos
    sig.line = startLine
    sig.col = startCol
    
    this.expectValue("new")
    
    ; Parse type parameters <T>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      sig.params = typeParams
    }
    
    ; Parse parameters
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length sig.children) > 0) {
        this.expectValue(",")
      }
      def param (this.parseParam())
      push sig.children param
    }
    this.expectValue(")")
    
    ; Return type
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      sig.typeAnnotation = typeAnnot
    }
    
    return sig
  }
  
  ; === Type Alias Declaration ===
  
  fn parseTypeAlias:TSNode () {
    def node (new TSNode())
    node.nodeType = "TSTypeAliasDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("type")
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Parse generic type parameters <T, U>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      node.params = typeParams
    }
    
    this.expectValue("=")
    
    def typeExpr (this.parseType())
    node.typeAnnotation = typeExpr
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  ; === Decorator ===
  
  fn parseDecorator:TSNode () {
    def node (new TSNode())
    node.nodeType = "Decorator"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("@")
    
    ; Parse decorator expression (identifier or call)
    def expr (this.parsePostfix())
    node.left = expr
    
    return node
  }
  
  ; === Class Declaration ===
  
  fn parseClass:TSNode () {
    def node (new TSNode())
    node.nodeType = "ClassDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    ; Optional abstract modifier
    if (this.matchValue("abstract")) {
      node.kind = "abstract"
      this.advance()
    }
    
    this.expectValue("class")
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Parse generic type parameters <T, U>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      node.params = typeParams
    }
    
    ; Parse extends clause
    if (this.matchValue("extends")) {
      this.advance()
      def superClass (this.parseType())
      def extendsNode (new TSNode())
      extendsNode.nodeType = "TSExpressionWithTypeArguments"
      extendsNode.left = superClass
      node.left = extendsNode
    }
    
    ; Parse implements clause
    if (this.matchValue("implements")) {
      this.advance()
      def impl (this.parseType())
      def implNode (new TSNode())
      implNode.nodeType = "TSExpressionWithTypeArguments"
      implNode.left = impl
      push node.children implNode
      while (this.matchValue(",")) {
        this.advance()
        def nextImpl (this.parseType())
        def nextImplNode (new TSNode())
        nextImplNode.nodeType = "TSExpressionWithTypeArguments"
        nextImplNode.left = nextImpl
        push node.children nextImplNode
      }
    }
    
    ; Parse class body
    def body (this.parseClassBody())
    node.body = body
    
    return node
  }
  
  fn parseClassBody:TSNode () {
    def body (new TSNode())
    body.nodeType = "ClassBody"
    def startTok (this.peek())
    body.start = startTok.start
    body.line = startTok.line
    body.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def member (this.parseClassMember())
      push body.children member
      
      ; Optional semicolon
      if (this.matchValue(";")) {
        this.advance()
      }
    }
    
    this.expectValue("}")
    return body
  }
  
  fn parseClassMember:TSNode () {
    def member (new TSNode())
    def startTok (this.peek())
    member.start = startTok.start
    member.line = startTok.line
    member.col = startTok.col
    
    ; Parse decorators on class members
    def decorators:[TSNode]
    while (this.matchValue("@")) {
      def dec (this.parseDecorator())
      push decorators dec
    }
    if ((array_length decorators) > 0) {
      member.decorators = decorators
    }
    
    ; Parse modifiers
    def isStatic false
    def isAbstract false
    def isReadonly false
    def isAsync false
    def accessibility ""
    
    def keepParsing true
    while (keepParsing) {
      def tokVal (this.peekValue())
      
      if (tokVal == "public") {
        accessibility = "public"
        this.advance()
      }
      if (tokVal == "private") {
        accessibility = "private"
        this.advance()
      }
      if (tokVal == "protected") {
        accessibility = "protected"
        this.advance()
      }
      if (tokVal == "static") {
        isStatic = true
        this.advance()
        
        ; Check for static block: static { ... }
        if (this.matchValue("{")) {
          member.nodeType = "StaticBlock"
          member.body = (this.parseBlock())
          member.start = startTok.start
          member.line = startTok.line
          member.col = startTok.col
          return member
        }
      }
      if (tokVal == "abstract") {
        isAbstract = true
        this.advance()
      }
      if (tokVal == "readonly") {
        isReadonly = true
        this.advance()
      }
      if (tokVal == "async") {
        isAsync = true
        this.advance()
      }
      
      def newTokVal (this.peekValue())
      if ((newTokVal != "public") && (newTokVal != "private") && (newTokVal != "protected") && (newTokVal != "static") && (newTokVal != "abstract") && (newTokVal != "readonly") && (newTokVal != "async")) {
        keepParsing = false
      }
    }
    
    ; Constructor
    if (this.matchValue("constructor")) {
      member.nodeType = "MethodDefinition"
      member.kind = "constructor"
      this.advance()
      
      this.expectValue("(")
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length member.params) > 0) {
          this.expectValue(",")
        }
        def param (this.parseConstructorParam())
        push member.params param
      }
      this.expectValue(")")
      
      ; Constructor body
      if (this.matchValue("{")) {
        def bodyNode (this.parseBlock())
        member.body = bodyNode
      }
      
      return member
    }
    
    ; Member name
    def nameTok (this.expect("Identifier"))
    member.name = nameTok.value
    
    ; Apply modifiers
    if (accessibility != "") {
      member.kind = accessibility
    }
    member.readonly = isReadonly
    
    ; Optional marker
    if (this.matchValue("?")) {
      member.optional = true
      this.advance()
    }
    
    ; Method or property?
    if (this.matchValue("(")) {
      ; Method
      member.nodeType = "MethodDefinition"
      if (isStatic) {
        member.kind = "static"
      }
      if (isAbstract) {
        member.kind = "abstract"
      }
      if (isAsync) {
        member.async = true
      }
      
      this.expectValue("(")
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length member.params) > 0) {
          this.expectValue(",")
        }
        def param (this.parseParam())
        push member.params param
      }
      this.expectValue(")")
      
      ; Return type
      if (this.matchValue(":")) {
        def returnType (this.parseTypeAnnotation())
        member.typeAnnotation = returnType
      }
      
      ; Method body
      if (this.matchValue("{")) {
        def bodyNode (this.parseBlock())
        member.body = bodyNode
      }
    } {
      ; Property
      member.nodeType = "PropertyDefinition"
      if (isStatic) {
        member.kind = "static"
      }
      
      ; Type annotation
      if (this.matchValue(":")) {
        def typeAnnot (this.parseTypeAnnotation())
        member.typeAnnotation = typeAnnot
      }
      
      ; Initializer
      if (this.matchValue("=")) {
        this.advance()
        def initExpr (this.parseExpr())
        member.init = initExpr
      }
    }
    
    return member
  }
  
  fn parseConstructorParam:TSNode () {
    def param (new TSNode())
    param.nodeType = "Parameter"
    def startTok (this.peek())
    param.start = startTok.start
    param.line = startTok.line
    param.col = startTok.col
    
    ; Check for parameter property modifiers
    def tokVal (this.peekValue())
    if ((tokVal == "public") || (tokVal == "private") || (tokVal == "protected") || (tokVal == "readonly")) {
      param.kind = tokVal
      this.advance()
      ; Could have multiple like "private readonly"
      def nextVal (this.peekValue())
      if (nextVal == "readonly") {
        param.readonly = true
        this.advance()
      }
    }
    
    def nameTok (this.expect("Identifier"))
    param.name = nameTok.value
    
    ; Optional marker
    if (this.matchValue("?")) {
      param.optional = true
      this.advance()
    }
    
    ; Type annotation
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      param.typeAnnotation = typeAnnot
    }
    
    ; Default value
    if (this.matchValue("=")) {
      this.advance()
      def defaultVal (this.parseExpr())
      param.init = defaultVal
    }
    
    return param
  }
  
  ; === Enum Declaration ===
  
  fn parseEnum:TSNode () {
    def node (new TSNode())
    node.nodeType = "TSEnumDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    ; const enum
    if (this.matchValue("const")) {
      node.kind = "const"
      this.advance()
    }
    
    this.expectValue("enum")
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Enum body
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def member (new TSNode())
      member.nodeType = "TSEnumMember"
      def memberTok (this.expect("Identifier"))
      member.name = memberTok.value
      member.start = memberTok.start
      member.line = memberTok.line
      member.col = memberTok.col
      
      ; Optional initializer
      if (this.matchValue("=")) {
        this.advance()
        def initVal (this.parseExpr())
        member.init = initVal
      }
      
      push node.children member
      
      if (this.matchValue(",")) {
        this.advance()
      }
    }
    
    this.expectValue("}")
    return node
  }
  
  ; === Namespace Declaration ===
  
  fn parseNamespace:TSNode () {
    def node (new TSNode())
    node.nodeType = "TSModuleDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("namespace")
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Namespace body
    this.expectValue("{")
    def body (new TSNode())
    body.nodeType = "TSModuleBlock"
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def stmt (this.parseStatement())
      push body.children stmt
    }
    
    this.expectValue("}")
    node.body = body
    return node
  }
  
  ; === Declare (ambient declarations) ===
  
  fn parseDeclare:TSNode () {
    def startTok (this.peek())
    this.expectValue("declare")
    
    def nextVal (this.peekValue())
    
    ; declare module "name" { ... }
    if (nextVal == "module") {
      def node (new TSNode())
      node.nodeType = "TSModuleDeclaration"
      node.start = startTok.start
      node.line = startTok.line
      node.col = startTok.col
      node.kind = "declare"
      
      this.advance() ; skip 'module'
      
      ; Module name can be a string literal
      def nameTok (this.peek())
      if (this.matchType("String")) {
        this.advance()
        node.name = nameTok.value
      } {
        this.advance()
        node.name = nameTok.value
      }
      
      ; Module body
      this.expectValue("{")
      def body (new TSNode())
      body.nodeType = "TSModuleBlock"
      
      while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
        def stmt (this.parseStatement())
        push body.children stmt
      }
      
      this.expectValue("}")
      node.body = body
      return node
    }
    
    ; declare function, declare class, etc.
    def node (this.parseStatement())
    node.kind = "declare"
    return node
  }
  
  ; === Control Flow Statements ===
  
  fn parseIfStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "IfStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("if")
    this.expectValue("(")
    def test (this.parseExpr())
    node.left = test
    this.expectValue(")")
    
    def consequent (this.parseStatement())
    node.body = consequent
    
    ; else clause
    if (this.matchValue("else")) {
      this.advance()
      def alternate (this.parseStatement())
      node.right = alternate
    }
    
    return node
  }
  
  fn parseWhileStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "WhileStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("while")
    this.expectValue("(")
    def test (this.parseExpr())
    node.left = test
    this.expectValue(")")
    
    def body (this.parseStatement())
    node.body = body
    
    return node
  }
  
  ; === Do-While Statement ===
  
  fn parseDoWhileStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "DoWhileStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("do")
    
    def body (this.parseStatement())
    node.body = body
    
    this.expectValue("while")
    this.expectValue("(")
    def test (this.parseExpr())
    node.left = test
    this.expectValue(")")
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  ; === Throw Statement ===
  
  fn parseThrow:TSNode () {
    def node (new TSNode())
    node.nodeType = "ThrowStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("throw")
    
    def arg (this.parseExpr())
    node.left = arg
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  fn parseForStatement:TSNode () {
    def node (new TSNode())
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("for")
    
    ; Check for for-await-of: for await (const x of iter) {}
    def isAwait false
    if (this.matchValue("await")) {
      this.advance()
      isAwait = true
    }
    
    this.expectValue("(")
    
    ; Check for for...of or for...in
    ; First parse potential variable declaration
    def tokVal (this.peekValue())
    
    if ((tokVal == "let") || (tokVal == "const") || (tokVal == "var")) {
      def kind tokVal
      this.advance()
      def varName (this.expect("Identifier"))
      
      def nextVal (this.peekValue())
      if (nextVal == "of") {
        ; for...of loop
        node.nodeType = "ForOfStatement"
        node.await = isAwait
        this.advance() ; consume 'of'
        
        def left (new TSNode())
        left.nodeType = "VariableDeclaration"
        left.kind = kind
        def declarator (new TSNode())
        declarator.nodeType = "VariableDeclarator"
        declarator.name = varName.value
        push left.children declarator
        node.left = left
        
        def right (this.parseExpr())
        node.right = right
        this.expectValue(")")
        
        def body (this.parseStatement())
        node.body = body
        return node
      }
      
      if (nextVal == "in") {
        ; for...in loop
        node.nodeType = "ForInStatement"
        this.advance() ; consume 'in'
        
        def left (new TSNode())
        left.nodeType = "VariableDeclaration"
        left.kind = kind
        def declarator (new TSNode())
        declarator.nodeType = "VariableDeclarator"
        declarator.name = varName.value
        push left.children declarator
        node.left = left
        
        def right (this.parseExpr())
        node.right = right
        this.expectValue(")")
        
        def body (this.parseStatement())
        node.body = body
        return node
      }
      
      ; Regular for loop - need to parse rest of init
      node.nodeType = "ForStatement"
      def initDecl (new TSNode())
      initDecl.nodeType = "VariableDeclaration"
      initDecl.kind = kind
      def declarator (new TSNode())
      declarator.nodeType = "VariableDeclarator"
      declarator.name = varName.value
      
      ; Type annotation
      if (this.matchValue(":")) {
        def typeAnnot (this.parseTypeAnnotation())
        declarator.typeAnnotation = typeAnnot
      }
      
      ; Initializer
      if (this.matchValue("=")) {
        this.advance()
        def initVal (this.parseExpr())
        declarator.init = initVal
      }
      
      push initDecl.children declarator
      node.init = initDecl
    } {
      ; Init could be expression or empty
      node.nodeType = "ForStatement"
      if ((this.matchValue(";")) == false) {
        def initExpr (this.parseExpr())
        node.init = initExpr
      }
    }
    
    this.expectValue(";")
    
    ; Test condition
    if ((this.matchValue(";")) == false) {
      def test (this.parseExpr())
      node.left = test
    }
    
    this.expectValue(";")
    
    ; Update expression
    if ((this.matchValue(")")) == false) {
      def update (this.parseExpr())
      node.right = update
    }
    
    this.expectValue(")")
    
    def body (this.parseStatement())
    node.body = body
    
    return node
  }
  
  fn parseSwitchStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "SwitchStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("switch")
    this.expectValue("(")
    def discriminant (this.parseExpr())
    node.left = discriminant
    this.expectValue(")")
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def caseNode (new TSNode())
      
      if (this.matchValue("case")) {
        caseNode.nodeType = "SwitchCase"
        this.advance()
        def test (this.parseExpr())
        caseNode.left = test
        this.expectValue(":")
      }
      
      if (this.matchValue("default")) {
        caseNode.nodeType = "SwitchCase"
        caseNode.kind = "default"
        this.advance()
        this.expectValue(":")
      }
      
      ; Parse consequent statements
      while (((this.matchValue("case")) == false) && ((this.matchValue("default")) == false) && ((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
        if (this.matchValue("break")) {
          def breakNode (new TSNode())
          breakNode.nodeType = "BreakStatement"
          this.advance()
          if (this.matchValue(";")) {
            this.advance()
          }
          push caseNode.children breakNode
        } {
          def stmt (this.parseStatement())
          push caseNode.children stmt
        }
      }
      
      push node.children caseNode
    }
    
    this.expectValue("}")
    return node
  }
  
  fn parseTryStatement:TSNode () {
    def node (new TSNode())
    node.nodeType = "TryStatement"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("try")
    
    def tryBlock (this.parseBlock())
    node.body = tryBlock
    
    ; catch clause
    if (this.matchValue("catch")) {
      def catchNode (new TSNode())
      catchNode.nodeType = "CatchClause"
      this.advance()
      
      if (this.matchValue("(")) {
        this.advance()
        def param (this.expect("Identifier"))
        catchNode.name = param.value
        
        ; Optional type annotation
        if (this.matchValue(":")) {
          def typeAnnot (this.parseTypeAnnotation())
          catchNode.typeAnnotation = typeAnnot
        }
        
        this.expectValue(")")
      }
      
      def catchBlock (this.parseBlock())
      catchNode.body = catchBlock
      node.left = catchNode
    }
    
    ; finally clause
    if (this.matchValue("finally")) {
      this.advance()
      def finallyBlock (this.parseBlock())
      node.right = finallyBlock
    }
    
    return node
  }

  ; === Variable Declaration ===
  
  fn parseVarDecl:TSNode () {
    def node (new TSNode())
    node.nodeType = "VariableDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    node.kind = startTok.value
    
    this.advance() ; consume let/const
    
    ; Parse declarator
    def declarator (new TSNode())
    declarator.nodeType = "VariableDeclarator"
    
    def nextVal (this.peekValue())
    
    ; Destructuring object pattern { a, b } = obj
    if (nextVal == "{") {
      def pattern (this.parseObjectPattern())
      declarator.left = pattern
      declarator.start = pattern.start
      declarator.line = pattern.line
      declarator.col = pattern.col
    } {
      ; Destructuring array pattern [x, y] = arr
      if (nextVal == "[") {
        def pattern (this.parseArrayPattern())
        declarator.left = pattern
        declarator.start = pattern.start
        declarator.line = pattern.line
        declarator.col = pattern.col
      } {
        ; Simple identifier
        def nameTok (this.expect("Identifier"))
        declarator.name = nameTok.value
        declarator.start = nameTok.start
        declarator.line = nameTok.line
        declarator.col = nameTok.col
      }
    }
    
    ; Type annotation
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      declarator.typeAnnotation = typeAnnot
    }
    
    ; Initializer
    if (this.matchValue("=")) {
      this.advance()
      def initExpr (this.parseExpr())
      declarator.init = initExpr
    }
    
    push node.children declarator
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return node
  }
  
  ; === Object Pattern { a, b, c: d } ===
  
  fn parseObjectPattern:TSNode () {
    def node (new TSNode())
    node.nodeType = "ObjectPattern"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length node.children) > 0) {
        this.expectValue(",")
        ; Allow trailing comma
        if (this.matchValue("}")) {
          break
        }
      }
      
      ; Rest pattern ...rest
      if (this.matchValue("...")) {
        this.advance()
        def restProp (new TSNode())
        restProp.nodeType = "RestElement"
        def restName (this.expect("Identifier"))
        restProp.name = restName.value
        push node.children restProp
      } {
        ; Property pattern: name or name: alias
        def prop (new TSNode())
        prop.nodeType = "Property"
        def keyTok (this.expect("Identifier"))
        prop.name = keyTok.value
        
        ; Check for : alias
        if (this.matchValue(":")) {
          this.advance()
          def valueTok (this.expect("Identifier"))
          def valueId (new TSNode())
          valueId.nodeType = "Identifier"
          valueId.name = valueTok.value
          prop.right = valueId
        } {
          prop.shorthand = true
        }
        
        ; Check for default value = expr
        if (this.matchValue("=")) {
          this.advance()
          def defaultExpr (this.parseExpr())
          prop.init = defaultExpr
          prop.left = defaultExpr  ; Also set left for compatibility
        }
        
        push node.children prop
      }
    }
    
    this.expectValue("}")
    return node
  }
  
  ; === Array Pattern [a, b, c] ===
  
  fn parseArrayPattern:TSNode () {
    def node (new TSNode())
    node.nodeType = "ArrayPattern"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    this.expectValue("[")
    
    while (((this.matchValue("]")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length node.children) > 0) {
        this.expectValue(",")
        ; Allow trailing comma
        if (this.matchValue("]")) {
          break
        }
      }
      
      ; Check for holes (elision): [a, , b]
      if (this.matchValue(",")) {
        def hole (new TSNode())
        hole.nodeType = "Elision"
        push node.children hole
      } {
        ; Rest pattern ...rest
        if (this.matchValue("...")) {
          this.advance()
          def restElem (new TSNode())
          restElem.nodeType = "RestElement"
          def restName (this.expect("Identifier"))
          restElem.name = restName.value
          push node.children restElem
        } {
          ; Element pattern
          def elem (new TSNode())
          def elemTok (this.expect("Identifier"))
          elem.nodeType = "Identifier"
          elem.name = elemTok.value
          
          ; Check for default value = expr
          if (this.matchValue("=")) {
            this.advance()
            def defaultExpr (this.parseExpr())
            def assignPat (new TSNode())
            assignPat.nodeType = "AssignmentPattern"
            assignPat.left = elem
            assignPat.right = defaultExpr
            push node.children assignPat
          } {
            push node.children elem
          }
        }
      }
    }
    
    this.expectValue("]")
    return node
  }
  
  ; === Function Declaration ===
  
  fn parseFuncDecl:TSNode (isAsync:boolean) {
    def node (new TSNode())
    node.nodeType = "FunctionDeclaration"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    ; Set async flag if async keyword was consumed before this call
    if (isAsync) {
      node.async = true
    }
    
    this.expectValue("function")
    
    ; Generator function: function* name() {} or async function* name() {}
    if (this.matchValue("*")) {
      this.advance()
      node.generator = true
    }
    
    def nameTok (this.expect("Identifier"))
    node.name = nameTok.value
    
    ; Type parameters <T, U>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      ; Store type params in children
      for typeParams tp:TSNode i {
        push node.children tp
      }
    }
    
    ; Parameters
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length node.params) > 0) {
        this.expectValue(",")
      }
      def param (this.parseParam())
      push node.params param
    }
    this.expectValue(")")
    
    ; Return type
    if (this.matchValue(":")) {
      def returnType (this.parseTypeAnnotation())
      node.typeAnnotation = returnType
    }
    
    ; Body
    def body (this.parseBlock())
    node.body = body
    
    return node
  }
  
  fn parseParam:TSNode () {
    ; Check for parameter decorators (@inject, @Required, etc.)
    def decorators:[TSNode]
    while (this.matchValue("@")) {
      def dec (this.parseDecorator())
      push decorators dec
    }
    
    ; Check for rest parameter (...name)
    def isRest:boolean false
    if (this.matchValue("...")) {
      this.advance()
      isRest = true
    }
    
    ; Check for object destructuring { name, value = default }
    if (this.matchValue("{")) {
      def pattern (this.parseObjectPattern())
      ; Copy decorators if any
      for decorators d:TSNode i {
        push pattern.decorators d
      }
      if isRest {
        def restElem (new TSNode())
        restElem.nodeType = "RestElement"
        restElem.left = pattern
        return restElem
      }
      return pattern
    }
    
    ; Check for array destructuring [ a, b, c ]
    if (this.matchValue("[")) {
      def pattern (this.parseArrayPattern())
      ; Copy decorators if any
      for decorators d:TSNode i {
        push pattern.decorators d
      }
      if isRest {
        def restElem (new TSNode())
        restElem.nodeType = "RestElement"
        restElem.left = pattern
        return restElem
      }
      return pattern
    }
    
    ; Simple parameter: name or ...name
    def param (new TSNode())
    if isRest {
      param.nodeType = "RestElement"
      param.kind = "rest"
    } {
      param.nodeType = "Parameter"
    }
    
    ; Copy decorators
    for decorators d:TSNode i {
      push param.decorators d
    }
    
    def nameTok (this.expect("Identifier"))
    param.name = nameTok.value
    param.start = nameTok.start
    param.line = nameTok.line
    param.col = nameTok.col
    
    ; Optional marker
    if (this.matchValue("?")) {
      param.optional = true
      this.advance()
    }
    
    ; Type annotation
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      param.typeAnnotation = typeAnnot
    }
    
    ; Default value
    if (this.matchValue("=")) {
      this.advance()
      param.init = (this.parseExpr())
    }
    
    return param
  }
  
  ; === Block Statement ===
  
  fn parseBlock:TSNode () {
    def block (new TSNode())
    block.nodeType = "BlockStatement"
    def startTok (this.peek())
    block.start = startTok.start
    block.line = startTok.line
    block.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def stmt (this.parseStatement())
      push block.children stmt
    }
    
    this.expectValue("}")
    return block
  }
  
  ; === Expression Statement ===
  
  fn parseExprStmt:TSNode () {
    def stmt (new TSNode())
    stmt.nodeType = "ExpressionStatement"
    def startTok (this.peek())
    stmt.start = startTok.start
    stmt.line = startTok.line
    stmt.col = startTok.col
    
    def expr (this.parseExpr())
    stmt.left = expr
    
    if (this.matchValue(";")) {
      this.advance()
    }
    
    return stmt
  }
  
  ; === Type Annotation ===
  
  fn parseTypeAnnotation:TSNode () {
    def annot (new TSNode())
    annot.nodeType = "TSTypeAnnotation"
    def startTok (this.peek())
    annot.start = startTok.start
    annot.line = startTok.line
    annot.col = startTok.col
    
    this.expectValue(":")
    
    ; Check for type predicate: x is Type or asserts x
    def nextVal (this.peekValue())
    
    ; Assertion function: asserts param or asserts param is Type
    if (nextVal == "asserts") {
      def assertsTok (this.peek())
      this.advance()
      
      def predicate (new TSNode())
      predicate.nodeType = "TSTypePredicate"
      predicate.start = assertsTok.start
      predicate.line = assertsTok.line
      predicate.col = assertsTok.col
      predicate.value = "asserts"
      
      def paramTok (this.expect("Identifier"))
      predicate.name = paramTok.value
      
      ; Optional type assertion: asserts param is Type
      if (this.matchValue("is")) {
        this.advance()
        def assertType (this.parseType())
        predicate.typeAnnotation = assertType
      }
      
      annot.typeAnnotation = predicate
      return annot
    }
    
    ; Check for type predicate: param is Type
    if (this.matchType("Identifier")) {
      def savedPos this.pos
      def savedTok:Token (unwrap this.currentToken)
      def paramTok (this.peek())
      this.advance()
      
      if (this.matchValue("is")) {
        this.advance()
        def predicate (new TSNode())
        predicate.nodeType = "TSTypePredicate"
        predicate.start = paramTok.start
        predicate.line = paramTok.line
        predicate.col = paramTok.col
        predicate.name = paramTok.value
        
        def typeExpr (this.parseType())
        predicate.typeAnnotation = typeExpr
        
        annot.typeAnnotation = predicate
        return annot
      }
      
      ; Not a type predicate, backtrack
      this.pos = savedPos
      this.currentToken = savedTok
    }
    
    def typeExpr (this.parseType())
    annot.typeAnnotation = typeExpr
    
    return annot
  }
  
  ; === Type Expression Parsing ===
  
  fn parseType:TSNode () {
    return (this.parseConditionalType())
  }
  
  ; === Conditional Type: T extends U ? X : Y ===
  
  fn parseConditionalType:TSNode () {
    def checkType (this.parseUnionType())
    
    ; Check for 'extends' keyword for conditional type
    if (this.matchValue("extends")) {
      this.advance()
      
      ; Parse the extends type (what we're checking against)
      ; Need to be careful - the extendsType stops before ? which is the conditional marker
      def extendsType (this.parseUnionType())
      
      ; If followed by ?, this is a conditional type
      if (this.matchValue("?")) {
        this.advance()
        
        def conditional (new TSNode())
        conditional.nodeType = "TSConditionalType"
        conditional.start = checkType.start
        conditional.line = checkType.line
        conditional.col = checkType.col
        
        ; checkType is what we're testing
        conditional.left = checkType
        ; extendsType is what we're testing against - store in params
        push conditional.params extendsType
        
        ; Parse true type (use parseUnionType to avoid deeper recursion issues)
        conditional.body = (this.parseUnionType())
        
        this.expectValue(":")
        
        ; Parse false type
        conditional.right = (this.parseUnionType())
        
        return conditional
      }
      
      ; Not a conditional type, just a type constraint (shouldn't happen at top level)
      ; Return as-is for now
      return checkType
    }
    
    return checkType
  }
  
  fn parseUnionType:TSNode () {
    def left (this.parseIntersectionType())
    
    if (this.matchValue("|")) {
      def union (new TSNode())
      union.nodeType = "TSUnionType"
      union.start = left.start
      union.line = left.line
      union.col = left.col
      push union.children left
      
      while (this.matchValue("|")) {
        this.advance()
        def right (this.parseIntersectionType())
        push union.children right
      }
      
      return union
    }
    
    return left
  }
  
  fn parseIntersectionType:TSNode () {
    def left (this.parseArrayType())
    
    if (this.matchValue("&")) {
      def intersection (new TSNode())
      intersection.nodeType = "TSIntersectionType"
      intersection.start = left.start
      intersection.line = left.line
      intersection.col = left.col
      push intersection.children left
      
      while (this.matchValue("&")) {
        this.advance()
        def right (this.parseArrayType())
        push intersection.children right
      }
      
      return intersection
    }
    
    return left
  }
  
  fn parseArrayType:TSNode () {
    def elemType (this.parsePrimaryType())
    
    ; Check for array brackets [] or indexed access [type]
    while (this.matchValue("[")) {
      ; Check if next is ] for array type
      if (this.checkNext("]")) {
        this.advance() ; [
        this.advance() ; ]
        
        def arrayType (new TSNode())
        arrayType.nodeType = "TSArrayType"
        arrayType.start = elemType.start
        arrayType.line = elemType.line
        arrayType.col = elemType.col
        arrayType.left = elemType
        elemType = arrayType
      } {
        ; Indexed access type: T[K] or Person["name"]
        this.advance() ; [
        def indexType (this.parseType())
        this.expectValue("]")
        
        def indexedAccess (new TSNode())
        indexedAccess.nodeType = "TSIndexedAccessType"
        indexedAccess.start = elemType.start
        indexedAccess.line = elemType.line
        indexedAccess.col = elemType.col
        indexedAccess.left = elemType
        indexedAccess.right = indexType
        elemType = indexedAccess
      }
    }
    
    return elemType
  }
  
  fn checkNext:boolean (value:string) {
    def nextPos (this.pos + 1)
    if (nextPos < (array_length this.tokens)) {
      def nextTok:Token (itemAt this.tokens nextPos)
      def v nextTok.value
      return (v == value)
    }
    return false
  }
  
  fn parsePrimaryType:TSNode () {
    def tokVal (this.peekValue())
    def tok (this.peek())
    
    ; keyof operator
    if (tokVal == "keyof") {
      this.advance()
      def operand (this.parsePrimaryType())
      def node (new TSNode())
      node.nodeType = "TSTypeOperator"
      node.value = "keyof"
      node.start = tok.start
      node.line = tok.line
      node.col = tok.col
      node.typeAnnotation = operand
      return node
    }
    
    ; typeof operator
    if (tokVal == "typeof") {
      this.advance()
      def operand (this.parsePrimaryType())
      def node (new TSNode())
      node.nodeType = "TSTypeQuery"
      node.value = "typeof"
      node.start = tok.start
      node.line = tok.line
      node.col = tok.col
      node.typeAnnotation = operand
      return node
    }
    
    ; infer keyword (for conditional types)
    if (tokVal == "infer") {
      this.advance()
      def paramTok (this.expect("Identifier"))
      def node (new TSNode())
      node.nodeType = "TSInferType"
      node.start = tok.start
      node.line = tok.line
      node.col = tok.col
      
      def typeParam (new TSNode())
      typeParam.nodeType = "TSTypeParameter"
      typeParam.name = paramTok.value
      node.typeAnnotation = typeParam
      
      return node
    }
    
    ; Primitive types
    if (tokVal == "string") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSStringKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "number") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSNumberKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "boolean") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSBooleanKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "any") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSAnyKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "unknown") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSUnknownKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "void") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSVoidKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "null") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSNullKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "never") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSNeverKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    if (tokVal == "undefined") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSUndefinedKeyword"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      return node
    }
    
    ; Type reference (Identifier)
    def tokType (this.peekType())
    if (tokType == "Identifier") {
      return (this.parseTypeRef())
    }
    
    ; String literal type ("left", "right")
    if (tokType == "String") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSLiteralType"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      node.value = tok.value
      node.kind = "string"
      return node
    }
    
    ; Number literal type (1, 2, 3)
    if (tokType == "Number") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSLiteralType"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      node.value = tok.value
      node.kind = "number"
      return node
    }
    
    ; Boolean literal types (true, false)
    if ((tokVal == "true") || (tokVal == "false")) {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSLiteralType"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      node.value = tokVal
      node.kind = "boolean"
      return node
    }
    
    ; Template literal type (`Hello ${string}`)
    if (tokType == "Template") {
      this.advance()
      def node (new TSNode())
      node.nodeType = "TSTemplateLiteralType"
      node.start = tok.start
      node.end = tok.end
      node.line = tok.line
      node.col = tok.col
      node.value = tok.value
      return node
    }
    
    ; Constructor type: new (params) => Type
    if (tokVal == "new") {
      return (this.parseConstructorType())
    }
    
    ; Import type: import("path").Type
    if (tokVal == "import") {
      return (this.parseImportType())
    }
    
    ; Parenthesized type or function type
    if (tokVal == "(") {
      return (this.parseParenOrFunctionType())
    }
    
    ; Tuple type [type, type]
    if (tokVal == "[") {
      return (this.parseTupleType())
    }
    
    ; Object type literal { prop: type }
    if (tokVal == "{") {
      return (this.parseTypeLiteral())
    }
    
    ; Fallback
    if (this.quiet == false) {
      print "Unknown type: " + tokVal
    }
    this.advance()
    def errNode (new TSNode())
    errNode.nodeType = "TSAnyKeyword"
    return errNode
  }
  
  fn parseTypeRef:TSNode () {
    def ref (new TSNode())
    ref.nodeType = "TSTypeReference"
    def tok (this.peek())
    ref.start = tok.start
    ref.line = tok.line
    ref.col = tok.col
    
    def nameTok (this.expect("Identifier"))
    ref.name = nameTok.value
    
    ; Generic type arguments
    if (this.matchValue("<")) {
      this.advance()
      
      while (((this.matchValue(">")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length ref.params) > 0) {
          this.expectValue(",")
        }
        def typeArg (this.parseType())
        push ref.params typeArg
      }
      
      this.expectValue(">")
    }
    
    return ref
  }
  
  ; === Tuple Type [type, type, ...] ===
  
  fn parseTupleType:TSNode () {
    def tuple (new TSNode())
    tuple.nodeType = "TSTupleType"
    def startTok (this.peek())
    tuple.start = startTok.start
    tuple.line = startTok.line
    tuple.col = startTok.col
    
    this.expectValue("[")
    
    while (((this.matchValue("]")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length tuple.children) > 0) {
        this.expectValue(",")
      }
      
      ; Check for rest element ...type or ...name: type
      if (this.matchValue("...")) {
        def restTok (this.peek())
        this.advance()
        
        ; Check for named rest element ...name: type
        def restName ""
        if (this.matchType("Identifier")) {
          def savedPos this.pos
          def savedTok:Token (unwrap this.currentToken)
          def nameTok (this.peek())
          this.advance()
          if (this.matchValue(":")) {
            restName = nameTok.value
            this.advance()
          } {
            ; Not named, backtrack
            this.pos = savedPos
            this.currentToken = savedTok
          }
        }
        
        def innerType (this.parseType())
        def restType (new TSNode())
        restType.nodeType = "TSRestType"
        restType.start = restTok.start
        restType.line = restTok.line
        restType.col = restTok.col
        restType.typeAnnotation = innerType
        if (restName != "") {
          restType.name = restName
        }
        push tuple.children restType
      } {
        ; Check for named tuple element: name: type or name?: type
        def isNamed false
        def elemName ""
        def elemOptional false
        def elemStart (this.peek())
        
        if (this.matchType("Identifier")) {
          def savedPos this.pos
          def savedTok:Token (unwrap this.currentToken)
          def nameTok (this.peek())
          this.advance()
          
          ; Check for optional marker
          if (this.matchValue("?")) {
            this.advance()
            elemOptional = true
          }
          
          if (this.matchValue(":")) {
            ; This is a named tuple element
            isNamed = true
            elemName = nameTok.value
            this.advance()
          } {
            ; Not named, backtrack
            this.pos = savedPos
            this.currentToken = savedTok
            elemOptional = false
          }
        }
        
        def elemType (this.parseType())
        
        if (isNamed) {
          def namedElem (new TSNode())
          namedElem.nodeType = "TSNamedTupleMember"
          namedElem.start = elemStart.start
          namedElem.line = elemStart.line
          namedElem.col = elemStart.col
          namedElem.name = elemName
          namedElem.optional = elemOptional
          namedElem.typeAnnotation = elemType
          push tuple.children namedElem
        } {
          ; Check for optional element type?
          if (this.matchValue("?")) {
            this.advance()
            def optType (new TSNode())
            optType.nodeType = "TSOptionalType"
            optType.start = elemType.start
            optType.line = elemType.line
            optType.col = elemType.col
            optType.typeAnnotation = elemType
            push tuple.children optType
          } {
            push tuple.children elemType
          }
        }
      }
    }
    
    this.expectValue("]")
    return tuple
  }
  
  ; === Parenthesized or Function Type ===
  ; (type) or (param: type) => returnType
  
  fn parseParenOrFunctionType:TSNode () {
    def startTok (this.peek())
    def startPos startTok.start
    def startLine startTok.line
    def startCol startTok.col
    
    this.expectValue("(")
    
    ; Empty parameter list - must be function type () => T
    if (this.matchValue(")")) {
      this.advance()
      if (this.matchValue("=>")) {
        this.advance()
        def returnType (this.parseType())
        def funcType (new TSNode())
        funcType.nodeType = "TSFunctionType"
        funcType.start = startPos
        funcType.line = startLine
        funcType.col = startCol
        funcType.typeAnnotation = returnType
        return funcType
      }
      ; Empty parens without => - return void type
      def voidNode (new TSNode())
      voidNode.nodeType = "TSVoidKeyword"
      return voidNode
    }
    
    ; Check if this looks like function params (identifier followed by : or ?)
    def isIdentifier (this.matchType("Identifier"))
    if (isIdentifier) {
      ; Save position for backtracking
      def savedPos this.pos
      def savedToken:Token (unwrap this.currentToken)
      
      this.advance() ; consume identifier
      
      ; If followed by : or ?, it's a function type parameter
      if ((this.matchValue(":")) || (this.matchValue("?"))) {
        ; Reset and parse as function type
        this.pos = savedPos
        this.currentToken = savedToken
        return (this.parseFunctionType(startPos startLine startCol))
      }
      
      ; If followed by , it could still be function type with untyped params
      if (this.matchValue(",")) {
        ; Look ahead for => after closing paren
        def savedPos2 this.pos
        def savedToken2:Token (unwrap this.currentToken)
        
        ; Skip to )
        def depth 1
        while ((depth > 0) && ((this.isAtEnd()) == false)) {
          if (this.matchValue("(")) {
            depth = depth + 1
          }
          if (this.matchValue(")")) {
            depth = depth - 1
          }
          if (depth > 0) {
            this.advance()
          }
        }
        
        if (this.matchValue(")")) {
          this.advance()
          if (this.matchValue("=>")) {
            ; It's a function type - backtrack and parse properly
            this.pos = savedPos
            this.currentToken = savedToken
            return (this.parseFunctionType(startPos startLine startCol))
          }
        }
        
        ; Not a function type - backtrack and parse as parenthesized
        this.pos = savedPos
        this.currentToken = savedToken
      }
      
      ; Reset position
      this.pos = savedPos
      this.currentToken = savedToken
    }
    
    ; Parse as parenthesized type
    def innerType (this.parseType())
    this.expectValue(")")
    
    ; Check if followed by => (makes it a function type)
    if (this.matchValue("=>")) {
      this.advance()
      def returnType (this.parseType())
      def funcType (new TSNode())
      funcType.nodeType = "TSFunctionType"
      funcType.start = startPos
      funcType.line = startLine
      funcType.col = startCol
      funcType.typeAnnotation = returnType
      return funcType
    }
    
    return innerType
  }
  
  fn parseFunctionType:TSNode (startPos:int startLine:int startCol:int) {
    def funcType (new TSNode())
    funcType.nodeType = "TSFunctionType"
    funcType.start = startPos
    funcType.line = startLine
    funcType.col = startCol
    
    ; Parse function type parameters
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length funcType.params) > 0) {
        this.expectValue(",")
      }
      
      def param (new TSNode())
      param.nodeType = "Parameter"
      
      def nameTok (this.expect("Identifier"))
      param.name = nameTok.value
      param.start = nameTok.start
      param.line = nameTok.line
      param.col = nameTok.col
      
      ; Optional marker
      if (this.matchValue("?")) {
        param.optional = true
        this.advance()
      }
      
      ; Type annotation
      if (this.matchValue(":")) {
        def typeAnnot (this.parseTypeAnnotation())
        param.typeAnnotation = typeAnnot
      }
      
      push funcType.params param
    }
    
    this.expectValue(")")
    
    ; Parse return type after =>
    if (this.matchValue("=>")) {
      this.advance()
      def returnType (this.parseType())
      funcType.typeAnnotation = returnType
    }
    
    return funcType
  }
  
  ; === Constructor Type: new (params) => Type ===
  
  fn parseConstructorType:TSNode () {
    def ctorType (new TSNode())
    ctorType.nodeType = "TSConstructorType"
    def startTok (this.peek())
    ctorType.start = startTok.start
    ctorType.line = startTok.line
    ctorType.col = startTok.col
    
    this.expectValue("new")
    
    ; Type parameters <T>
    if (this.matchValue("<")) {
      def typeParams (this.parseTypeParams())
      ctorType.children = typeParams
    }
    
    ; Parameters
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length ctorType.params) > 0) {
        this.expectValue(",")
      }
      def param (this.parseParam())
      push ctorType.params param
    }
    this.expectValue(")")
    
    ; Return type
    if (this.matchValue("=>")) {
      this.advance()
      def returnType (this.parseType())
      ctorType.typeAnnotation = returnType
    }
    
    return ctorType
  }
  
  ; === Import Type: import("path").Member ===
  
  fn parseImportType:TSNode () {
    def importType (new TSNode())
    importType.nodeType = "TSImportType"
    def startTok (this.peek())
    importType.start = startTok.start
    importType.line = startTok.line
    importType.col = startTok.col
    
    this.expectValue("import")
    this.expectValue("(")
    
    def sourceTok (this.expect("String"))
    importType.value = sourceTok.value
    
    this.expectValue(")")
    
    ; Optional member access .Member
    if (this.matchValue(".")) {
      this.advance()
      def memberTok (this.expect("Identifier"))
      importType.name = memberTok.value
      
      ; Generic type args <T>
      if (this.matchValue("<")) {
        this.advance()
        while (((this.matchValue(">")) == false) && ((this.isAtEnd()) == false)) {
          if ((array_length importType.params) > 0) {
            this.expectValue(",")
          }
          def typeArg (this.parseType())
          push importType.params typeArg
        }
        this.expectValue(">")
      }
    }
    
    return importType
  }
  
  ; === Object Type Literal { prop: type } ===
  
  fn parseTypeLiteral:TSNode () {
    def literal (new TSNode())
    literal.nodeType = "TSTypeLiteral"
    def startTok (this.peek())
    literal.start = startTok.start
    literal.line = startTok.line
    literal.col = startTok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      def member (this.parseTypeLiteralMember())
      push literal.children member
      
      if ((this.matchValue(";")) || (this.matchValue(","))) {
        this.advance()
      }
    }
    
    this.expectValue("}")
    return literal
  }
  
  fn parseTypeLiteralMember:TSNode () {
    def startTok (this.peek())
    def startPos startTok.start
    def startLine startTok.line
    def startCol startTok.col
    
    ; Check for readonly modifier (could be for mapped type or property)
    def isReadonly false
    if (this.matchValue("readonly")) {
      isReadonly = true
      this.advance()
    }
    
    ; Check for +/- modifiers (mapped types)
    def readonlyModifier ""
    if ((this.matchValue("+")) || (this.matchValue("-"))) {
      readonlyModifier = (this.peekValue())
      this.advance()
      if (this.matchValue("readonly")) {
        isReadonly = true
        this.advance()
      }
    }
    
    ; Check for index signature or mapped type: [key: type]: type or [K in keyof T]: T[K]
    if (this.matchValue("[")) {
      ; Need to look ahead to determine if this is mapped type or index signature
      ; Mapped type: [K in ...] 
      ; Index signature: [key: type]
      
      this.advance() ; consume [
      
      def paramName (this.expect("Identifier"))
      
      ; Check for 'in' keyword - indicates mapped type
      if (this.matchValue("in")) {
        return (this.parseMappedType(isReadonly readonlyModifier paramName.value startPos startLine startCol))
      }
      
      ; Otherwise it's an index signature
      return (this.parseIndexSignatureRest(isReadonly paramName startPos startLine startCol))
    }
    
    ; Property or method name
    def nameTok (this.expect("Identifier"))
    def memberName nameTok.value
    
    ; Check for optional marker
    def isOptional false
    if (this.matchValue("?")) {
      isOptional = true
      this.advance()
    }
    
    ; Check for method signature: name(params): returnType
    if (this.matchValue("(")) {
      return (this.parseMethodSignature(memberName isOptional startPos startLine startCol))
    }
    
    ; Property signature
    def prop (new TSNode())
    prop.nodeType = "TSPropertySignature"
    prop.start = startPos
    prop.line = startLine
    prop.col = startCol
    prop.name = memberName
    prop.readonly = isReadonly
    prop.optional = isOptional
    
    ; Type annotation
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      prop.typeAnnotation = typeAnnot
    }
    
    return prop
  }
  
  ; === Mapped Type { [K in keyof T]: T[K] } ===
  
  fn parseMappedType:TSNode (isReadonly:boolean readonlyMod:string paramName:string startPos:int startLine:int startCol:int) {
    def mapped (new TSNode())
    mapped.nodeType = "TSMappedType"
    mapped.start = startPos
    mapped.line = startLine
    mapped.col = startCol
    mapped.readonly = isReadonly
    if (readonlyMod != "") {
      mapped.kind = readonlyMod ; + or - for readonly modifier
    }
    
    this.expectValue("in")
    
    ; Parse type parameter: K in keyof T or K in T
    def typeParam (new TSNode())
    typeParam.nodeType = "TSTypeParameter"
    typeParam.name = paramName
    
    ; Parse constraint (what comes after 'in')
    def constraint (this.parseType())
    typeParam.typeAnnotation = constraint
    
    push mapped.params typeParam
    
    ; Optional 'as' clause for key remapping: [K in keyof T as NewKey]
    if (this.matchValue("as")) {
      this.advance()
      def nameType (this.parseType())
      mapped.right = nameType ; store the 'as' type
    }
    
    this.expectValue("]")
    
    ; Optional modifier for optionality +/- ?
    def optionalMod ""
    if ((this.matchValue("+")) || (this.matchValue("-"))) {
      optionalMod = (this.peekValue())
      this.advance()
    }
    if (this.matchValue("?")) {
      mapped.optional = true
      if (optionalMod != "") {
        mapped.value = optionalMod ; store +/- for optional
      }
      this.advance()
    }
    
    ; Type annotation
    if (this.matchValue(":")) {
      this.advance()
      def valueType (this.parseType())
      mapped.typeAnnotation = valueType
    }
    
    return mapped
  }
  
  ; === Index Signature (rest of parsing after [ and param name) ===
  
  fn parseIndexSignatureRest:TSNode (isReadonly:boolean paramTok:Token startPos:int startLine:int startCol:int) {
    def indexSig (new TSNode())
    indexSig.nodeType = "TSIndexSignature"
    indexSig.start = startPos
    indexSig.line = startLine
    indexSig.col = startCol
    indexSig.readonly = isReadonly
    
    ; Create param node from token
    def param (new TSNode())
    param.nodeType = "Parameter"
    param.name = paramTok.value
    param.start = paramTok.start
    param.line = paramTok.line
    param.col = paramTok.col
    
    ; Type annotation for param
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      param.typeAnnotation = typeAnnot
    }
    
    push indexSig.params param
    
    this.expectValue("]")
    
    ; Type annotation for index signature
    if (this.matchValue(":")) {
      def typeAnnot (this.parseTypeAnnotation())
      indexSig.typeAnnotation = typeAnnot
    }
    
    return indexSig
  }
  
  fn parseMethodSignature:TSNode (methodName:string isOptional:boolean startPos:int startLine:int startCol:int) {
    def method (new TSNode())
    method.nodeType = "TSMethodSignature"
    method.start = startPos
    method.line = startLine
    method.col = startCol
    method.name = methodName
    method.optional = isOptional
    
    ; Parse parameters
    this.expectValue("(")
    while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
      if ((array_length method.params) > 0) {
        this.expectValue(",")
      }
      def param (this.parseParam())
      push method.params param
    }
    this.expectValue(")")
    
    ; Return type annotation
    if (this.matchValue(":")) {
      def returnType (this.parseTypeAnnotation())
      method.typeAnnotation = returnType
    }
    
    return method
  }

  ; === Expression Parsing (simplified) ===
  
  fn parseExpr:TSNode () {
    return (this.parseAssign())
  }
  
  fn parseAssign:TSNode () {
    def left (this.parseNullishCoalescing())
    
    def tokVal (this.peekValue())
    
    ; Regular assignment
    if (tokVal == "=") {
      this.advance()
      def right (this.parseAssign())
      
      def assign (new TSNode())
      assign.nodeType = "AssignmentExpression"
      assign.value = "="
      assign.left = left
      assign.right = right
      assign.start = left.start
      assign.line = left.line
      assign.col = left.col
      return assign
    }
    
    ; Logical assignment operators: &&=, ||=, ??=
    if ((tokVal == "&&=") || (tokVal == "||=") || (tokVal == "??=")) {
      this.advance()
      def right (this.parseAssign())
      
      def assign (new TSNode())
      assign.nodeType = "AssignmentExpression"
      assign.value = tokVal
      assign.left = left
      assign.right = right
      assign.start = left.start
      assign.line = left.line
      assign.col = left.col
      return assign
    }
    
    return left
  }
  
  ; === Nullish Coalescing (??) ===
  
  fn parseNullishCoalescing:TSNode () {
    def left (this.parseTernary())
    
    while (this.matchValue("??")) {
      this.advance()
      def right (this.parseTernary())
      
      def nullish (new TSNode())
      nullish.nodeType = "LogicalExpression"
      nullish.value = "??"
      nullish.left = left
      nullish.right = right
      nullish.start = left.start
      nullish.line = left.line
      nullish.col = left.col
      left = nullish
    }
    
    return left
  }
  
  ; === Ternary/Conditional Expression (? :) ===
  
  fn parseTernary:TSNode () {
    def testExpr (this.parseLogicalOr())
    
    if (this.matchValue("?")) {
      this.advance()
      def consequentExpr (this.parseAssign())
      
      if (this.matchValue(":")) {
        this.advance()
        def alternateExpr (this.parseAssign())
        
        def cond (new TSNode())
        cond.nodeType = "ConditionalExpression"
        cond.start = testExpr.start
        cond.line = testExpr.line
        cond.col = testExpr.col
        cond.left = testExpr
        ; Set ESTree standard field names
        cond.test = testExpr
        cond.consequent = consequentExpr
        cond.alternate = alternateExpr
        return cond
      }
    }
    
    return testExpr
  }
  
  ; === Logical OR (||) ===
  
  fn parseLogicalOr:TSNode () {
    def left (this.parseLogicalAnd())
    
    while (this.matchValue("||")) {
      this.advance()
      def right (this.parseLogicalAnd())
      
      def expr (new TSNode())
      expr.nodeType = "BinaryExpression"
      expr.value = "||"
      expr.left = left
      expr.right = right
      expr.start = left.start
      expr.line = left.line
      expr.col = left.col
      left = expr
    }
    
    return left
  }
  
  ; === Logical AND (&&) ===
  
  fn parseLogicalAnd:TSNode () {
    def left (this.parseEquality())
    
    while (this.matchValue("&&")) {
      this.advance()
      def right (this.parseEquality())
      
      def expr (new TSNode())
      expr.nodeType = "BinaryExpression"
      expr.value = "&&"
      expr.left = left
      expr.right = right
      expr.start = left.start
      expr.line = left.line
      expr.col = left.col
      left = expr
    }
    
    return left
  }
  
  ; === Equality (==, !=, ===, !==) ===
  
  fn parseEquality:TSNode () {
    def left (this.parseComparison())
    
    def tokVal (this.peekValue())
    while ((tokVal == "==") || (tokVal == "!=") || (tokVal == "===") || (tokVal == "!==")) {
      def opTok (this.peek())
      this.advance()
      def right (this.parseComparison())
      
      def expr (new TSNode())
      expr.nodeType = "BinaryExpression"
      expr.value = opTok.value
      expr.left = left
      expr.right = right
      expr.start = left.start
      expr.line = left.line
      expr.col = left.col
      left = expr
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  ; === Comparison (<, >, <=, >=) ===
  
  fn parseComparison:TSNode () {
    def left (this.parseAdditive())
    
    def tokVal (this.peekValue())
    while ((tokVal == "<") || (tokVal == ">") || (tokVal == "<=") || (tokVal == ">=")) {
      ; In TSX mode, check if < might be a generic call
      if (tokVal == "<") {
        if (this.tsxMode == true) {
          if (left.nodeType == "Identifier") {
            if (this.startsWithLowerCase(left.name)) {
              if (this.looksLikeGenericCall()) {
                return left
              }
            }
          }
        }
      }
      
      def opTok (this.peek())
      this.advance()
      def right (this.parseAdditive())
      
      def expr (new TSNode())
      expr.nodeType = "BinaryExpression"
      expr.value = opTok.value
      expr.left = left
      expr.right = right
      expr.start = left.start
      expr.line = left.line
      expr.col = left.col
      left = expr
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  ; === Additive (+ -) ===
  ; Lower precedence than multiplicative

  fn parseAdditive:TSNode () {
    def left (this.parseMultiplicative())
    
    def tokVal (this.peekValue())
    while ((tokVal == "+") || (tokVal == "-")) {
      
      def opTok (this.peek())
      this.advance()
      def right (this.parseMultiplicative())
      
      def binExpr (new TSNode())
      binExpr.nodeType = "BinaryExpression"
      binExpr.value = opTok.value
      binExpr.left = left
      binExpr.right = right
      binExpr.start = left.start
      binExpr.line = left.line
      binExpr.col = left.col
      left = binExpr
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  ; === Multiplicative (* / % **) ===
  ; Higher precedence than additive

  fn parseMultiplicative:TSNode () {
    def left (this.parseUnary())
    
    def tokVal (this.peekValue())
    while ((tokVal == "*") || (tokVal == "/") || (tokVal == "%") || (tokVal == "**")) {
      
      def opTok (this.peek())
      this.advance()
      def right (this.parseUnary())
      
      def binExpr (new TSNode())
      binExpr.nodeType = "BinaryExpression"
      binExpr.value = opTok.value
      binExpr.left = left
      binExpr.right = right
      binExpr.start = left.start
      binExpr.line = left.line
      binExpr.col = left.col
      left = binExpr
      tokVal = (this.peekValue())
    }
    
    return left
  }
  
  fn parseUnary:TSNode () {
    def tokVal (this.peekValue())
    
    if ((tokVal == "!") || (tokVal == "-")) {
      def opTok (this.peek())
      this.advance()
      def arg (this.parseUnary())
      
      def unary (new TSNode())
      unary.nodeType = "UnaryExpression"
      unary.value = opTok.value
      unary.left = arg
      unary.start = opTok.start
      unary.line = opTok.line
      unary.col = opTok.col
      return unary
    }
    
    ; yield expression: yield value, yield* generator()
    if (tokVal == "yield") {
      def yieldTok (this.peek())
      this.advance()
      
      def yieldExpr (new TSNode())
      yieldExpr.nodeType = "YieldExpression"
      yieldExpr.start = yieldTok.start
      yieldExpr.line = yieldTok.line
      yieldExpr.col = yieldTok.col
      
      ; Check for yield* (delegation)
      if (this.matchValue("*")) {
        this.advance()
        yieldExpr.delegate = true
      }
      
      ; Parse argument if not at statement end
      def nextVal (this.peekValue())
      if ((nextVal != ";") && (nextVal != "}") && (nextVal != ",") && (nextVal != ")")) {
        yieldExpr.left = (this.parseAssign())
      }
      
      return yieldExpr
    }
    
    ; await expression
    if (tokVal == "await") {
      def awaitTok (this.peek())
      this.advance()
      def arg (this.parseUnary())
      
      def awaitExpr (new TSNode())
      awaitExpr.nodeType = "AwaitExpression"
      awaitExpr.left = arg
      awaitExpr.start = awaitTok.start
      awaitExpr.line = awaitTok.line
      awaitExpr.col = awaitTok.col
      return awaitExpr
    }
    
    ; Type assertion with angle brackets <Type>value
    ; In TSX mode, skip this if it looks like JSX (next is > for fragment, or Identifier for element)
    ; But NOT if it's <T extends ...> which is a generic type parameter
    if (tokVal == "<") {
      ; Check for JSX in TSX mode first
      if (this.tsxMode == true) {
        def peekNext (this.peekNextValue())
        def peekNextT (this.peekNextType())
        ; JSX Fragment <>
        if (peekNext == ">") {
          return (this.parsePostfix())
        }
        ; JSX Element <div ...> or <Component ...>
        ; But NOT if followed by "extends" which indicates generic: <T extends ...>
        if (peekNextT == "Identifier") {
          def peekTwoAhead (this.peekAheadValue(2))
          if (peekTwoAhead != "extends") {
            return (this.parsePostfix())
          }
          ; If we have <T extends, fall through to type parsing (generic arrow function)
        }
      }
      
      def startTok (this.peek())
      this.advance()
      
      ; Check if this looks like a type (starts with identifier, keyword, or TSType)
      def nextType (this.peekType())
      if ((nextType == "Identifier") || (nextType == "Keyword") || (nextType == "TSType")) {
        def typeNode (this.parseType())
        if (this.matchValue(">")) {
          this.advance()
          def arg (this.parseUnary())
          
          def assertion (new TSNode())
          assertion.nodeType = "TSTypeAssertion"
          assertion.typeAnnotation = typeNode
          assertion.left = arg
          assertion.start = startTok.start
          assertion.line = startTok.line
          assertion.col = startTok.col
          return assertion
        }
      }
    }
    
    return (this.parsePostfix())
  }
  
  ; === Postfix expressions: call, member access, optional chaining, non-null assertion ===
  
  fn parsePostfix:TSNode () {
    def expr (this.parsePrimary())
    
    def keepParsing true
    while (keepParsing) {
      def tokVal (this.peekValue())
      
      ; Generic function call with type arguments: foo<T>(x)
      ; In TSX mode, use heuristics to disambiguate from JSX
      if (tokVal == "<") {
        def shouldParseAsGenericCall false
        
        ; In non-TSX mode, < after identifier/call is likely generic
        if (this.tsxMode == false) {
          ; Check if followed by valid type args pattern - identifier then > or ,
          def next1 (this.peekAheadValue(1))
          def next2 (this.peekAheadValue(2))
          if ((next2 == ">") || (next2 == ",") || (next2 == "extends")) {
            shouldParseAsGenericCall = true
          }
        } {
          ; TSX mode - use lookahead heuristic
          ; Only try generic call if:
          ; 1. The expr is an identifier starting with lowercase (functions are usually lowercase)
          ; 2. Lookahead shows pattern like <Type>( 
          if (expr.nodeType == "Identifier") {
            if (this.startsWithLowerCase(expr.name)) {
              if (this.looksLikeGenericCall()) {
                shouldParseAsGenericCall = true
              }
            }
          }
          ; Also handle member expressions like obj.method<T>()
          if (expr.nodeType == "MemberExpression") {
            if (this.looksLikeGenericCall()) {
              shouldParseAsGenericCall = true
            }
          }
        }
        
        if (shouldParseAsGenericCall) {
          ; Parse type arguments <T, U, ...> directly into call node
          this.advance() ; consume <
          
          def call (new TSNode())
          call.nodeType = "CallExpression"
          call.left = expr
          call.start = expr.start
          call.line = expr.line
          call.col = expr.col
          
          ; Parse type arguments into params (use parseType, not parseTypeAnnotation which expects :)
          while (((this.matchValue(">")) == false) && ((this.isAtEnd()) == false)) {
            if ((array_length call.params) > 0) {
              this.expectValue(",")
            }
            def typeArg (this.parseType())
            push call.params typeArg
          }
          this.expectValue(">")
          
          ; Now expect ( for the call
          if (this.matchValue("(")) {
            this.advance()
            
            while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
              if ((array_length call.children) > 0) {
                this.expectValue(",")
              }
              if (this.matchValue("...")) {
                this.advance()
                def spreadArg (this.parseExpr())
                def spread (new TSNode())
                spread.nodeType = "SpreadElement"
                spread.left = spreadArg
                push call.children spread
              } {
                def arg (this.parseExpr())
                push call.children arg
              }
            }
            this.expectValue(")")
            expr = call
          }
        }
      }
      
      ; Re-check tokVal in case we consumed tokens above
      tokVal = (this.peekValue())
      
      ; Function call ()
      if (tokVal == "(") {
        this.advance()
        def call (new TSNode())
        call.nodeType = "CallExpression"
        call.left = expr
        call.start = expr.start
        call.line = expr.line
        call.col = expr.col
        
        while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
          if ((array_length call.children) > 0) {
            this.expectValue(",")
          }
          ; Check for spread argument ...arg
          if (this.matchValue("...")) {
            this.advance()
            def spreadArg (this.parseExpr())
            def spread (new TSNode())
            spread.nodeType = "SpreadElement"
            spread.left = spreadArg
            push call.children spread
          } {
            def arg (this.parseExpr())
            push call.children arg
          }
        }
        this.expectValue(")")
        expr = call
      }
      
      ; Member access .property
      if (tokVal == ".") {
        this.advance()
        def propTok (this.expect("Identifier"))
        def member (new TSNode())
        member.nodeType = "MemberExpression"
        member.left = expr
        member.name = propTok.value
        member.start = expr.start
        member.line = expr.line
        member.col = expr.col
        expr = member
      }
      
      ; Optional chaining ?.
      if (tokVal == "?.") {
        this.advance()
        def nextTokVal (this.peekValue())
        
        ; Optional call ?.()
        if (nextTokVal == "(") {
          this.advance()
          def optCall (new TSNode())
          optCall.nodeType = "OptionalCallExpression"
          optCall.optional = true
          optCall.left = expr
          optCall.start = expr.start
          optCall.line = expr.line
          optCall.col = expr.col
          
          while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
            if ((array_length optCall.children) > 0) {
              this.expectValue(",")
            }
            def arg (this.parseExpr())
            push optCall.children arg
          }
          this.expectValue(")")
          expr = optCall
        }
        
        ; Optional index ?.[expr]
        if (nextTokVal == "[") {
          this.advance()
          def indexExpr (this.parseExpr())
          this.expectValue("]")
          def optIndex (new TSNode())
          optIndex.nodeType = "OptionalMemberExpression"
          optIndex.optional = true
          optIndex.left = expr
          optIndex.right = indexExpr
          optIndex.start = expr.start
          optIndex.line = expr.line
          optIndex.col = expr.col
          expr = optIndex
        }
        
        ; Optional member access ?.property
        if (this.matchType("Identifier")) {
          def propTok (this.expect("Identifier"))
          def optMember (new TSNode())
          optMember.nodeType = "OptionalMemberExpression"
          optMember.optional = true
          optMember.left = expr
          optMember.name = propTok.value
          optMember.start = expr.start
          optMember.line = expr.line
          optMember.col = expr.col
          expr = optMember
        }
      }
      
      ; Computed member access [expr]
      if (tokVal == "[") {
        this.advance()
        def indexExpr (this.parseExpr())
        this.expectValue("]")
        def computed (new TSNode())
        computed.nodeType = "MemberExpression"
        computed.left = expr
        computed.right = indexExpr
        computed.start = expr.start
        computed.line = expr.line
        computed.col = expr.col
        expr = computed
      }
      
      ; Non-null assertion !
      ; Treat ! as non-null assertion in postfix position
      if (tokVal == "!") {
        def tok (this.peek())
        this.advance()
        def nonNull (new TSNode())
        nonNull.nodeType = "TSNonNullExpression"
        nonNull.left = expr
        nonNull.start = expr.start
        nonNull.line = expr.line
        nonNull.col = tok.col
        expr = nonNull
      }
      
      ; Type assertion with 'as' keyword
      if (tokVal == "as") {
        this.advance()
        def asType (this.parseType())
        def assertion (new TSNode())
        assertion.nodeType = "TSAsExpression"
        assertion.left = expr
        assertion.typeAnnotation = asType
        assertion.start = expr.start
        assertion.line = expr.line
        assertion.col = expr.col
        expr = assertion
      }
      
      ; Satisfies expression
      if (tokVal == "satisfies") {
        this.advance()
        def satisfiesType (this.parseType())
        def satisfiesExpr (new TSNode())
        satisfiesExpr.nodeType = "TSSatisfiesExpression"
        satisfiesExpr.left = expr
        satisfiesExpr.typeAnnotation = satisfiesType
        satisfiesExpr.start = expr.start
        satisfiesExpr.line = expr.line
        satisfiesExpr.col = expr.col
        expr = satisfiesExpr
      }
      
      ; Tagged template literal: tag`template`
      def tokType (this.peekType())
      if (tokType == "Template") {
        def quasi (this.parseTemplateLiteral())
        def tagged (new TSNode())
        tagged.nodeType = "TaggedTemplateExpression"
        tagged.left = expr
        tagged.right = quasi
        tagged.start = expr.start
        tagged.line = expr.line
        tagged.col = expr.col
        expr = tagged
      }
      
      ; Check if we should continue
      def newTokVal (this.peekValue())
      def newTokType (this.peekType())
      if ((newTokVal != "(") && (newTokVal != ".") && (newTokVal != "?.") && (newTokVal != "[") && (newTokVal != "!") && (newTokVal != "as") && (newTokVal != "satisfies") && (newTokType != "Template")) {
        keepParsing = false
      }
    }
    
    return expr
  }
  
  fn parsePrimary:TSNode () {
    def tokType (this.peekType())
    def tokVal (this.peekValue())
    def tok (this.peek())
    
    ; Identifier (including TSType keywords like 'symbol', 'string', 'number' used as variable names)
    if ((tokType == "Identifier") || (tokType == "TSType")) {
      this.advance()
      def id (new TSNode())
      id.nodeType = "Identifier"
      id.name = tok.value
      id.start = tok.start
      id.end = tok.end
      id.line = tok.line
      id.col = tok.col
      return id
    }
    
    ; Number literal
    if (tokType == "Number") {
      this.advance()
      def num (new TSNode())
      num.nodeType = "NumericLiteral"
      num.value = tok.value
      num.start = tok.start
      num.end = tok.end
      num.line = tok.line
      num.col = tok.col
      return num
    }
    
    ; BigInt literal
    if (tokType == "BigInt") {
      this.advance()
      def bigint (new TSNode())
      bigint.nodeType = "BigIntLiteral"
      bigint.value = tok.value
      bigint.start = tok.start
      bigint.end = tok.end
      bigint.line = tok.line
      bigint.col = tok.col
      return bigint
    }
    
    ; String literal
    if (tokType == "String") {
      this.advance()
      def str (new TSNode())
      str.nodeType = "StringLiteral"
      str.value = tok.value
      str.start = tok.start
      str.end = tok.end
      str.line = tok.line
      str.col = tok.col
      return str
    }
    
    ; Template literal
    if (tokType == "Template") {
      return (this.parseTemplateLiteral())
    }
    
    ; Boolean literal
    if ((tokVal == "true") || (tokVal == "false")) {
      this.advance()
      def bool (new TSNode())
      bool.nodeType = "BooleanLiteral"
      bool.value = tokVal
      bool.start = tok.start
      bool.end = tok.end
      bool.line = tok.line
      bool.col = tok.col
      return bool
    }
    
    ; null literal
    if (tokVal == "null") {
      this.advance()
      def nullLit (new TSNode())
      nullLit.nodeType = "NullLiteral"
      nullLit.start = tok.start
      nullLit.end = tok.end
      nullLit.line = tok.line
      nullLit.col = tok.col
      return nullLit
    }
    
    ; undefined
    if (tokVal == "undefined") {
      this.advance()
      def undefId (new TSNode())
      undefId.nodeType = "Identifier"
      undefId.name = "undefined"
      undefId.start = tok.start
      undefId.end = tok.end
      undefId.line = tok.line
      undefId.col = tok.col
      return undefId
    }
    
    ; Array literal [...]
    if (tokVal == "[") {
      return (this.parseArrayLiteral())
    }
    
    ; Object literal {...}
    if (tokVal == "{") {
      return (this.parseObjectLiteral())
    }
    
    ; JSX element in TSX mode
    if ((this.tsxMode == true) && (tokVal == "<")) {
      ; Check if this looks like JSX (not a comparison)
      def nextType (this.peekNextType())
      def nextVal (this.peekNextValue())
      ; Fragment <>
      if (nextVal == ">") {
        return (this.parseJSXFragment())
      }
      ; JSX element, but NOT if followed by "extends" (generic type parameter)
      if ((nextType == "Identifier") || (nextType == "Keyword")) {
        def peekTwoAhead (this.peekAheadValue(2))
        if (peekTwoAhead != "extends") {
          return (this.parseJSXElement())
        }
        ; If <T extends, this is a generic arrow function, not JSX
      }
    }
    
    ; Arrow function or parenthesized expression
    if (tokVal == "(") {
      return (this.parseParenOrArrow())
    }
    
    ; async arrow function
    if (tokVal == "async") {
      def nextVal (this.peekNextValue())
      def nextType (this.peekNextType())
      if ((nextVal == "(") || (nextType == "Identifier")) {
        return (this.parseArrowFunction())
      }
    }
    
    ; new expression
    if (tokVal == "new") {
      return (this.parseNewExpression())
    }
    
    ; Dynamic import: import("./mod.js") or import.meta
    if (tokVal == "import") {
      def importTok (this.peek())
      this.advance()
      
      ; Check for import.meta
      if (this.matchValue(".")) {
        this.advance()
        if (this.matchValue("meta")) {
          this.advance()
          def metaProp (new TSNode())
          metaProp.nodeType = "MetaProperty"
          metaProp.name = "import"
          metaProp.value = "meta"
          metaProp.start = importTok.start
          metaProp.line = importTok.line
          metaProp.col = importTok.col
          return metaProp
        }
      }
      
      ; Dynamic import()
      if (this.matchValue("(")) {
        this.advance()
        def source (this.parseExpr())
        this.expectValue(")")
        
        def importExpr (new TSNode())
        importExpr.nodeType = "ImportExpression"
        importExpr.left = source
        importExpr.start = importTok.start
        importExpr.line = importTok.line
        importExpr.col = importTok.col
        return importExpr
      }
    }
    
    ; this keyword
    if (tokVal == "this") {
      this.advance()
      def thisExpr (new TSNode())
      thisExpr.nodeType = "ThisExpression"
      thisExpr.start = tok.start
      thisExpr.end = tok.end
      thisExpr.line = tok.line
      thisExpr.col = tok.col
      return thisExpr
    }
    
    ; Fallback
    if (this.quiet == false) {
      print "Unexpected token: " + tokVal
    }
    this.advance()
    def errId (new TSNode())
    errId.nodeType = "Identifier"
    errId.name = "error"
    return errId
  }
  
  ; === Template Literal ===
  
  fn parseTemplateLiteral:TSNode () {
    def node (new TSNode())
    node.nodeType = "TemplateLiteral"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    ; Simple case: just consume the template token
    this.advance()
    def quasi (new TSNode())
    quasi.nodeType = "TemplateElement"
    quasi.value = tok.value
    push node.children quasi
    
    return node
  }
  
  ; === Array Literal ===
  
  fn parseArrayLiteral:TSNode () {
    def node (new TSNode())
    node.nodeType = "ArrayExpression"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("[")
    
    while (((this.matchValue("]")) == false) && ((this.isAtEnd()) == false)) {
      ; Check for spread element
      if (this.matchValue("...")) {
        this.advance()
        def spreadArg (this.parseExpr())
        def spread (new TSNode())
        spread.nodeType = "SpreadElement"
        spread.left = spreadArg
        push node.children spread
      } {
        ; Check for empty slot (elision)
        if (this.matchValue(",")) {
          ; Don't add anything, just skip
        } {
          def elem (this.parseExpr())
          push node.children elem
        }
      }
      
      if (this.matchValue(",")) {
        this.advance()
      }
    }
    
    this.expectValue("]")
    return node
  }
  
  ; === Object Literal ===
  
  fn parseObjectLiteral:TSNode () {
    def node (new TSNode())
    node.nodeType = "ObjectExpression"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("{")
    
    while (((this.matchValue("}")) == false) && ((this.isAtEnd()) == false)) {
      ; Check for spread property
      if (this.matchValue("...")) {
        this.advance()
        def spreadArg (this.parseExpr())
        def spread (new TSNode())
        spread.nodeType = "SpreadElement"
        spread.left = spreadArg
        push node.children spread
      } {
        def prop (new TSNode())
        prop.nodeType = "Property"
        
        ; Flags for property type
        def isComputed:boolean false
        def isMethod:boolean false
        def isGetter:boolean false
        def isSetter:boolean false
        def isAsync:boolean false
        
        ; Check for async - must look ahead to see if next is identifier or [
        def currVal (this.peekValue())
        def nextType (this.peekNextType())
        def nextVal (this.peekNextValue())
        
        if (currVal == "async") {
          if ((nextType == "Identifier") || (nextVal == "[") || (nextVal == "(")) {
            this.advance()
            isAsync = true
            prop.async = true
            ; Re-fetch current values after consuming async
            currVal = (this.peekValue())
            nextType = (this.peekNextType())
            nextVal = (this.peekNextValue())
          }
        }
        
        ; Check for getter/setter - must look ahead to see if next is identifier or [
        if (currVal == "get") {
          if ((nextType == "Identifier") || (nextVal == "[")) {
            this.advance()
            isGetter = true
            prop.kind = "get"
          }
        }
        if (currVal == "set") {
          if ((nextType == "Identifier") || (nextVal == "[")) {
            this.advance()
            isSetter = true
            prop.kind = "set"
          }
        }
        
        ; Now get the property key (after potentially consuming get/set)
        def keyTok (this.peek())
        
        ; Computed property key [expression]
        if (this.matchValue("[")) {
          this.advance()
          def keyExpr (this.parseExpr())
          this.expectValue("]")
          prop.right = keyExpr
          isComputed = true
          prop.computed = true
        }
        if (this.matchType("Identifier")) {
          prop.name = keyTok.value
          this.advance()
        }
        if (this.matchType("String")) {
          prop.name = keyTok.value
          this.advance()
        }
        if (this.matchType("Number")) {
          prop.name = keyTok.value
          this.advance()
        }
        
        ; Check for method shorthand or getter/setter: { foo() {} } or { get x() {} }
        if (this.matchValue("(")) {
          isMethod = true
          prop.method = true
          ; Parse method as function expression
          def fnNode (new TSNode())
          fnNode.nodeType = "FunctionExpression"
          this.advance()
          ; Parse parameters
          while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
            if ((array_length fnNode.params) > 0) {
              this.expectValue(",")
            }
            push fnNode.params (this.parseParam())
          }
          this.expectValue(")")
          ; Parse optional return type
          if (this.matchValue(":")) {
            this.advance()
            fnNode.typeAnnotation = (this.parseType())
          }
          ; Parse body
          if (this.matchValue("{")) {
            fnNode.body = (this.parseBlock())
          }
          prop.left = fnNode
          ; ESTree: kind is "get", "set", or "init" for methods
          if ((isGetter == false) && (isSetter == false)) {
            prop.kind = "init"
          }
        }
        
        ; Check for shorthand property (no colon) or regular property
        if (isMethod == false) {
          if (this.matchValue(":")) {
            this.advance()
            def valueExpr (this.parseExpr())
            prop.left = valueExpr
            prop.kind = "init"
          } {
            ; Shorthand: { foo } means { foo: foo }
            ; But not for computed properties
            if (isComputed == false) {
              def shorthandVal (new TSNode())
              shorthandVal.nodeType = "Identifier"
              shorthandVal.name = prop.name
              prop.left = shorthandVal
              prop.shorthand = true
              prop.kind = "init"
            }
          }
        }
        
        push node.children prop
      }
      
      if (this.matchValue(",")) {
        this.advance()
      }
    }
    
    this.expectValue("}")
    return node
  }
  
  ; === Paren or Arrow Function ===
  
  fn parseParenOrArrow:TSNode () {
    def startTok (this.peek())
    
    ; Look ahead to determine if this is an arrow function
    ; Arrow function: (...) => or (...): Type =>
    def savedPos:int this.pos
    def savedTok:Token (unwrap this.currentToken)
    
    this.advance()  ; consume (
    
    ; Find matching )
    def parenDepth 1
    while ((parenDepth > 0) && ((this.isAtEnd()) == false)) {
      def v (this.peekValue())
      if (v == "(") {
        parenDepth = parenDepth + 1
      }
      if (v == ")") {
        parenDepth = parenDepth - 1
      }
      if (parenDepth > 0) {
        this.advance()
      }
    }
    
    if ((this.matchValue(")")) == false) {
      ; Error - restore and parse as parenthesized
      this.pos = savedPos
      this.currentToken = savedTok
      this.advance()
      def expr (this.parseExpr())
      this.expectValue(")")
      return expr
    }
    
    this.advance()  ; consume )
    
    ; Check for type annotation
    if (this.matchValue(":")) {
      this.advance()
      ; Skip the type
      this.parseType()
    }
    
    ; Check for =>
    if (this.matchValue("=>")) {
      ; It's an arrow function - restore and parse properly
      this.pos = savedPos
      this.currentToken = savedTok
      return (this.parseArrowFunction())
    }
    
    ; Not an arrow function - restore and parse as parenthesized expression
    this.pos = savedPos
    this.currentToken = savedTok
    this.advance()  ; consume (
    def expr (this.parseExpr())
    this.expectValue(")")
    return expr
  }
  
  ; === Arrow Function ===
  
  fn parseArrowFunction:TSNode () {
    def node (new TSNode())
    node.nodeType = "ArrowFunctionExpression"
    def startTok (this.peek())
    node.start = startTok.start
    node.line = startTok.line
    node.col = startTok.col
    
    ; Check for async
    if (this.matchValue("async")) {
      this.advance()
      node.kind = "async"
    }
    
    ; Parse parameters
    if (this.matchValue("(")) {
      this.advance()
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length node.params) > 0) {
          this.expectValue(",")
        }
        def param (this.parseParam())
        push node.params param
      }
      this.expectValue(")")
    } {
      ; Single identifier parameter: x =>
      def paramTok (this.expect("Identifier"))
      def param (new TSNode())
      param.nodeType = "Parameter"
      param.name = paramTok.value
      push node.params param
    }
    
    ; Optional return type annotation
    if (this.matchValue(":")) {
      this.advance()
      def retType (this.parseType())
      node.typeAnnotation = retType
    }
    
    this.expectValue("=>")
    
    ; Parse body: expression or block
    if (this.matchValue("{")) {
      def body (this.parseBlock())
      node.body = body
    } {
      def body (this.parseExpr())
      node.body = body
    }
    
    return node
  }
  
  ; === New Expression ===
  
  fn parseNewExpression:TSNode () {
    def node (new TSNode())
    node.nodeType = "NewExpression"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("new")
    
    ; Check for new.target meta property
    if (this.matchValue(".")) {
      this.advance()
      if (this.matchValue("target")) {
        this.advance()
        node.nodeType = "MetaProperty"
        node.name = "new"
        node.value = "target"
        return node
      }
    }
    
    ; Parse callee
    def callee (this.parsePrimary())
    node.left = callee
    
    ; Parse type arguments <T> - skip for now
    if (this.matchValue("<")) {
      ; Skip type args by finding matching >
      def depth 1
      this.advance()
      while ((depth > 0) && ((this.isAtEnd()) == false)) {
        def v (this.peekValue())
        if (v == "<") {
          depth = depth + 1
        }
        if (v == ">") {
          depth = depth - 1
        }
        this.advance()
      }
    }
    
    ; Parse arguments
    if (this.matchValue("(")) {
      this.advance()
      while (((this.matchValue(")")) == false) && ((this.isAtEnd()) == false)) {
        if ((array_length node.children) > 0) {
          this.expectValue(",")
        }
        def arg (this.parseExpr())
        push node.children arg
      }
      this.expectValue(")")
    }
    
    return node
  }
  
  ; === Helper: peek next token type ===
  
  fn peekNextType:string () {
    def nextPos (this.pos + 1)
    if (nextPos < (array_length this.tokens)) {
      def nextTok:Token (itemAt this.tokens nextPos)
      return nextTok.tokenType
    }
    return "EOF"
  }
  
  ; === Helper: peek N tokens ahead value ===
  
  fn peekAheadValue:string (offset:int) {
    def aheadPos (this.pos + offset)
    if (aheadPos < (array_length this.tokens)) {
      def tok:Token (itemAt this.tokens aheadPos)
      return tok.value
    }
    return ""
  }
  
  ; === Helper: check if string starts with lowercase letter ===
  fn startsWithLowerCase:boolean (s:string) {
    if ((strlen s) == 0) {
      return false
    }
    ; charAt returns the char code in Ranger
    def code:int (charAt s 0)
    ; a-z are ASCII 97-122
    if ((code >= 97) && (code <= 122)) {
      return true
    }
    return false
  }
  
  ; === Helper: lookahead to check if < starts a generic call like foo<T>(x) ===
  ; Returns true if this looks like a generic function call, not JSX
  ; Simple heuristic: scan for matching > then check for (
  fn looksLikeGenericCall:boolean () {
    def depth 1
    def offset 1
    def maxLookahead 20
    
    while ((depth > 0) && (offset < maxLookahead)) {
      def ahead (this.peekAheadValue(offset))
      if (ahead == "") {
        return false
      }
      if (ahead == "<") {
        depth = (depth + 1)
      }
      if (ahead == ">") {
        depth = (depth - 1)
      }
      ; If we see things that can't appear in type arguments, bail
      if ((ahead == "{") || (ahead == "}") || (ahead == ";") || (ahead == "=>")) {
        return false
      }
      offset = (offset + 1)
    }
    
    ; If depth is 0, we found matching >
    ; Check if next token after > is (
    if (depth == 0) {
      def afterClose (this.peekAheadValue(offset))
      if (afterClose == "(") {
        return true
      }
    }
    return false
  }
  
  ; === JSX Parsing (TSX Mode) ===
  
  fn parseJSXElement:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXElement"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    ; Parse opening element <Component ...>
    def opening (this.parseJSXOpeningElement())
    node.left = opening
    
    ; Check if self-closing
    if (opening.kind == "self-closing") {
      node.nodeType = "JSXElement"
      return node
    }
    
    ; Parse children
    def tagName opening.name
    while ((this.isAtEnd()) == false) {
      def v (this.peekValue())
      
      ; Check for closing tag
      if (v == "<") {
        def nextVal (this.peekNextValue())
        if (nextVal == "/") {
          ; This is a closing tag
          break
        }
        ; Nested JSX element
        def child (this.parseJSXElement())
        push node.children child
      } {
        ; Text or expression
        if (v == "{") {
          def exprChild (this.parseJSXExpressionContainer())
          push node.children exprChild
        } {
          ; Check for text content (anything that's not < or {)
          def t (this.peekType())
          if ((t != "EOF") && (v != "<") && (v != "{")) {
            def textChild (this.parseJSXText())
            push node.children textChild
          } {
            break
          }
        }
      }
    }
    
    ; Parse closing element </Component>
    def closing (this.parseJSXClosingElement())
    node.right = closing
    
    return node
  }
  
  fn parseJSXOpeningElement:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXOpeningElement"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("<")
    
    ; Parse tag name (can be Identifier or MemberExpression like Foo.Bar)
    def tagName (this.parseJSXElementName())
    node.name = tagName.name
    node.left = tagName
    
    ; Parse attributes
    while ((this.isAtEnd()) == false) {
      def v (this.peekValue())
      if ((v == ">") || (v == "/")) {
        break
      }
      def attr (this.parseJSXAttribute())
      push node.children attr
    }
    
    ; Check for self-closing />
    if (this.matchValue("/")) {
      this.advance()
      node.kind = "self-closing"
    }
    
    this.expectValue(">")
    
    return node
  }
  
  fn parseJSXClosingElement:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXClosingElement"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("<")
    this.expectValue("/")
    
    ; Parse tag name
    def tagName (this.parseJSXElementName())
    node.name = tagName.name
    node.left = tagName
    
    this.expectValue(">")
    
    return node
  }
  
  fn parseJSXElementName:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXIdentifier"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    ; First part of name
    def namePart tok.value
    this.advance()
    
    ; Check for member expression (Foo.Bar)
    while (this.matchValue(".")) {
      this.advance()
      def nextTok (this.peek())
      namePart = namePart + "." + nextTok.value
      this.advance()
      node.nodeType = "JSXMemberExpression"
    }
    
    node.name = namePart
    return node
  }
  
  fn parseJSXAttribute:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXAttribute"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    ; Check for spread attribute {...props}
    if (this.matchValue("{")) {
      this.advance()
      if (this.matchValue("...")) {
        this.advance()
        node.nodeType = "JSXSpreadAttribute"
        def arg (this.parseExpr())
        node.left = arg
        this.expectValue("}")
        return node
      }
      ; Go back - this shouldn't happen in valid JSX
      ; But handle it gracefully
    }
    
    ; Parse attribute name
    def attrName tok.value
    node.name = attrName
    this.advance()
    
    ; Check for = and value
    if (this.matchValue("=")) {
      this.advance()
      
      def valTok (this.peekValue())
      if (valTok == "{") {
        ; JSX expression
        def exprValue (this.parseJSXExpressionContainer())
        node.right = exprValue
      } {
        ; String literal
        def strTok (this.peek())
        def strNode (new TSNode())
        strNode.nodeType = "StringLiteral"
        strNode.value = strTok.value
        strNode.start = strTok.start
        strNode.end = strTok.end
        strNode.line = strTok.line
        strNode.col = strTok.col
        this.advance()
        node.right = strNode
      }
    }
    
    return node
  }
  
  fn parseJSXExpressionContainer:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXExpressionContainer"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    this.expectValue("{")
    
    ; Check for empty expression
    if (this.matchValue("}")) {
      def empty (new TSNode())
      empty.nodeType = "JSXEmptyExpression"
      node.left = empty
    } {
      def expr (this.parseExpr())
      node.left = expr
    }
    
    this.expectValue("}")
    
    return node
  }
  
  fn parseJSXText:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXText"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    node.value = tok.value
    
    this.advance()
    
    return node
  }
  
  ; === JSX Fragment <>...</> ===
  
  fn parseJSXFragment:TSNode () {
    def node (new TSNode())
    node.nodeType = "JSXFragment"
    def tok (this.peek())
    node.start = tok.start
    node.line = tok.line
    node.col = tok.col
    
    ; Opening <>
    this.expectValue("<")
    this.expectValue(">")
    
    ; Parse children
    while ((this.isAtEnd()) == false) {
      def v (this.peekValue())
      
      if (v == "<") {
        def nextVal (this.peekNextValue())
        if (nextVal == "/") {
          ; Check if it's closing fragment
          break
        }
        def child (this.parseJSXElement())
        push node.children child
      } {
        if (v == "{") {
          def exprChild (this.parseJSXExpressionContainer())
          push node.children exprChild
        } {
          def t (this.peekType())
          if ((t != "EOF") && (v != "<") && (v != "{")) {
            def textChild (this.parseJSXText())
            push node.children textChild
          } {
            break
          }
        }
      }
    }
    
    ; Closing </>
    this.expectValue("<")
    this.expectValue("/")
    this.expectValue(">")
    
    return node
  }
}
