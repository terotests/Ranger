; Helper class to hold a list of method names (for call graph)
class MethodCallList {
  def calls:[string]
  
  Constructor () {
    def c:[string]
    calls = c
  }
  
  fn add:void (methodName:string) {
    push calls methodName
  }
}

class RangerRustClassWriter {
  Extends (RangerGenericClassWriter)
  def compiler:LiveCompiler
  def thisName:string "self"
  def fileHeaderWritten:boolean false
  
  ; Rust needs semicolons at end of statements
  fn lineEnding:string () {
    return ";"
  }
  
  ; Escape Rust reserved words by prefixing with r#
  fn adjustType:string (tn:string) {
    switch tn {
      case "type" { return "r#type" }
      case "static" { return "r#static" }
      case "async" { return "r#async" }
      case "await" { return "r#await" }
      case "dyn" { return "r#dyn" }
      case "impl" { return "r#impl" }
      case "trait" { return "r#trait" }
      case "mod" { return "r#mod" }
      case "pub" { return "r#pub" }
      case "use" { return "r#use" }
      case "extern" { return "r#extern" }
      case "crate" { return "r#crate" }
      case "super" { return "r#super" }
      case "where" { return "r#where" }
      case "unsafe" { return "r#unsafe" }
      case "move" { return "r#move" }
      case "ref" { return "r#ref" }
      case "mut" { return "r#mut" }
      case "const" { return "r#const" }
      case "match" { return "r#match" }
      case "as" { return "r#as" }
      case "abstract" { return "r#abstract" }
      case "become" { return "r#become" }
      case "box" { return "r#box" }
      case "do" { return "r#do" }
      case "final" { return "r#final" }
      case "macro" { return "r#macro" }
      case "override" { return "r#override" }
      case "priv" { return "r#priv" }
      case "typeof" { return "r#typeof" }
      case "unsized" { return "r#unsized" }
      case "virtual" { return "r#virtual" }
      case "yield" { return "r#yield" }
      case "try" { return "r#try" }
    }
    return tn
  }
  
  fn WriteScalarValue (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    switch node.value_type {
      case RangerNodeType.Double {
        wr.out((("" + node.double_value) + "_f64") false)
      }
      case RangerNodeType.String {
        def s:string (this.EncodeString(node ctx wr))
        wr.out(((("\"" + s) + "\"") + ".to_string()") false)
      }
      case RangerNodeType.Integer {
        wr.out(("" + node.int_value) false)
      }
      case RangerNodeType.Boolean {
        if node.boolean_value {
          wr.out("true" false)
        } {
          wr.out("false" false)
        }
      }
    }
  }
  fn getObjectTypeString:string (type_string:string ctx:RangerAppWriterContext) {
    switch type_string {
      case "int" {
        return "i64"
      }
      case "string" {
        return "String"
      }
      case "boolean" {
        return "bool"
      }
      case "double" {
        return "f64"
      }
      case "buffer" {
        return "Vec<u8>"
      }
      case "int_buffer" {
        return "Vec<i64>"
      }
      case "double_buffer" {
        return "Vec<f64>"
      }
    }
    ; Check if this type is a trait type (class is extended by other classes)
    def typeClass@(optional):RangerAppClassDesc (ctx.findClass(type_string))
    if (!null? typeClass) {
      def tc:RangerAppClassDesc (unwrap typeClass)
      if tc.is_extended_by_children {
        return ("Rc<RefCell<dyn " + type_string + "Trait>>")
      }
    }
    return type_string
  }
  fn getTypeString:string (type_string:string) {
    switch type_string {
      case "int" {
        return "i64"
      }
      case "string" {
        return "String"
      }
      case "boolean" {
        return "bool"
      }
      case "double" {
        return "f64"
      }
      case "buffer" {
        return "Vec<u8>"
      }
      case "int_buffer" {
        return "Vec<i64>"
      }
      case "double_buffer" {
        return "Vec<f64>"
      }
    }
    return type_string
  }
  fn writeTypeDef:void (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    def is_optional:boolean (node.hasFlag("optional"))
    def is_weak:boolean (node.hasFlag("weak"))
    def is_self_referential:boolean false
    
    ; Check if this is a self-referential type (field type == current class)
    def uc@(optional):RangerAppClassDesc (ctx.getCurrentClass())
    
    ; Check if current class is trait-related (is a trait parent or extends one)
    def class_is_trait_related:boolean false
    if (!null? uc) {
      def currClass:RangerAppClassDesc (unwrap uc)
      if (node.type_name == currClass.name) {
        is_self_referential = true
      }
      ; Check if class is a trait parent
      if currClass.is_extended_by_children {
        class_is_trait_related = true
      }
      ; Check if class extends a trait parent
      if (class_is_trait_related == false) {
        for currClass.extends_classes extParentName:string epi {
          def extParentClass@(optional):RangerAppClassDesc (ctx.findClass(extParentName))
          if (!null? extParentClass) {
            def epc:RangerAppClassDesc (unwrap extParentClass)
            if epc.is_extended_by_children {
              class_is_trait_related = true
            }
          }
        }
      }
    }
    
    ; Check if the field type is a trait type (will be wrapped in Rc<RefCell<dyn Trait>>)
    def field_type_is_trait:boolean false
    def typeClass@(optional):RangerAppClassDesc (ctx.findClass(node.type_name))
    if (!null? typeClass) {
      def tc:RangerAppClassDesc (unwrap typeClass)
      if tc.is_extended_by_children {
        field_type_is_trait = true
      }
    }
    
    ; Determine if we need to wrap in RefCell for interior mutability
    ; This is needed when: class is trait-related, field is optional, field is NOT a trait type
    def needs_refcell_wrap:boolean ((class_is_trait_related && is_optional) && (field_type_is_trait == false))
    ; Only wrap object types in RefCell (not primitives, arrays, etc.)
    def is_object_type:boolean false
    def v_type_check:RangerNodeType node.value_type
    if ((v_type_check == RangerNodeType.Object) || (v_type_check == RangerNodeType.VRef) || (v_type_check == RangerNodeType.NoType)) {
      v_type_check = (node.typeNameAsType(ctx))
    }
    if (node.eval_type != RangerNodeType.NoType) {
      v_type_check = node.eval_type
    }
    ; Check if it's an object type (not primitive, array, hash, etc.)
    if ((((((((v_type_check != RangerNodeType.Integer) && (v_type_check != RangerNodeType.Double)) && (v_type_check != RangerNodeType.String)) && (v_type_check != RangerNodeType.Boolean)) && (v_type_check != RangerNodeType.Char)) && (v_type_check != RangerNodeType.Array)) && (v_type_check != RangerNodeType.Hash)) && (v_type_check != RangerNodeType.Buffer)) {
      is_object_type = true
    }
    if (is_object_type == false) {
      needs_refcell_wrap = false
    }
    
    ; Handle weak references - uses Weak<RefCell<T>> to break reference cycles
    if is_weak {
      if is_optional {
        wr.out("Option<Weak<RefCell<" false)
      } {
        wr.out("Weak<RefCell<" false)
      }
    } {
      if is_optional {
        if is_self_referential {
          ; Self-referential optional fields need Box to break infinite recursion
          wr.out("Option<Box<" false)
        } {
          if needs_refcell_wrap {
            ; Wrap in RefCell for interior mutability in trait-related classes
            wr.out("Option<RefCell<" false)
          } {
            wr.out("Option<" false)
          }
        }
      }
    }
    def v_type:RangerNodeType node.value_type
    if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.VRef) || (v_type == RangerNodeType.NoType)) {
      v_type = (node.typeNameAsType(ctx))
    }
    if (node.eval_type != RangerNodeType.NoType) {
      v_type = node.eval_type
    }
    switch v_type {
      case RangerNodeType.Enum {
        wr.out("i64" false)
      }
      case RangerNodeType.Integer {
        wr.out("i64" false)
      }
      case RangerNodeType.Double {
        wr.out("f64" false)
      }
      case RangerNodeType.String {
        wr.out("String" false)
      }
      case RangerNodeType.Boolean {
        wr.out("bool" false)
      }
      case RangerNodeType.Char {
        wr.out("i64" false)
      }
      case RangerNodeType.CharBuffer {
        wr.out("Vec<u8>" false)
      }
      case RangerNodeType.Buffer {
        wr.out("Vec<u8>" false)
      }
      case RangerNodeType.IntBuffer {
        wr.out("Vec<i64>" false)
      }
      case RangerNodeType.DoubleBuffer {
        wr.out("Vec<f64>" false)
      }
      case RangerNodeType.Hash {
        wr.out((((("HashMap<" + (this.getObjectTypeString(node.key_type ctx))) + ",") + (this.getObjectTypeString(node.array_type ctx))) + ">") false)
        wr.addImport("std::collections::HashMap")
      }
      case RangerNodeType.Array {
        wr.out((("Vec<" + (this.getObjectTypeString(node.array_type ctx))) + ">") false)
      }
      default {
        if (node.type_name == "void") {
          wr.out("()" false)
          return
        }
        ; Check if this type is a trait type (class is extended by other classes)
        ; If so, use Rc<RefCell<dyn Trait>> for polymorphism with interior mutability
        def typeClass@(optional):RangerAppClassDesc (ctx.findClass(node.type_name))
        if (!null? typeClass) {
          def tc:RangerAppClassDesc (unwrap typeClass)
          if tc.is_extended_by_children {
            wr.out(("Rc<RefCell<dyn " + node.type_name + "Trait>>") false)
          } {
            wr.out((this.getTypeString(node.type_name)) false)
          }
        } {
          wr.out((this.getTypeString(node.type_name)) false)
        }
      }
    }
    ; Close wrapper types
    if is_weak {
      if is_optional {
        ; Close Option<Weak<RefCell<T>>>
        wr.out(">>>" false)
      } {
        ; Close Weak<RefCell<T>>
        wr.out(">>" false)
      }
    } {
      if is_optional {
        if is_self_referential {
          wr.out(">>" false)
        } {
          if needs_refcell_wrap {
            ; Close both RefCell and Option: Option<RefCell<T>>
            wr.out(">>" false)
          } {
            wr.out(">" false)
          }
        }
      }
    }
  }
  fn WriteVRef:void (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if (node.vref == "this") {
      wr.out(thisName false)
      return
    }

    if (node.eval_type == RangerNodeType.Enum) {
      if( (array_length node.ns) > 1) {
        def rootObjName:string (itemAt node.ns 0)
        def enumName:string (itemAt node.ns 1)
        def e@(optional):RangerAppEnum (ctx.getEnum(rootObjName))
        if (!null? e) {
          wr.out(("" + (unwrap (get e.values enumName))) false)
          return
        }
      }
    }

    if ((array_length node.nsp) > 0) {
      def had_static:boolean false
      def nsp_len:int (array_length node.nsp)
      for node.nsp p:RangerAppParamDesc i {
        if (i == 0) {
          def part:string (itemAt node.ns 0)
          if(part == "this") {
            wr.out(thisName false)
            continue
          } 
        }        

        if (i > 0) {
          if had_static {
            wr.out("::" false)
          } {
            wr.out("." false)
          }
        }
        if (i == 0) {
          ; if (p.nameNode.hasFlag("optional")) {
          ; }
          def part:string (itemAt node.ns 0)
          if ((part != "this") && (ctx.isMemberVariable(part))) {
            def uc@(optional):RangerAppClassDesc (ctx.getCurrentClass())
            def currC:RangerAppClassDesc (unwrap uc)
            def up@(optional):RangerAppParamDesc (currC.findVariable(part))
            if (!null? up) {
              if( false == (ctx.isInStatic()) ) {
                wr.out((thisName + ".") false)
              }               
            }
          }
        }
        if ((strlen p.compiledName) > 0) {
          wr.out((this.adjustType(p.compiledName)) false)
        } {
          if ((strlen p.name) > 0) {
            wr.out((this.adjustType(p.name)) false)
          } {
            wr.out((this.adjustType( (itemAt node.ns i))) false)
          }
        }
        ; Check if this is a local variable with rust_needs_rc_wrap (Rc<RefCell<T>>)
        ; If so and there are more parts (method call), add .borrow_mut()
        if (i == 0) {
          if ((nsp_len > 1) && p.rust_needs_rc_wrap) {
            wr.out(".borrow_mut()" false)
          }
        }
        ; Check if this field has weak annotation
        def field_is_weak:boolean false
        def pNameNWeak@(optional):CodeNode p.nameNode
        if (!null? pNameNWeak) {
          def pNNWeak:CodeNode (unwrap pNameNWeak)
          if (pNNWeak.hasFlag("weak")) {
            field_is_weak = true
          }
        }
        ; Handle weak references - need to upgrade() to get strong reference
        if field_is_weak {
          if (i < (nsp_len - 1)) {
            ; More parts coming - upgrade weak ref and access the inner value
            if p.is_optional {
              ; Optional weak: .as_ref().unwrap().upgrade().unwrap().borrow_mut()
              wr.out(".as_ref().unwrap().upgrade().unwrap().borrow_mut()" false)
            } {
              ; Non-optional weak: .upgrade().unwrap().borrow_mut()
              wr.out(".upgrade().unwrap().borrow_mut()" false)
            }
          }
        } {
          ; Rust: If this field is optional and there are more parts after it, unwrap it
          if p.is_optional {
            if (i < (nsp_len - 1)) {
              ; More parts coming - need to unwrap the Option
              ; Check if this is a trait type (Rc<RefCell<dyn Trait>>)
              def field_is_trait_type:boolean false
              def pNameN@(optional):CodeNode p.nameNode
              if (!null? pNameN) {
                def pNN:CodeNode (unwrap pNameN)
                def pTypeName:string pNN.type_name
                def pTypeClass@(optional):RangerAppClassDesc (ctx.findClass(pTypeName))
              if (!null? pTypeClass) {
                def ptc:RangerAppClassDesc (unwrap pTypeClass)
                if ptc.is_extended_by_children {
                  field_is_trait_type = true
                }
              }
            }
            ; Check if the class that OWNS this field is trait-related
            ; (Fields in trait-related classes have Option<RefCell<T>> type)
            def owning_class_is_trait_related:boolean false
            def pOwnerClass@(optional):RangerAppClassDesc p.propertyClass
            ; If propertyClass is null, fall back to current class (self field)
            if (null? pOwnerClass) {
              if p.is_class_variable {
                pOwnerClass = (ctx.getCurrentClass())
              }
            }
            if (!null? pOwnerClass) {
              def ownerC:RangerAppClassDesc (unwrap pOwnerClass)
              if ownerC.is_extended_by_children {
                owning_class_is_trait_related = true
              }
              if (owning_class_is_trait_related == false) {
                for ownerC.extends_classes extParentName2:string epi2 {
                  def extParentClass2@(optional):RangerAppClassDesc (ctx.findClass(extParentName2))
                  if (!null? extParentClass2) {
                    def epc2:RangerAppClassDesc (unwrap extParentClass2)
                    if epc2.is_extended_by_children {
                      owning_class_is_trait_related = true
                    }
                  }
                }
              }
            }
            ; Use borrow_mut for:
            ; 1. Trait types (Rc<RefCell<dyn Trait>>)
            ; 2. Non-trait optional object fields in trait-related classes (Option<RefCell<T>>)
            if field_is_trait_type {
              ; Trait types use Rc<RefCell<dyn Trait>> - use borrow_mut for interior mutability
              wr.out(".as_ref().unwrap().borrow_mut()" false)
            } {
              if owning_class_is_trait_related {
                ; Non-trait optional object fields in trait-related classes use Option<RefCell<T>>
                wr.out(".as_ref().unwrap().borrow_mut()" false)
              } {
                ; Use as_mut().unwrap() to allow both read and write access
                wr.out(".as_mut().unwrap()" false)
              }
            }
          }
        }
        }
        if (p.isClass()) {
          had_static = true
        }
      }
      return
    }

    if node.hasParamDesc {
      def part:string (itemAt node.ns 0)
      if ((part != "this") && (ctx.isMemberVariable(part))) {
        def uc@(optional):RangerAppClassDesc (ctx.getCurrentClass())
        def currC:RangerAppClassDesc (unwrap uc)
        def up@(optional):RangerAppParamDesc (currC.findVariable(part))
        if (!null? up) {
          if( false == (ctx.isInStatic()) ) {
            wr.out((thisName + ".") false)
          }
        }
      }
      def p:RangerAppParamDesc node.paramDesc
      wr.out((this.adjustType(p.compiledName)) false)
      return
    }

    def b_was_static:boolean false
    for node.ns part:string i {
      if (i > 0) {
        if ((i == 1) && b_was_static) {
          wr.out("::" false)
        } {
          wr.out("." false)
        }
      }
      if (i == 0) {
        if (ctx.hasClass(part)) {
          b_was_static = true
        }
        if ((part != "this") && (ctx.hasCurrentClass())) {
          def uc@(optional):RangerAppClassDesc (ctx.getCurrentClass())
          def currC:RangerAppClassDesc (unwrap uc)
          def up@(optional):RangerAppParamDesc (currC.findVariable(part))
          if (!null? up) {
            if( false == (ctx.isInStatic()) ) {
              wr.out((thisName + ".") false)
            }
          }
        }
      }
      wr.out((this.adjustType(part)) false)
    }
  }
  fn writeStructField (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if node.hasParamDesc {
      def nn:CodeNode (itemAt node.children 1)
      def p:RangerAppParamDesc nn.paramDesc
      wr.out(((this.adjustType(p.compiledName)) + " : ") false)
      def nameN:CodeNode (unwrap p.nameNode)
      this.writeTypeDef(nameN ctx wr)
      wr.out(", " true)
    }
  }
  fn writeVarDef (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if node.hasParamDesc {
      def nn:CodeNode (itemAt node.children 1)
      def p:RangerAppParamDesc nn.paramDesc
      if ((p.ref_cnt == 0) && (p.is_class_variable == false)) {
        wr.out("// unused:  " false)
      }
      def map_or_hash:boolean ((nn.value_type == RangerNodeType.Array) || (nn.value_type == RangerNodeType.Hash))
      ; Buffer type needs mut since buffer_set/buffer_fill/buffer_copy modify in place
      def is_buffer:boolean ((nn.value_type == RangerNodeType.Buffer) || (nn.value_type == RangerNodeType.IntBuffer) || (nn.value_type == RangerNodeType.DoubleBuffer))
      ; In Rust, calling &mut self methods requires the variable to be mut
      ; For now, always use mut for objects and arrays to avoid borrow issues
      def needs_mut:boolean ((((p.set_cnt > 0) || p.is_class_variable) || map_or_hash) || is_buffer)
      def is_object:boolean (nn.value_type == RangerNodeType.Object)
      
      ; Check if this local variable needs Rc<RefCell<T>> wrapping (for weak ref pattern)
      ; This is detected by static analysis when the variable is passed to a method 
      ; whose parameter is assigned to a @(weak) field
      def local_needs_rc_wrap:boolean p.rust_needs_rc_wrap
      
      if (needs_mut || is_object) {
        wr.out((("let mut " + p.compiledName) + " : ") false)
      } {
        wr.out((("let " + p.compiledName) + " : ") false)
      }
      def nameN:CodeNode (unwrap p.nameNode)
      
      ; Rust: Check if RHS is an optional field - we need to unwrap it and use non-optional type
      def rhs_is_optional_field:boolean false
      if ((array_length node.children) > 2) {
        def value:CodeNode (node.getThird())
        if (value.value_type == RangerNodeType.VRef) {
          if ((array_length value.nsp) > 0) {
            def lastIdx:int ((array_length value.nsp) - 1)
            def lastParam:RangerAppParamDesc (itemAt value.nsp lastIdx)
            if lastParam.is_optional {
              rhs_is_optional_field = true
            }
          } {
            ; Simple variable reference (no dots) - check paramDesc directly
            if value.hasParamDesc {
              def vp:RangerAppParamDesc value.paramDesc
              if vp.is_optional {
                rhs_is_optional_field = true
              }
            }
          }
        }
      }
      
      ; Write type - with Rc<RefCell<>> wrapper if needed for weak ref pattern
      if local_needs_rc_wrap {
        ; Variable needs Rc<RefCell<T>> type
        wr.out("Rc<RefCell<" false)
        this.writeTypeDef(nameN ctx wr)
        wr.out(">>" false)
      } {
        if rhs_is_optional_field {
          ; Write the underlying type without Option wrapper
          def v_type:RangerNodeType nameN.value_type
          if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.VRef) || (v_type == RangerNodeType.NoType)) {
            v_type = (nameN.typeNameAsType(ctx))
          }
          if (nameN.eval_type != RangerNodeType.NoType) {
            v_type = nameN.eval_type
          }
          wr.out((this.getTypeString(nameN.type_name)) false)
        } {
          this.writeTypeDef(nameN ctx wr)
        }
      }
      
      if ((array_length node.children) > 2) {
        wr.out(" = " false)
        
        ; Wrap initialization in Rc::new(RefCell::new(...)) if needed
        if local_needs_rc_wrap {
          wr.out("Rc::new(RefCell::new(" false)
        }
        
        ctx.setInExpr()
        def value:CodeNode (node.getThird())
        this.WalkNode(value ctx wr)
        ctx.unsetInExpr()
        
        ; Close Rc::new(RefCell::new(...)) if we opened it
        if local_needs_rc_wrap {
          wr.out("))" false)
        }
        
        ; If RHS was optional field, unwrap it
        if rhs_is_optional_field {
          ; Clone before unwrap for object types to avoid move issues
          def v_type:RangerNodeType nameN.value_type
          if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.VRef) || (v_type == RangerNodeType.NoType)) {
            v_type = (nameN.typeNameAsType(ctx))
          }
          if (v_type == RangerNodeType.Object) {
            wr.out(".clone().unwrap()" false)
          } {
            wr.out(".unwrap()" false)
          }
        }
        ; In Rust, reading a non-primitive variable moves it - clone to avoid E0507
        ; Clone strings, objects, arrays when reading from self fields
        if (value.value_type == RangerNodeType.VRef) {
          def should_clone_vardef:boolean false
          if (nameN.type_name == "string") {
            ; Clone if accessing a field (has dot path)
            if ((array_length value.ns) > 1) {
              should_clone_vardef = true
            } {
              ; For simple variable references, clone if ref_cnt > 1 (used elsewhere)
              if value.hasParamDesc {
                def vp:RangerAppParamDesc value.paramDesc
                if (vp.ref_cnt > 1) {
                  should_clone_vardef = true
                }
              }
            }
          }
          ; Clone objects/arrays when reading from self fields (prevents E0507)
          if value.hasParamDesc {
            def vp:RangerAppParamDesc value.paramDesc
            if vp.is_class_variable {
              ; This is reading from a self field
              def v_type:RangerNodeType nameN.value_type
              if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.VRef) || (v_type == RangerNodeType.NoType)) {
                v_type = (nameN.typeNameAsType(ctx))
              }
              if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.Array) || (v_type == RangerNodeType.Buffer) || (v_type == RangerNodeType.IntBuffer)) {
                should_clone_vardef = true
              }
            }
          }
          if should_clone_vardef {
            wr.out(".clone()" false)
          }
        }
      } {
        if (nn.value_type == RangerNodeType.Array) {
          wr.out(" = Vec::new()" false)
        }
        if (nn.value_type == RangerNodeType.Hash) {
          wr.out(" = HashMap::new()" false)
        }
        ; Initialize optional variables to None in Rust
        if (nameN.hasFlag("optional")) {
          wr.out(" = None" false)
        }
      }
      wr.out(";" false)
      if ((p.ref_cnt == 0) && (p.is_class_variable == true)) {
        wr.out("     // note: unused" false)
      }
      if ((p.ref_cnt == 0) && (p.is_class_variable == false)) {
        wr.newline()
      } {
        wr.newline()
      }
    }
  }
  fn writeArgsDef (fnDesc:RangerAppFunctionDesc ctx:RangerAppWriterContext wr:CodeWriter) {
    for fnDesc.params arg:RangerAppParamDesc i {
      if (i > 0) {
        wr.out(", " false)
      }
      def nameN:CodeNode (unwrap arg.nameNode)
      ; In Rust, object parameters that might have fields modified need 'mut'
      def v_type:RangerNodeType nameN.value_type
      if ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.VRef) || (v_type == RangerNodeType.NoType)) {
        v_type = (nameN.typeNameAsType(ctx))
      }
      def is_object:boolean ((v_type == RangerNodeType.Object) || (v_type == RangerNodeType.Array) || (v_type == RangerNodeType.Hash) || (v_type == RangerNodeType.IntBuffer) || (v_type == RangerNodeType.DoubleBuffer) || (v_type == RangerNodeType.CharBuffer) || (v_type == RangerNodeType.Buffer))
      ; Use compiledName to include any name transformations (e.g. len -> __len)
      def paramName:string (this.adjustType(arg.compiledName))
      
      ; Check static analysis flags for mutable reference requirement
      ; rust_borrow_type: 0=owned, 1=borrow, 2=mut_borrow
      ; needs_cpp_reference also indicates mutation (same analysis)
      def needsMutRef:boolean false
      if arg.needs_cpp_reference {
        needsMutRef = true
      }
      if (arg.rust_borrow_type == 2) {
        needsMutRef = true
      }
      
      ; Check if parameter is assigned to a weak field - needs Rc<RefCell<T>> type
      ; This is detected by static analysis when we see: this.weakField = param
      if arg.rust_needs_rc_wrap {
        ; Parameter is assigned to weak field - needs Rc<RefCell<T>> type
        wr.out(("mut " + paramName + " : Rc<RefCell<") false)
        this.writeTypeDef(nameN ctx wr)
        wr.out(">>" false)
        continue
      }
      
      ; Check if parameter is assigned - if so, make it mut
      if needsMutRef {
        ; Parameter is mutated - needs mut
        wr.out(("mut " + paramName + " : &mut ") false)
        this.writeTypeDef(nameN ctx wr)
      } {
        if is_object {
          wr.out(("mut " + paramName + " : ") false)
          this.writeTypeDef(nameN ctx wr)
        } {
          if (arg.set_cnt > 0) {
            wr.out(("mut " + paramName + " : ") false)
          } {
            wr.out((paramName + " : ") false)
          }
          this.writeTypeDef(nameN ctx wr)
        }
      }
    }
  }

  ; Override CreateCallExpression to handle optional types in Rust
  ; When calling a method on an optional object, we need to unwrap it first
  ; Helper: Check if a node tree contains any self (this) reference
  fn containsSelfReference:boolean (node:CodeNode) {
    ; Check if this node references a class variable (member of self)
    if node.hasParamDesc {
      def pp:RangerAppParamDesc node.paramDesc
      if pp.is_class_variable {
        return true
      }
    }
    ; Check for method calls - hasFnCall typically uses &mut self
    if node.hasFnCall {
      ; This is a method call - it likely uses &mut self
      return true
    }
    ; Recurse to children
    for node.children child:CodeNode i {
      if (this.containsSelfReference(child)) {
        return true
      }
    }
    return false
  }

  ; Helper: Check if a function body uses 'this' (self) - for Rust static method optimization
  ; Methods that don't reference 'this' or class variables can be emitted as static methods
  ; This avoids E0499 errors when calling such methods with &mut self.field arguments
  fn fnBodyUsesThis:boolean (node:CodeNode ctx:RangerAppWriterContext) {
    ; Check if this is a direct 'this' reference
    if (node.vref == "this") {
      return true
    }
    ; Check ns array for 'this' as first element (e.g., this.field)
    if (has node.ns) {
      if ((array_length node.ns) > 0) {
        def firstPart:string (itemAt node.ns 0)
        if (firstPart == "this") {
          return true
        }
        ; Also check if the first part is a class member variable using context
        if (ctx.isMemberVariable(firstPart)) {
          return true
        }
      }
    }
    ; Check if vref is a class member variable
    if ((strlen node.vref) > 0) {
      if (ctx.isMemberVariable(node.vref)) {
        return true
      }
    }
    ; Check if this node references a class variable (member of self)
    if node.hasParamDesc {
      def pp:RangerAppParamDesc node.paramDesc
      if pp.is_class_variable {
        return true
      }
    }
    ; Recurse to children
    for node.children child:CodeNode i {
      if (this.fnBodyUsesThis(child ctx)) {
        return true
      }
    }
    return false
  }

  ; ====== CALL GRAPH ANALYSIS FOR MUTATION DETECTION ======
  ; These functions analyze method bodies to determine if they mutate 'this' (self)
  ; We build a call graph to handle transitive mutations properly
  
  ; Helper: Collect all self-method calls from a node (returns method names)
  fn collectSelfMethodCalls:void (node:CodeNode ctx:RangerAppWriterContext calls:[string]) {
    ; Check for method calls via vref pattern (e.g., "this.method")
    if ((strlen node.vref) > 5) {
      def prefix:string (substring node.vref 0 5)
      if (prefix == "this.") {
        ; Extract method name after "this."
        def methodName:string (substring node.vref 5 (strlen node.vref))
        push calls methodName
      }
    }
    
    ; Check for call expressions
    if node.has_call {
      if ((array_length node.children) >= 3) {
        def callObj:CodeNode (node.getSecond())
        def methodNode:CodeNode (node.getThird())
        if (callObj.vref == "this") {
          push calls methodNode.vref
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.collectSelfMethodCalls(child ctx calls)
    }
  }
  
  ; Helper: Check if method body DIRECTLY mutates this (field assignments, optional field access)
  ; Does NOT consider transitive mutations via method calls
  fn fnBodyDirectlyMutatesThis:boolean (node:CodeNode ctx:RangerAppWriterContext) {
    ; Debug: show every node being checked
    print ("DEBUG fnBodyDirectlyMutatesThis: vref=" + node.vref + " has_call=" + (to_string node.has_call) + " children=" + (to_string (array_length node.children)))
    
    ; Check ns array for optional field access (requires as_mut())
    if (has node.ns) {
      if ((array_length node.ns) > 0) {
        def firstPart:string (itemAt node.ns 0)
        if (firstPart == "this") {
          ; If there are more parts in ns (like this.field.isSet), check if any field is optional
          if ((array_length node.ns) > 1) {
            def secondPart:string (itemAt node.ns 1)
            if (ctx.isVarDefined(secondPart)) {
              def vDef:RangerAppParamDesc (ctx.getVariableDef(secondPart))
              if vDef.is_optional {
                return true  ; Access to optional field requires &mut self (due to as_mut())
              }
            }
          }
        }
        ; Also check if first part is a class member that's optional
        if (ctx.isVarDefined(firstPart)) {
          def vDef:RangerAppParamDesc (ctx.getVariableDef(firstPart))
          if vDef.is_optional {
            return true
          }
        }
      }
    }
    
    ; Check for assignment to class variables
    if ((array_length node.children) >= 3) {
      def fc:CodeNode (node.getFirst())
      def cmd:string fc.vref
      if (cmd == "=") {
        def left:CodeNode (node.getSecond())
        ; Check if left side is a class variable
        if left.hasParamDesc {
          def pp:RangerAppParamDesc left.paramDesc
          if pp.is_class_variable {
            return true
          }
        }
        ; Check ns array for 'this' as first element (e.g., this.field = ...)
        if (has left.ns) {
          if ((array_length left.ns) > 0) {
            def firstPart:string (itemAt left.ns 0)
            if (firstPart == "this") {
              return true
            }
            if (ctx.isMemberVariable(firstPart)) {
              return true
            }
          }
        }
        ; Check if left vref is a class member variable
        if ((strlen left.vref) > 0) {
          if (ctx.isMemberVariable(left.vref)) {
            return true
          }
        }
      }
    }
    
    ; Check for method calls on member variables (e.g., this.fontManager.loadFont())
    ; This mutates the member variable (requires &mut self)
    if node.has_call {
      if ((array_length node.children) >= 3) {
        def callObj:CodeNode (node.getSecond())
        def methodNode:CodeNode (node.getThird())
        ; Debug: show what we're checking
        print ("DEBUG fnBodyDirectlyMutatesThis: has_call=true callObj.vref=" + callObj.vref + " method=" + methodNode.vref + " ns_len=" + (to_string (array_length callObj.ns)))
        ; Check if callObj is a member variable or starts with 'this.'
        if (has callObj.ns) {
          if ((array_length callObj.ns) > 0) {
            def firstPart:string (itemAt callObj.ns 0)
            print ("DEBUG fnBodyDirectlyMutatesThis: ns[0]=" + firstPart)
            if (firstPart == "this") {
              ; this.something.method() - assume it could mutate
              return true
            }
            if (ctx.isMemberVariable(firstPart)) {
              ; memberVar.method() - assume it could mutate
              print ("DEBUG fnBodyDirectlyMutatesThis: " + firstPart + " is member, returning true")
              return true
            }
          }
        }
        ; Also check vref for patterns like "this.member"
        if ((strlen callObj.vref) > 5) {
          def prefix:string (substring callObj.vref 0 5)
          if (prefix == "this.") {
            return true
          }
        }
        ; Check if callObj is a member variable directly (e.g., fontManager.loadFont())
        if ((strlen callObj.vref) > 0) {
          if (ctx.isMemberVariable(callObj.vref)) {
            print ("DEBUG fnBodyDirectlyMutatesThis: " + callObj.vref + " is member variable, returning true")
            return true
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      if (this.fnBodyDirectlyMutatesThis(child ctx)) {
        return true
      }
    }
    return false
  }
  
  ; Build call graph and mutation info for a class
  ; Returns two maps: methodName -> directlyMutates (boolean), methodName -> MethodCallList
  fn buildClassMutationGraph:void (cl:RangerAppClassDesc ctx:RangerAppWriterContext directMutations:[string:boolean] callGraph:[string:MethodCallList]) {
    print ("DEBUG buildClassMutationGraph: class=" + cl.name + " variants=" + (to_string (array_length cl.defined_variants)))
    for cl.defined_variants fnVar:string i {
      def mVs:RangerAppMethodVariants (get cl.method_variants fnVar)
      for mVs.variants variant:RangerAppFunctionDesc i {
        print ("DEBUG buildClassMutationGraph: checking method " + variant.name)
        def fnB@(optional):CodeNode variant.fnBody
        if (!null? fnB) {
          def fnCtx@(optional):RangerAppWriterContext variant.fnCtx
          def useCtx:RangerAppWriterContext ctx
          if (!null? fnCtx) {
            useCtx = (unwrap fnCtx)
          }
          def fnBody:CodeNode (unwrap fnB)
          
          ; Check direct mutation
          def directlyMutates:boolean (this.fnBodyDirectlyMutatesThis(fnBody useCtx))
          print ("DEBUG buildClassMutationGraph: " + variant.name + " directlyMutates=" + (to_string directlyMutates))
          set directMutations variant.name directlyMutates
          
          ; Collect method calls into a MethodCallList
          def callList:MethodCallList (new MethodCallList())
          this.collectSelfMethodCalls(fnBody useCtx callList.calls)
          set callGraph variant.name callList
        }
      }
    }
  }
  
  ; Check if a method transitively mutates (directly or via called methods)
  ; Uses visited set to prevent infinite recursion on cycles
  fn methodTransitivelyMutates:boolean (methodName:string directMutations:[string:boolean] callGraph:[string:MethodCallList] visited:[string]) {
    ; Check if already visited (cycle detection)
    for visited v:string i {
      if (v == methodName) {
        return false  ; Cycle - assume no mutation from this path
      }
    }
    push visited methodName
    
    ; Check direct mutation
    if (has directMutations methodName) {
      def dm:boolean (get directMutations methodName)
      if dm {
        return true
      }
    }
    
    ; Check called methods
    if (has callGraph methodName) {
      def callList:MethodCallList (get callGraph methodName)
      for callList.calls calledMethod:string i {
        if (this.methodTransitivelyMutates(calledMethod directMutations callGraph visited)) {
          return true
        }
      }
    }
    
    return false
  }
  
  ; Main entry: Check if a method mutates this (uses call graph for transitive analysis)
  fn methodMutatesThis:boolean (methodName:string directMutations:[string:boolean] callGraph:[string:MethodCallList]) {
    def visited:[string]
    return (this.methodTransitivelyMutates(methodName directMutations callGraph visited))
  }

  ; Legacy function - kept for compatibility but uses new analysis
  fn fnBodyMutatesThis:boolean (node:CodeNode ctx:RangerAppWriterContext) {
    ; This is a simplified version that doesn't use call graph
    ; Used when we don't have the full class context
    return (this.fnBodyDirectlyMutatesThis(node ctx))
  }

  fn CreateCallExpression(node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if node.has_call {
      def obj:CodeNode (node.getSecond())
      def method:CodeNode (node.getThird())
      def args:CodeNode (itemAt node.children 3)

      ; Check if the object is an optional type (which needs .as_ref().unwrap() or .as_mut().unwrap())
      def obj_is_optional:boolean false
      def obj_is_trait_type:boolean false  ; True if obj's type is Rc<dyn Trait>
      def owning_class_is_trait_related:boolean false ; True if owning class extends a trait or is extended
      if obj.hasParamDesc {
        def pp:RangerAppParamDesc obj.paramDesc
        if pp.is_optional {
          obj_is_optional = true
        }
        ; Check if the object's type is a trait type (parent class that is extended)
        def objNameN@(optional):CodeNode pp.nameNode
        if (!null? objNameN) {
          def objNN:CodeNode (unwrap objNameN)
          def objTypeName:string objNN.type_name
          def objTypeClass@(optional):RangerAppClassDesc (ctx.findClass(objTypeName))
          if (!null? objTypeClass) {
            def otc:RangerAppClassDesc (unwrap objTypeClass)
            if otc.is_extended_by_children {
              obj_is_trait_type = true
            }
          }
        }
        
        ; Check if owning class is trait-related
        def objOwnerClass@(optional):RangerAppClassDesc pp.propertyClass
        if (null? objOwnerClass) {
          if pp.is_class_variable {
            objOwnerClass = (ctx.getCurrentClass())
          }
        }
        if (!null? objOwnerClass) {
          def objOC:RangerAppClassDesc (unwrap objOwnerClass)
          if objOC.is_extended_by_children {
            owning_class_is_trait_related = true
          }
          if (owning_class_is_trait_related == false) {
            for objOC.extends_classes objExtParent:string objEpi {
              def objExtParentClass@(optional):RangerAppClassDesc (ctx.findClass(objExtParent))
              if (!null? objExtParentClass) {
                def objEpc:RangerAppClassDesc (unwrap objExtParentClass)
                if objEpc.is_extended_by_children {
                  owning_class_is_trait_related = true
                }
              }
            }
          }
        }
      }

      ; Check if obj is a class variable (member of self)
      def obj_is_self_member:boolean false
      if obj.hasParamDesc {
        def pp:RangerAppParamDesc obj.paramDesc
        if pp.is_class_variable {
          obj_is_self_member = true
        }
      }

      ; If calling method on self.optionalMember, and args contain self references,
      ; we need to pre-evaluate all arguments to avoid borrow conflicts
      def needs_arg_preevaluation:boolean false
      if (obj_is_optional && obj_is_self_member) {
        ; Check if any argument contains a self reference
        if (this.containsSelfReference(args)) {
          needs_arg_preevaluation = true
        }
      }
      
      ; DEBUG: Log detection for self member calls
      if obj_is_self_member {
        print ("DEBUG: self member " + obj.vref + "." + method.vref + " - obj_is_optional=" + (to_string obj_is_optional) + " obj_is_trait_type=" + (to_string obj_is_trait_type) + " containsSelf=" + (to_string (this.containsSelfReference(args))) + " needs_preeval=" + (to_string needs_arg_preevaluation) + " args_cnt=" + (to_string (array_length args.children)))
      }

      ; Pre-evaluate all arguments if needed
      ; BUT only do this if we're not inside an expression (can't emit let in expr)
      if (needs_arg_preevaluation && ((ctx.expressionLevel()) == 0)) {
        def pms (filter (args.children) {
          if (item.hasFlag("keyword")) {
            return false
          }
          return true
        })
        
        def tmpVarIdx:int 0
        for pms arg:CodeNode i {
          def tmpVarName:string ("__arg_" + (to_string tmpVarIdx))
          tmpVarIdx = tmpVarIdx + 1
          
          ; Generate: let __arg_N = <arg>;
          wr.out(("let " + tmpVarName + " = ") false)
          ctx.setInExpr()
          this.WalkNode(arg ctx wr)
          ctx.unsetInExpr()
          wr.out(";" true)
          
          ; Mark the arg node to use this temp var
          arg.rust_use_tmpvar = tmpVarName
        }
      }

      if obj_is_optional {
        ; For optional objects with trait types: Rc<RefCell<dyn Trait>>
        ; Or for optional objects in trait-related classes: Option<RefCell<T>>
        ctx.setInExpr()
        this.WalkNode(obj ctx wr)
        ctx.unsetInExpr()
        if (obj_is_trait_type || owning_class_is_trait_related) {
          ; Trait types use Rc<RefCell<...>> - borrow_mut for interior mutability
          ; Fields in trait-related classes use Option<RefCell<T>>
          wr.out(".as_ref().unwrap().borrow_mut()." false)
        } {
          wr.out(".as_mut().unwrap()." false)
        }
      } {
        ; Standard case - wrap in parentheses
        wr.out("(" false)
        ctx.setInExpr()
        this.WalkNode(obj ctx wr)
        ctx.unsetInExpr()
        if obj_is_trait_type {
          ; Trait types use Rc<RefCell<...>> - borrow_mut for interior mutability
          wr.out(").borrow_mut()." false)
        } {
          wr.out(")." false)
        }
      }
      
      wr.out(method.vref false)
      wr.out("(" false)
      ctx.setInExpr()

      def pms (filter (args.children) {
        if (item.hasFlag("keyword")) {
          return false
        }
        return true
      })
      
      for pms arg:CodeNode i {
        if (i > 0) {
          wr.out(", " false)
        }
        ; Check if this arg should use a pre-evaluated temp variable
        if ((strlen arg.rust_use_tmpvar) > 0) {
          wr.out(arg.rust_use_tmpvar false)
          ; Clear the flag after use
          arg.rust_use_tmpvar = ""
        } {
          this.WalkNode(arg ctx wr)
        }
      }
      ctx.unsetInExpr()
      wr.out(")" false)
      if ((ctx.expressionLevel()) == 0) {
        wr.out(";" true)
      }
    }    
  }

  ; Override CreateMethodCall for Rust to handle borrow conflicts with optional self members
  ; This is used for is_direct_method_call nodes (e.g., streamBuffer.writeString(...))
  fn CreateMethodCall(node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    def obj:CodeNode (node.getFirst())
    def args:CodeNode (node.getSecond())
    
    ; Check if the object is an optional class variable (self member)
    def obj_is_optional:boolean false
    def obj_is_self_member:boolean false
    if obj.hasParamDesc {
      def pp:RangerAppParamDesc obj.paramDesc
      obj_is_optional = pp.is_optional
      obj_is_self_member = pp.is_class_variable
    }
    
    ; Also check the object's children - for chained access like obj.method
    ; The object node might contain the target with paramDesc
    if (obj_is_self_member == false) {
      for obj.children child:CodeNode i {
        if child.hasParamDesc {
          def pp:RangerAppParamDesc child.paramDesc
          if pp.is_class_variable {
            obj_is_self_member = true
            if pp.is_optional {
              obj_is_optional = true
            }
          }
        }
      }
    }
    
    ; Check if we need to pre-evaluate arguments to avoid borrow conflicts
    def needs_arg_preevaluation:boolean false
    if (obj_is_optional && obj_is_self_member) {
      if (this.containsSelfReference(args)) {
        needs_arg_preevaluation = true
      }
    }
    
    ; DEBUG
    if obj_is_self_member {
      print ("DEBUG CreateMethodCall: obj_is_optional=" + (to_string obj_is_optional) + " obj_is_self_member=" + (to_string obj_is_self_member) + " containsSelf=" + (to_string (this.containsSelfReference(args))) + " needs_preeval=" + (to_string needs_arg_preevaluation))
    }
    
    ; Pre-evaluate arguments if needed (only at statement level, not inside expressions)
    if (needs_arg_preevaluation && ((ctx.expressionLevel()) == 0)) {
      def pms (filter (args.children) {
        if (item.hasFlag("keyword")) {
          return false
        }
        return true
      })
      
      def tmpVarIdx:int 0
      for pms arg:CodeNode i {
        def tmpVarName:string ("__arg_" + (to_string tmpVarIdx))
        tmpVarIdx = tmpVarIdx + 1
        
        ; Generate: let __arg_N = <arg>;
        wr.out(("let " + tmpVarName + " = ") false)
        ctx.setInExpr()
        this.WalkNode(arg ctx wr)
        ctx.unsetInExpr()
        wr.out(";" true)
        
        ; Mark the arg to use temp var
        arg.rust_use_tmpvar = tmpVarName
      }
    }
    
    ; Write the actual method call
    ctx.setInExpr()
    this.WalkNode(obj ctx wr)
    ctx.unsetInExpr()
    wr.out("(" false)
    ctx.setInExpr()
    
    def pms (filter (args.children) {
      if (item.hasFlag("keyword")) {
        return false
      }
      return true
    })
    
    for pms arg:CodeNode i {
      if (i > 0) {
        wr.out(", " false)
      }
      ; Check if this arg should use a pre-evaluated temp variable
      if ((strlen arg.rust_use_tmpvar) > 0) {
        wr.out(arg.rust_use_tmpvar false)
        ; Clear the flag after use
        arg.rust_use_tmpvar = ""
      } {
        this.WalkNode(arg ctx wr)
      }
    }
    ctx.unsetInExpr()
    wr.out(")" false)
    if ((ctx.expressionLevel()) == 0) {
      wr.out(";" true)
    }
  }

  ; Check if a node is a self method call (this.method(...))
  fn isSelfMethodCall:boolean (node:CodeNode) {
    if node.hasFnCall {
      def fc:CodeNode (node.getFirst())
      if (has fc.ns) {
        def part:string (itemAt fc.ns 0)
        if (part == "this") {
          return true
        }
      }
    }
    return false
  }

  ; Check if any argument contains a self method call - returns the argument index, -1 if none
  fn findSelfCallInArgs:int (node:CodeNode) {
    if node.hasFnCall {
      def givenArgs:CodeNode (node.getSecond())
      def idx:int 0
      for givenArgs.children arg:CodeNode i {
        if (this.isSelfMethodCall(arg)) {
          return i
        }
        idx = i + 1
      }
    }
    return (-1)
  }

  fn writeFnCall (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if node.hasFnCall {
      def fc:CodeNode (node.getFirst())
      def part:string (itemAt fc.ns 0)
      
      ; Check if the target is a class variable (self member) and if it's optional
      def target_is_self_member:boolean false
      def target_is_optional:boolean false
      
      ; Check the first part of the namespace path
      if (part == "this") {
        target_is_self_member = true
      } {
        ; Check if it's a class variable
        if (ctx.isMemberVariable(part)) {
          target_is_self_member = true
          ; Check if it's optional
          def uc@(optional):RangerAppClassDesc (ctx.getCurrentClass())
          if (!null? uc) {
            def currC:RangerAppClassDesc (unwrap uc)
            def up@(optional):RangerAppParamDesc (currC.findVariable(part))
            if (!null? up) {
              def p:RangerAppParamDesc (unwrap up)
              if p.is_optional {
                target_is_optional = true
              }
            }
          }
        }
      }
      
      def givenArgs:CodeNode (node.getSecond())
      
      ; If calling method on optional self member and args contain self references,
      ; we need to pre-evaluate all arguments
      def needs_arg_preevaluation:boolean false
      if (target_is_self_member && target_is_optional) {
        if (this.containsSelfReference(givenArgs)) {
          needs_arg_preevaluation = true
        }
      }
      
      ; DEBUG
      if target_is_self_member {
        print ("DEBUG writeFnCall: part=" + part + " target_is_optional=" + (to_string target_is_optional) + " containsSelf=" + (to_string (this.containsSelfReference(givenArgs))) + " needs_preeval=" + (to_string needs_arg_preevaluation))
      }
      
      ; Pre-evaluate all arguments if needed to avoid borrow conflicts
      ; BUT only do this if we're not inside an expression (can't emit let in expr)
      if (needs_arg_preevaluation && ((ctx.expressionLevel()) == 0)) {
        def tempVars:[string]
        def tmpIdx:int 0
        for givenArgs.children argNode:CodeNode argIdx {
          def tmpName:string ("__arg_" + (to_string tmpIdx))
          tmpIdx = tmpIdx + 1
          push tempVars tmpName
          ; Write temp variable assignment - clone to avoid move issues in loops
          wr.out(("let " + tmpName + " = ") false)
          ctx.setInExpr()
          this.WalkNode(argNode ctx wr)
          ctx.unsetInExpr()
          ; Clone non-primitive types to avoid moving
          if (argNode.value_type == RangerNodeType.VRef) {
            wr.out(".clone()" false)
          }
          wr.out(";" true)
        }
        
        ; Now write the actual function call with temp vars
        this.WriteVRef(fc ctx wr)
        wr.out("(" false)
        for node.fnDesc.params arg:RangerAppParamDesc i {
          if (i > 0) {
            wr.out(", " false)
          }
          def tmpVar:string (itemAt tempVars i)
          wr.out(tmpVar false)
        }
        wr.out(")" false)
        if ((ctx.expressionLevel()) == 0) {
          wr.out(";" true)
        }
        return
      }

      ; In Rust, we can't have self.method1(self.method2()) due to double mutable borrow
      ; Detect this pattern and extract inner self calls to temp variables
      def is_self_call:boolean (part == "this")
      def selfCallArgIdx:int (this.findSelfCallInArgs(node))
      
      ; If this is a self method call and has a self call in arguments, extract to temp var
      if (is_self_call && (selfCallArgIdx >= 0)) {
        ; Extract all self call arguments to temp variables first
        def tempVars:[string]
        for givenArgs.children argNode:CodeNode argIdx {
          if (this.isSelfMethodCall(argNode)) {
            def tempName:string (ctx.rustGetTempVar())
            push tempVars tempName
            ; Write temp variable assignment
            wr.out(("let " + tempName + " = ") false)
            ctx.setInExpr()
            this.WalkNode(argNode ctx wr)
            ctx.unsetInExpr()
            wr.out(";" true)
          } {
            push tempVars ""
          }
        }
        
        ; Now write the actual function call with temp vars substituted
        ; Note: Don't add self. here as WriteVRef already handles member variables
        this.WriteVRef(fc ctx wr)
        wr.out("(" false)
        for node.fnDesc.params arg:RangerAppParamDesc i {
          def n@(optional):CodeNode (itemAt givenArgs.children i)
          if (i > 0) {
            wr.out(", " false)
          }
          if (null? n) {
            def nameN:CodeNode (unwrap arg.nameNode)
            def defVal@(optional):CodeNode (nameN.getFlag("default"))
            if (!null? defVal) {
              def defV:CodeNode (unwrap defVal)
              def fc2:CodeNode (defV.vref_annotation.getFirst())
              ctx.setInExpr()
              this.WalkNode(fc2 ctx wr)
              ctx.unsetInExpr()
            } {
              ctx.addError(node "Default argument was missing")
            }
            continue _
          }
          ; Check if we have a temp var for this arg
          def tempVar:string (itemAt tempVars i)
          if ((strlen tempVar) > 0) {
            ; Check if parameter needs mutable reference - add &mut prefix
            def needsMutRefTmp:boolean false
            if arg.needs_cpp_reference {
              needsMutRefTmp = true
            }
            if (arg.rust_borrow_type == 2) {
              needsMutRefTmp = true
            }
            if needsMutRefTmp {
              wr.out("&mut " false)
            }
            wr.out(tempVar false)
          } {
            def nVal:CodeNode (unwrap n)
            ; Check if parameter needs mutable reference
            def needsMutRef2:boolean false
            if arg.needs_cpp_reference {
              needsMutRef2 = true
            }
            if (arg.rust_borrow_type == 2) {
              needsMutRef2 = true
            }
            
            if needsMutRef2 {
              ; Parameter needs &mut - output &mut prefix
              wr.out("&mut " false)
              ctx.setInExpr()
              this.WalkNode(nVal ctx wr)
              ctx.unsetInExpr()
            } {
              ctx.setInExpr()
              this.WalkNode(nVal ctx wr)
              ctx.unsetInExpr()
              ; In Rust, values are moved when passed, so clone when passing a variable
              def argNameN:CodeNode (unwrap arg.nameNode)
              def arg_type:RangerNodeType argNameN.value_type
              if ((arg_type == RangerNodeType.Object) || (arg_type == RangerNodeType.VRef) || (arg_type == RangerNodeType.NoType)) {
                arg_type = (argNameN.typeNameAsType(ctx))
              }
              def needs_clone:boolean false
              if (argNameN.type_name == "string") {
                needs_clone = true
              }
              if (arg_type == RangerNodeType.Object) {
                needs_clone = true
              }
              ; In Rust, arrays and hashes need cloning to avoid move errors
              if ((arg_type == RangerNodeType.Array) || (arg_type == RangerNodeType.Hash) || (arg_type == RangerNodeType.IntBuffer) || (arg_type == RangerNodeType.DoubleBuffer) || (arg_type == RangerNodeType.CharBuffer) || (arg_type == RangerNodeType.Buffer)) {
                needs_clone = true
              }
              if needs_clone {
                if (nVal.value_type == RangerNodeType.VRef) {
                  wr.out(".clone()" false)
                }
              }
            }
          }
        }
        wr.out(")" false)
        if ((ctx.expressionLevel()) == 0) {
          wr.out(";" true)
        }
        return
      }

      ; Check if this is a self method call that can be called as static
      ; Methods that don't use 'this' can be called as ClassName::method() to avoid borrow issues
      def call_as_static:boolean false
      if is_self_call {
        if node.hasFnCall {
          def fnD:RangerAppFunctionDesc node.fnDesc
          ; Check directly if the method body uses 'this'
          def fnB@(optional):CodeNode fnD.fnBody
          if (!null? fnB) {
            ; Use the function's context for proper member variable lookup
            def fnCtx@(optional):RangerAppWriterContext fnD.fnCtx
            def useCtx:RangerAppWriterContext ctx
            if (!null? fnCtx) {
              useCtx = (unwrap fnCtx)
            }
            def uses_this:boolean (this.fnBodyUsesThis((unwrap fnB) useCtx))
            if (uses_this == false) {
              call_as_static = true
            }
          }
        }
      }
      
      ; If calling as static, use ClassName::method() syntax
      ; Use the method's container class (where it's defined), not the current class
      if call_as_static {
        def fnD:RangerAppFunctionDesc node.fnDesc
        def fnContainerClass@(optional):RangerAppClassDesc fnD.container_class
        if (!null? fnContainerClass) {
          def containerClass:RangerAppClassDesc (unwrap fnContainerClass)
          ; Get method name from fc.ns (e.g., ["this", "buildHuffmanCodes"])
          def methodName:string (itemAt fc.ns 1)
          wr.out(((containerClass.name + "::") + methodName) false)
          wr.out("(" false)
          for node.fnDesc.params arg:RangerAppParamDesc i {
            def n@(optional):CodeNode (itemAt givenArgs.children i)
            if (i > 0) {
              wr.out(", " false)
            }
            if (null? n) {
              def nameN:CodeNode (unwrap arg.nameNode)
              def defVal@(optional):CodeNode (nameN.getFlag("default"))
              if (!null? defVal) {
                def defV:CodeNode (unwrap defVal)
                def fc2:CodeNode (defV.vref_annotation.getFirst())
                ctx.setInExpr()
                this.WalkNode(fc2 ctx wr)
                ctx.unsetInExpr()
              } {
                ctx.addError(node "Default argument was missing")
              }
              continue _
            }
            def nVal:CodeNode (unwrap n)
            ; Check if parameter needs mutable reference
            def needsMutRef:boolean false
            if arg.needs_cpp_reference {
              needsMutRef = true
            }
            if (arg.rust_borrow_type == 2) {
              needsMutRef = true
            }
            
            if needsMutRef {
              wr.out("&mut " false)
              ctx.setInExpr()
              this.WalkNode(nVal ctx wr)
              ctx.unsetInExpr()
            } {
              ctx.setInExpr()
              this.WalkNode(nVal ctx wr)
              ctx.unsetInExpr()
              ; Clone non-primitives when passing by value
              def argNameN:CodeNode (unwrap arg.nameNode)
              def arg_type:RangerNodeType argNameN.value_type
              if ((arg_type == RangerNodeType.Object) || (arg_type == RangerNodeType.VRef) || (arg_type == RangerNodeType.NoType)) {
                arg_type = (argNameN.typeNameAsType(ctx))
              }
              def needs_clone:boolean false
              if (argNameN.type_name == "string") { needs_clone = true }
              if (arg_type == RangerNodeType.Object) { needs_clone = true }
              if ((arg_type == RangerNodeType.Array) || (arg_type == RangerNodeType.Hash) || (arg_type == RangerNodeType.IntBuffer) || (arg_type == RangerNodeType.DoubleBuffer) || (arg_type == RangerNodeType.CharBuffer) || (arg_type == RangerNodeType.Buffer)) {
                needs_clone = true
              }
              if needs_clone {
                if (nVal.value_type == RangerNodeType.VRef) {
                  wr.out(".clone()" false)
                }
              }
            }
          }
          wr.out(")" false)
          if ((ctx.expressionLevel()) == 0) {
            wr.out(";" true)
          }
          return
        }
      }

      ; Check if calling a static method on another object (not self)
      ; In this case we need to use ClassName::method() syntax instead of obj.method()
      def call_other_as_static:boolean false
      if (is_self_call == false) {
        if node.hasFnCall {
          def fnD2:RangerAppFunctionDesc node.fnDesc
          def fnB2@(optional):CodeNode fnD2.fnBody
          if (!null? fnB2) {
            ; Use the function's context for proper member variable lookup
            def fnCtx2@(optional):RangerAppWriterContext fnD2.fnCtx
            def useCtx2:RangerAppWriterContext ctx
            if (!null? fnCtx2) {
              useCtx2 = (unwrap fnCtx2)
            }
            def uses_this2:boolean (this.fnBodyUsesThis((unwrap fnB2) useCtx2))
            if (uses_this2 == false) {
              call_other_as_static = true
            }
          }
        }
      }
      
      ; If calling static method on another object, use ClassName::method() syntax
      if call_other_as_static {
        def fnD2:RangerAppFunctionDesc node.fnDesc
        def fnContainerClass2@(optional):RangerAppClassDesc fnD2.container_class
        if (!null? fnContainerClass2) {
          def containerClass2:RangerAppClassDesc (unwrap fnContainerClass2)
          ; Get method name from fc.ns (last element is method name)
          def methodName2:string (itemAt fc.ns ((array_length fc.ns) - 1))
          wr.out(((containerClass2.name + "::") + methodName2) false)
          wr.out("(" false)
          for node.fnDesc.params arg:RangerAppParamDesc i {
            def n@(optional):CodeNode (itemAt givenArgs.children i)
            if (i > 0) {
              wr.out(", " false)
            }
            if (null? n) {
              def nameN:CodeNode (unwrap arg.nameNode)
              def defVal@(optional):CodeNode (nameN.getFlag("default"))
              if (!null? defVal) {
                def defV:CodeNode (unwrap defVal)
                def fc2:CodeNode (defV.vref_annotation.getFirst())
                ctx.setInExpr()
                this.WalkNode(fc2 ctx wr)
                ctx.unsetInExpr()
              } {
                ctx.addError(node "Default argument was missing")
              }
              continue _
            }
            def nVal:CodeNode (unwrap n)
            ctx.setInExpr()
            this.WalkNode(nVal ctx wr)
            ctx.unsetInExpr()
            ; Clone non-primitives
            def argNameN:CodeNode (unwrap arg.nameNode)
            def arg_type:RangerNodeType argNameN.value_type
            if ((arg_type == RangerNodeType.Object) || (arg_type == RangerNodeType.VRef) || (arg_type == RangerNodeType.NoType)) {
              arg_type = (argNameN.typeNameAsType(ctx))
            }
            def needs_clone:boolean false
            if (argNameN.type_name == "string") { needs_clone = true }
            if (arg_type == RangerNodeType.Object) { needs_clone = true }
            if ((arg_type == RangerNodeType.Array) || (arg_type == RangerNodeType.Hash)) {
              needs_clone = true
            }
            if needs_clone {
              if (nVal.value_type == RangerNodeType.VRef) {
                wr.out(".clone()" false)
              }
            }
          }
          wr.out(")" false)
          if ((ctx.expressionLevel()) == 0) {
            wr.out(";" true)
          }
          return
        }
      }

      ; Standard path - no double borrow issue
      ; Note: Don't add self. here as WriteVRef already handles member variables
      this.WriteVRef(fc ctx wr)
      wr.out("(" false)
      for node.fnDesc.params arg:RangerAppParamDesc i {
        def n@(optional):CodeNode (itemAt givenArgs.children i)
        if (i > 0) {
          wr.out(", " false)
        }
        if (null? n) {
          def nameN:CodeNode (unwrap arg.nameNode)
          def defVal@(optional):CodeNode (nameN.getFlag("default"))
          if (!null? defVal) {
            def defV:CodeNode (unwrap defVal)
            def fc2:CodeNode (defV.vref_annotation.getFirst())
            ctx.setInExpr()
            this.WalkNode(fc2 ctx wr)
            ctx.unsetInExpr()
          } {
            ctx.addError(node "Default argument was missing")
          }
          continue _
        }
        def nVal:CodeNode (unwrap n)
        ; Check if parameter needs mutable reference
        def needsMutRef:boolean false
        if arg.needs_cpp_reference {
          needsMutRef = true
        }
        if (arg.rust_borrow_type == 2) {
          needsMutRef = true
        }
        
        ; Check if parameter type is a trait type - if so, wrap in Box::new()
        def arg_is_trait_type:boolean false
        def argNameN:CodeNode (unwrap arg.nameNode)
        def argTypeClass@(optional):RangerAppClassDesc (ctx.findClass(argNameN.type_name))
        if (!null? argTypeClass) {
          def atc:RangerAppClassDesc (unwrap argTypeClass)
          if atc.is_extended_by_children {
            arg_is_trait_type = true
          }
        }
        
        ; Check if the value being passed is already a Rc<dyn Trait>
        def value_is_already_boxed_trait:boolean false
        if (nVal.value_type == RangerNodeType.VRef) {
          if nVal.hasParamDesc {
            def valP:RangerAppParamDesc nVal.paramDesc
            def valNameN@(optional):CodeNode valP.nameNode
            if (!null? valNameN) {
              def valNN:CodeNode (unwrap valNameN)
              def valTypeName:string valNN.type_name
              if ((strlen valTypeName) > 0) {
                def valTypeClass@(optional):RangerAppClassDesc (ctx.findClass(valTypeName))
                if (!null? valTypeClass) {
                  def vtc:RangerAppClassDesc (unwrap valTypeClass)
                  if vtc.is_extended_by_children {
                    ; Value is already Rc<dyn Trait>, clone for shared ownership
                    value_is_already_boxed_trait = true
                  }
                }
              }
            }
          }
        }
        
        if needsMutRef {
          ; Parameter needs &mut - output &mut prefix
          wr.out("&mut " false)
          ctx.setInExpr()
          this.WalkNode(nVal ctx wr)
          ctx.unsetInExpr()
        } {
          ; Standard case - may need clone and/or Rc::new(RefCell::new()) for trait types
          ; But if value is already Rc<RefCell<dyn Trait>>, don't wrap or clone
          if value_is_already_boxed_trait {
            ; Already Rc<RefCell<dyn Trait>>, clone the Rc for shared ownership
            ctx.setInExpr()
            this.WalkNode(nVal ctx wr)
            ctx.unsetInExpr()
            wr.out(".clone()" false)
          } {
            ; Check if passing `this` to a trait-type parameter - this isn't supported
            ; because we can't create Rc<RefCell<Self>> from &mut self
            def is_passing_this_to_trait:boolean false
            if arg_is_trait_type {
              if (nVal.vref == "this") {
                is_passing_this_to_trait = true
              }
            }
            if is_passing_this_to_trait {
              ; Cannot pass `this` to a trait-type parameter in Rust
              ; The object would need to be wrapped in Rc at construction time
              wr.out("panic!(\"Cannot pass 'this' to trait-type parameter in Rust. Object must be externally wrapped in Rc<RefCell<...>>\")" false)
            } {
              ; Check if parameter needs Rc<RefCell<T>> wrap (for weak ref pattern)
              def needs_rc_wrap:boolean arg.rust_needs_rc_wrap
              
              ; BUT if the value being passed is already Rc<RefCell<...>> (has rust_needs_rc_wrap), don't double wrap
              def value_already_rc_wrapped:boolean false
              if needs_rc_wrap {
                if (nVal.value_type == RangerNodeType.VRef) {
                  if nVal.hasParamDesc {
                    def valParam:RangerAppParamDesc nVal.paramDesc
                    if valParam.rust_needs_rc_wrap {
                      value_already_rc_wrapped = true
                    }
                  }
                }
              }
              
              if arg_is_trait_type {
                wr.out("Rc::new(RefCell::new(" false)
              } {
                if (needs_rc_wrap && (value_already_rc_wrapped == false)) {
                  ; Parameter is passed to a method that assigns to weak field
                  ; Wrap the argument in Rc::new(RefCell::new(...))
                  wr.out("Rc::new(RefCell::new(" false)
                }
              }
              ctx.setInExpr()
              this.WalkNode(nVal ctx wr)
              ctx.unsetInExpr()
              ; In Rust, values are moved when passed, so clone when passing a variable
              ; This applies to strings and objects (non-primitives)
              def arg_type:RangerNodeType argNameN.value_type
              if ((arg_type == RangerNodeType.Object) || (arg_type == RangerNodeType.VRef) || (arg_type == RangerNodeType.NoType)) {
                arg_type = (argNameN.typeNameAsType(ctx))
              }
              def needs_clone:boolean false
              if (argNameN.type_name == "string") {
                needs_clone = true
              }
              if (arg_type == RangerNodeType.Object) {
                needs_clone = true
              }
              ; In Rust, arrays and hashes need cloning to avoid move errors
              if ((arg_type == RangerNodeType.Array) || (arg_type == RangerNodeType.Hash) || (arg_type == RangerNodeType.IntBuffer) || (arg_type == RangerNodeType.DoubleBuffer) || (arg_type == RangerNodeType.CharBuffer) || (arg_type == RangerNodeType.Buffer)) {
                needs_clone = true
              }
              ; If value is already Rc<RefCell<...>>, clone it (for shared ownership)
              if value_already_rc_wrapped {
                wr.out(".clone()" false)
              } {
                if needs_clone {
                  if (nVal.value_type == RangerNodeType.VRef) {
                    wr.out(".clone()" false)
                  }
                }
              }
              ; Close the Rc::new(RefCell::new()) if we opened it
              if arg_is_trait_type {
                wr.out("))" false)
              } {
                if (needs_rc_wrap && (value_already_rc_wrapped == false)) {
                  wr.out("))" false)
                }
              }
            }
          }
        }
      }
      wr.out(")" false)
      if ((ctx.expressionLevel()) == 0) {
        wr.out(";" true)
      }
    }
  }
  fn writeNewCall (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    if node.hasNewOper {
      def cl:RangerAppClassDesc node.clDesc
      def fc:CodeNode (node.getSecond())
      wr.out(node.clDesc.name false)
      wr.out("::new(" false)
      def constr@(optional):RangerAppFunctionDesc cl.constructor_fn
      def givenArgs:CodeNode (node.getThird())
      if (!null? constr) {
        def c:RangerAppFunctionDesc (unwrap constr)
        for c.params arg:RangerAppParamDesc i {
          def n:CodeNode (itemAt givenArgs.children i)
          if (i > 0) {
            wr.out(", " false)
          }
          this.WalkNode(n ctx wr)
          ; In Rust, values are moved when passed, so clone when passing a variable
          def argNameN:CodeNode (unwrap arg.nameNode)
          def arg_type:RangerNodeType argNameN.value_type
          if ((arg_type == RangerNodeType.Object) || (arg_type == RangerNodeType.VRef) || (arg_type == RangerNodeType.NoType)) {
            arg_type = (argNameN.typeNameAsType(ctx))
          }
          def needs_clone:boolean false
          if (argNameN.type_name == "string") {
            needs_clone = true
          }
          if (arg_type == RangerNodeType.Object) {
            needs_clone = true
          }
          ; In Rust, arrays and hashes need cloning to avoid move errors
          if ((arg_type == RangerNodeType.Array) || (arg_type == RangerNodeType.Hash) || (arg_type == RangerNodeType.IntBuffer) || (arg_type == RangerNodeType.DoubleBuffer) || (arg_type == RangerNodeType.CharBuffer) || (arg_type == RangerNodeType.Buffer)) {
            needs_clone = true
          }
          if needs_clone {
            if (n.value_type == RangerNodeType.VRef) {
              wr.out(".clone()" false)
            }
          }
        }
      }
      wr.out(")" false)
    }
  }
  fn writeClass (node:CodeNode ctx:RangerAppWriterContext orig_wr:CodeWriter) {
    def ucl@(optional):RangerAppClassDesc node.clDesc
    if (null? ucl) {
      return
    }
    def cl:RangerAppClassDesc (unwrap ucl)
    
    ; Save previous class and set current class for self-referential type detection
    def prevClass@(optional):RangerAppClassDesc (ctx.getCurrentClass())
    ctx.setCurrentClass(cl)
    
    def wr:CodeWriter orig_wr
    
    ; Write file header with allow directives for common warnings
    if (fileHeaderWritten == false) {
      wr.out("#![allow(unused_parens)]" true)
      wr.out("#![allow(unused_mut)]" true)
      wr.out("#![allow(unused_variables)]" true)
      wr.out("#![allow(non_snake_case)]" true)
      wr.out("#![allow(dead_code)]" true)
      wr.out("" true)
      wr.out("use std::rc::Rc;" true)
      wr.out("use std::rc::Weak;" true)
      wr.out("use std::cell::RefCell;" true)
      wr.out("" true)
      fileHeaderWritten = true
    }
    
    ; Check if class has trait object fields (cannot derive Clone)
    def hasTraitObjectField:boolean false
    for cl.variables pvar:RangerAppParamDesc i {
      ; Check if the type is a class that has child classes (used as trait object)
      def nameN@(optional):CodeNode pvar.nameNode
      if (!null? nameN) {
        def nn:CodeNode (unwrap nameN)
        def typeName:string nn.type_name
        if ((strlen typeName) > 0) {
          def typeClass@(optional):RangerAppClassDesc (ctx.findClass(typeName))
          if (!null? typeClass) {
            def tc:RangerAppClassDesc (unwrap typeClass)
            if tc.is_extended_by_children {
              hasTraitObjectField = true
            }
          }
        }
      }
    }
    
    if hasTraitObjectField {
      ; Don't derive Clone for structs with trait object fields
      wr.out("// Cannot derive Clone due to trait object fields" true)
    } {
      wr.out("#[derive(Clone)]" true)
    }
    wr.out((("struct " + cl.name) + " { ") true)
    wr.indent(1)
    for cl.variables pvar:RangerAppParamDesc i {
      def pnode:CodeNode (unwrap pvar.node)
      this.writeStructField(pnode ctx wr)
    }
    wr.indent(-1)
    wr.out("}" true)
    wr.out((("impl " + cl.name) + " { ") true)
    wr.indent(1)
    thisName = "me"
    wr.out("" true)
    wr.out("pub fn new(" false)
    if cl.has_constructor {
      def constr@(optional):RangerAppFunctionDesc cl.constructor_fn
      if (!null? constr) {
        def c:RangerAppFunctionDesc (unwrap constr)
        for c.params arg:RangerAppParamDesc i {
          if (i > 0) {
            wr.out(", " false)
          }
          wr.out((arg.name + " : ") false)
          def nameN:CodeNode (unwrap arg.nameNode)
          this.writeTypeDef(nameN ctx wr)
        }
      }
    }
    wr.out(((") ->  " + cl.name) + " {") true)
    wr.indent(1)
    wr.newline()
    wr.out((("let mut me = " + cl.name) + " { ") true)
    wr.indent(1)
    for cl.variables pvar:RangerAppParamDesc i {
      def nn@(optional):CodeNode pvar.node
      if (!null? nn) {
        def node:CodeNode (unwrap nn)
        if ((array_length node.children) > 2) {
          def valueNode:CodeNode (itemAt node.children 2)
          wr.out(((this.adjustType(pvar.compiledName)) + ":") false)
          ctx.setInExpr()
          this.WalkNode(valueNode ctx wr)
          ctx.unsetInExpr()
          wr.out(", " true)
        } {
          ; Initialize array fields with Vec::new()
          if (pvar.isArray()) {
            wr.out(((this.adjustType(pvar.compiledName)) + ": Vec::new(), ") true)
          } {
            ; Initialize optional fields with None
            if pvar.is_optional {
              wr.out(((this.adjustType(pvar.compiledName)) + ": None, ") true)
            }
          }
        }
      }
    }
    wr.indent(-1)
    wr.out("};" true)
    wr.newline()
    if cl.has_constructor {
      def constr@(optional):RangerAppFunctionDesc cl.constructor_fn
      if (!null? constr) {
        def c:RangerAppFunctionDesc (unwrap constr)
        def subCtx@(optional):RangerAppWriterContext c.fnCtx
        if (!null? subCtx) {
          def sCtx:RangerAppWriterContext (unwrap subCtx)
          sCtx.is_function = true
          def fnB:CodeNode (unwrap c.fnBody)
          this.WalkNode(fnB sCtx wr)
        }
      }
    }
    wr.out("return me;" true)
    wr.indent(-1)
    wr.out("}" true)
    thisName = "self"
    
    ; Build call graph for mutation analysis (detects transitive mutations via method calls)
    def directMutations:[string:boolean]
    def callGraph:[string:MethodCallList]
    this.buildClassMutationGraph(cl ctx directMutations callGraph)
    
    for cl.static_methods variant:RangerAppFunctionDesc i {
      def vnn:CodeNode (unwrap variant.nameNode)
      if (vnn.hasFlag("main")) {
        continue _
      }
      wr.out((("pub fn " + variant.name) + "(") false)
      this.writeArgsDef(variant ctx wr)
      wr.out(") -> " false)
      this.writeTypeDef(vnn ctx wr)
      wr.out(" {" true)
      wr.indent(1)
      wr.newline()
      def subCtx@(optional):RangerAppWriterContext variant.fnCtx
      if (!null? subCtx) {
        def sCtx:RangerAppWriterContext (unwrap subCtx)
        sCtx.is_function = true
        def fnB:CodeNode (unwrap variant.fnBody)
        this.WalkNode(fnB sCtx wr)
      }
      wr.newline()
      wr.indent(-1)
      wr.out("}" true)
    }
    for cl.defined_variants fnVar:string i {
      def mVs:RangerAppMethodVariants (get cl.method_variants fnVar)
      for mVs.variants variant:RangerAppFunctionDesc i {
        ; Check if this method uses 'this' - if not, emit as static (no self)
        ; This avoids E0499 errors when calling with &mut self.field arguments
        def fnB@(optional):CodeNode variant.fnBody
        def method_uses_this:boolean true
        def method_mutates_this:boolean true  ; Default to true for safety
        if (!null? fnB) {
          ; Use the function's context for proper member variable lookup
          def fnCtx@(optional):RangerAppWriterContext variant.fnCtx
          def useCtx:RangerAppWriterContext ctx
          if (!null? fnCtx) {
            useCtx = (unwrap fnCtx)
          }
          method_uses_this = (this.fnBodyUsesThis((unwrap fnB) useCtx))
          ; Only check for mutation if the method uses this
          if method_uses_this {
            ; Use call graph for transitive mutation detection
            method_mutates_this = (this.methodMutatesThis(variant.name directMutations callGraph))
            print ("DEBUG method " + cl.name + "." + variant.name + " uses_this=" + (to_string method_uses_this) + " mutates_this=" + (to_string method_mutates_this))
          }
        }
        ; Mark on the function descriptor so writeFnCall knows to use static call
        variant.rust_can_be_static = (method_uses_this == false)
        
        wr.out((("fn " + variant.name) + "(") false)
        if method_uses_this {
          ; For trait parent classes (is_extended_by_children), use &self for trait methods
          ; because mutation happens through RefCell when called via the trait
          ; Only apply to methods that are part of the trait interface
          def method_is_in_trait:boolean false
          if cl.is_extended_by_children {
            ; This is a trait parent class - its own methods are the trait interface
            method_is_in_trait = true
          } {
            ; Check if this class extends a trait parent and if this method is in the trait
            for cl.extends_classes extParentName:string epi {
              def extParentClass@(optional):RangerAppClassDesc (ctx.findClass(extParentName))
              if (!null? extParentClass) {
                def epc:RangerAppClassDesc (unwrap extParentClass)
                if epc.is_extended_by_children {
                  ; Check if this method is defined in the parent's trait interface
                  if (has epc.defined_methods variant.name) {
                    method_is_in_trait = true
                  }
                }
              }
            }
          }
          if method_is_in_trait {
            ; Use &mut self for trait methods to allow mutation
            ; This is necessary because Ranger methods can always mutate state
            wr.out("&mut self, " false)
          } {
            if method_mutates_this {
              wr.out("&mut self, " false)
            } {
              wr.out("&self, " false)
            }
          }
        }
        this.writeArgsDef(variant ctx wr)
        wr.out(") -> " false)
        def vnn:CodeNode (unwrap variant.nameNode)
        this.writeTypeDef(vnn ctx wr)
        wr.out(" {" true)
        wr.indent(1)
        wr.newline()
        def subCtx@(optional):RangerAppWriterContext variant.fnCtx
        if (!null? subCtx) {
          def sCtx:RangerAppWriterContext (unwrap subCtx)
          sCtx.is_function = true
          def fnBNode:CodeNode (unwrap variant.fnBody)
          this.WalkNode(fnBNode sCtx wr)
        }
        wr.newline()
        wr.indent(-1)
        wr.out("}" true)
      }
    }
    wr.indent(-1)
    wr.out("}" true)
    
    ; Generate inherited methods from parent classes
    if ((array_length cl.extends_classes) > 0) {
      for cl.extends_classes parentName:string pi {
        def parentClass@(optional):RangerAppClassDesc (ctx.findClass(parentName))
        if (!null? parentClass) {
          def pc:RangerAppClassDesc (unwrap parentClass)
          
          ; Build call graph for parent class (for mutation analysis)
          def parentDirectMutations:[string:boolean]
          def parentCallGraph:[string:MethodCallList]
          this.buildClassMutationGraph(pc ctx parentDirectMutations parentCallGraph)
          
          wr.out(("impl " + cl.name + " {") true)
          wr.indent(1)
          wr.out(("// Inherited methods from parent class " + parentName) true)
          ; Iterate through parent's methods
          for pc.defined_variants fnVar:string i {
            def mVs:RangerAppMethodVariants (get pc.method_variants fnVar)
            for mVs.variants variant:RangerAppFunctionDesc i {
              ; Skip if child has this method (child overrides it)
              if (has cl.defined_methods variant.name) {
                continue
              }
              ; Generate the inherited method
              def fnB@(optional):CodeNode variant.fnBody
              def method_uses_this:boolean true
              def method_mutates_this:boolean true  ; Default to true for safety
              if (!null? fnB) {
                def fnCtx@(optional):RangerAppWriterContext variant.fnCtx
                def useCtx:RangerAppWriterContext ctx
                if (!null? fnCtx) {
                  useCtx = (unwrap fnCtx)
                }
                method_uses_this = (this.fnBodyUsesThis((unwrap fnB) useCtx))
                ; Only check for mutation if the method uses this
                if method_uses_this {
                  ; Use call graph for transitive mutation detection
                  method_mutates_this = (this.methodMutatesThis(variant.name parentDirectMutations parentCallGraph))
                }
              }
              variant.rust_can_be_static = (method_uses_this == false)
              
              wr.out((("fn " + variant.name) + "(") false)
              if method_uses_this {
                ; For trait parent classes (is_extended_by_children), use &mut self
                ; to allow mutation in the method body
                if pc.is_extended_by_children {
                  wr.out("&mut self, " false)
                } {
                  if method_mutates_this {
                    wr.out("&mut self, " false)
                  } {
                    wr.out("&self, " false)
                  }
                }
              }
              this.writeArgsDef(variant ctx wr)
              wr.out(") -> " false)
              def vnn:CodeNode (unwrap variant.nameNode)
              this.writeTypeDef(vnn ctx wr)
              wr.out(" {" true)
              wr.indent(1)
              wr.newline()
              def subCtx@(optional):RangerAppWriterContext variant.fnCtx
              if (!null? subCtx) {
                def sCtx:RangerAppWriterContext (unwrap subCtx)
                sCtx.is_function = true
                def fnBNode:CodeNode (unwrap variant.fnBody)
                this.WalkNode(fnBNode sCtx wr)
              }
              wr.newline()
              wr.indent(-1)
              wr.out("}" true)
            }
          }
          wr.indent(-1)
          wr.out("}" true)
        }
      }
    }
    
    ; Generate trait if this class is extended by other classes (for Rust polymorphism)
    if cl.is_extended_by_children {
      wr.out("" true)
      wr.out(("pub trait " + cl.name + "Trait {") true)
      wr.indent(1)
      ; Add method signatures only (no default implementations)
      ; Traits use &mut self to allow mutation through the trait interface
      ; This is necessary because Ranger methods can always mutate state
      for cl.defined_variants fnVar:string i {
        def mVs:RangerAppMethodVariants (get cl.method_variants fnVar)
        for mVs.variants variant:RangerAppFunctionDesc i {
          ; Use &mut self for trait methods to allow mutation
          wr.out(("fn " + variant.name + "(&mut self") false)
          for variant.params arg:RangerAppParamDesc pi {
            wr.out(", " false)
            def nameN:CodeNode (unwrap arg.nameNode)
            wr.out((arg.compiledName + " : ") false)
            this.writeTypeDef(nameN ctx wr)
          }
          wr.out(") -> " false)
          def vnn:CodeNode (unwrap variant.nameNode)
          this.writeTypeDef(vnn ctx wr)
          wr.out(";" true)
        }
      }
      wr.indent(-1)
      wr.out("}" true)
      
      ; Implement the trait for this class itself
      wr.out(("impl " + cl.name + "Trait for " + cl.name + " {") true)
      wr.indent(1)
      for cl.defined_variants fnVar:string i {
        def mVs:RangerAppMethodVariants (get cl.method_variants fnVar)
        for mVs.variants variant:RangerAppFunctionDesc i {
          ; Use &mut self for trait methods to match trait definition
          wr.out(("fn " + variant.name + "(&mut self") false)
          for variant.params arg:RangerAppParamDesc pi {
            wr.out(", " false)
            def nameN:CodeNode (unwrap arg.nameNode)
            wr.out((arg.compiledName + " : ") false)
            this.writeTypeDef(nameN ctx wr)
          }
          wr.out(") -> " false)
          def vnn:CodeNode (unwrap variant.nameNode)
          this.writeTypeDef(vnn ctx wr)
          wr.out(" {" true)
          wr.indent(1)
          ; Check if method is static - if so, don't pass self
          if variant.rust_can_be_static {
            wr.out(((cl.name + "::" + variant.name) + "(") false)
            def firstArg:boolean true
            for variant.params arg:RangerAppParamDesc pi {
              if firstArg {
                firstArg = false
              } {
                wr.out(", " false)
              }
              wr.out(arg.compiledName false)
            }
          } {
            wr.out(((cl.name + "::" + variant.name) + "(self") false)
            for variant.params arg:RangerAppParamDesc pi {
              wr.out((", " + arg.compiledName) false)
            }
          }
          wr.out(")" true)
          wr.indent(-1)
          wr.out("}" true)
        }
      }
      wr.indent(-1)
      wr.out("}" true)
    }
    
    ; If this class extends a parent class, implement the parent's trait
    if ((array_length cl.extends_classes) > 0) {
      for cl.extends_classes parentName:string pi {
        def parentClass@(optional):RangerAppClassDesc (ctx.findClass(parentName))
        if (!null? parentClass) {
          def pc:RangerAppClassDesc (unwrap parentClass)
          if pc.is_extended_by_children {
            wr.out(("impl " + parentName + "Trait for " + cl.name + " {") true)
            wr.indent(1)
            ; Implement ALL parent trait methods
            for pc.defined_variants fnVar:string i {
              def mVs:RangerAppMethodVariants (get pc.method_variants fnVar)
              for mVs.variants variant:RangerAppFunctionDesc i {
                ; Use &mut self for trait methods to match trait definition
                wr.out(("fn " + variant.name + "(&mut self") false)
                for variant.params arg:RangerAppParamDesc pi {
                  wr.out(", " false)
                  def nameN:CodeNode (unwrap arg.nameNode)
                  wr.out((arg.compiledName + " : ") false)
                  this.writeTypeDef(nameN ctx wr)
                }
                wr.out(") -> " false)
                def vnn:CodeNode (unwrap variant.nameNode)
                this.writeTypeDef(vnn ctx wr)
                wr.out(" {" true)
                wr.indent(1)
                ; Determine if we should use the child's version or inherited version
                ; and whether the method is static
                def isStatic:boolean variant.rust_can_be_static
                ; If child has this method, check child's version for static
                if (has cl.defined_methods variant.name) {
                  ; Child overrides - check child's method for static status
                  if (has cl.method_variants variant.name) {
                    def cmvs:RangerAppMethodVariants (get cl.method_variants variant.name)
                    if ((array_length cmvs.variants) > 0) {
                      def childVariant:RangerAppFunctionDesc (at cmvs.variants 0)
                      isStatic = childVariant.rust_can_be_static
                    }
                  }
                }
                ; Generate the call
                if isStatic {
                  wr.out(((cl.name + "::" + variant.name) + "(") false)
                  def firstArg:boolean true
                  for variant.params arg:RangerAppParamDesc pi {
                    if firstArg {
                      firstArg = false
                    } {
                      wr.out(", " false)
                    }
                    wr.out(arg.compiledName false)
                  }
                } {
                  wr.out(((cl.name + "::" + variant.name) + "(self") false)
                  for variant.params arg:RangerAppParamDesc pi {
                    wr.out((", " + arg.compiledName) false)
                  }
                }
                wr.out(")" true)
                wr.indent(-1)
                wr.out("}" true)
              }
            }
            wr.indent(-1)
            wr.out("}" true)
          }
        }
      }
    }
    
    for cl.static_methods variant:RangerAppFunctionDesc i {
      def nn:CodeNode (unwrap variant.nameNode)
      if ((nn.hasFlag("main")) && (nn.code.filename == (ctx.getRootFile()))) {
        wr.out("fn main() {" true)
        wr.indent(1)
        wr.newline()
        def subCtx@(optional):RangerAppWriterContext variant.fnCtx
        if (!null? subCtx) {
          def sCtx:RangerAppWriterContext (unwrap subCtx)
          sCtx.is_function = true
          def fnB:CodeNode (unwrap variant.fnBody)
          this.WalkNode(fnB sCtx wr)
        }
        wr.newline()
        wr.indent(-1)
        wr.out("}" true)
      }
    }
    ; Restore previous class context
    if (!null? prevClass) {
      ctx.setCurrentClass((unwrap prevClass))
    }
  }

  ; Custom operator handler for Rust - handles push with string conversion and optional assignments
  fn CustomOperator:void (node:CodeNode ctx:RangerAppWriterContext wr:CodeWriter) {
    def fc:CodeNode (node.getFirst())
    def cmd:string fc.vref

    ; Handle print operator - use references to avoid moving/cloning values
    if (cmd == "print") {
      def arg:CodeNode (node.getSecond())
      wr.out("println!(\"{}\", " false)
      
      ; Check if argument is a simple variable reference that would be moved
      ; If so, use a reference instead
      if (arg.value_type == RangerNodeType.VRef) {
        ; For variables, use & reference to avoid moving
        wr.out("&" false)
        ctx.setInExpr()
        this.WalkNode(arg ctx wr)
        ctx.unsetInExpr()
      } {
        ; For expressions (like string concatenation), just evaluate normally
        ctx.setInExpr()
        this.WalkNode(arg ctx wr)
        ctx.unsetInExpr()
      }
      wr.out(");" true)
      return
    }

    ; Handle assignment operations in Rust
    if (cmd == "=") {
      def left:CodeNode (node.getSecond())
      def right:CodeNode (node.getThird())
      
      ; Check if left side is an optional field with self-referential type
      def is_optional:boolean false
      def is_self_ref:boolean false
      def is_weak:boolean false  ; True if LHS field has @(weak) annotation
      def field_type_name:string ""
      def left_is_self_field:boolean false
      def left_is_array:boolean false
      def left_is_trait_type:boolean false  ; True if LHS field type is a trait (parent class)
      def curr_class_is_trait_related:boolean false  ; True if current class is trait parent or extends one
      
      ; Check if current class is trait-related
      def ucAssign@(optional):RangerAppClassDesc (ctx.getCurrentClass())
      if (!null? ucAssign) {
        def currCAssign:RangerAppClassDesc (unwrap ucAssign)
        if currCAssign.is_extended_by_children {
          curr_class_is_trait_related = true
        }
        if (curr_class_is_trait_related == false) {
          for currCAssign.extends_classes extParentNameA:string epiA {
            def extParentClassA@(optional):RangerAppClassDesc (ctx.findClass(extParentNameA))
            if (!null? extParentClassA) {
              def epcA:RangerAppClassDesc (unwrap extParentClassA)
              if epcA.is_extended_by_children {
                curr_class_is_trait_related = true
              }
            }
          }
        }
      }
      
      if left.hasParamDesc {
        def pp:RangerAppParamDesc left.paramDesc
        is_optional = pp.is_optional
        left_is_self_field = pp.is_class_variable
        def nameN@(optional):CodeNode pp.nameNode
        if (!null? nameN) {
          def nn:CodeNode (unwrap nameN)
          field_type_name = nn.type_name
          ; Check if field has weak annotation
          if (nn.hasFlag("weak")) {
            is_weak = true
          }
          ; Check if field is an array type 
          if (nn.value_type == RangerNodeType.Array) {
            left_is_array = true
          }
          ; Check if field type equals the class that owns this property (self-referential)
          def oc@(optional):RangerAppClassDesc pp.propertyClass
          if (!null? oc) {
            def ownerClass:RangerAppClassDesc (unwrap oc)
            if (ownerClass.name == field_type_name) {
              is_self_ref = true
            }
          }
          ; Check if the field type is a trait type (parent class that is extended)
          def fieldTypeClass@(optional):RangerAppClassDesc (ctx.findClass(field_type_name))
          if (!null? fieldTypeClass) {
            def ftc:RangerAppClassDesc (unwrap fieldTypeClass)
            if ftc.is_extended_by_children {
              left_is_trait_type = true
            }
          }
        }
        ; Debug output for problematic assignments - disabled
        ; if is_optional {
        ;   def dbg_is_arr:string "false"
        ;   if left_is_array {
        ;     dbg_is_arr = "true"
        ;   }
        ;   print ("DEBUG: Assignment has is_optional=true, field=" + field_type_name + " left_is_array=" + dbg_is_arr)
        ; }
      }
      
      ; Arrays are not optional even if pp.is_optional says so - this can happen due to 
      ; how some array fields are inferred
      if left_is_array {
        is_optional = false
      }
      
      ; Check if right side is a variable that should be cloned
      ; Clone when: assigning a non-primitive VRef to a field (the var may be used later)
      def should_clone_rhs:boolean false
      def rhs_is_string:boolean false
      def rhs_is_object:boolean false
      def rhs_is_optional:boolean false
      def rhs_is_array:boolean false
      
      ; Debug: Check what kind of node the right side is
      ; print ("DEBUG right: value_type=" + (node_type_as_string right.value_type) + " hasParamDesc=" + (if right.hasParamDesc "true" "false"))
      
      ; For field access like specifier.local, check the evalType which should tell us if it's optional
      if right.hasParamDesc {
        def rp:RangerAppParamDesc right.paramDesc
        ; Also check for objects
        def rNameN@(optional):CodeNode rp.nameNode
        if (!null? rNameN) {
          def rnn:CodeNode (unwrap rNameN)
          if (rnn.type_name == "string") {
            rhs_is_string = true
          }
          def rv_type:RangerNodeType rnn.value_type
          if ((rv_type == RangerNodeType.Object) || (rv_type == RangerNodeType.VRef)) {
            rv_type = (rnn.typeNameAsType(ctx))
          }
          if (rv_type == RangerNodeType.Object) {
            rhs_is_object = true
          }
          if (rv_type == RangerNodeType.Array) {
            rhs_is_object = true
            rhs_is_array = true
          }
        }
        ; Set rhs_is_optional only if it's actually optional and NOT an array
        ; Arrays in Rust are Vec<T>, not Option<Vec<T>>
        if rp.is_optional {
          if (rhs_is_array == false) {
            rhs_is_optional = true
          }
        }
        ; Clone if RHS is used more than once (based on ref_cnt)
        ; or if it's being assigned to a field (it might be used again)
        if left_is_self_field {
          if (rhs_is_string || rhs_is_object) {
            should_clone_rhs = true
          }
        }
        ; Also clone strings/objects when assigning between local variables
        ; because the source variable might be used later
        if rhs_is_string {
          should_clone_rhs = true
        }
        if rhs_is_object {
          should_clone_rhs = true  
        }
        ; Clone optional fields when assigning to prevent partial move
        if rhs_is_optional {
          should_clone_rhs = true
        }
        ; But don't clone if RHS type has trait object fields (no Clone derive)
        if should_clone_rhs {
          if rhs_is_object {
            def rNameN2@(optional):CodeNode rp.nameNode
            if (!null? rNameN2) {
              def rnn2:CodeNode (unwrap rNameN2)
              def rhsTypeName2:string rnn2.type_name
              if ((strlen rhsTypeName2) > 0) {
                def rhsTypeClass2@(optional):RangerAppClassDesc (ctx.findClass(rhsTypeName2))
                if (!null? rhsTypeClass2) {
                  def rtc2:RangerAppClassDesc (unwrap rhsTypeClass2)
                  ; Check if this class has trait object fields
                  for rtc2.variables pvar2:RangerAppParamDesc i2 {
                    def pNameN2@(optional):CodeNode pvar2.nameNode
                    if (!null? pNameN2) {
                      def pnn2:CodeNode (unwrap pNameN2)
                      def pTypeName2:string pnn2.type_name
                      if ((strlen pTypeName2) > 0) {
                        def pTypeClass2@(optional):RangerAppClassDesc (ctx.findClass(pTypeName2))
                        if (!null? pTypeClass2) {
                          def ptc2:RangerAppClassDesc (unwrap pTypeClass2)
                          if ptc2.is_extended_by_children {
                            ; This class has trait object fields, can't clone
                            should_clone_rhs = false
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      if (right.value_type == RangerNodeType.VRef) {
        if right.hasParamDesc {
          def rp:RangerAppParamDesc right.paramDesc
          def rNameN@(optional):CodeNode rp.nameNode
          if (!null? rNameN) {
            def rnn:CodeNode (unwrap rNameN)
            if (rnn.type_name == "string") {
              rhs_is_string = true
            }
            def rv_type:RangerNodeType rnn.value_type
            if ((rv_type == RangerNodeType.Object) || (rv_type == RangerNodeType.VRef)) {
              rv_type = (rnn.typeNameAsType(ctx))
            }
            if (rv_type == RangerNodeType.Object) {
              rhs_is_object = true
            }
            if (rv_type == RangerNodeType.Array) {
              rhs_is_object = true
              rhs_is_array = true
            }
          }
          ; Set rhs_is_optional only if it's actually optional and NOT an array
          ; Arrays in Rust are Vec<T>, not Option<Vec<T>>
          if rp.is_optional {
            if (rhs_is_array == false) {
              rhs_is_optional = true
            }
          }
          ; Clone if RHS is used more than once (based on ref_cnt)
          ; or if it's being assigned to a field (it might be used again)
          if left_is_self_field {
            if (rhs_is_string || rhs_is_object) {
              should_clone_rhs = true
            }
          }
          ; Also clone strings/objects when assigning between local variables
          ; because the source variable might be used later
          if rhs_is_string {
            should_clone_rhs = true
          }
          if rhs_is_object {
            should_clone_rhs = true  
          }
          ; Clone optional fields when assigning to prevent partial move
          if rhs_is_optional {
            should_clone_rhs = true
          }
          ; But don't clone if RHS type has trait object fields (no Clone derive)
          if should_clone_rhs {
            if rhs_is_object {
              def rNameN3@(optional):CodeNode rp.nameNode
              if (!null? rNameN3) {
                def rnn3:CodeNode (unwrap rNameN3)
                def rhsTypeName3:string rnn3.type_name
                if ((strlen rhsTypeName3) > 0) {
                  def rhsTypeClass3@(optional):RangerAppClassDesc (ctx.findClass(rhsTypeName3))
                  if (!null? rhsTypeClass3) {
                    def rtc3:RangerAppClassDesc (unwrap rhsTypeClass3)
                    ; Check if this class has trait object fields
                    for rtc3.variables pvar3:RangerAppParamDesc i3 {
                      def pNameN3@(optional):CodeNode pvar3.nameNode
                      if (!null? pNameN3) {
                        def pnn3:CodeNode (unwrap pNameN3)
                        def pTypeName3:string pnn3.type_name
                        if ((strlen pTypeName3) > 0) {
                          def pTypeClass3@(optional):RangerAppClassDesc (ctx.findClass(pTypeName3))
                          if (!null? pTypeClass3) {
                            def ptc3:RangerAppClassDesc (unwrap pTypeClass3)
                            if ptc3.is_extended_by_children {
                              ; This class has trait object fields, can't clone
                              should_clone_rhs = false
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
      ; Check if RHS is already a Rc<dyn Trait> (parameter with trait object type)
      def rhs_is_already_boxed_trait:boolean false
      if (right.value_type == RangerNodeType.VRef) {
        if right.hasParamDesc {
          def rhsP:RangerAppParamDesc right.paramDesc
          def rhsNameN@(optional):CodeNode rhsP.nameNode
          if (!null? rhsNameN) {
            def rhsNN:CodeNode (unwrap rhsNameN)
            def rhsTypeName:string rhsNN.type_name
            if ((strlen rhsTypeName) > 0) {
              def rhsTypeClass@(optional):RangerAppClassDesc (ctx.findClass(rhsTypeName))
              if (!null? rhsTypeClass) {
                def rtc:RangerAppClassDesc (unwrap rhsTypeClass)
                if rtc.is_extended_by_children {
                  ; RHS is a parameter of trait object type, already Rc<dyn Trait>
                  rhs_is_already_boxed_trait = true
                  should_clone_rhs = false
                }
              }
            }
          }
        }
      }
      
      ctx.setInExpr()
      this.WalkNode(left ctx wr)
      
      ; Handle weak reference assignments - use Rc::downgrade() to create Weak pointer
      if is_weak {
        ; Check if RHS is a parameter that's already Rc<RefCell<T>> (rust_needs_rc_wrap)
        def rhs_is_rc_wrapped:boolean false
        if right.hasParamDesc {
          def rhsParam:RangerAppParamDesc right.paramDesc
          if rhsParam.rust_needs_rc_wrap {
            rhs_is_rc_wrapped = true
          }
        }
        
        if rhs_is_rc_wrapped {
          ; RHS is already Rc<RefCell<T>>, just downgrade it directly
          if is_optional {
            wr.out(" = Some(Rc::downgrade(&" false)
            this.WalkNode(right ctx wr)
            wr.out("));" true)
          } {
            wr.out(" = Rc::downgrade(&" false)
            this.WalkNode(right ctx wr)
            wr.out(");" true)
          }
        } {
          ; RHS is a raw value, need to wrap in Rc::new(RefCell::new(...)) first
          ; WARNING: This creates a temporary Rc that goes out of scope immediately,
          ; making the Weak reference invalid! This pattern should be avoided.
          ; The proper fix is to ensure the caller passes an Rc<RefCell<T>>.
          if is_optional {
            wr.out(" = Some(Rc::downgrade(&Rc::new(RefCell::new(" false)
            this.WalkNode(right ctx wr)
            if should_clone_rhs {
              wr.out(".clone()" false)
            }
            wr.out("))));" true)
          } {
            wr.out(" = Rc::downgrade(&Rc::new(RefCell::new(" false)
            this.WalkNode(right ctx wr)
            if should_clone_rhs {
              wr.out(".clone()" false)
            }
            wr.out(")));" true)
          }
        }
        ctx.unsetInExpr()
        return
      }
      
      if is_optional {
        if rhs_is_optional {
          ; Both sides are optional - just clone the RHS, don't wrap with Some()
          wr.out(" = " false)
          this.WalkNode(right ctx wr)
          wr.out(".clone();" true)
        } {
          if is_self_ref {
            ; Assignment to self-referential optional field: needs Some(Box::new(value.clone()))
            wr.out(" = Some(Box::new(" false)
            this.WalkNode(right ctx wr)
            wr.out(".clone()));" true)
          } {
            if left_is_trait_type {
              if rhs_is_already_boxed_trait {
                ; RHS is already Rc<RefCell<dyn Trait>>, clone the Rc for shared ownership
                wr.out(" = Some(" false)
                this.WalkNode(right ctx wr)
                wr.out(".clone());" true)
              } {
                ; Assignment to trait type field: needs Some(Rc::new(RefCell::new(value)))
                wr.out(" = Some(Rc::new(RefCell::new(" false)
                this.WalkNode(right ctx wr)
                if should_clone_rhs {
                  wr.out(".clone()" false)
                }
                wr.out(")));" true)
              }
            } {
              ; Check if this is a non-trait optional object field in a trait-related class
              ; Such fields are wrapped in Option<RefCell<T>>
              def needs_refcell_wrap_assign:boolean false
              if curr_class_is_trait_related {
                ; Check if field type is an object type (not primitive)
                def fieldTypeClassAssign@(optional):RangerAppClassDesc (ctx.findClass(field_type_name))
                if (!null? fieldTypeClassAssign) {
                  needs_refcell_wrap_assign = true
                }
              }
              if needs_refcell_wrap_assign {
                ; Optional assignment to RefCell-wrapped field: Some(RefCell::new(value))
                wr.out(" = Some(RefCell::new(" false)
                this.WalkNode(right ctx wr)
                if should_clone_rhs {
                  wr.out(".clone()" false)
                }
                wr.out("));" true)
              } {
                ; Standard optional assignment: wrap with Some()
                wr.out(" = Some(" false)
                this.WalkNode(right ctx wr)
                if should_clone_rhs {
                  wr.out(".clone()" false)
                }
                wr.out(");" true)
              }
            }
          }
        }
      } {
        ; Non-optional assignment
        wr.out(" = " false)
        if left_is_trait_type {
          if rhs_is_already_boxed_trait {
            ; RHS is already Rc<RefCell<dyn Trait>>, clone for shared ownership
            this.WalkNode(right ctx wr)
            wr.out(".clone()" false)
          } {
            wr.out("Rc::new(RefCell::new(" false)
            this.WalkNode(right ctx wr)
            if should_clone_rhs {
              wr.out(".clone()" false)
            }
            wr.out("))" false)
          }
        } {
          this.WalkNode(right ctx wr)
          if should_clone_rhs {
            wr.out(".clone()" false)
          }
        }
        ; If RHS is optional but LHS is not, need to unwrap
        if rhs_is_optional {
          wr.out(".unwrap()" false)
        }
        wr.out(";" true)
      }
      ctx.unsetInExpr()
      return
    }

    if (cmd == "return") {
      def cnt:int (node.children.length())
      if (cnt > 1) {
        def retVal:CodeNode (node.getSecond())
        
        ; Check if the return value is a function call with nested self method calls
        ; Pattern: return this.method1(this.method2(...), ...) 
        ; In Rust this causes double-borrow - we need to extract inner self calls first
        if retVal.hasFnCall {
          def retFc:CodeNode (retVal.getFirst())
          def isSelfCall:boolean false
          if (has retFc.ns) {
            def firstPart:string (itemAt retFc.ns 0)
            if (firstPart == "this") {
              isSelfCall = true
            }
          }
          
          if isSelfCall {
            ; Check arguments for nested self method calls
            def givenArgs:CodeNode (retVal.getSecond())
            def tempVars:[string]
            def tempIdx:int 0
            
            for givenArgs.children arg:CodeNode i {
              if arg.hasFnCall {
                def argFc:CodeNode (arg.getFirst())
                if (has argFc.ns) {
                  def argFirstPart:string (itemAt argFc.ns 0)
                  if (argFirstPart == "this") {
                    ; Found nested self call - extract to temp var
                    def tmpName:string (ctx.rustGetTempVar())
                    wr.out(("let " + tmpName + " = ") false)
                    ctx.setInExpr()
                    this.WalkNode(arg ctx wr)
                    ctx.unsetInExpr()
                    wr.out(";" true)
                    push tempVars tmpName
                    tempIdx = tempIdx + 1
                  } {
                    push tempVars ""
                  }
                } {
                  push tempVars ""
                }
              } {
                push tempVars ""
              }
            }
            
            ; Now emit the return with temp vars substituted
            if (tempIdx > 0) {
              wr.out("return " false)
              this.WriteVRef(retFc ctx wr)
              wr.out("(" false)
              for retVal.fnDesc.params arg:RangerAppParamDesc i {
                if (i > 0) {
                  wr.out(", " false)
                }
                def tmpVar:string (itemAt tempVars i)
                if ((strlen tmpVar) > 0) {
                  wr.out(tmpVar false)
                } {
                  def n@(optional):CodeNode (itemAt givenArgs.children i)
                  if (!null? n) {
                    def nVal:CodeNode (unwrap n)
                    ctx.setInExpr()
                    this.WalkNode(nVal ctx wr)
                    ctx.unsetInExpr()
                    ; Clone if needed for strings/objects
                    def argNameN:CodeNode (unwrap arg.nameNode)
                    if ((argNameN.type_name == "string") && (nVal.value_type == RangerNodeType.VRef)) {
                      wr.out(".clone()" false)
                    }
                  }
                }
              }
              wr.out(")" false)
              ; Add clone for return value if needed
              def tn:string retVal.eval_type_name
              if ((tn == "string") || (retVal.eval_type == RangerNodeType.Object)) {
                wr.out(".clone()" false)
              }
              wr.out(";" true)
              return
            }
          }
        }
        
        ; Default case - no nested self calls or not a self call
        wr.out("return " false)
        ctx.setInExpr()
        this.WalkNode(retVal ctx wr)
        ctx.unsetInExpr()
        ; Add .clone() for non-primitive types (String, objects, arrays, etc.) 
        ; Check if the return value needs cloning based on its evaluated type
        def tn:string retVal.eval_type_name
        def needs_ret_clone:boolean false
        if ((tn == "string") || (retVal.eval_type == RangerNodeType.Object)) {
          needs_ret_clone = true
        }
        ; Arrays also need cloning when returning from self fields
        if (retVal.eval_type == RangerNodeType.Array) {
          needs_ret_clone = true
        }
        ; If returning a VRef (variable reference), check if it's a self field
        if (retVal.value_type == RangerNodeType.VRef) {
          if retVal.hasParamDesc {
            def rp:RangerAppParamDesc retVal.paramDesc
            if rp.is_class_variable {
              ; Returning a self field - clone unless primitive
              def rNameN@(optional):CodeNode rp.nameNode
              if (!null? rNameN) {
                def rnn:CodeNode (unwrap rNameN)
                def rv_type:RangerNodeType rnn.value_type
                if ((rv_type == RangerNodeType.Object) || (rv_type == RangerNodeType.VRef)) {
                  rv_type = (rnn.typeNameAsType(ctx))
                }
                if ((rv_type == RangerNodeType.Object) || (rv_type == RangerNodeType.Array) || (rv_type == RangerNodeType.Buffer) || (rv_type == RangerNodeType.IntBuffer)) {
                  needs_ret_clone = true
                }
              }
            }
          }
        }
        if needs_ret_clone {
          wr.out(".clone()" false)
        }
        wr.out(";" true)
      } {
        wr.out("return;" true)
      }
      return
    }

    ; Handle clear for optional objects - need to unwrap before calling clear()
    if (cmd == "clear") {
      def target:CodeNode (node.getSecond())
      def is_optional_target:boolean false
      
      ; Check if target is an optional field
      if target.hasParamDesc {
        def pp:RangerAppParamDesc target.paramDesc
        if pp.is_optional {
          ; Check it's not an array (arrays handled differently)
          def nameN@(optional):CodeNode pp.nameNode
          if (!null? nameN) {
            def nn:CodeNode (unwrap nameN)
            if (nn.value_type != RangerNodeType.Array) {
              is_optional_target = true
            }
          }
        }
      }
      
      if is_optional_target {
        ; For optional objects, unwrap then call clear
        ; Check if the owning class is trait-related (uses Option<RefCell<T>>)
        def clear_needs_borrow_mut:boolean false
        if target.hasParamDesc {
          def clearPp:RangerAppParamDesc target.paramDesc
          def clearOwnerClass@(optional):RangerAppClassDesc clearPp.propertyClass
          ; If propertyClass is null, fall back to current class (self field)
          if (null? clearOwnerClass) {
            if clearPp.is_class_variable {
              clearOwnerClass = (ctx.getCurrentClass())
            }
          }
          if (!null? clearOwnerClass) {
            def clearOwnerC:RangerAppClassDesc (unwrap clearOwnerClass)
            if clearOwnerC.is_extended_by_children {
              clear_needs_borrow_mut = true
            }
            if (clear_needs_borrow_mut == false) {
              for clearOwnerC.extends_classes clearExtParent:string clearEpi {
                def clearExtParentClass@(optional):RangerAppClassDesc (ctx.findClass(clearExtParent))
                if (!null? clearExtParentClass) {
                  def clearEpc:RangerAppClassDesc (unwrap clearExtParentClass)
                  if clearEpc.is_extended_by_children {
                    clear_needs_borrow_mut = true
                  }
                }
              }
            }
          }
        }
        ctx.setInExpr()
        this.WalkNode(target ctx wr)
        if clear_needs_borrow_mut {
          wr.out(".as_ref().unwrap().borrow_mut().clear();" true)
        } {
          wr.out(".as_mut().unwrap().clear();" true)
        }
        ctx.unsetInExpr()
      } {
        ; For non-optional arrays, use the standard .length = 0 pattern
        ctx.setInExpr()
        this.WalkNode(target ctx wr)
        wr.out(".length = 0;" true)
        ctx.unsetInExpr()
      }
      return
    }

    if (cmd == "push") {
      def left:CodeNode (node.getSecond())
      def right:CodeNode (node.getThird())
      
      ; Get the array type to check if it's a string array
      def arr_type:string ""
      if left.hasParamDesc {
        def pp:RangerAppParamDesc left.paramDesc
        arr_type = pp.nameNode.array_type
      }
      
      ; Check if the pushed value might be used after this (needs cloning)
      def needs_clone:boolean false
      if (right.value_type == RangerNodeType.VRef) {
        if right.hasParamDesc {
          def rp:RangerAppParamDesc right.paramDesc
          ; Clone if ref_cnt > 1 (used more than once) or if it's a string/object
          if (rp.ref_cnt > 1) {
            needs_clone = true
          }
          ; Always clone strings since they don't implement Copy
          if (arr_type == "string") {
            needs_clone = true
          }
        }
      }
      
      ; Write the push operation
      ctx.setInExpr()
      this.WalkNode(left ctx wr)
      wr.out(".push(" false)
      this.WalkNode(right ctx wr)
      
      ; Add .to_string() if pushing to a string array and the value is a string literal
      if (arr_type == "string") {
        if (right.value_type == RangerNodeType.String) {
          wr.out(".to_string()" false)
        }
      }
      ; Clone when needed to avoid move errors
      if needs_clone {
        wr.out(".clone()" false)
      } {
        ; Add .clone() when pushing objects to arrays (the pushed value may be used later)
        if (right.value_type == RangerNodeType.VRef) {
          if (arr_type != "string") {
            if (arr_type != "int") {
              if (arr_type != "double") {
                if (arr_type != "boolean") {
                  wr.out(".clone()" false)
                }
              }
            }
          }
        }
      }
      ctx.unsetInExpr()
      wr.out(");" true)
      return
    }

    ; Handle unwrap for optional types - need to dereference Box for self-referential types
    ; and handle Weak references with upgrade()
    if (cmd == "unwrap") {
      def arg:CodeNode (node.getSecond())
      
      ; Check if the inner type is a self-referential Box
      def needs_deref:boolean false
      def is_self_field:boolean false
      def is_weak_ref:boolean false
      def inner_type:string ""
      
      if arg.hasParamDesc {
        def pp:RangerAppParamDesc arg.paramDesc
        ; Check if this is a class variable (self field)
        is_self_field = pp.is_class_variable
        def nameN@(optional):CodeNode pp.nameNode
        if (!null? nameN) {
          def nn:CodeNode (unwrap nameN)
          inner_type = nn.type_name
          ; Check if this is a weak reference
          if (nn.hasFlag("weak")) {
            is_weak_ref = true
          }
          ; Check if field type equals the class that owns this property (self-referential)
          def oc@(optional):RangerAppClassDesc pp.propertyClass
          if (!null? oc) {
            def ownerClass:RangerAppClassDesc (unwrap oc)
            if (ownerClass.name == inner_type) {
              needs_deref = true
            }
          }
        }
      }
      
      ctx.setInExpr()
      
      ; Handle weak references - need to upgrade() to get Rc, then borrow_mut() to access value
      if is_weak_ref {
        this.WalkNode(arg ctx wr)
        if is_self_field {
          ; Clone the Option<Weak<...>> first, then upgrade and borrow
          wr.out(".clone().unwrap().upgrade().unwrap().borrow_mut()" false)
        } {
          wr.out(".unwrap().upgrade().unwrap().borrow_mut()" false)
        }
        ctx.unsetInExpr()
        return
      }
      
      if needs_deref {
        wr.out("(*" false)
        this.WalkNode(arg ctx wr)
        ; Clone self fields before unwrap to avoid moving out of self
        if is_self_field {
          wr.out(".clone().unwrap())" false)
        } {
          wr.out(".unwrap())" false)
        }
      } {
        this.WalkNode(arg ctx wr)
        ; Clone self fields before unwrap to avoid moving out of self
        if is_self_field {
          wr.out(".clone().unwrap()" false)
        } {
          wr.out(".unwrap()" false)
        }
      }
      ctx.unsetInExpr()
      return
    }
  }
}
