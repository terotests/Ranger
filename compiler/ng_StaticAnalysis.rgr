; ng_StaticAnalysis.rgr
; Static analysis pass for C++ and Rust code generation
; Detects mutation patterns to generate proper references and borrows

Import "ng_RangerAppParamDesc.rgr"
Import "ng_RangerAppFunctionDesc.rgr"
Import "ng_RangerAppClassDesc.rgr"
Import "ng_RangerAppEnums.rgr"
Import "ng_CodeNode.rgr"
Import "ng_RangerAppWriterContext.rgr"

class StaticAnalyzer {
  def ctx@(optional):RangerAppWriterContext
  def currentFunction@(weak optional):RangerAppFunctionDesc
  def currentClass@(weak optional):RangerAppClassDesc
  def debug:boolean true
  
  ; Registry of operators that mutate their first argument
  def mutatingOps:[string:boolean]
  
  Constructor () {
    ; Initialize empty - will be set up when analyzeAll is called
  }
  
  fn initMutatingOps:void () {
    ; Buffer/array mutation operators - these modify data IN-PLACE
    set mutatingOps "buffer_set" true
    set mutatingOps "int_buffer_set" true
    set mutatingOps "double_buffer_set" true
    set mutatingOps "int_buffer_fill" true
    set mutatingOps "double_buffer_fill" true
    
    ; Array mutation operators - these modify the array IN-PLACE
    set mutatingOps "push" true
    set mutatingOps "set" true
    set mutatingOps "clear" true
    set mutatingOps "remove" true
    set mutatingOps "removeIndex" true
    set mutatingOps "removeLast" true
    set mutatingOps "removeFirst" true
    
    ; Dictionary mutation operators
    set mutatingOps "put" true
    
    ; NOTE: "=" is NOT a mutating operator - it reassigns the variable,
    ; it doesn't modify the object in-place
  }
  
  ; Check if an operator mutates its first argument
  fn isMutatingOperator:boolean (opName:string) {
    if (has mutatingOps opName) {
      return (unwrap (get mutatingOps opName))
    }
    return false
  }
  
  ; Check if a node represents a mutating operation
  fn isMutatingNode:boolean (node:CodeNode) {
    if (node.expression == false) { 
      return false 
    }
    if ((array_length node.children) == 0) {
      return false
    }
    def first:CodeNode (node.getFirst())
    if ((strlen first.vref) > 0) {
      return (this.isMutatingOperator(first.vref))
    }
    return false
  }
  
  ; Get the root variable name from a node
  fn getRootVarName:string (node:CodeNode) {
    if ((strlen node.vref) > 0) {
      return node.vref
    }
    ; For expressions with children, check first child
    if ((array_length node.children) > 0) {
      def first:CodeNode (node.getFirst())
      if ((strlen first.vref) > 0) {
        return first.vref
      }
    }
    return ""
  }
  
  ; Check if a node looks like a member access (obj.field pattern)
  fn isMemberAccess:boolean (node:CodeNode) {
    ; Check namespace array - this is how member access is represented in the AST
    ; e.g., currentChunk.data would have ns = ["currentChunk", "data"]
    if ((array_length node.ns) >= 2) {
      return true
    }
    ; Member access in Ranger: vref contains a dot like "obj.field"
    if ((strlen node.vref) > 0) {
      def idx:int (indexOf node.vref ".")
      if (idx > 0) {
        return true
      }
    }
    ; Or it could be an expression with children for chained access
    if node.expression {
      if ((array_length node.children) >= 2) {
        def first:CodeNode (node.getFirst())
        ; If first child looks like a variable or "this", it might be member access
        if ((strlen first.vref) > 0) {
          def second:CodeNode (node.getSecond())
          if ((strlen second.vref) > 0) {
            ; This looks like (obj field) pattern
            return true
          }
        }
      }
    }
    return false
  }
  
  ; Get the member path from a member access expression
  fn getMemberPath:string (node:CodeNode) {
    ; Check namespace array first - this is the primary representation
    if ((array_length node.ns) >= 2) {
      def path:string ""
      for node.ns part:string i {
        if (i > 0) {
          path = path + "."
        }
        path = path + part
      }
      return path
    }
    ; Simple case: vref contains dot
    if ((strlen node.vref) > 0) {
      def idx:int (indexOf node.vref ".")
      if (idx > 0) {
        return node.vref
      }
    }
    ; Expression case
    if node.expression {
      if ((array_length node.children) >= 2) {
        def first:CodeNode (node.getFirst())
        def second:CodeNode (node.getSecond())
        if (((strlen first.vref) > 0) && ((strlen second.vref) > 0)) {
          return (first.vref + "." + second.vref)
        }
      }
    }
    return ""
  }
  
  ; Mark a variable as mutated by walking from localVariables
  fn markVarAsMutated:void (varName:string fnCtx:RangerAppWriterContext) {
    if ((strlen varName) == 0) {
      return
    }
    
    ; Try to find the variable in the context
    def param:RangerAppParamDesc (fnCtx.getVariableDef(varName))
    if ((strlen param.name) > 0) {
      param.is_mutating = true
      param.mutation_count = param.mutation_count + 1
      
      ; If this variable was assigned from a member field, it needs a C++ reference
      if (param.is_assigned_from_member) {
        param.needs_cpp_reference = true
        param.rust_borrow_type = 2  ; mut_borrow
        if debug {
          print ("StaticAnalysis: " + varName + " needs C++ reference (mutated, assigned from member)")
        }
      }
      
      ; If this is a FUNCTION PARAMETER (not local var) with array/hash type and is mutated, needs reference
      ; This is needed because in Ranger, array/hash parameters are passed by reference semantically
      ; but C++ passes std::vector/map by value unless we add &
      ; We check varType == FunctionParameter to distinguish function params from local vars
      if (param.varType == RangerContextVarType.FunctionParameter) {
        if (!null? param.nameNode) {
          def typeNode:CodeNode (unwrap param.nameNode)
          ; Check if it's an array type by looking at array_type field
          if ((strlen typeNode.array_type) > 0) {
            param.needs_cpp_reference = true
            if debug {
              print ("StaticAnalysis: " + varName + " needs C++ reference (mutated array function parameter)")
            }
          }
          ; Check if it's a hash type by looking at key_type field
          if ((strlen typeNode.key_type) > 0) {
            param.needs_cpp_reference = true
            if debug {
              print ("StaticAnalysis: " + varName + " needs C++ reference (mutated hash function parameter)")
            }
          }
          ; Check if it's a buffer type (int_buffer, double_buffer, buffer)
          ; These are translated to std::vector in C++ and need reference for mutation
          if (typeNode.type_name == "int_buffer") {
            param.needs_cpp_reference = true
            if debug {
              print ("StaticAnalysis: " + varName + " needs C++ reference (mutated int_buffer function parameter)")
            }
          }
          if (typeNode.type_name == "double_buffer") {
            param.needs_cpp_reference = true
            if debug {
              print ("StaticAnalysis: " + varName + " needs C++ reference (mutated double_buffer function parameter)")
            }
          }
          if (typeNode.type_name == "buffer") {
            param.needs_cpp_reference = true
            if debug {
              print ("StaticAnalysis: " + varName + " needs C++ reference (mutated buffer function parameter)")
            }
          }
        }
      }
    }
  }
  
  ; Analyze a variable definition for member assignment
  fn analyzeVarDef:void (node:CodeNode) {
    ; Variable definitions look like: (def varname:type value)
    if ((array_length node.children) < 2) {
      return
    }
    
    def nameNode:CodeNode (node.getSecond())
    def varName:string nameNode.vref
    if ((strlen varName) == 0) {
      return
    }
    
    ; Check if there's a paramDesc and an initializer value
    if (!null? nameNode.paramDesc) {
      ; Check if there's an initializer value
      if ((array_length node.children) >= 3) {
        def valueNode:CodeNode (itemAt node.children 2)
        
        ; Check if the value is a member access (obj.field)
        if (this.isMemberAccess(valueNode)) {
          def param:RangerAppParamDesc (unwrap nameNode.paramDesc)
          param.is_assigned_from_member = true
          param.source_member_name = (this.getMemberPath(valueNode))
          if debug {
            print ("StaticAnalysis: " + varName + " assigned from member " + param.source_member_name)
          }
        }
      }
    }
  }
  
  ; Walk the AST to collect variable definitions and detect mutations
  fn walkForMutations:void (node:CodeNode fnCtx:RangerAppWriterContext) {
    ; Check if this is a variable definition
    if node.expression {
      if ((array_length node.children) > 0) {
        def first:CodeNode (node.getFirst())
        if (first.vref == "def") {
          this.analyzeVarDef(node)
        }
      }
    }
    
    ; Check if this is a mutating operation
    if (this.isMutatingNode(node)) {
      ; Get the target (second child for most ops)
      if ((array_length node.children) >= 2) {
        def target:CodeNode (node.getSecond())
        def varName:string (this.getRootVarName(target))
        this.markVarAsMutated(varName fnCtx)
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForMutations(child fnCtx)
    }
  }
  
  ; Analyze return statements in a function
  fn walkForReturns:void (node:CodeNode) {
    if node.expression {
      if ((array_length node.children) > 0) {
        def first:CodeNode (node.getFirst())
        if (first.vref == "return") {
          if ((array_length node.children) >= 2) {
            def retValue:CodeNode (node.getSecond())
            ; Check if returning a member field (this.field pattern)
            def path:string (this.getMemberPath(retValue))
            if ((strlen path) > 0) {
              def idx:int (indexOf path "this.")
              if (idx == 0) {
                if (!null? currentFunction) {
                  def fn:RangerAppFunctionDesc (unwrap currentFunction)
                  fn.returns_member_field = true
                  ; Extract member name from "this.fieldname"
                  def memberName:string (substring path 5 (strlen path))
                  fn.returned_member_name = memberName
                }
              }
            }
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForReturns(child)
    }
  }
  
  ; ============================================================================
  ; SELF MUTATION DETECTION (for Rust &self vs &mut self)
  ; ============================================================================
  ; Detects when a method assigns to this.field, which requires &mut self in Rust
  
  ; Check if a node is an assignment to this.field
  fn isSelfAssignment:boolean (node:CodeNode) {
    if (node.expression == false) {
      return false
    }
    if ((array_length node.children) < 2) {
      return false
    }
    def first:CodeNode (node.getFirst())
    ; Check for assignment operator
    if (first.vref != "=") {
      return false
    }
    ; Check if LHS is this.something
    def lhs:CodeNode (node.getSecond())
    if ((array_length lhs.ns) > 0) {
      def firstPart:string (itemAt lhs.ns 0)
      if (firstPart == "this") {
        return true
      }
    }
    return false
  }
  
  ; Check if a node uses 'this' (field access or method call)
  fn usesSelf:boolean (node:CodeNode) {
    ; Direct 'this' reference
    if (node.vref == "this") {
      return true
    }
    ; Namespace starting with 'this'
    if ((array_length node.ns) > 0) {
      def firstPart:string (itemAt node.ns 0)
      if (firstPart == "this") {
        return true
      }
    }
    return false
  }
  
  ; Walk AST to detect self mutations and self usage
  fn walkForSelfAnalysis:void (node:CodeNode) {
    ; Check if this is an assignment to this.field
    if (this.isSelfAssignment(node)) {
      if (!null? currentFunction) {
        def fn:RangerAppFunctionDesc (unwrap currentFunction)
        fn.mutates_self = true
        fn.rust_uses_self = true
        if debug {
          print ("StaticAnalysis: " + fn.name + " mutates self (assignment to this.field)")
        }
      }
    }
    
    ; Check if this uses 'this' at all
    if (this.usesSelf(node)) {
      if (!null? currentFunction) {
        def fn:RangerAppFunctionDesc (unwrap currentFunction)
        fn.rust_uses_self = true
      }
    }
    
    ; Check if 'this' is a mutating operation target (e.g., push this.array item)
    if (this.isMutatingNode(node)) {
      if ((array_length node.children) >= 2) {
        def target:CodeNode (node.getSecond())
        if (this.usesSelf(target)) {
          if (!null? currentFunction) {
            def fn:RangerAppFunctionDesc (unwrap currentFunction)
            fn.mutates_self = true
            fn.rust_uses_self = true
            if debug {
              print ("StaticAnalysis: " + fn.name + " mutates self (mutating op on this.field)")
            }
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForSelfAnalysis(child)
    }
  }
  
  ; ============================================================================
  ; WEAK REFERENCE PARAMETER DETECTION
  ; ============================================================================
  ; Detects when a function parameter is assigned to a @(weak) field
  ; This is needed to generate Rc<RefCell<T>> parameter types in Rust
  
  ; Check if a field has the @(weak) annotation
  fn isWeakField:boolean (fieldName:string) {
    if (null? currentClass) {
      return false
    }
    def cl:RangerAppClassDesc (unwrap currentClass)
    ; Find the field in the class variables
    for cl.variables pvar:RangerAppParamDesc i {
      if (!null? pvar.nameNode) {
        def nameN:CodeNode (unwrap pvar.nameNode)
        if (nameN.vref == fieldName) {
          ; Check if the field has the weak flag
          return (nameN.hasFlag("weak"))
        }
      }
    }
    return false
  }
  
  ; Analyze assignments in a function to detect parameter-to-weak-field assignments
  fn walkForWeakAssignments:void (node:CodeNode fnCtx:RangerAppWriterContext) {
    if (node.expression == false) {
      ; Recurse to children
      for node.children child:CodeNode i {
        this.walkForWeakAssignments(child fnCtx)
      }
      return
    }
    
    if ((array_length node.children) < 3) {
      ; Recurse to children
      for node.children child:CodeNode i {
        this.walkForWeakAssignments(child fnCtx)
      }
      return
    }
    
    def first:CodeNode (node.getFirst())
    ; Check for assignment: (= lhs rhs)
    if (first.vref == "=") {
      def lhs:CodeNode (node.getSecond())
      def rhs:CodeNode (itemAt node.children 2)
      
      ; Check if LHS is this.field where field is @(weak)
      ; Two patterns: explicit "this.field" or implicit "field" where field is class variable
      def fieldName:string ""
      def is_self_field:boolean false
      
      ; Pattern 1: this.field (explicit this)
      if ((array_length lhs.ns) >= 2) {
        def firstPart:string (itemAt lhs.ns 0)
        if (firstPart == "this") {
          fieldName = (itemAt lhs.ns 1)
          is_self_field = true
        }
      }
      
      ; Pattern 2: field (implicit this - check if it's a class variable)
      if (is_self_field == false) {
        if lhs.hasParamDesc {
          def lhsParam:RangerAppParamDesc lhs.paramDesc
          if lhsParam.is_class_variable {
            ; This is an assignment to a class variable without explicit this
            fieldName = lhsParam.name
            is_self_field = true
          }
        }
      }
      
      if is_self_field {
        if (this.isWeakField(fieldName)) {
          ; RHS is being assigned to a weak field
          ; Check if RHS is a function parameter
          def rhsVarName:string rhs.vref
          if ((strlen rhsVarName) > 0) {
            ; Find the parameter
            def param:RangerAppParamDesc (fnCtx.getVariableDef(rhsVarName))
            if (param.varType == RangerContextVarType.FunctionParameter) {
              param.rust_assigned_to_weak = true
              param.rust_needs_rc_wrap = true
              if debug {
                print ("StaticAnalysis: parameter " + rhsVarName + " assigned to weak field " + fieldName)
              }
            }
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForWeakAssignments(child fnCtx)
    }
  }
  
  ; Walk for transitive weak assignments
  ; Detects when a function parameter is passed to a method that has rust_needs_rc_wrap parameter
  ; For example: imgM.setRenderer(selfRc) where setRenderer's param has rust_needs_rc_wrap
  fn walkForTransitiveWeak:void (node:CodeNode fnCtx:RangerAppWriterContext) {
    ; Look for method calls where arguments are function parameters
    ; Check both has_call (for "call obj method args" style) and hasFnCall (for "obj.method(args)" style)
    def isCall:boolean (node.has_call || node.hasFnCall)
    
    ; Debug: show what we're checking
    if ((node.has_call == true) || (node.hasFnCall == true)) {
      print ("StaticAnalysis: found call node has_call=" + (to_string node.has_call) + " hasFnCall=" + (to_string node.hasFnCall) + " vref=" + node.vref)
    }
    
    if isCall {
      ; Check if fnDesc is available (set by FlowWork/FlowParser for resolved calls)
      if (!null? node.fnDesc) {
        ; This is a function/method call with fnDesc available
        def fnDesc:RangerAppFunctionDesc node.fnDesc
        ; Check arguments against function parameters
        def childCnt:int (array_length node.children)
        
        ; Debug: print all function calls being checked
        print ("StaticAnalysis: transitive check call to " + fnDesc.name + " childCnt=" + (to_string childCnt))
        
        ; For hasFnCall (obj.method(args) style), structure is:
        ; node.children[0] = fnNode (method reference like obj.method)
        ; node.children[1] = callParams (contains actual args as children)
        ; For has_call (call obj method args), structure is:
        ; node.children = [call-marker, obj, method, args-node]
        
        if node.hasFnCall {
          ; obj.method(args) style - args are in children[1].children
          if (childCnt >= 2) {
            def callParams:CodeNode (itemAt node.children 1)
            def argCnt:int (array_length callParams.children)
            def paramCnt:int (array_length fnDesc.params)
            
            print ("StaticAnalysis:   hasFnCall style, argCnt=" + (to_string argCnt))
            
            for callParams.children arg:CodeNode i {
              ; This is an argument to the function call
              def argVref:string arg.vref
              print ("StaticAnalysis:   arg[" + (to_string i) + "]=" + argVref + " hasParamDesc=" + (to_string arg.hasParamDesc))
              if ((strlen argVref) > 0) {
                ; Check if argument is a function parameter OR local variable from our context
                if arg.hasParamDesc {
                  def argParam:RangerAppParamDesc arg.paramDesc
                  def isFunctionParam:boolean (argParam.varType == RangerContextVarType.FunctionParameter)
                  def isLocalVar:boolean (argParam.varType == RangerContextVarType.LocalVariable)
                  print ("StaticAnalysis:   is FunctionParameter=" + (to_string isFunctionParam) + " isLocalVar=" + (to_string isLocalVar))
                  if (isFunctionParam || isLocalVar) {
                    ; Check if the called function's corresponding parameter has rust_needs_rc_wrap
                    if (i < paramCnt) {
                      def calledParam:RangerAppParamDesc (itemAt fnDesc.params i)
                      print ("StaticAnalysis:   calledParam.rust_needs_rc_wrap=" + (to_string calledParam.rust_needs_rc_wrap))
                      if calledParam.rust_needs_rc_wrap {
                        ; The called method expects Rc<RefCell<T>>, so our arg needs it too
                        argParam.rust_needs_rc_wrap = true
                        print ("StaticAnalysis: transitive weak - " + argVref + " passed to " + fnDesc.name + " which needs Rc wrap")
                      }
                    }
                  }
                }
              }
            }
          }
        } {
          ; (call obj method args) style - args start at index 3
          if (childCnt > 3) {
            def argsNode:CodeNode (itemAt node.children 3)
            def paramCnt:int (array_length fnDesc.params)
            
            for argsNode.children arg:CodeNode i {
              def argVref:string arg.vref
              if ((strlen argVref) > 0) {
                if arg.hasParamDesc {
                  def argParam:RangerAppParamDesc arg.paramDesc
                  def isFunctionParam:boolean (argParam.varType == RangerContextVarType.FunctionParameter)
                  def isLocalVar:boolean (argParam.varType == RangerContextVarType.LocalVariable)
                  if (isFunctionParam || isLocalVar) {
                    if (i < paramCnt) {
                      def calledParam:RangerAppParamDesc (itemAt fnDesc.params i)
                      if calledParam.rust_needs_rc_wrap {
                        argParam.rust_needs_rc_wrap = true
                        print ("StaticAnalysis: transitive weak - " + argVref + " passed to " + fnDesc.name + " which needs Rc wrap")
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForTransitiveWeak(child fnCtx)
    }
  }
  
  ; ============================================================================
  ; RUST BORROW CONFLICT DETECTION
  ; ============================================================================
  ; Detects patterns like: self.member.method(self.otherMethod())
  ; where both calls try to borrow self mutably
  
  ; Check if a node contains a self method call (this.method() pattern)
  fn containsSelfMethodCall:boolean (node:CodeNode) {
    ; Check if this node is a call on self
    if node.has_call {
      if ((array_length node.ns) > 0) {
        def firstPart:string (itemAt node.ns 0)
        if (firstPart == "this") {
          return true
        }
      }
    }
    
    ; Check vref for "this" pattern
    if ((strlen node.vref) > 0) {
      if (node.vref == "this") {
        return true
      }
    }
    
    ; Check namespace for "this" as first part
    if ((array_length node.ns) > 0) {
      def firstPart:string (itemAt node.ns 0)
      if (firstPart == "this") {
        ; And if this is used as a method call
        if node.expression {
          return true
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      if (this.containsSelfMethodCall(child)) {
        return true
      }
    }
    return false
  }
  
  ; Collect all argument nodes that contain self method calls
  fn collectSelfMethodCallArgs:void (node:CodeNode results:[CodeNode]) {
    ; Check if this node is a call with self reference
    if node.has_call {
      if (this.containsSelfMethodCall(node)) {
        push results node
        return  ; Don't recurse into children of collected node
      }
    }
    
    ; Check if this is a self-referencing expression
    if node.expression {
      if ((array_length node.ns) > 0) {
        def firstPart:string (itemAt node.ns 0)
        if (firstPart == "this") {
          ; This is a this.something expression that might need pre-evaluation
          if (this.containsSelfMethodCall(node)) {
            push results node
            return
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.collectSelfMethodCallArgs(child results)
    }
  }
  
  ; Walk AST to detect and mark Rust borrow conflicts
  fn walkForRustBorrowConflicts:void (node:CodeNode) {
    ; Look for method calls: node.has_call indicates a call expression
    ; Pattern: (call obj method args)
    if node.has_call {
      ; Check if this is a call on self.member
      if ((array_length node.children) >= 4) {
        def objNode:CodeNode (node.getSecond())
        def argsNode:CodeNode (itemAt node.children 3)
        
        ; Check if obj is self.something
        def objIsSelfMember:boolean false
        if ((array_length objNode.ns) > 0) {
          def firstPart:string (itemAt objNode.ns 0)
          if (firstPart == "this") {
            objIsSelfMember = true
          }
        }
        
        if objIsSelfMember {
          ; Now check if any arguments contain self method calls
          def argsWithSelfCalls:[CodeNode]
          this.collectSelfMethodCallArgs(argsNode argsWithSelfCalls)
          
          if ((array_length argsWithSelfCalls) > 0) {
            ; Mark this node as needing pre-evaluation of args
            node.rust_needs_preevaluate = true
            node.rust_preevaluated_args = argsWithSelfCalls
            
            if debug {
              print "StaticAnalysis: Rust borrow conflict detected, marking for pre-evaluation"
            }
          }
        }
      }
    }
    
    ; Recurse to children
    for node.children child:CodeNode i {
      this.walkForRustBorrowConflicts(child)
    }
  }
  
  ; Analyze a single function
  fn analyzeFunction:void (fn:RangerAppFunctionDesc) {
    if (fn.static_analysis_done) {
      return
    }
    
    currentFunction = fn
    
    if (!null? fn.fnBody) {
      if (!null? fn.fnCtx) {
        ; Walk for mutations using the function context
        this.walkForMutations((unwrap fn.fnBody) (unwrap fn.fnCtx))
        
        ; Walk for weak field assignments (Rust Rc<RefCell<T>> detection)
        this.walkForWeakAssignments((unwrap fn.fnBody) (unwrap fn.fnCtx))
      }
      
      ; Analyze return patterns
      this.walkForReturns((unwrap fn.fnBody))
      
      ; Analyze self mutations and usage (Rust &self vs &mut self)
      this.walkForSelfAnalysis((unwrap fn.fnBody))
      
      ; Analyze for Rust borrow conflicts
      this.walkForRustBorrowConflicts((unwrap fn.fnBody))
    }
    
    fn.static_analysis_done = true
  }
  
  ; Analyze all methods in a class
  fn analyzeClass:void (cl:RangerAppClassDesc) {
    currentClass = cl
    
    for cl.methods m:RangerAppFunctionDesc i {
      this.analyzeFunction(m)
    }
    
    ; Also analyze the constructor
    if (!null? cl.constructor_fn) {
      this.analyzeFunction((unwrap cl.constructor_fn))
    }
  }
  
  ; Second pass: analyze transitive weak assignments
  ; Must be called AFTER all functions have been analyzed with walkForWeakAssignments
  fn analyzeTransitiveWeak:void (fn:RangerAppFunctionDesc) {
    if (!null? fn.fnBody) {
      if (!null? fn.fnCtx) {
        this.walkForTransitiveWeak((unwrap fn.fnBody) (unwrap fn.fnCtx))
      }
    }
  }
  
  fn analyzeClassTransitiveWeak:void (cl:RangerAppClassDesc) {
    currentClass = cl
    
    for cl.methods m:RangerAppFunctionDesc i {
      this.analyzeTransitiveWeak(m)
    }
    
    ; Also analyze the constructor
    if (!null? cl.constructor_fn) {
      this.analyzeTransitiveWeak((unwrap cl.constructor_fn))
    }
  }
  
  ; Run analysis on all classes in the context
  fn analyzeAll:void () {
    if (null? ctx) {
      return
    }
    
    ; Initialize the mutating operators map
    this.initMutatingOps()
    
    def root:RangerAppWriterContext ((unwrap ctx).getRoot())
    
    ; Pass 1: Analyze all classes - detect direct weak assignments
    for root.definedClasses cl:RangerAppClassDesc i {
      this.analyzeClass(cl)
    }
    
    ; Pass 2: Analyze transitive weak assignments (after all direct assignments detected)
    for root.definedClasses cl:RangerAppClassDesc i {
      this.analyzeClassTransitiveWeak(cl)
    }
    
    if debug {
      print "StaticAnalysis: completed analysis of all classes"
    }
  }
}
