use std::collections::HashMap;
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(dead_code)]

#[derive(Clone)]
struct CmdParams { 
  flags : HashMap<String,bool>, 
  params : HashMap<String,String>, 
  values : Vec<String>, 
}
impl CmdParams { 
  
  pub fn new() ->  CmdParams {
    let mut me = CmdParams { 
      flags: None, 
      params: None, 
      values: Vec::new(), 
    };
    return me;
  }
  pub fn fromDictionary(mut dict : JSONDataObject) -> CmdParams {
    let mut obj : CmdParams = CmdParams::new();
    try {
      let mut values : Option<JSONDataObject> = dict.get("flags".to_string()).and_then(|v| v.as_object()).cloned();
      if  values.is_some() {
        let mut theObjflags : JSONDataObject = values.unwrap();
        let mut obj_keys : Vec<String> = theObjflags.keys().cloned().collect::<Vec<String>>();
        operatorsOf::forEach_12(obj_keys, (item, index) => { 
          let v : Option<bool> = theObjflags.get(item).and_then(|v| v.as_bool());
          if  v.is_some() {
            obj.flags.insert(item, v.unwrap());
          }
        }
        );
      }
      let mut values_1 : Option<JSONDataObject> = dict.get("params".to_string()).and_then(|v| v.as_object()).cloned();
      if  values_1.is_some() {
        let mut theObjparams : JSONDataObject = values_1.unwrap();
        let mut obj_keys_1 : Vec<String> = theObjparams.keys().cloned().collect::<Vec<String>>();
        operatorsOf::forEach_12(obj_keys_1, (item, index) => { 
          let v_1 : Option<String> = theObjparams.get(item).and_then(|v| v.as_str()).map(|s| s.to_string());
          if  v_1.is_some() {
            obj.params.insert(item, v_1.unwrap());
          }
        }
        );
      }
      let mut values_2 : Option<JSONArrayObject> = dict.get("values".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_2.is_some() {
        let mut arr : JSONArrayObject = values_2.unwrap();
        operatorsOfJSONArrayObject_57::forEach_58(arr.clone(), (item, index) => { 
          caseitemoopushobj.valuesoo
        }
        );
      }
    } catch(e) {
    }
    return obj.clone();
  }
  fn hasParam(&mut self, name : String) -> bool {
    return self.params.contains_key(&name);
  }
  fn getParam(&mut self, name : String) -> Option<String> {
    return self.params.get(name).clone();
  }
  fn collect(&mut self, ) -> () {
    let mut cnt : i64 = (std::env::args().len() as i64 - 1);
    let mut i : i64 = 0;
    while cnt > 0 {
      let argStr : String = std::env::args().nth((i + 1) as usize).unwrap_or_default();
      let firstC : i64 = argStr.chars().nth(0 as usize).unwrap_or('\0') as i64;
      if  firstC == (45) {
        let pS : String = argStr.chars().skip(1 as usize).take(((argStr.len() as i64) - 1) as usize).collect::<String>();
        let mut parts : Vec<String> = pS.split("=".to_string());
        if  ((parts.len() as i64)) == 1 {
          let flag : String = parts[0 as usize].clone();
          self.flags.insert(flag, true);
        } else {
          let name : String = parts[0 as usize].clone();
          parts.splice(0, 1).pop();
          let value : String = parts.join("=".to_string());
          self.params.insert(name, value);
        }
      } else {
        self.values.push(argStr);
      }
      cnt = cnt - 1;
      i = i + 1;
    }
  }
  fn toDictionary(&mut self, ) -> JSONDataObject {
    let mut res : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
    try {
      let mut values_1 : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
      let keyList :  = keysself.flags;
      forkeyListkeynameindexlet item : bool = (self.flags.get(keyname)).unwrap();
      values_1.insert(keyname.to_string(), item);
      res.insert("flags".to_string().to_string(), values_1);
      let mut values_2 : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
      let keyList_1 :  = keysself.params;
      forkeyList_1keyname_1index_1let item_1 : String = (self.params.get(keyname_1)).unwrap();
      values_2.insert(keyname_1.to_string(), item_1);
      res.insert("params".to_string().to_string(), values_2);
      let mut values_3 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i in 0..self.values.len() {
        let mut item_2 = self.values[i as usize].clone();
        values_3.push(serde_json::json!(item_2));
      }
      res.insert("values".to_string().to_string(), values_3);
    } catch(e) {
    }
    return res.clone();
  }
}
#[derive(Clone)]
struct test_cmdparams { 
}
impl test_cmdparams { 
  
  pub fn new() ->  test_cmdparams {
    let mut me = test_cmdparams { 
    };
    return me;
  }
  fn run(&mut self, ) -> () {
    let mut prms : CmdParams = CmdParams::new();
    prms.collect();
    println!( "{}", "--- params ----".to_string() );
    let pNames :  = keysprms.params;
    forpNamesvi
    println!( "{}", format!("{}{}", (format!("{}{}", v, " = ".to_string())), ((prms.params.get(v)).unwrap())) );
    println!( "{}", "--- flags ----".to_string() );
    let flagNames :  = keysprms.flags;
    forflagNamesv_1i_1
    println!( "{}", v_1 );
    println!( "{}", "--- values ----".to_string() );
    for i_2 in 0..prms.values.len() {
      let mut v_2 = prms.values[i_2 as usize].clone();
      println!( "{}", v_2 );
    }
  }
}
fn main() {
  let mut o : test_cmdparams = test_cmdparams::new();
  o.run();
}
#[derive(Clone)]
struct InputFSFolder { 
  name : String, 
  data : String, 
  is_folder : bool, 
  base64bin : bool, 
  folders : Vec<InputFSFolder>, 
  files : Vec<InputFSFile>, 
}
impl InputFSFolder { 
  
  pub fn new() ->  InputFSFolder {
    let mut me = InputFSFolder { 
      name:"".to_string(), 
      data:"".to_string(), 
      is_folder:true, 
      base64bin:false, 
      folders: Vec::new(), 
      files: Vec::new(), 
    };
    return me;
  }
  pub fn fromDictionary(mut dict : JSONDataObject) -> InputFSFolder {
    let mut obj : InputFSFolder = InputFSFolder::new();
    try {
      let v : Option<String> = dict.get("name".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v.is_some() {
        obj.name = v.unwrap();
      }
      let v_1 : Option<String> = dict.get("data".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_1.is_some() {
        obj.data = v_1.unwrap();
      }
      let v_2 : Option<bool> = dict.get("is_folder".to_string()).and_then(|v| v.as_bool());
      if  v_2.is_some() {
        obj.is_folder = v_2.unwrap();
      }
      let v_3 : Option<bool> = dict.get("base64bin".to_string()).and_then(|v| v.as_bool());
      if  v_3.is_some() {
        obj.base64bin = v_3.unwrap();
      }
      let mut values : Option<JSONArrayObject> = dict.get("folders".to_string()).and_then(|v| v.as_array()).cloned();
      if  values.is_some() {
        let mut arr : JSONArrayObject = values.unwrap();
        operatorsOf_57::forEach_58(arr.clone(), (item, index) => { 
          caseitemoodefnewObjInputFSFolder::fromDictionaryoopushobj.foldersnewObj
        }
        );
      }
      let mut values_1 : Option<JSONArrayObject> = dict.get("files".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_1.is_some() {
        let mut arr_1 : JSONArrayObject = values_1.unwrap();
        operatorsOf_57::forEach_58(arr_1.clone(), (item, index) => { 
          caseitemoodefnewObjInputFSFile::fromDictionaryoopushobj.filesnewObj
        }
        );
      }
    } catch(e) {
    }
    return obj.clone();
  }
  fn forTree(&mut self, cb : ) -> () {
    cb(self);
    operatorsOf::forEach_2(self.folders, (item, index) => { 
      item.forTree(cb);
    }
    );
  }
  fn toDictionary(&mut self, ) -> JSONDataObject {
    let mut res : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
    try {
      res.insert("name".to_string().to_string(), self.name);
      res.insert("data".to_string().to_string(), self.data);
      res.insert("is_folder".to_string().to_string(), self.is_folder);
      res.insert("base64bin".to_string().to_string(), self.base64bin);
      let mut values : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i in 0..self.folders.len() {
        let mut item = self.folders[i as usize].clone();
        let mut obj : JSONDataObject = item.toDictionary();
        values.push(serde_json::json!(obj));
      }
      res.insert("folders".to_string().to_string(), values);
      let mut values_1 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i_1 in 0..self.files.len() {
        let mut item_1 = self.files[i_1 as usize].clone();
        let mut obj_1 : JSONDataObject = item_1.toDictionary();
        values_1.push(serde_json::json!(obj_1));
      }
      res.insert("files".to_string().to_string(), values_1);
    } catch(e) {
    }
    return res.clone();
  }
}
#[derive(Clone)]
struct InputFSFile { 
  name : String, 
  data : String, 
  is_folder : bool, 
  base64bin : bool, 
}
impl InputFSFile { 
  
  pub fn new() ->  InputFSFile {
    let mut me = InputFSFile { 
      name:"".to_string(), 
      data:"".to_string(), 
      is_folder:false, 
      base64bin:false, 
    };
    return me;
  }
  pub fn fromDictionary(mut dict : JSONDataObject) -> InputFSFile {
    let mut obj : InputFSFile = InputFSFile::new();
    try {
      let v : Option<String> = dict.get("name".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v.is_some() {
        obj.name = v.unwrap();
      }
      let v_1 : Option<String> = dict.get("data".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_1.is_some() {
        obj.data = v_1.unwrap();
      }
      let v_2 : Option<bool> = dict.get("is_folder".to_string()).and_then(|v| v.as_bool());
      if  v_2.is_some() {
        obj.is_folder = v_2.unwrap();
      }
      let v_3 : Option<bool> = dict.get("base64bin".to_string()).and_then(|v| v.as_bool());
      if  v_3.is_some() {
        obj.base64bin = v_3.unwrap();
      }
    } catch(e) {
    }
    return obj.clone();
  }
  fn toDictionary(&mut self, ) -> JSONDataObject {
    let mut res : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
    try {
      res.insert("name".to_string().to_string(), self.name);
      res.insert("data".to_string().to_string(), self.data);
      res.insert("is_folder".to_string().to_string(), self.is_folder);
      res.insert("base64bin".to_string().to_string(), self.base64bin);
    } catch(e) {
    }
    return res.clone();
  }
}
#[derive(Clone)]
struct InputEnv { 
  use_real : bool, 
  filesystem : Option<InputFSFolder>, 
  envVars : HashMap<String,String>, 
  commandLine : Option<CmdParams>, 
}
impl InputEnv { 
  
  pub fn new() ->  InputEnv {
    let mut me = InputEnv { 
      use_real:false, 
      filesystem: None, 
      envVars: None, 
      commandLine: None, 
    };
    return me;
  }
  pub fn fromDictionary(mut dict : JSONDataObject) -> InputEnv {
    let mut obj : InputEnv = InputEnv::new();
    try {
      let v : Option<bool> = dict.get("use_real".to_string()).and_then(|v| v.as_bool());
      if  v.is_some() {
        obj.use_real = v.unwrap();
      }
      let mut theValue : Option<JSONDataObject> = dict.get("filesystem".to_string()).and_then(|v| v.as_object()).cloned();
      if  theValue.is_some() {
        let mut newObj : InputFSFolder = InputFSFolder::fromDictionary((theValue.unwrap()));
        obj.filesystem = Some(newObj.clone());
      }
      let mut values : Option<JSONDataObject> = dict.get("envVars".to_string()).and_then(|v| v.as_object()).cloned();
      if  values.is_some() {
        let mut theObjenvVars : JSONDataObject = values.unwrap();
        let mut obj_keys : Vec<String> = theObjenvVars.keys().cloned().collect::<Vec<String>>();
        operatorsOf::forEach_12(obj_keys, (item, index) => { 
          let v_1 : Option<String> = theObjenvVars.get(item).and_then(|v| v.as_str()).map(|s| s.to_string());
          if  v_1.is_some() {
            obj.envVars.insert(item, v_1.unwrap());
          }
        }
        );
      }
      let mut theValue_1 : Option<JSONDataObject> = dict.get("commandLine".to_string()).and_then(|v| v.as_object()).cloned();
      if  theValue_1.is_some() {
        let mut newObj_1 : CmdParams = CmdParams::fromDictionary((theValue_1.unwrap()));
        obj.commandLine = Some(newObj_1.clone());
      }
    } catch(e) {
    }
    return obj.clone();
  }
  fn setEnv(&mut self, name : String, value : String) -> () {
    self.envVars.insert(name, value);
  }
  fn toDictionary(&mut self, ) -> JSONDataObject {
    let mut res : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
    try {
      res.insert("use_real".to_string().to_string(), self.use_real);
      if  self.filesystem.is_some() {
        res.insert("filesystem".to_string().to_string(), ((self.filesystem.clone().unwrap())).toDictionary());
      }
      let mut values : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
      let keyList :  = keysself.envVars;
      forkeyListkeynameindexlet item : String = (self.envVars.get(keyname)).unwrap();
      values.insert(keyname.to_string(), item);
      res.insert("envVars".to_string().to_string(), values);
      if  self.commandLine.is_some() {
        res.insert("commandLine".to_string().to_string(), ((self.commandLine.clone().unwrap())).toDictionary());
      }
    } catch(e) {
    }
    return res.clone();
  }
}
#[derive(Clone)]
struct test_input_filesystem { 
}
impl test_input_filesystem { 
  
  pub fn new() ->  test_input_filesystem {
    let mut me = test_input_filesystem { 
    };
    return me;
  }
}
fn main() {
  println!( "{}", "--> started".to_string() );
  let mut env : InputEnv = InputEnv::new();
  env.filesystem = Some(InputFSFolder::new());
  operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "README2.md".to_string(), "Data of readme round here...".to_string());
  operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "README.md".to_string(), "# the readme file".to_string());
  env.envVars.insert("RANGER_DIR".to_string(), "/".to_string());
  let mut subF : Option<InputFSFolder> = operatorsOf_3::createc95folder_5((env.filesystem.clone().unwrap()), "lib".to_string());
  /** unused:  let mut someFile : Option<InputFSFile> = operatorsOf_3::createc95file_4((subF.unwrap()), "stdlib.clj".to_string(), "Contents of the standard library".to_string());   **/ 
  operatorsOf_3::createc95file_4(subF.unwrap(), "JSON.clj".to_string(), "JSON file comes round here...".to_string());
  operatorsOf_3::createc95file_4(subF.unwrap(), "DOMLib.clj".to_string(), "JSON file comes round here...".to_string());
  operatorsOf_3::createc95file_4(operatorsOf_3::createc95folder_5((subF.unwrap()), "etc".to_string()).unwrap(), "readme.txt".to_string(), "...".to_string());
  operatorsOf_3::createc95file_4(operatorsOf_3::createc95folder_5((subF.unwrap()), "etc".to_string()).unwrap(), "notes.txt".to_string(), "...".to_string());
  println!( "{}", serde_json::to_string(&env.toDictionary()).unwrap() );
  let data : Option<String> = operatorsOfInputEnv_8::readc95file_9(env.clone(), "/".to_string(), "README.md".to_string());
  if  data.is_some() {
    println!( "{}", format!("{}{}", " -> data ".to_string(), (data.unwrap())) );
  }
  let data_2 : Option<String> = operatorsOf_8::readc95file_9(env.clone(), "/lib/".to_string(), "stdlib.clj".to_string());
  if  data_2.is_some() {
    println!( "{}", format!("{}{}", " -> data ".to_string(), (data_2.unwrap())) );
  }
  if  operatorsOf_8::filec95exists_9(env.clone(), "/lib/".to_string(), "stdlib.clj".to_string()) {
    println!( "{}", "stdlib does exists".to_string() );
  }
  if  operatorsOf_8::filec95exists_9(env.clone(), "/lib/etc/".to_string(), "readme.txt".to_string()) {
    println!( "{}", "/lib/etc/readme.txt does exists".to_string() );
  }
  env.filesystem.forTree((item) => { 
    let mut myFold_1 : InputFSFolder = item;
    println!( "{}", "*******************************".to_string() );
    println!( "{}", format!("{}{}", " DIR: ".to_string(), (if ((myFold_1.name.len() as i64) > 0) { myFold_1.name } else { "/".to_string() })) );
    let cnt_7 : i64 = (myFold_1.folders.len() as i64);
    let mut i_7 : i64 = 0;
    while i_7 < cnt_7 {
      let mut mF_13 : InputFSFolder = myFold_1.folders[i_7 as usize].clone();
      println!( "{}", format!("{}{}", " folder -> ".to_string(), (mF_13).name) );
      i_7 = i_7 + 1;
    }
    let cnt_9 : i64 = (myFold_1.files.len() as i64);
    let mut i_9 : i64 = 0;
    while i_9 < cnt_9 {
      let mut mF_19 : InputFSFile = myFold_1.files[i_9 as usize].clone();
      println!( "{}", [(format!("{}{}", (format!("{}{}", " file -> ".to_string(), mF_19.name)), " size : ".to_string())) , ((mF_19.data.len() as i64).to_string()) ].join("") );
      i_9 = i_9 + 1;
    }
    let mut __REGx4 : Vec<Any> = Vec::new();
    let mut results_3 : Vec<Any> = Vec::new();
    operatorsOf::forEach_10(myFold_1.files, (item, index) => { 
      let mut tmp_6 : InputFSFile = item;
      results_3.push(tmp_6.clone());
    }
    );
    operatorsOf::forEach_2(myFold_1.folders, (item, index) => { 
      let mut tmp_7 : InputFSFolder = item;
      results_3.push(tmp_7.clone());
    }
    );
    __REGx4 = results_3.clone();
    let mut __REGx3 : Vec<Any> = __REGx4;
    let cnt_11 : i64 = (__REGx3.len() as i64);
    let mut i_11 : i64 = 0;
    while i_11 < cnt_11 {
      println!( "{}", "...".to_string() );
      i_11 = i_11 + 1;
    }
  }
  );
  let mut __REGx2_1 : String;
  let s_1 : String = "It is ok".to_string();
  println!( "{}", "It is ok".to_string() );
  __REGx2_1 = Some(s_1.clone());
  let mut __REGx1_1 : String = format!("{}{}", "say: ".to_string(), __REGx2_1);
  let mut __REGx3_1 : String;
  let s_3 : String = __REGx1_1;
  println!( "{}", __REGx1_1 );
  __REGx3_1 = Some(s_3.clone());
}
#[derive(Clone)]
struct RangerAppTodo { 
  description : String, 
  todonode : Option<CodeNode>, 
}
impl RangerAppTodo { 
  
  pub fn new() ->  RangerAppTodo {
    let mut me = RangerAppTodo { 
      description:"".to_string(), 
      todonode: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerCompilerMessage { 
  error_level : i64, 
  code_line : i64, 
  fileName : String, 
  description : String, 
  node : Option<CodeNode>, 
}
impl RangerCompilerMessage { 
  
  pub fn new() ->  RangerCompilerMessage {
    let mut me = RangerCompilerMessage { 
      error_level:0, 
      code_line:0, 
      fileName:"".to_string(), 
      description:"".to_string(), 
      node: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerParamEventHandler { 
}
impl RangerParamEventHandler { 
  
  pub fn new() ->  RangerParamEventHandler {
    let mut me = RangerParamEventHandler { 
    };
    return me;
  }
  fn callback(&mut self, mut param : RangerAppParamDesc) -> () {
  }
}
#[derive(Clone)]
struct RangerParamEventList { 
  list : Vec<RangerParamEventHandler>, 
}
impl RangerParamEventList { 
  
  pub fn new() ->  RangerParamEventList {
    let mut me = RangerParamEventList { 
      list: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerParamEventMap { 
  events : HashMap<String,RangerParamEventList>, 
}
impl RangerParamEventMap { 
  
  pub fn new() ->  RangerParamEventMap {
    let mut me = RangerParamEventMap { 
      events: None, 
    };
    return me;
  }
  fn clearAllEvents(&mut self, ) -> () {
  }
  fn addEvent(&mut self, name : String, mut e : RangerParamEventHandler) -> () {
    if  (self.events.contains_key(&name)) == false {
      self.events.insert(name, RangerParamEventList::new());
    }
    let mut list : RangerParamEventList = (self.events.get(name)).unwrap();
    list.list.push(e.clone());
  }
  fn fireEvent(&mut self, name : String, mut from : RangerAppParamDesc) -> () {
    if  self.events.contains_key(&name) {
      let mut list : RangerParamEventList = (self.events.get(name)).unwrap();
      for i in 0..list.list.len() {
        let mut ev = list.list[i as usize].clone();
        ev.callback(from.clone());
      }
    }
  }
}
#[derive(Clone)]
struct RangerAppArrayValue { 
  value_type : i64, 
  value_type_name : String, 
  values : Vec<RangerAppValue>, 
}
impl RangerAppArrayValue { 
  
  pub fn new() ->  RangerAppArrayValue {
    let mut me = RangerAppArrayValue { 
      value_type:0, 
      value_type_name:"".to_string(), 
      values: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppHashValue { 
  value_type : i64, 
  key_type_name : String, 
  value_type_name : String, 
  s_values : HashMap<String,RangerAppValue>, 
  i_values : HashMap<String,RangerAppValue>, 
  b_values : HashMap<String,RangerAppValue>, 
  d_values : HashMap<String,RangerAppValue>, 
}
impl RangerAppHashValue { 
  
  pub fn new() ->  RangerAppHashValue {
    let mut me = RangerAppHashValue { 
      value_type:0, 
      key_type_name:"".to_string(), 
      value_type_name:"".to_string(), 
      s_values: None, 
      i_values: None, 
      b_values: None, 
      d_values: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppValue { 
  double_value : f64, 
  string_value : String, 
  int_value : i64, 
  boolean_value : bool, 
  arr : Option<RangerAppArrayValue>, 
  hash : Option<RangerAppHashValue>, 
}
impl RangerAppValue { 
  
  pub fn new() ->  RangerAppValue {
    let mut me = RangerAppValue { 
      double_value:0_f64, 
      string_value:"".to_string(), 
      int_value:0, 
      boolean_value:false, 
      arr: None, 
      hash: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerRefForce { 
  strength : i64, 
  lifetime : i64, 
  changer : Option<CodeNode>, 
}
impl RangerRefForce { 
  
  pub fn new() ->  RangerRefForce {
    let mut me = RangerRefForce { 
      strength:0, 
      lifetime:1, 
      changer: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppParamDesc { 
  name : String, 
  value : Option<RangerAppValue>, 
  compiledName : String, 
  debugString : String, 
  is_register : bool, 
  ref_cnt : i64, 
  init_cnt : i64, 
  set_cnt : i64, 
  return_cnt : i64, 
  prop_assign_cnt : i64, 
  value_type : i64, 
  has_default : bool, 
  def_value : Option<CodeNode>, 
  default_value : Option<RangerNodeValue>, 
  isThis : bool, 
  classDesc : Option<RangerAppClassDesc>, 
  is_immutable : bool, 
  is_static : bool, 
  propertyClass : Option<RangerAppClassDesc>, 
  fnDesc : Option<RangerAppFunctionDesc>, 
  ownerHistory : Vec<RangerRefForce>, 
  varType : i64, 
  refType : i64, 
  initRefType : i64, 
  isParam : Option<bool>, 
  paramIndex : i64, 
  is_optional : bool, 
  is_mutating : bool, 
  is_set : bool, 
  is_class_variable : bool, 
  is_captured : bool, 
  node : Option<CodeNode>, 
  nameNode : Option<CodeNode>, 
  fnBody : Option<CodeNode>, 
  params : Vec<RangerAppParamDesc>, 
  return_value : Option<Box<RangerAppParamDesc>>, 
  description : String, 
  git_doc : String, 
  has_events : bool, 
  eMap : Option<RangerParamEventMap>, 
}
impl RangerAppParamDesc { 
  
  pub fn new() ->  RangerAppParamDesc {
    let mut me = RangerAppParamDesc { 
      name:"".to_string(), 
      value: None, 
      compiledName:"".to_string(), 
      debugString:"".to_string(), 
      is_register:false, 
      ref_cnt:0, 
      init_cnt:0, 
      set_cnt:0, 
      return_cnt:0, 
      prop_assign_cnt:0, 
      value_type:0, 
      has_default:false, 
      def_value: None, 
      default_value: None, 
      isThis:false, 
      classDesc: None, 
      is_immutable:false, 
      is_static:false, 
      propertyClass: None, 
      fnDesc: None, 
      ownerHistory: Vec::new(), 
      varType:0, 
      refType:0, 
      initRefType:0, 
      isParam: None, 
      paramIndex:0, 
      is_optional:false, 
      is_mutating:false, 
      is_set:false, 
      is_class_variable:false, 
      is_captured:false, 
      node: None, 
      nameNode: None, 
      fnBody: None, 
      params: Vec::new(), 
      return_value: None, 
      description:"".to_string(), 
      git_doc:"".to_string(), 
      has_events:false, 
      eMap: None, 
    };
    return me;
  }
  fn addEvent(&mut self, name : String, mut e : RangerParamEventHandler) -> () {
    if  self.has_events == false {
      self.eMap = Some(RangerParamEventMap::new());
      self.has_events = true;
    }
    self.self.eMap.addEvent(name.clone(), e.clone());
  }
  fn changeStrength(&mut self, newStrength : i64, lifeTime : i64, mut changer : CodeNode) -> () {
    let mut entry : RangerRefForce = RangerRefForce::new();
    entry.strength = newStrength;
    entry.lifetime = lifeTime;
    entry.changer = Some(changer.clone());
    self.ownerHistory.push(entry.clone());
  }
  fn isFunction(&mut self, ) -> bool {
    return false;
  }
  fn isProperty(&mut self, ) -> bool {
    return true;
  }
  fn isClass(&mut self, ) -> bool {
    return false;
  }
  fn isOperator(&mut self, ) -> bool {
    return false;
  }
  fn doesInherit(&mut self, ) -> bool {
    return false;
  }
  fn isAllocatedType(&mut self, ) -> bool {
    if  self.nameNode.is_some() {
      if  self.nameNode.eval_type != 0 {
        if  self.nameNode.eval_type == 6 {
          return true;
        }
        if  self.nameNode.eval_type == 7 {
          return true;
        }
        if  (((((self.nameNode.eval_type == 15) || (self.nameNode.eval_type == 14)) || (self.nameNode.eval_type == 4)) || (self.nameNode.eval_type == 2)) || (self.nameNode.eval_type == 5)) || (self.nameNode.eval_type == 3) {
          return false;
        }
        if  self.nameNode.eval_type == 13 {
          return false;
        }
        return true;
      }
      if  self.nameNode.value_type == 11 {
        if  false == self.self.nameNode.isPrimitive() {
          return true;
        }
      }
      if  self.nameNode.value_type == 6 {
        return true;
      }
      if  self.nameNode.value_type == 7 {
        return true;
      }
    }
    return false;
  }
  fn moveRefTo(&mut self, mut nodeToMove : CodeNode, mut target : RangerAppParamDesc, mut ctx : RangerAppWriterContext) -> () {
    let b_disable_errors : bool = ctx.hasCompilerFlag("refcnt".to_string()) == false;
    if  nodeToMove.ref_change_done {
      return;
    }
    if  false == target.isAllocatedType() {
      return;
    }
    if  false == self.isAllocatedType() {
      return;
    }
    nodeToMove.ref_change_done = true;
    let other_s : i64 = target.getStrength();
    let my_s : i64 = self.getStrength();
    let mut my_lifetime : i64 = self.getLifetime();
    let other_lifetime : i64 = target.getLifetime();
    let mut a_lives : bool = false;
    let mut b_lives : bool = false;
    let tmp_var : bool = self.self.nameNode.hasFlag("temp".to_string());
    if  target.nameNode.is_some() {
      if  target.nameNode.hasFlag("lives".to_string()) {
        my_lifetime = 2;
        b_lives = true;
      }
    }
    if  self.nameNode.is_some() {
      if  self.self.nameNode.hasFlag("lives".to_string()) {
        my_lifetime = 2;
        a_lives = true;
      }
    }
    if  other_s > 0 {
      if  my_s == 1 {
        let mut lt : i64 = my_lifetime;
        if  other_lifetime > my_lifetime {
          lt = other_lifetime;
        }
        self.changeStrength(0, lt, nodeToMove.clone());
      } else {
        if  my_s == 0 {
          if  tmp_var == false {
            if  false == b_disable_errors {
              ctx.addError(nodeToMove.clone(), "Can not move a weak reference to a strong target.".to_string());
              println!( "{}", "can not move weak refs to strong target:".to_string() );
              self.debugRefChanges();
            }
          }
        } else {
          if  false == b_disable_errors {
            ctx.addError(nodeToMove.clone(), format!("{}{}", "Can not move immutable reference to a strong target, evald type ".to_string(), self.nameNode.eval_type_name));
          }
        }
      }
    } else {
      if  a_lives || b_lives {
      } else {
        if  (my_lifetime < other_lifetime) && (self.return_cnt == 0) {
          if  self.self.nameNode.hasFlag("returnvalue".to_string()) == false {
            if  false == b_disable_errors {
              ctx.addError(nodeToMove.clone(), ["Can not create a weak reference if target has longer lifetime than original, current lifetime == ".to_string() , (my_lifetime.to_string()) ].join(""));
            }
          }
        }
      }
    }
  }
  fn originalStrength(&mut self, ) -> i64 {
    let __len : i64 = (self.ownerHistory.len() as i64);
    if  __len > 0 {
      let mut firstEntry : RangerRefForce = self.ownerHistory[0 as usize].clone();
      return firstEntry.strength;
    }
    return 1;
  }
  fn getLifetime(&mut self, ) -> i64 {
    let __len : i64 = (self.ownerHistory.len() as i64);
    if  __len > 0 {
      let mut lastEntry : RangerRefForce = self.ownerHistory[(__len - 1) as usize].clone();
      return lastEntry.lifetime;
    }
    return 1;
  }
  fn getStrength(&mut self, ) -> i64 {
    let __len : i64 = (self.ownerHistory.len() as i64);
    if  __len > 0 {
      let mut lastEntry : RangerRefForce = self.ownerHistory[(__len - 1) as usize].clone();
      return lastEntry.strength;
    }
    return 1;
  }
  fn debugRefChanges(&mut self, ) -> () {
    println!( "{}", format!("{}{}", (format!("{}{}", "variable ".to_string(), self.name)), " ref history : ".to_string()) );
    for i in 0..self.ownerHistory.len() {
      let mut h = self.ownerHistory[i as usize].clone();
      println!( "{}", format!("{}{}", (format!("{}{}", ([" => change to ".to_string() , (h.strength.to_string()) ].join("")), " by ".to_string())), h.changer.getCode()) );
    }
  }
  fn pointsToObject(&mut self, mut ctx : RangerAppWriterContext) -> bool {
    if  self.nameNode.is_some() {
      let mut is_primitive : bool = false;
      switch (self.nameNode.array_type ) { 
        case "string".to_string() : 
          is_primitive = true;
          break;
        case "int".to_string() : 
          is_primitive = true;
          break;
        case "boolean".to_string() : 
          is_primitive = true;
          break;
        case "double".to_string() : 
          is_primitive = true;
          break;
      }
      if  is_primitive {
        return false;
      }
      if  (self.nameNode.value_type == 6) || (self.nameNode.value_type == 7) {
        let mut is_object : bool = true;
        switch (self.nameNode.array_type ) { 
          case "string".to_string() : 
            is_object = false;
            break;
          case "int".to_string() : 
            is_object = false;
            break;
          case "boolean".to_string() : 
            is_object = false;
            break;
          case "double".to_string() : 
            is_object = false;
            break;
        }
        return is_object;
      }
      if  self.nameNode.value_type == 11 {
        let mut is_object_1 : bool = true;
        switch (self.nameNode.type_name ) { 
          case "string".to_string() : 
            is_object_1 = false;
            break;
          case "int".to_string() : 
            is_object_1 = false;
            break;
          case "boolean".to_string() : 
            is_object_1 = false;
            break;
          case "double".to_string() : 
            is_object_1 = false;
            break;
        }
        if  ctx.isEnumDefined(self.nameNode.type_name.clone()) {
          return false;
        }
        return is_object_1;
      }
    }
    return false;
  }
  fn isObject(&mut self, ) -> bool {
    if  self.nameNode.is_some() {
      if  self.nameNode.value_type == 11 {
        if  false == self.self.nameNode.isPrimitive() {
          return true;
        }
      }
    }
    return false;
  }
  fn isArray(&mut self, ) -> bool {
    if  self.nameNode.is_some() {
      if  self.nameNode.value_type == 6 {
        return true;
      }
    }
    return false;
  }
  fn isHash(&mut self, ) -> bool {
    if  self.nameNode.is_some() {
      if  self.nameNode.value_type == 7 {
        return true;
      }
    }
    return false;
  }
  fn isPrimitive(&mut self, ) -> bool {
    if  self.nameNode.is_some() {
      return self.self.nameNode.isPrimitive();
    }
    return false;
  }
  fn getRefTypeName(&mut self, ) -> String {
    switch (self.refType ) { 
      case 0 : 
        return "NoType".to_string().clone();
        break;
      case 1 : 
        return "Weak".to_string().clone();
        break;
    }
    return "".to_string().clone();
  }
  fn getVarTypeName(&mut self, ) -> String {
    switch (self.refType ) { 
      case 0 : 
        return "NoType".to_string().clone();
        break;
      case 1 : 
        return "This".to_string().clone();
        break;
    }
    return "".to_string().clone();
  }
  fn getTypeName(&mut self, ) -> String {
    let s : String = self.nameNode.type_name.clone();
    return s.clone();
  }
}
#[derive(Clone)]
struct RangerAppFunctionDesc { 
  name : String, 
  ref_cnt : i64, 
  node : Option<CodeNode>, 
  nameNode : Option<CodeNode>, 
  fnBody : Option<CodeNode>, 
  params : Vec<RangerAppParamDesc>, 
  return_value : Option<RangerAppParamDesc>, 
  is_method : bool, 
  is_static : bool, 
  is_lambda : bool, 
  is_unsed : bool, 
  is_called_from_main : bool, 
  container_class : Option<RangerAppClassDesc>, 
  refType : i64, 
  fnCtx : Option<RangerAppWriterContext>, 
  insideFn : Option<Box<RangerAppFunctionDesc>>, 
  call_graph_done : bool, 
  isCalling : Vec<RangerAppFunctionDesc>, 
  isCalledBy : Vec<RangerAppFunctionDesc>, 
  isUsingClasses : Vec<RangerAppClassDesc>, 
  isDirectlyUsingClasses : Vec<RangerAppClassDesc>, 
  myLambdas : Vec<RangerAppFunctionDesc>, 
}
impl RangerAppFunctionDesc { 
  
  pub fn new() ->  RangerAppFunctionDesc {
    let mut me = RangerAppFunctionDesc { 
      name:"".to_string(), 
      ref_cnt:0, 
      node: None, 
      nameNode: None, 
      fnBody: None, 
      params: Vec::new(), 
      return_value: None, 
      is_method:false, 
      is_static:false, 
      is_lambda:false, 
      is_unsed:false, 
      is_called_from_main:false, 
      container_class: None, 
      refType:0, 
      fnCtx: None, 
      insideFn: None, 
      call_graph_done:false, 
      isCalling: Vec::new(), 
      isCalledBy: Vec::new(), 
      isUsingClasses: Vec::new(), 
      isDirectlyUsingClasses: Vec::new(), 
      myLambdas: Vec::new(), 
    };
    return me;
  }
  fn addCallTo(&mut self, mut m : RangerAppFunctionDesc) -> () {
    if  (m.isCalledBy.iter().position( |&r| r == self ).unwrap()) < 0 {
      m.isCalledBy.push(self.clone());
      self.isCalling.push(m.clone());
    }
  }
  fn addIndirectClassUsage(&mut self, mut m : RangerAppClassDesc, mut ctx : RangerAppWriterContext) -> () {
    if  (self.isUsingClasses.iter().position( |&r| r == m ).unwrap()) < 0 {
      self.isUsingClasses.push(m.clone());
      operatorsOf::forEach_11(m.variables, (item, index) => { 
        let mut nn : Option<CodeNode> = item.nameNode;
        if  ctx.isDefinedClass(nn.type_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(nn.type_name.clone());
          self.addIndirectClassUsage(cc.clone(), ctx.clone());
        }
        if  ctx.isDefinedClass(nn.array_type.clone()) {
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(nn.array_type.clone());
          self.addIndirectClassUsage(cc_1.clone(), ctx.clone());
        }
      }
      );
    }
  }
  fn addClassUsage(&mut self, mut m : RangerAppClassDesc, mut ctx : RangerAppWriterContext) -> () {
    if  (self.isUsingClasses.iter().position( |&r| r == m ).unwrap()) < 0 {
      self.isUsingClasses.push(m.clone());
      self.isDirectlyUsingClasses.push(m.clone());
      operatorsOf::forEach_11(m.variables, (item, index) => { 
        let mut nn : Option<CodeNode> = item.nameNode;
        if  ctx.isDefinedClass(nn.type_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(nn.type_name.clone());
          self.addIndirectClassUsage(cc.clone(), ctx.clone());
        }
        if  ctx.isDefinedClass(nn.array_type.clone()) {
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(nn.array_type.clone());
          self.addIndirectClassUsage(cc_1.clone(), ctx.clone());
        }
      }
      );
    } else {
      if  (self.isDirectlyUsingClasses.iter().position( |&r| r == m ).unwrap()) < 0 {
        self.isDirectlyUsingClasses.push(m.clone());
      }
    }
  }
  fn forOtherVersions(&mut self, mut ctx : RangerAppWriterContext, cb : ) -> () {
    if  self.container_class.is_none() {
      return;
    }
    let mut f : RangerAppFunctionDesc = self;
    let mut cc : RangerAppClassDesc = f.container_class.clone().unwrap();
    operatorsOf::forEach_12(cc.extends_classes, (item, index) => { 
      let mut otherClass : RangerAppClassDesc = ctx.findClass(item.clone());
      if  otherClass.hasMethod(f.name.clone()) {
        let mut m : Option<Box<RangerAppFunctionDesc>> = otherClass.findMethod(f.name.clone());
        cb(m);
      }
    }
    );
    let mut root : RangerAppWriterContext = ctx.getRoot();
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  (item.extends_classes.iter().position( |&r| r == f.container_class.name ).unwrap()) >= 0 {
        if  item.hasMethod(f.name.clone()) {
          let mut m_1 : Option<Box<RangerAppFunctionDesc>> = item.findMethod(f.name.clone());
          cb(m_1);
        }
      }
    }
    );
  }
  fn isFunction(&mut self, ) -> bool {
    return true;
  }
  fn isClass(&mut self, ) -> bool {
    return false;
  }
  fn isProperty(&mut self, ) -> bool {
    return false;
  }
}
#[derive(Clone)]
struct RangerAppMethodVariants { 
  name : String, 
  variants : Vec<RangerAppFunctionDesc>, 
}
impl RangerAppMethodVariants { 
  
  pub fn new() ->  RangerAppMethodVariants {
    let mut me = RangerAppMethodVariants { 
      name:"".to_string(), 
      variants: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppInterfaceImpl { 
  name : String, 
  typeParams : Option<CodeNode>, 
}
impl RangerAppInterfaceImpl { 
  
  pub fn new() ->  RangerAppInterfaceImpl {
    let mut me = RangerAppInterfaceImpl { 
      name:"".to_string(), 
      typeParams: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerTraitParams { 
  param_names : Vec<String>, 
  values : HashMap<String,String>, 
}
impl RangerTraitParams { 
  
  pub fn new() ->  RangerTraitParams {
    let mut me = RangerTraitParams { 
      param_names: Vec::new(), 
      values: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppClassDesc { 
  name : String, 
  is_system : bool, 
  compiledName : String, 
  systemNames : HashMap<String,String>, 
  systemNodes : HashMap<String,CodeNode>, 
  systemInfo : Option<CodeNode>, 
  is_interface : bool, 
  is_system_union : bool, 
  is_template : bool, 
  is_serialized : bool, 
  is_trait : bool, 
  is_operator_class : bool, 
  is_generic_instance : bool, 
  is_union : bool, 
  is_used_by_main : bool, 
  is_not_used : bool, 
  generic_params : Option<CodeNode>, 
  ctx : Option<RangerAppWriterContext>, 
  variables : Vec<RangerAppParamDesc>, 
  capturedLocals : Vec<RangerAppParamDesc>, 
  methods : Vec<RangerAppFunctionDesc>, 
  defined_methods : HashMap<String,bool>, 
  static_methods : Vec<RangerAppFunctionDesc>, 
  defined_static_methods : HashMap<String,bool>, 
  defined_variants : Vec<String>, 
  method_variants : HashMap<String,RangerAppMethodVariants>, 
  has_constructor : bool, 
  constructor_node : Option<CodeNode>, 
  constructor_fn : Option<RangerAppFunctionDesc>, 
  has_destructor : bool, 
  destructor_node : Option<CodeNode>, 
  destructor_fn : Option<RangerAppFunctionDesc>, 
  extends_classes : Vec<String>, 
  implements_interfaces : Vec<String>, 
  consumes_traits : Vec<String>, 
  trait_params : HashMap<String,RangerTraitParams>, 
  is_union_of : Vec<String>, 
  nameNode : Option<CodeNode>, 
  classNode : Option<CodeNode>, 
  contr_writers : Vec<CodeWriter>, 
  is_inherited : bool, 
}
impl RangerAppClassDesc { 
  
  pub fn new() ->  RangerAppClassDesc {
    let mut me = RangerAppClassDesc { 
      name:"".to_string(), 
      is_system:false, 
      compiledName:"".to_string(), 
      systemNames: None, 
      systemNodes: None, 
      systemInfo: None, 
      is_interface:false, 
      is_system_union:false, 
      is_template:false, 
      is_serialized:false, 
      is_trait:false, 
      is_operator_class:false, 
      is_generic_instance:false, 
      is_union:false, 
      is_used_by_main:false, 
      is_not_used:false, 
      generic_params: None, 
      ctx: None, 
      variables: Vec::new(), 
      capturedLocals: Vec::new(), 
      methods: Vec::new(), 
      defined_methods: None, 
      static_methods: Vec::new(), 
      defined_static_methods: None, 
      defined_variants: Vec::new(), 
      method_variants: None, 
      has_constructor:false, 
      constructor_node: None, 
      constructor_fn: None, 
      has_destructor:false, 
      destructor_node: None, 
      destructor_fn: None, 
      extends_classes: Vec::new(), 
      implements_interfaces: Vec::new(), 
      consumes_traits: Vec::new(), 
      trait_params: None, 
      is_union_of: Vec::new(), 
      nameNode: None, 
      classNode: None, 
      contr_writers: Vec::new(), 
      is_inherited:false, 
    };
    return me;
  }
  fn isClass(&mut self, ) -> bool {
    return true;
  }
  fn isProperty(&mut self, ) -> bool {
    return false;
  }
  fn doesInherit(&mut self, ) -> bool {
    return self.is_inherited;
  }
  fn isNormalClass(&mut self, ) -> bool {
    let special : bool = ((((self.is_operator_class || self.is_trait) || self.is_system) || self.is_generic_instance) || self.is_system_union) || self.is_union;
    return special == false;
  }
  fn hasTrait(&mut self, class_name : String, mut ctx : RangerAppWriterContext) -> Option<Box<RangerAppClassDesc>> {
    let mut res : Option<Box<RangerAppClassDesc>> = None;
    for i in 0..self.consumes_traits.len() {
      let mut c_name = self.consumes_traits[i as usize].clone();
      let mut c : RangerAppClassDesc = ctx.findClass(c_name.clone());
      if  c_name == class_name {
        res = Some(c.clone());
        return res.clone();
      }
    }
    return res.clone();
  }
  fn isSameOrParentClass(&mut self, class_name : String, mut ctx : RangerAppWriterContext) -> bool {
    if  ctx.isPrimitiveType(class_name.clone()) {
      if  (self.is_union_of.iter().position( |&r| r == class_name ).unwrap()) >= 0 {
        return true;
      }
      return false;
    }
    if  class_name == self.name {
      return true;
    }
    if  (self.extends_classes.iter().position( |&r| r == class_name ).unwrap()) >= 0 {
      return true;
    }
    if  (self.consumes_traits.iter().position( |&r| r == class_name ).unwrap()) >= 0 {
      return true;
    }
    if  (self.implements_interfaces.iter().position( |&r| r == class_name ).unwrap()) >= 0 {
      return true;
    }
    if  (self.is_union_of.iter().position( |&r| r == class_name ).unwrap()) >= 0 {
      return true;
    }
    for i in 0..self.extends_classes.len() {
      let mut c_name = self.extends_classes[i as usize].clone();
      let mut c : RangerAppClassDesc = ctx.findClass(c_name.clone());
      if  c.isSameOrParentClass(class_name.clone(), ctx.clone()) {
        return true;
      }
    }
    for i_1 in 0..self.consumes_traits.len() {
      let mut c_name_1 = self.consumes_traits[i_1 as usize].clone();
      let mut c_1 : RangerAppClassDesc = ctx.findClass(c_name_1.clone());
      if  c_1.isSameOrParentClass(class_name.clone(), ctx.clone()) {
        return true;
      }
    }
    for i_2 in 0..self.implements_interfaces.len() {
      let mut i_name = self.implements_interfaces[i_2 as usize].clone();
      let mut c_2 : RangerAppClassDesc = ctx.findClass(i_name.clone());
      if  c_2.isSameOrParentClass(class_name.clone(), ctx.clone()) {
        return true;
      }
    }
    for i_3 in 0..self.is_union_of.len() {
      let mut i_name_1 = self.is_union_of[i_3 as usize].clone();
      if  ctx.isDefinedClass(i_name_1.clone()) {
        let mut c_3 : RangerAppClassDesc = ctx.findClass(i_name_1.clone());
        if  c_3.isSameOrParentClass(class_name.clone(), ctx.clone()) {
          return true;
        }
      } else {
      }
    }
    return false;
  }
  fn hasOwnMethod(&mut self, m_name : String) -> bool {
    if  self.defined_methods.contains_key(&m_name) {
      return true;
    }
    return false;
  }
  fn hasMethod(&mut self, m_name : String) -> bool {
    if  self.defined_methods.contains_key(&m_name) {
      return true;
    }
    for i in 0..self.extends_classes.len() {
      let mut cname = self.extends_classes[i as usize].clone();
      let mut cDesc : RangerAppClassDesc = self.self.ctx.findClass(cname.clone());
      if  cDesc.hasMethod(m_name.clone()) {
        return cDesc.hasMethod(m_name.clone());
      }
    }
    return false;
  }
  fn findMethod(&mut self, f_name : String) -> Option<RangerAppFunctionDesc> {
    let mut res : Option<RangerAppFunctionDesc> = None;
    let vNames :  = keysself.method_variants;
    forvNamesmnamei
    if  mname == f_name {
      let mut list : RangerAppMethodVariants = (self.method_variants.get(mname)).unwrap();
      res = Some(list.variants[0 as usize].clone());
      return res.clone();
    }
    for i_1 in 0..self.extends_classes.len() {
      let mut cname = self.extends_classes[i_1 as usize].clone();
      let mut cDesc : RangerAppClassDesc = self.self.ctx.findClass(cname.clone());
      if  cDesc.hasMethod(f_name.clone()) {
        return cDesc.findMethod(f_name.clone()).clone();
      }
    }
    return res.clone();
  }
  fn hasStaticMethod(&mut self, m_name : String) -> bool {
    return self.defined_static_methods.contains_key(&m_name);
  }
  fn findStaticMethod(&mut self, f_name : String) -> Option<RangerAppFunctionDesc> {
    let mut e : Option<RangerAppFunctionDesc> = None;
    for i in 0..self.static_methods.len() {
      let mut m = self.static_methods[i as usize].clone();
      if  m.name == f_name {
        e = Some(m.clone());
        return e.clone();
      }
    }
    for i_1 in 0..self.extends_classes.len() {
      let mut cname = self.extends_classes[i_1 as usize].clone();
      let mut cDesc : RangerAppClassDesc = self.self.ctx.findClass(cname.clone());
      if  cDesc.hasStaticMethod(f_name.clone()) {
        return cDesc.findStaticMethod(f_name.clone()).clone();
      }
    }
    return e.clone();
  }
  fn findVariable(&mut self, f_name : String) -> Option<RangerAppParamDesc> {
    let mut e : Option<RangerAppParamDesc> = None;
    for i in 0..self.variables.len() {
      let mut m = self.variables[i as usize].clone();
      if  m.name == f_name {
        e = Some(m.clone());
        return e.clone();
      }
    }
    for i_1 in 0..self.extends_classes.len() {
      let mut cname = self.extends_classes[i_1 as usize].clone();
      let mut cDesc : RangerAppClassDesc = self.self.ctx.findClass(cname.clone());
      return cDesc.findVariable(f_name.clone()).clone();
    }
    return e.clone();
  }
  fn addParentClass(&mut self, p_name : String) -> () {
    self.extends_classes.push(p_name);
  }
  fn createVariable(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    try {
      let mut parser : Option<RangerFlowParser> = ctx.getParser();
      let s : String = node.getVRefAt(1);
      let mut vDef : CodeNode = node.children[1 as usize].clone();
      let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
      if  vDef.has_type_annotation {
        parser.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
      }
      if  s != ctx.transformWord(s.clone()) {
      }
      let mut currC : RangerAppClassDesc = self;
      if  currC.is_immutable {
        vDef.setFlag("weak".to_string());
        if  vDef.value_type == 6 {
          let mut initNode : CodeNode = node.newExpressionNode();
          (initNode).push(node.newVRefNode("new".to_string()));
          let mut tDef : CodeNode = node.newVRefNode("Vector".to_string());
          let mut vAnn : CodeNode = node.newExpressionNode();
          (vAnn).push(node.newVRefNode(vDef.array_type.clone()));
          tDef.has_vref_annotation = true;
          tDef.vref_annotation = Some(Box::new(vAnn.clone()));
          (initNode).push(tDef);
          node.children[2 as usize] = initNode;
          vDef.value_type = 11;
          vDef.type_name = "Vector".to_string();
          let mut tAnn : CodeNode = node.newExpressionNode();
          (tAnn).push(node.newVRefNode(vDef.array_type.clone()));
          vDef.has_type_annotation = true;
          vDef.type_annotation = Some(Box::new(tAnn.clone()));
          parser.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
          parser.CheckVRefTypeAnnotationOf(tDef.clone(), ctx.clone(), wr.clone());
        }
        if  vDef.value_type == 7 {
          let mut initNode_1 : CodeNode = node.newExpressionNode();
          (initNode_1).push(node.newVRefNode("new".to_string()));
          let mut tDef_1 : CodeNode = node.newVRefNode("Map".to_string());
          let mut vAnn_1 : CodeNode = node.newExpressionNode();
          (vAnn_1).push(node.newVRefNode(vDef.key_type.clone()));
          (vAnn_1).push(node.newVRefNode(vDef.array_type.clone()));
          tDef_1.has_vref_annotation = true;
          tDef_1.vref_annotation = Some(Box::new(vAnn_1.clone()));
          (initNode_1).push(tDef_1);
          node.children[2 as usize] = initNode_1;
          vDef.value_type = 11;
          vDef.type_name = "Map".to_string();
          let mut tAnn_1 : CodeNode = node.newExpressionNode();
          (tAnn_1).push(node.newVRefNode(vDef.key_type.clone()));
          (tAnn_1).push(node.newVRefNode(vDef.array_type.clone()));
          vDef.has_type_annotation = true;
          vDef.type_annotation = Some(Box::new(tAnn_1.clone()));
          parser.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
          parser.CheckVRefTypeAnnotationOf(tDef_1.clone(), ctx.clone(), wr.clone());
        }
      }
      p.name = s.clone();
      p.value_type = vDef.value_type;
      p.node = Some(node.clone());
      p.is_class_variable = true;
      p.varType = 8;
      p.node = Some(node.clone());
      p.nameNode = Some(vDef.clone());
      vDef.hasParamDesc = true;
      vDef.ownParamDesc = Some(p.clone());
      vDef.paramDesc = Some(p.clone());
      node.hasParamDesc = true;
      node.paramDesc = Some(p.clone());
      if  vDef.hasFlag("weak".to_string()) {
        p.changeStrength(0, 2, p.nameNode.clone().unwrap());
      } else {
        p.changeStrength(2, 2, p.nameNode.clone().unwrap());
      }
      if  ((node.children.len() as i64)) > 2 {
        p.set_cnt = 1;
        p.init_cnt = 1;
        p.def_value = Some(node.children[2 as usize].clone());
        p.is_optional = false;
        if  p.def_value.value_type == 4 {
          vDef.type_name = "string".to_string();
        }
        if  p.def_value.value_type == 3 {
          vDef.type_name = "int".to_string();
        }
        if  p.def_value.value_type == 2 {
          vDef.type_name = "double".to_string();
        }
        if  p.def_value.value_type == 5 {
          vDef.type_name = "boolean".to_string();
        }
        let mut valueNode : CodeNode = node.children[2 as usize].clone();
        if  ((valueNode.children.len() as i64)) > 0 {
          let mut fc : CodeNode = valueNode.getFirst();
          if  fc.vref == "new".to_string() {
            let mut second : CodeNode = valueNode.getSecond();
            parser.CheckVRefTypeAnnotationOf(second.clone(), ctx.clone(), wr.clone());
          }
        }
      } else {
        p.is_optional = true;
        if  false == ((vDef.value_type == 6) || (vDef.value_type == 7)) {
          vDef.setFlag("optional".to_string());
        }
      }
      currC.addVariable(p.clone());
      let mut subCtx : Option<RangerAppWriterContext> = currC.ctx;
      subCtx.defineVariable(p.name.clone(), p.clone());
      p.is_class_variable = true;
    } catch(e) {
      ctx.addError(node.clone(), format!("{}{}", "Could not add variable into class ".to_string(), self.name));
    }
  }
  fn addVariable(&mut self, mut desc : RangerAppParamDesc) -> () {
    self.variables.push(desc.clone());
    desc.propertyClass = Some(self);
  }
  fn addMethod(&mut self, mut desc : RangerAppFunctionDesc) -> () {
    self.defined_methods.insert(desc.name, true);
    self.methods.push(desc.clone());
    let mut defVs : Option<RangerAppMethodVariants> = self.method_variants.get(desc.name);
    if  defVs.is_none() {
      let mut new_v : RangerAppMethodVariants = RangerAppMethodVariants::new();
      self.method_variants.insert(desc.name, new_v);
      self.defined_variants.push(desc.name);
      new_v.variants.push(desc.clone());
    } else {
      let mut new_v2 : RangerAppMethodVariants = defVs.unwrap();
      new_v2.variants.push(desc.clone());
    }
    desc.container_class = Some(self);
  }
  fn addStaticMethod(&mut self, mut desc : RangerAppFunctionDesc) -> () {
    self.defined_static_methods.insert(desc.name, true);
    self.static_methods.push(desc.clone());
    if  desc.name == "main".to_string() {
      let mut nn : Option<CodeNode> = desc.nameNode;
      if  nn.has_vref_annotation == false {
        let mut vAnn : CodeNode = self.self.node.newExpressionNode();
        nn.has_vref_annotation = true;
        nn.vref_annotation = Some(Box::new(vAnn.clone()));
      }
      nn.vref_annotation.children.push(nn.vref_annotation.newVRefNode("main".to_string()));
    }
  }
}
#[derive(Clone)]
struct RangerTypeClass { 
  name : String, 
  compiledName : String, 
  value_type : i64, 
  arrayType : Option<Box<RangerTypeClass>>, 
  keyType : Option<Box<RangerTypeClass>>, 
  implements_traits : Vec<RangerTypeClass>, 
  implements_interfaces : Vec<RangerTypeClass>, 
  extends_classes : Vec<RangerTypeClass>, 
  belongs_to_union : Vec<RangerTypeClass>, 
  description : Option<Any>, 
  is_empty : bool, 
  is_primitive : bool, 
  is_mutable : bool, 
  is_optional : bool, 
  is_union : bool, 
  is_trait : bool, 
  is_class : bool, 
  is_system : bool, 
  is_interface : bool, 
  is_generic : bool, 
  is_lambda : bool, 
  nameNode : Option<CodeNode>, 
  templateParams : Option<CodeNode>, 
}
impl RangerTypeClass { 
  
  pub fn new() ->  RangerTypeClass {
    let mut me = RangerTypeClass { 
      name:"".to_string(), 
      compiledName:"".to_string(), 
      value_type:0, 
      arrayType: None, 
      keyType: None, 
      implements_traits: Vec::new(), 
      implements_interfaces: Vec::new(), 
      extends_classes: Vec::new(), 
      belongs_to_union: Vec::new(), 
      description: None, 
      is_empty:false, 
      is_primitive:false, 
      is_mutable:false, 
      is_optional:false, 
      is_union:false, 
      is_trait:false, 
      is_class:false, 
      is_system:false, 
      is_interface:false, 
      is_generic:false, 
      is_lambda:false, 
      nameNode: None, 
      templateParams: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct SourceCode { 
  code : String, 
  lines : Vec<String>, 
  filename : String, 
}
impl SourceCode { 
  
  pub fn new(code_str : String) ->  SourceCode {
    let mut me = SourceCode { 
      code:"".to_string(), 
      lines: Vec::new(), 
      filename:"".to_string(), 
    };
    me.code = code_str.clone();
    me.lines = code_str.split("\n".to_string());
    return me;
  }
  fn getLineString(&mut self, line_index : i64) -> String {
    if  ((self.lines.len() as i64)) > line_index {
      return self.lines[line_index as usize].clone().clone();
    }
    return "".to_string().clone();
  }
  fn getLine(&mut self, sp : i64) -> i64 {
    let mut cnt : i64 = 0;
    for i in 0..self.lines.len() {
      let mut str = self.lines[i as usize].clone();
      cnt = cnt + ((str.len() as i64) + 1);
      if  cnt > sp {
        return i;
      }
    }
    return -1;
  }
  fn getColumnStr(&mut self, sp : i64) -> String {
    let mut cnt : i64 = 0;
    let mut last_col : i64 = 0;
    for i in 0..self.lines.len() {
      let mut str = self.lines[i as usize].clone();
      cnt = cnt + ((str.len() as i64) + 1);
      if  cnt > sp {
        let mut ll : i64 = sp - last_col;
        let mut ss : String = "".to_string();
        while ll > 0 {
          ss = format!("{}{}", ss, " ".to_string());
          ll = ll - 1;
        }
        return ss.clone();
      }
      last_col = cnt;
    }
    return "".to_string().clone();
  }
  fn getColumn(&mut self, sp : i64) -> i64 {
    let mut cnt : i64 = 0;
    let mut last_col : i64 = 0;
    for i in 0..self.lines.len() {
      let mut str = self.lines[i as usize].clone();
      cnt = cnt + ((str.len() as i64) + 1);
      if  cnt > sp {
        return sp - last_col;
      }
      last_col = cnt;
    }
    return -1;
  }
}
#[derive(Clone)]
struct CodeNodeLiteral { 
  expression : bool, 
  vref : String, 
  is_block_node : bool, 
  type_name : String, 
  key_type : String, 
  array_type : String, 
  ns : Vec<String>, 
  has_vref_annotation : bool, 
  vref_annotation : Option<Box<CodeNodeLiteral>>, 
  has_type_annotation : bool, 
  type_annotation : Option<Box<CodeNodeLiteral>>, 
  parsed_type : i64, 
  value_type : i64, 
  double_value : f64, 
  string_value : String, 
  int_value : i64, 
  boolean_value : bool, 
  expression_value : Option<Box<CodeNodeLiteral>>, 
  props : HashMap<String,CodeNodeLiteral>, 
  prop_keys : Vec<String>, 
  comments : Vec<CodeNodeLiteral>, 
  children : Vec<CodeNodeLiteral>, 
  attrs : Vec<CodeNodeLiteral>, 
}
impl CodeNodeLiteral { 
  
  pub fn new() ->  CodeNodeLiteral {
    let mut me = CodeNodeLiteral { 
      expression:false, 
      vref:"".to_string(), 
      is_block_node:false, 
      type_name:"".to_string(), 
      key_type:"".to_string(), 
      array_type:"".to_string(), 
      ns: Vec::new(), 
      has_vref_annotation:false, 
      vref_annotation: None, 
      has_type_annotation:false, 
      type_annotation: None, 
      parsed_type:0, 
      value_type:0, 
      double_value:0_f64, 
      string_value:"".to_string(), 
      int_value:0, 
      boolean_value:false, 
      expression_value: None, 
      props: None, 
      prop_keys: Vec::new(), 
      comments: Vec::new(), 
      children: Vec::new(), 
      attrs: Vec::new(), 
    };
    return me;
  }
  pub fn fromDictionary(mut dict : JSONDataObject) -> CodeNodeLiteral {
    let mut obj : CodeNodeLiteral = CodeNodeLiteral::new();
    try {
      let v : Option<bool> = dict.get("expression".to_string()).and_then(|v| v.as_bool());
      if  v.is_some() {
        obj.expression = v.unwrap();
      }
      let v_1 : Option<String> = dict.get("vref".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_1.is_some() {
        obj.vref = v_1.unwrap();
      }
      let v_2 : Option<bool> = dict.get("is_block_node".to_string()).and_then(|v| v.as_bool());
      if  v_2.is_some() {
        obj.is_block_node = v_2.unwrap();
      }
      let v_3 : Option<String> = dict.get("type_name".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_3.is_some() {
        obj.type_name = v_3.unwrap();
      }
      let v_4 : Option<String> = dict.get("key_type".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_4.is_some() {
        obj.key_type = v_4.unwrap();
      }
      let v_5 : Option<String> = dict.get("array_type".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_5.is_some() {
        obj.array_type = v_5.unwrap();
      }
      let mut values : Option<JSONArrayObject> = dict.get("ns".to_string()).and_then(|v| v.as_array()).cloned();
      if  values.is_some() {
        let mut arr : JSONArrayObject = values.unwrap();
        operatorsOf_57::forEach_58(arr.clone(), (item, index) => { 
          caseitemoopushobj.nsoo
        }
        );
      }
      let v_6 : Option<bool> = dict.get("has_vref_annotation".to_string()).and_then(|v| v.as_bool());
      if  v_6.is_some() {
        obj.has_vref_annotation = v_6.unwrap();
      }
      let mut theValue : Option<JSONDataObject> = dict.get("vref_annotation".to_string()).and_then(|v| v.as_object()).cloned();
      if  theValue.is_some() {
        let mut newObj : CodeNodeLiteral = CodeNodeLiteral::fromDictionary((theValue.unwrap()));
        obj.vref_annotation = Some(Box::new(newObj.clone()));
      }
      let v_7 : Option<bool> = dict.get("has_type_annotation".to_string()).and_then(|v| v.as_bool());
      if  v_7.is_some() {
        obj.has_type_annotation = v_7.unwrap();
      }
      let mut theValue_1 : Option<JSONDataObject> = dict.get("type_annotation".to_string()).and_then(|v| v.as_object()).cloned();
      if  theValue_1.is_some() {
        let mut newObj_1 : CodeNodeLiteral = CodeNodeLiteral::fromDictionary((theValue_1.unwrap()));
        obj.type_annotation = Some(Box::new(newObj_1.clone()));
      }
      let v_8 : Option<f64> = dict.get("double_value".to_string()).and_then(|v| v.as_f64());
      if  v_8.is_some() {
        obj.double_value = v_8.unwrap();
      }
      let v_9 : Option<String> = dict.get("string_value".to_string()).and_then(|v| v.as_str()).map(|s| s.to_string());
      if  v_9.is_some() {
        obj.string_value = v_9.unwrap();
      }
      let v_10 : Option<i64> = dict.get("int_value".to_string()).and_then(|v| v.as_i64());
      if  v_10.is_some() {
        obj.int_value = v_10.unwrap();
      }
      let v_11 : Option<bool> = dict.get("boolean_value".to_string()).and_then(|v| v.as_bool());
      if  v_11.is_some() {
        obj.boolean_value = v_11.unwrap();
      }
      let mut theValue_2 : Option<JSONDataObject> = dict.get("expression_value".to_string()).and_then(|v| v.as_object()).cloned();
      if  theValue_2.is_some() {
        let mut newObj_2 : CodeNodeLiteral = CodeNodeLiteral::fromDictionary((theValue_2.unwrap()));
        obj.expression_value = Some(Box::new(newObj_2.clone()));
      }
      let mut values_1 : Option<JSONDataObject> = dict.get("props".to_string()).and_then(|v| v.as_object()).cloned();
      if  values_1.is_some() {
        let mut theObjprops : JSONDataObject = values_1.unwrap();
        let mut obj_keys : Vec<String> = theObjprops.keys().cloned().collect::<Vec<String>>();
        operatorsOf::forEach_12(obj_keys, (item, index) => { 
          let mut theValue_3 : Option<JSONDataObject> = theObjprops.get(item).and_then(|v| v.as_object()).cloned();
          if  theValue_3.is_some() {
            let mut newObj_3 : CodeNodeLiteral = CodeNodeLiteral::fromDictionary((theValue_3.unwrap()));
            obj.props.insert(item, newObj_3);
          }
        }
        );
      }
      let mut values_2 : Option<JSONArrayObject> = dict.get("prop_keys".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_2.is_some() {
        let mut arr_1 : JSONArrayObject = values_2.unwrap();
        operatorsOf_57::forEach_58(arr_1.clone(), (item, index) => { 
          caseitemoopushobj.prop_keysoo
        }
        );
      }
      let mut values_3 : Option<JSONArrayObject> = dict.get("comments".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_3.is_some() {
        let mut arr_2 : JSONArrayObject = values_3.unwrap();
        operatorsOf_57::forEach_58(arr_2.clone(), (item, index) => { 
          caseitemoodefnewObjCodeNodeLiteral::fromDictionaryoopushobj.commentsnewObj
        }
        );
      }
      let mut values_4 : Option<JSONArrayObject> = dict.get("children".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_4.is_some() {
        let mut arr_3 : JSONArrayObject = values_4.unwrap();
        operatorsOf_57::forEach_58(arr_3.clone(), (item, index) => { 
          caseitemoodefnewObjCodeNodeLiteral::fromDictionaryoopushobj.childrennewObj
        }
        );
      }
      let mut values_5 : Option<JSONArrayObject> = dict.get("attrs".to_string()).and_then(|v| v.as_array()).cloned();
      if  values_5.is_some() {
        let mut arr_4 : JSONArrayObject = values_5.unwrap();
        operatorsOf_57::forEach_58(arr_4.clone(), (item, index) => { 
          caseitemoodefnewObjCodeNodeLiteral::fromDictionaryoopushobj.attrsnewObj
        }
        );
      }
    } catch(e) {
    }
    return obj.clone();
  }
  fn toDictionary(&mut self, ) -> JSONDataObject {
    let mut res : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
    try {
      res.insert("expression".to_string().to_string(), self.expression);
      res.insert("vref".to_string().to_string(), self.vref);
      res.insert("is_block_node".to_string().to_string(), self.is_block_node);
      res.insert("type_name".to_string().to_string(), self.type_name);
      res.insert("key_type".to_string().to_string(), self.key_type);
      res.insert("array_type".to_string().to_string(), self.array_type);
      let mut values : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i in 0..self.ns.len() {
        let mut item = self.ns[i as usize].clone();
        values.push(serde_json::json!(item));
      }
      res.insert("ns".to_string().to_string(), values);
      res.insert("has_vref_annotation".to_string().to_string(), self.has_vref_annotation);
      if  self.vref_annotation.is_some() {
        res.insert("vref_annotation".to_string().to_string(), (((*self.vref_annotation.clone().unwrap()))).toDictionary());
      }
      res.insert("has_type_annotation".to_string().to_string(), self.has_type_annotation);
      if  self.type_annotation.is_some() {
        res.insert("type_annotation".to_string().to_string(), (((*self.type_annotation.clone().unwrap()))).toDictionary());
      }
      res.insert("parsed_type".to_string().to_string(), serde_json::json!(self.parsed_type));
      res.insert("value_type".to_string().to_string(), serde_json::json!(self.value_type));
      res.insert("double_value".to_string().to_string(), self.double_value);
      res.insert("string_value".to_string().to_string(), self.string_value);
      res.insert("int_value".to_string().to_string(), self.int_value);
      res.insert("boolean_value".to_string().to_string(), self.boolean_value);
      if  self.expression_value.is_some() {
        res.insert("expression_value".to_string().to_string(), (((*self.expression_value.clone().unwrap()))).toDictionary());
      }
      let mut values_1 : JSONDataObject = serde_json::Map::<String, serde_json::Value>::new();
      let keyList :  = keysself.props;
      forkeyListkeynameindexlet mut item_1 : CodeNodeLiteral = (self.props.get(keyname)).unwrap();
      let mut obj : JSONDataObject = item_1.toDictionary();
      values_1.insert(keyname.to_string(), obj);
      res.insert("props".to_string().to_string(), values_1);
      let mut values_2 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i_1 in 0..self.prop_keys.len() {
        let mut item_2 = self.prop_keys[i_1 as usize].clone();
        values_2.push(serde_json::json!(item_2));
      }
      res.insert("prop_keys".to_string().to_string(), values_2);
      let mut values_3 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i_2 in 0..self.comments.len() {
        let mut item_3 = self.comments[i_2 as usize].clone();
        let mut obj_1 : JSONDataObject = item_3.toDictionary();
        values_3.push(serde_json::json!(obj_1));
      }
      res.insert("comments".to_string().to_string(), values_3);
      let mut values_4 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i_3 in 0..self.children.len() {
        let mut item_4 = self.children[i_3 as usize].clone();
        let mut obj_2 : JSONDataObject = item_4.toDictionary();
        values_4.push(serde_json::json!(obj_2));
      }
      res.insert("children".to_string().to_string(), values_4);
      let mut values_5 : JSONArrayObject = Vec::<serde_json::Value>::new();
      for i_4 in 0..self.attrs.len() {
        let mut item_5 = self.attrs[i_4 as usize].clone();
        let mut obj_3 : JSONDataObject = item_5.toDictionary();
        values_5.push(serde_json::json!(obj_3));
      }
      res.insert("attrs".to_string().to_string(), values_5);
    } catch(e) {
    }
    return res.clone();
  }
}
#[derive(Clone)]
struct CodeNode { 
  code : Option<SourceCode>, 
  sp : i64, 
  ep : i64, 
  row : i64, 
  col : i64, 
  has_operator : bool, 
  disabled_node : bool, 
  op_index : i64, 
  is_array_literal : bool, 
  is_system_class : bool, 
  is_plugin : bool, 
  is_direct_method_call : bool, 
  mutable_def : bool, 
  expression : bool, 
  vref : String, 
  is_block_node : bool, 
  infix_operator : bool, 
  infix_node : Option<Box<CodeNode>>, 
  infix_subnode : bool, 
  has_lambda : bool, 
  has_lambda_call : bool, 
  has_call : bool, 
  operator_pred : i64, 
  to_the_right : bool, 
  right_node : Option<Box<CodeNode>>, 
  type_type : String, 
  type_name : String, 
  key_type : String, 
  array_type : String, 
  ns : Vec<String>, 
  has_vref_annotation : bool, 
  vref_annotation : Option<Box<CodeNode>>, 
  has_type_annotation : bool, 
  type_annotation : Option<Box<CodeNode>>, 
  parsed_type : i64, 
  value_type : i64, 
  ref_type : i64, 
  ref_need_assign : i64, 
  double_value : f64, 
  string_value : String, 
  int_value : i64, 
  boolean_value : bool, 
  expression_value : Option<Box<CodeNode>>, 
  props : HashMap<String,CodeNode>, 
  prop_keys : Vec<String>, 
  comments : Vec<CodeNode>, 
  children : Vec<CodeNode>, 
  parent : Option<Box<CodeNode>>, 
  attrs : Vec<CodeNode>, 
  appGUID : String, 
  register_name : String, 
  register_expressions : Vec<CodeNode>, 
  after_expression : Vec<CodeNode>, 
  definedTypeClass : Option<RangerTypeClass>, 
  evalTypeClass : Option<RangerTypeClass>, 
  lambda_ctx : Option<RangerAppWriterContext>, 
  nsp : Vec<RangerAppParamDesc>, 
  eval_type : i64, 
  eval_type_name : String, 
  eval_key_type : String, 
  eval_array_type : String, 
  eval_function : Option<Box<CodeNode>>, 
  flow_done : bool, 
  ref_change_done : bool, 
  eval_type_node : Option<Box<CodeNode>>, 
  didReturnAtIndex : i64, 
  hasVarDef : bool, 
  hasClassDescription : bool, 
  hasNewOper : bool, 
  clDesc : Option<RangerAppClassDesc>, 
  hasFnCall : bool, 
  fnDesc : Option<RangerAppFunctionDesc>, 
  lambdaFnDesc : Option<RangerAppFunctionDesc>, 
  hasParamDesc : bool, 
  paramDesc : Option<RangerAppParamDesc>, 
  ownParamDesc : Option<RangerAppParamDesc>, 
  evalCtx : Option<RangerAppWriterContext>, 
  evalState : Option<NodeEvalState>, 
  operator_node : Option<Box<CodeNode>>, 
  flow_ctx : Option<RangerAppWriterContext>, 
  is_part_of_chain : bool, 
  methodChain : Vec<CallChain>, 
  chainTarget : Option<Box<CodeNode>>, 
  register_set : bool, 
  did_walk : bool, 
  reg_compiled_name : String, 
  tag : String, 
  matched_type : String, 
}
impl CodeNode { 
  
  pub fn new(source : SourceCode, start : i64, end : i64) ->  CodeNode {
    let mut me = CodeNode { 
      code: None, 
      sp:0, 
      ep:0, 
      row:0, 
      col:0, 
      has_operator:false, 
      disabled_node:false, 
      op_index:0, 
      is_array_literal:false, 
      is_system_class:false, 
      is_plugin:false, 
      is_direct_method_call:false, 
      mutable_def:false, 
      expression:false, 
      vref:"".to_string(), 
      is_block_node:false, 
      infix_operator:false, 
      infix_node: None, 
      infix_subnode:false, 
      has_lambda:false, 
      has_lambda_call:false, 
      has_call:false, 
      operator_pred:0, 
      to_the_right:false, 
      right_node: None, 
      type_type:"".to_string(), 
      type_name:"".to_string(), 
      key_type:"".to_string(), 
      array_type:"".to_string(), 
      ns: Vec::new(), 
      has_vref_annotation:false, 
      vref_annotation: None, 
      has_type_annotation:false, 
      type_annotation: None, 
      parsed_type:0, 
      value_type:0, 
      ref_type:0, 
      ref_need_assign:0, 
      double_value:0_f64, 
      string_value:"".to_string(), 
      int_value:0, 
      boolean_value:false, 
      expression_value: None, 
      props: None, 
      prop_keys: Vec::new(), 
      comments: Vec::new(), 
      children: Vec::new(), 
      parent: None, 
      attrs: Vec::new(), 
      appGUID:"".to_string(), 
      register_name:"".to_string(), 
      register_expressions: Vec::new(), 
      after_expression: Vec::new(), 
      definedTypeClass: None, 
      evalTypeClass: None, 
      lambda_ctx: None, 
      nsp: Vec::new(), 
      eval_type:0, 
      eval_type_name:"".to_string(), 
      eval_key_type:"".to_string(), 
      eval_array_type:"".to_string(), 
      eval_function: None, 
      flow_done:false, 
      ref_change_done:false, 
      eval_type_node: None, 
      didReturnAtIndex:-1, 
      hasVarDef:false, 
      hasClassDescription:false, 
      hasNewOper:false, 
      clDesc: None, 
      hasFnCall:false, 
      fnDesc: None, 
      lambdaFnDesc: None, 
      hasParamDesc:false, 
      paramDesc: None, 
      ownParamDesc: None, 
      evalCtx: None, 
      evalState: None, 
      operator_node: None, 
      flow_ctx: None, 
      is_part_of_chain:false, 
      methodChain: Vec::new(), 
      chainTarget: None, 
      register_set:false, 
      did_walk:false, 
      reg_compiled_name:"".to_string(), 
      tag:"".to_string(), 
      matched_type:"".to_string(), 
    };
    me.sp = start;
    me.ep = end;
    me.code = Some(source.clone());
    return me;
  }
  pub fn vref1(name : String) -> CodeNode {
    let mut code : SourceCode = SourceCode::new(name.clone());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, name.len() as i64);
    newNode.vref = name.clone();
    newNode.value_type = 11;
    newNode.parsed_type = 11;
    newNode.ns = name.split(".".to_string());
    return newNode.clone();
  }
  pub fn vref2(name : String, typeName : String) -> CodeNode {
    let mut code : SourceCode = SourceCode::new(name.clone());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, name.len() as i64);
    newNode.vref = name.clone();
    newNode.type_name = typeName.clone();
    newNode.value_type = 11;
    newNode.parsed_type = 11;
    newNode.ns = name.split(".".to_string());
    return newNode.clone();
  }
  pub fn newStr(name : String) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.string_value = name.clone();
    newNode.value_type = 4;
    newNode.parsed_type = 4;
    return newNode.clone();
  }
  pub fn newBool(value : bool) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.boolean_value = value;
    newNode.value_type = 5;
    newNode.parsed_type = 5;
    return newNode.clone();
  }
  pub fn newInt(value : i64) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.int_value = value;
    newNode.value_type = 3;
    newNode.parsed_type = 3;
    return newNode.clone();
  }
  pub fn newDouble(value : f64) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.double_value = value;
    newNode.value_type = 2;
    newNode.parsed_type = 2;
    return newNode.clone();
  }
  pub fn op(opName : String) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.expression = true;
    let mut opNode : CodeNode = CodeNode::vref1(opName.clone());
    newNode.children.push(opNode.clone());
    return newNode.clone();
  }
  pub fn op2(opName : String, mut param1 : CodeNode) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.expression = true;
    let mut opNode : CodeNode = CodeNode::vref1(opName.clone());
    newNode.children.push(opNode.clone());
    newNode.children.push(param1.clone());
    return newNode.clone();
  }
  pub fn op3(opName : String, mut list : Vec<CodeNode>) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.expression = true;
    let mut opNode : CodeNode = CodeNode::vref1(opName.clone());
    newNode.children.push(opNode.clone());
    for i in 0..list.len() {
      let mut item = list[i as usize].clone();
      newNode.children.push(item.clone());
    }
    return newNode.clone();
  }
  pub fn fromList(mut list : Vec<CodeNode>) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.expression = true;
    for i in 0..list.len() {
      let mut item = list[i as usize].clone();
      newNode.children.push(item.clone());
      item.parent = Some(Box::new(newNode.clone()));
    }
    return newNode.clone();
  }
  pub fn expressionNode() -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.expression = true;
    return newNode.clone();
  }
  pub fn blockNode() -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.is_block_node = true;
    newNode.expression = true;
    return newNode.clone();
  }
  pub fn blockFromList(mut list : Vec<CodeNode>) -> CodeNode {
    let mut code : SourceCode = SourceCode::new("".to_string());
    let mut newNode : CodeNode = CodeNode::new(code.clone(), 0, 0);
    newNode.is_block_node = true;
    newNode.expression = true;
    for i in 0..list.len() {
      let mut item = list[i as usize].clone();
      newNode.children.push(item.clone());
      item.parent = Some(Box::new(newNode.clone()));
    }
    return newNode.clone();
  }
  fn childCnt(&mut self, ) -> i64 {
    return (self.children.len() as i64);
  }
  fn getChild(&mut self, index : i64) -> Option<Box<CodeNode>> {
    let mut res : Option<Box<CodeNode>> = None;
    if  (index >= 0) && (((self.children.len() as i64)) > index) {
      res = Some(self.children[index as usize].clone());
    }
    return res.clone();
  }
  fn chlen(&mut self, ) -> i64 {
    return (self.children.len() as i64);
  }
  fn forTree(&mut self, callback : ) -> () {
    for i in 0..self.children.len() {
      let mut ch = self.children[i as usize].clone();
      callback(ch, i);
      ch.forTree(callback);
    }
  }
  fn parallelTree(&mut self, mut otherTree : CodeNode, callback : ) -> () {
    let left_cnt : i64 = (self.children.len() as i64);
    let right_cnt : i64 = (otherTree.children.len() as i64);
    let cnt : i64 = if (left_cnt < right_cnt) { right_cnt } else { left_cnt };
    let mut i : i64 = 0;
    while i < cnt {
      let mut left : Option<Box<CodeNode>> = None;
      let mut right : Option<Box<CodeNode>> = None;
      if  i < left_cnt {
        left = Some(self.children[i as usize].clone());
      }
      if  i < right_cnt {
        right = Some(otherTree.children[i as usize].clone());
      }
      callback(left, right, i);
      if  (left.is_some()) && (right.is_some()) {
        if  ((left.children.len() as i64)) > 0 {
          left.parallelTree(right.unwrap(), callback);
        }
      }
      i = i + 1;
    }
  }
  fn walkTreeUntil(&mut self, callback : ) -> () {
    for i in 0..self.children.len() {
      let mut ch = self.children[i as usize].clone();
      if  callback(ch, i) {
        ch.walkTreeUntil(callback);
      }
    }
  }
  fn getParsedString(&mut self, ) -> String {
    return self.code.code.chars().skip(self.sp as usize).take((self.ep - self.sp) as usize).collect::<String>().clone();
  }
  fn getFilename(&mut self, ) -> String {
    return self.code.filename.clone();
  }
  fn getFlag(&mut self, flagName : String) -> Option<Box<CodeNode>> {
    let mut res : Option<Box<CodeNode>> = None;
    if  false == self.has_vref_annotation {
      return res.clone();
    }
    for i in 0..self.vref_annotation.children.len() {
      let mut ch = self.vref_annotation.children[i as usize].clone();
      if  ch.vref == flagName {
        res = Some(ch.clone());
        return res.clone();
      }
    }
    return res.clone();
  }
  fn hasFlag(&mut self, flagName : String) -> bool {
    if  false == self.has_vref_annotation {
      return false;
    }
    for i in 0..self.vref_annotation.children.len() {
      let mut ch = self.vref_annotation.children[i as usize].clone();
      if  ch.vref == flagName {
        return true;
      }
    }
    return false;
  }
  fn setFlag(&mut self, flagName : String) -> () {
    if  false == self.has_vref_annotation {
      self.vref_annotation = Some(Box::new(CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep).clone()));
    }
    if  self.hasFlag(flagName.clone()) {
      return;
    }
    let mut flag : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    flag.vref = flagName.clone();
    flag.value_type = 11;
    flag.parsed_type = flag.value_type;
    self.vref_annotation.children.push(flag.clone());
    self.has_vref_annotation = true;
  }
  fn getTypeInformationString(&mut self, ) -> String {
    let mut s : String = "".to_string();
    if  (self.vref.len() as i64) > 0 {
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, "<vref:".to_string())), self.vref)), ">".to_string());
    } else {
      s = format!("{}{}", s, "<no.vref>".to_string());
    }
    if  (self.type_name.len() as i64) > 0 {
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, "<type_name:".to_string())), self.type_name)), ">".to_string());
    } else {
      s = format!("{}{}", s, "<no.type_name>".to_string());
    }
    if  (self.array_type.len() as i64) > 0 {
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, "<array_type:".to_string())), self.array_type)), ">".to_string());
    } else {
      s = format!("{}{}", s, "<no.array_type>".to_string());
    }
    if  (self.key_type.len() as i64) > 0 {
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, "<key_type:".to_string())), self.key_type)), ">".to_string());
    } else {
      s = format!("{}{}", s, "<no.key_type>".to_string());
    }
    switch (self.value_type ) { 
      case 5 : 
        s = format!("{}{}", s, "<value_type=Boolean>".to_string());
        break;
      case 4 : 
        s = format!("{}{}", s, "<value_type=String>".to_string());
        break;
    }
    return s.clone();
  }
  fn getLine(&mut self, ) -> i64 {
    return self.self.code.getLine(self.sp);
  }
  fn getLineString(&mut self, line_index : i64) -> String {
    return self.self.code.getLineString(line_index).clone();
  }
  fn getColStartString(&mut self, ) -> String {
    return self.self.code.getColumnStr(self.sp).clone();
  }
  fn getLineAsString(&mut self, ) -> String {
    let idx : i64 = self.getLine();
    let line_name_idx : i64 = idx + 1;
    return format!("{}{}", (format!("{}{}", ([(format!("{}{}", self.getFilename(), ", line ".to_string())) , (line_name_idx.to_string()) ].join("")), " : ".to_string())), self.self.code.getLineString(idx)).clone();
  }
  fn getSource(&mut self, ) -> String {
    if  self.ep > self.sp {
      let start : i64 = self.sp;
      let end : i64 = self.ep;
      return self.code.code.chars().skip(start as usize).take((end - start) as usize).collect::<String>().clone();
    }
    return "".to_string().clone();
  }
  fn getPositionalString(&mut self, ) -> String {
    if  (self.ep > self.sp) && ((self.ep - self.sp) < 50) {
      let mut start : i64 = self.sp;
      let mut end : i64 = self.ep;
      start = start - 100;
      end = end + 50;
      if  start < 0 {
        start = 0;
      }
      if  end >= (self.code.code.len() as i64) {
        end = (self.code.code.len() as i64) - 1;
      }
      return self.code.code.chars().skip(start as usize).take((end - start) as usize).collect::<String>().clone();
    }
    return "".to_string().clone();
  }
  fn isPrimitive(&mut self, ) -> bool {
    switch (self.value_type ) { 
      case 2 : 
        return true;
        break;
      case 4 : 
        return true;
        break;
      case 3 : 
        return true;
        break;
      case 5 : 
        return true;
        break;
      case 14 : 
        return true;
        break;
      case 15 : 
        return true;
        break;
      case 13 : 
        return true;
        break;
    }
    return false;
  }
  fn getFirst(&mut self, ) -> CodeNode {
    return self.children[0 as usize].clone().clone();
  }
  fn getSecond(&mut self, ) -> CodeNode {
    return self.children[1 as usize].clone().clone();
  }
  fn getThird(&mut self, ) -> CodeNode {
    return self.children[2 as usize].clone().clone();
  }
  fn isSecondExpr(&mut self, ) -> bool {
    if  ((self.children.len() as i64)) > 1 {
      let mut second : CodeNode = self.children[1 as usize].clone();
      if  second.expression {
        return true;
      }
    }
    return false;
  }
  fn getOperator(&mut self, ) -> String {
    let s : String = "".to_string();
    if  ((self.children.len() as i64)) > 0 {
      let mut fc : CodeNode = self.children[0 as usize].clone();
      if  fc.value_type == 11 {
        return fc.vref.clone();
      }
    }
    return s.clone();
  }
  fn getVRefAt(&mut self, idx : i64) -> String {
    let s : String = "".to_string();
    if  ((self.children.len() as i64)) > idx {
      let mut fc : CodeNode = self.children[idx as usize].clone();
      return fc.vref.clone();
    }
    return s.clone();
  }
  fn getStringAt(&mut self, idx : i64) -> String {
    let s : String = "".to_string();
    if  ((self.children.len() as i64)) > idx {
      let mut fc : CodeNode = self.children[idx as usize].clone();
      if  fc.value_type == 4 {
        return fc.string_value.clone();
      }
    }
    return s.clone();
  }
  fn hasExpressionProperty(&mut self, name : String) -> bool {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      return ann.expression;
    }
    return false;
  }
  fn getExpressionProperty(&mut self, name : String) -> Option<Box<CodeNode>> {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      return ann.clone();
    }
    return ann.clone();
  }
  fn hasIntProperty(&mut self, name : String) -> bool {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      let mut fc : CodeNode = ann.children[0 as usize].clone();
      if  fc.value_type == 3 {
        return true;
      }
    }
    return false;
  }
  fn getIntProperty(&mut self, name : String) -> i64 {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      let mut fc : CodeNode = ann.children[0 as usize].clone();
      if  fc.value_type == 3 {
        return fc.int_value;
      }
    }
    return 0;
  }
  fn hasDoubleProperty(&mut self, name : String) -> bool {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 2 {
        return true;
      }
    }
    return false;
  }
  fn getDoubleProperty(&mut self, name : String) -> f64 {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 2 {
        return ann.double_value;
      }
    }
    return 0_f64;
  }
  fn setStringProperty(&mut self, name : String, value : String) -> () {
    self.props.insert(name, CodeNode::newStr(value.clone()));
  }
  fn hasStringProperty(&mut self, name : String) -> bool {
    if  false == (self.props.contains_key(&name)) {
      return false;
    }
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 4 {
        return true;
      }
    }
    return false;
  }
  fn getStringProperty(&mut self, name : String) -> String {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 4 {
        return ann.string_value.clone();
      }
    }
    return "".to_string().clone();
  }
  fn hasBooleanProperty(&mut self, name : String) -> bool {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 5 {
        return true;
      }
    }
    return false;
  }
  fn getBooleanProperty(&mut self, name : String) -> bool {
    let mut ann : Option<Box<CodeNode>> = self.props.get(name);
    if  ann.is_some() {
      if  ann.value_type == 5 {
        return ann.boolean_value;
      }
    }
    return false;
  }
  fn isFirstTypeVref(&mut self, vrefName : String) -> bool {
    if  ((self.children.len() as i64)) > 0 {
      let mut fc : CodeNode = self.children[0 as usize].clone();
      if  fc.value_type == 11 {
        return true;
      }
    }
    return false;
  }
  fn isFirstVref(&mut self, vrefName : String) -> bool {
    if  ((self.children.len() as i64)) > 0 {
      let mut fc : CodeNode = self.children[0 as usize].clone();
      if  fc.vref == vrefName {
        return true;
      }
    }
    return false;
  }
  fn getString(&mut self, ) -> String {
    return self.code.code.chars().skip(self.sp as usize).take((self.ep - self.sp) as usize).collect::<String>().clone();
  }
  fn walk(&mut self, ) -> () {
    switch (self.value_type ) { 
      case 2 : 
        println!( "{}", ["Double : ".to_string() , (self.double_value.to_string()) ].join("") );
        break;
      case 4 : 
        println!( "{}", format!("{}{}", "String : ".to_string(), self.string_value) );
        break;
    }
    if  self.expression {
      println!( "{}", "(".to_string() );
    } else {
      println!( "{}", self.code.code.chars().skip(self.sp as usize).take((self.ep - self.sp) as usize).collect::<String>() );
    }
    for i in 0..self.children.len() {
      let mut item = self.children[i as usize].clone();
      item.walk();
    }
    if  self.expression {
      println!( "{}", ")".to_string() );
    }
  }
  fn isParsedAsPrimitive(&mut self, ) -> bool {
    return TTypes::isPrimitive(self.parsed_type);
  }
  fn isPrimitiveType(&mut self, ) -> bool {
    return TTypes::isPrimitive(TTypes::nameToValue(self.type_name.clone()));
  }
  fn isAPrimitiveType(&mut self, ) -> bool {
    return TTypes::isPrimitive(TTypes::nameToValue(self.array_type.clone()));
  }
  fn writeCode(&mut self, mut wr : CodeWriter) -> () {
    switch (self.value_type ) { 
      case 2 : 
        wr.out((self.double_value.toString()), false);
        break;
      case 4 : 
        wr.out(format!("{}{}", (format!("{}{}", (String.fromCharCode(34)), self.string_value)), (String.fromCharCode(34))), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (self.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  self.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
      case 11 : 
        wr.out(self.vref.clone(), false);
        if  (self.type_name.len() as i64) > 0 {
          wr.out(format!("{}{}", ":".to_string(), self.type_name), false);
        }
        break;
      case 7 : 
        wr.out(self.vref.clone(), false);
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", ":[".to_string(), self.key_type)), ":".to_string())), self.array_type)), "]".to_string()), false);
        break;
      case 6 : 
        wr.out(self.vref.clone(), false);
        wr.out(format!("{}{}", (format!("{}{}", ":[".to_string(), self.array_type)), "]".to_string()), false);
        break;
      case 17 : 
        wr.out("(fn--> ".to_string(), false);
        for i in 0..self.children.len() {
          let mut ch = self.children[i as usize].clone();
          ch.writeCode(wr.clone());
        }
        wr.out(")".to_string(), false);
        break;
      default: 
        if  self.expression {
          wr.out("(".to_string(), false);
          for i_1 in 0..self.children.len() {
            let mut ch_1 = self.children[i_1 as usize].clone();
            if  i_1 > 0 {
              wr.out(" ".to_string(), false);
            }
            ch_1.writeCode(wr.clone());
          }
          wr.out(")".to_string(), false);
        } else {
          if  self.is_block_node {
            wr.out("{".to_string(), true);
            for i_2 in 0..self.children.len() {
              let mut ch_2 = self.children[i_2 as usize].clone();
              ch_2.writeCode(wr.clone());
            }
            wr.out("}".to_string(), true);
          } else {
            wr.out("<unknown>".to_string(), false);
            wr.out("{".to_string(), true);
            for i_3 in 0..self.children.len() {
              let mut ch_3 = self.children[i_3 as usize].clone();
              ch_3.writeCode(wr.clone());
            }
            wr.out("}".to_string(), true);
          }
        }
        break;
    }
  }
  fn createChainTarget(&mut self, ) -> () {
    let chCnt : i64 = (self.children.len() as i64);
    if  chCnt > 2 {
      let mut fc : CodeNode = self.getFirst();
      if  fc.vref == "def".to_string() {
        self.chainTarget = Some(Box::new(self.getThird().clone()));
      }
      if  fc.vref == "=".to_string() {
        self.chainTarget = Some(Box::new(self.getThird().clone()));
      }
    }
  }
  fn inferDefExpressionTypeFromValue(&mut self, mut node : CodeNode) -> () {
    let mut cn : CodeNode = node.children[1 as usize].clone();
    let mut nodeValue : CodeNode = node.children[2 as usize].clone();
    if  cn.expression_value.is_some() {
      cn.value_type = 17;
      cn.parsed_type = 17;
      cn.has_vref_annotation = true;
    }
    if  nodeValue.eval_type == 17 {
      if  nodeValue.expression_value.is_some() {
        cn.expression_value = Some(Box::new(nodeValue.expression_value.copy().clone()));
      } else {
        if  node.expression_value.is_none() {
          let mut copyOf : CodeNode = nodeValue.rebuildWithType(RangerArgMatch::new(), false);
          copyOf.children.pop();
          cn.expression_value = Some(Box::new(copyOf.clone()));
        }
      }
      cn.value_type = 17;
    }
  }
  fn inferDefTypeFromValue(&mut self, mut node : CodeNode) -> () {
    let mut cn : CodeNode = node.children[1 as usize].clone();
    let mut nodeValue : CodeNode = node.children[2 as usize].clone();
    cn.value_type = nodeValue.eval_type;
    cn.type_name = nodeValue.eval_type_name.clone();
    cn.array_type = nodeValue.eval_array_type.clone();
    cn.key_type = nodeValue.eval_key_type.clone();
    if  nodeValue.eval_type == 17 {
      if  nodeValue.expression_value.is_some() {
        cn.expression_value = Some(Box::new(nodeValue.expression_value.copy().clone()));
      } else {
        if  node.expression_value.is_none() {
          let mut copyOf : CodeNode = nodeValue.rebuildWithType(RangerArgMatch::new(), false);
          copyOf.children.pop();
          cn.expression_value = Some(Box::new(copyOf.clone()));
        }
      }
      cn.type_name = "".to_string();
    }
  }
  fn getCode(&mut self, ) -> String {
    let mut wr : CodeWriter = CodeWriter::new();
    self.writeCode(wr.clone());
    return wr.getCode().clone();
  }
  fn cleanNode(&mut self, ) -> () {
    let mut cp : CodeNode = self;
    nullifycp.evalTypeClassnullifycp.lambda_ctx
    cp.nsp.length = 0;
    cp.eval_type = 0;
    cp.eval_type_name = "".to_string();
    cp.eval_key_type = "".to_string();
    cp.eval_array_type = "".to_string();
    nullifycp.eval_function
    cp.flow_done = false;
    cp.ref_change_done = false;
    nullifycp.eval_type_node
    cp.didReturnAtIndex = -1;
    cp.hasVarDef = false;
    cp.hasClassDescription = false;
    cp.hasNewOper = false;
    nullifycp.clDesc
    cp.hasFnCall = false;
    nullifycp.fnDesc
    cp.hasParamDesc = false;
    nullifycp.paramDescnullifycp.ownParamDescnullifycp.evalCtxnullifycp.evalStatenullifycp.operator_nodenullifycp.flow_ctx
    cp.is_part_of_chain = false;
    cp.methodChain.length = 0;
    nullifycp.chainTarget
    cp.tag = "".to_string();
    cp.has_operator = false;
    cp.disabled_node = false;
    cp.op_index = 0;
    cp.is_array_literal = false;
    cp.is_system_class = false;
    cp.is_plugin = false;
    cp.mutable_def = false;
    cp.has_lambda = false;
    cp.has_lambda_call = false;
    cp.has_call = false;
    cp.type_type = self.type_type.clone();
    cp.value_type = self.parsed_type;
    operatorsOf::forEach_15(cp.children, (item, index) => { 
      item.cleanNode();
    }
    );
  }
  fn cleanCopy(&mut self, ) -> CodeNode {
    let mut match : RangerArgMatch = RangerArgMatch::new();
    let mut cp : CodeNode = self.rebuildWithType(match.clone(), false);
    cp.cleanNode();
    return cp.clone();
  }
  fn copy(&mut self, ) -> CodeNode {
    let mut match : RangerArgMatch = RangerArgMatch::new();
    let mut cp : CodeNode = self.rebuildWithType(match.clone(), false);
    cp.register_expressions = operatorsOf::clone_46(self.register_expressions);
    return cp.clone();
  }
  fn clone(&mut self, ) -> CodeNode {
    let mut match : RangerArgMatch = RangerArgMatch::new();
    let mut cp : CodeNode = self.cloneWithType(match.clone(), false);
    return cp.clone();
  }
  fn push(&mut self, mut node : CodeNode) -> () {
    self.children.push(node.clone());
    node.parent = Some(Box::new(self.clone()));
  }
  fn add(&mut self, mut node : CodeNode) -> () {
    self.children.push(node.clone());
    node.parent = Some(Box::new(self.clone()));
  }
  fn newVRefNode(&mut self, name : String) -> CodeNode {
    let mut newNode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    newNode.vref = name.clone();
    newNode.value_type = 11;
    newNode.parsed_type = 11;
    newNode.ns = name.split(".".to_string());
    return newNode.clone();
  }
  fn newStringNode(&mut self, name : String) -> CodeNode {
    let mut newNode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    newNode.string_value = name.clone();
    newNode.value_type = 4;
    newNode.parsed_type = 11;
    return newNode.clone();
  }
  fn newExpressionNode(&mut self, ) -> CodeNode {
    let mut newNode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    newNode.expression = true;
    return newNode.clone();
  }
  fn getChildrenFrom(&mut self, mut otherNode : CodeNode) -> () {
    self.children.length = 0;
    for i in 0..otherNode.children.len() {
      let mut ch = otherNode.children[i as usize].clone();
      (self).push(ch);
      ch.parent = Some(Box::new(self.clone()));
    }
    otherNode.children.length = 0;
  }
  fn cloneWithType(&mut self, mut match : RangerArgMatch, changeVref : bool) -> CodeNode {
    let mut newNode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    if  r#match.nodes.contains_key(&self.vref) {
      let mut ast : CodeNode = (r#match.nodes.get(self.vref)).unwrap();
      return ast.rebuildWithType(match.clone(), true).clone();
    }
    newNode.has_operator = self.has_operator;
    newNode.op_index = self.op_index;
    newNode.mutable_def = self.mutable_def;
    newNode.expression = self.expression;
    newNode.register_name = self.register_name.clone();
    newNode.operator_node = self.operator_node.clone();
    if  changeVref {
      newNode.vref = r#match.getTypeName(self.vref.clone());
    } else {
      newNode.vref = self.vref.clone();
    }
    newNode.is_block_node = self.is_block_node;
    newNode.type_type = r#match.getTypeName(self.type_type.clone());
    newNode.type_name = r#match.getTypeName(self.type_name.clone());
    newNode.key_type = r#match.getTypeName(self.key_type.clone());
    newNode.array_type = r#match.getTypeName(self.array_type.clone());
    newNode.value_type = self.value_type;
    newNode.parsed_type = self.parsed_type;
    newNode.copyEvalResFrom(self.clone());
    newNode.register_expressions = operatorsOf::clone_46(self.register_expressions);
    if  self.has_vref_annotation {
      newNode.has_vref_annotation = true;
      let mut ann : Option<Box<CodeNode>> = self.vref_annotation;
      newNode.vref_annotation = Some(Box::new(ann.cloneWithType(match.clone(), true).clone()));
    }
    if  self.has_type_annotation {
      newNode.has_type_annotation = true;
      let mut t_ann : Option<Box<CodeNode>> = self.type_annotation;
      newNode.type_annotation = Some(Box::new(t_ann.cloneWithType(match.clone(), true).clone()));
    }
    for i in 0..self.ns.len() {
      let mut n = self.ns[i as usize].clone();
      if  changeVref {
        let new_ns : String = r#match.getTypeName(n.clone());
        newNode.ns.push(new_ns);
      } else {
        newNode.vref = self.vref.clone();
        newNode.ns.push(n);
      }
    }
    newNode.string_value = self.string_value.clone();
    switch (self.value_type ) { 
      case 2 : 
        newNode.double_value = self.double_value;
        break;
      case 4 : 
        newNode.string_value = self.string_value.clone();
        break;
      case 3 : 
        newNode.int_value = self.int_value;
        break;
      case 5 : 
        newNode.boolean_value = self.boolean_value;
        break;
      case 17 : 
        if  self.expression_value.is_some() {
          newNode.expression_value = Some(Box::new(self.self.expression_value.cloneWithType(match.clone(), changeVref).clone()));
        }
        break;
    }
    for i_1 in 0..self.prop_keys.len() {
      let mut key = self.prop_keys[i_1 as usize].clone();
      newNode.prop_keys.push(key);
      let mut oldp : Option<Box<CodeNode>> = self.props.get(key);
      let mut np : CodeNode = oldp.cloneWithType(match.clone(), changeVref);
      newNode.props.insert(key, np);
    }
    for i_2 in 0..self.children.len() {
      let mut ch = self.children[i_2 as usize].clone();
      let mut newCh : CodeNode = ch.cloneWithType(match.clone(), changeVref);
      newCh.parent = Some(Box::new(newNode.clone()));
      newNode.children.push(newCh.clone());
    }
    for i_3 in 0..self.attrs.len() {
      let mut ch_1 = self.attrs[i_3 as usize].clone();
      let mut newCh_1 : CodeNode = ch_1.rebuildWithType(match.clone(), changeVref);
      newNode.attrs.push(newCh_1.clone());
    }
    return newNode.clone();
  }
  fn rebuildWithType(&mut self, mut match : RangerArgMatch, changeVref : bool) -> CodeNode {
    let mut newNode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.sp, self.ep);
    if  r#match.nodes.contains_key(&self.vref) {
      let mut ast : CodeNode = (r#match.nodes.get(self.vref)).unwrap();
      if  ast == self {
        let mut tmp : CodeNode = self;
        return tmp.clone();
      }
      let mut newNode_2 : CodeNode = ast.rebuildWithType(match.clone(), true);
      r#match.builtNodes.insert(self.vref, newNode_2);
      return newNode_2.clone();
    }
    newNode.has_operator = self.has_operator;
    newNode.op_index = self.op_index;
    newNode.mutable_def = self.mutable_def;
    newNode.expression = self.expression;
    newNode.register_name = self.register_name.clone();
    newNode.reg_compiled_name = self.reg_compiled_name.clone();
    newNode.operator_node = self.operator_node.clone();
    newNode.matched_type = self.matched_type.clone();
    if  changeVref {
      newNode.vref = r#match.getTypeName(self.vref.clone());
    } else {
      newNode.vref = self.vref.clone();
    }
    newNode.is_block_node = self.is_block_node;
    newNode.type_type = r#match.getTypeName(self.type_type.clone());
    newNode.type_name = r#match.getTypeName(self.type_name.clone());
    newNode.key_type = r#match.getTypeName(self.key_type.clone());
    newNode.array_type = r#match.getTypeName(self.array_type.clone());
    newNode.value_type = self.value_type;
    newNode.parsed_type = self.parsed_type;
    if  self.has_vref_annotation {
      newNode.has_vref_annotation = true;
      let mut ann : Option<Box<CodeNode>> = self.vref_annotation;
      newNode.vref_annotation = Some(Box::new(ann.rebuildWithType(match.clone(), true).clone()));
    }
    if  self.has_type_annotation {
      newNode.has_type_annotation = true;
      let mut t_ann : Option<Box<CodeNode>> = self.type_annotation;
      newNode.type_annotation = Some(Box::new(t_ann.rebuildWithType(match.clone(), true).clone()));
    }
    for i in 0..self.ns.len() {
      let mut n = self.ns[i as usize].clone();
      if  changeVref {
        let new_ns : String = r#match.getTypeName(n.clone());
        newNode.ns.push(new_ns);
      } else {
        newNode.vref = self.vref.clone();
        newNode.ns.push(n);
      }
    }
    newNode.string_value = self.string_value.clone();
    switch (self.value_type ) { 
      case 2 : 
        newNode.double_value = self.double_value;
        break;
      case 4 : 
        newNode.string_value = self.string_value.clone();
        break;
      case 3 : 
        newNode.int_value = self.int_value;
        break;
      case 5 : 
        newNode.boolean_value = self.boolean_value;
        break;
      case 17 : 
        if  self.expression_value.is_some() {
          newNode.expression_value = Some(Box::new(self.self.expression_value.rebuildWithType(match.clone(), changeVref).clone()));
        }
        break;
    }
    for i_1 in 0..self.prop_keys.len() {
      let mut key = self.prop_keys[i_1 as usize].clone();
      newNode.prop_keys.push(key);
      let mut oldp : Option<Box<CodeNode>> = self.props.get(key);
      let mut np : CodeNode = oldp.rebuildWithType(match.clone(), changeVref);
      newNode.props.insert(key, np);
    }
    for i_2 in 0..self.children.len() {
      let mut ch = self.children[i_2 as usize].clone();
      let mut newCh : CodeNode = ch.rebuildWithType(match.clone(), changeVref);
      newCh.parent = Some(Box::new(newNode.clone()));
      newNode.children.push(newCh.clone());
    }
    for i_3 in 0..self.attrs.len() {
      let mut ch_1 = self.attrs[i_3 as usize].clone();
      let mut newCh_1 : CodeNode = ch_1.rebuildWithType(match.clone(), changeVref);
      newNode.attrs.push(newCh_1.clone());
    }
    return newNode.clone();
  }
  fn buildTypeSignatureUsingMatch(&mut self, mut match : RangerArgMatch) -> String {
    let tName : String = r#match.getTypeName(self.type_name.clone());
    switch (tName ) { 
      case "double".to_string() : 
        return "double".to_string().clone();
        break;
      case "string".to_string() : 
        return "string".to_string().clone();
        break;
      case "integer".to_string() : 
        return "int".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "boolean".to_string().clone();
        break;
    }
    let mut s : String = "".to_string();
    if  self.value_type == 6 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, r#match.getTypeName(self.array_type.clone()));
      s = format!("{}{}", s, self.getTypeSignatureWithMatch(match.clone()));
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    if  self.value_type == 7 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, r#match.getTypeName(self.key_type.clone()));
      s = format!("{}{}", s, ":".to_string());
      s = format!("{}{}", s, r#match.getTypeName(self.array_type.clone()));
      s = format!("{}{}", s, self.getTypeSignatureWithMatch(match.clone()));
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    s = r#match.getTypeName(self.type_name.clone());
    s = format!("{}{}", s, self.getVRefSignatureWithMatch(match.clone()));
    return s.clone();
  }
  fn buildTypeSignature(&mut self, ) -> String {
    if  self.hasFlag("keyword".to_string()) {
      return format!("{}{}", self.vref, "::keyword".to_string()).clone();
    }
    if  TTypes::isPrimitive(self.value_type) {
      return TTypes::valueAsString(self.value_type).clone();
    }
    let mut s : String = "".to_string();
    if  self.value_type == 6 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, self.array_type);
      s = format!("{}{}", s, self.getTypeSignature());
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    if  self.value_type == 7 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, self.key_type);
      s = format!("{}{}", s, ":".to_string());
      s = format!("{}{}", s, self.array_type);
      s = format!("{}{}", s, self.getTypeSignature());
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    if  self.value_type == 17 {
      let mut fnNode : CodeNode = self.self.expression_value.getFirst();
      let mut argNode : CodeNode = self.self.expression_value.getSecond();
      s = format!("{}{}", (format!("{}{}", s, "(_:".to_string())), fnNode.buildTypeSignature());
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, " (".to_string())), (operatorsOf::map_47(argNode.children, (item, index) => { 
        return format!("{}{}", "_:".to_string(), item.buildTypeSignature()).clone();
      }
      ).join(" ".to_string())))), "))".to_string());
      return s.clone();
    }
    s = self.type_name.clone();
    return s.clone();
  }
  fn getVRefSignatureWithMatch(&mut self, mut match : RangerArgMatch) -> String {
    if  self.has_vref_annotation {
      let mut nn : CodeNode = self.self.vref_annotation.rebuildWithType(match.clone(), true);
      return format!("{}{}", "@".to_string(), nn.getCode()).clone();
    }
    return "".to_string().clone();
  }
  fn getVRefSignature(&mut self, ) -> String {
    if  self.has_vref_annotation {
      return format!("{}{}", "@".to_string(), self.self.vref_annotation.getCode()).clone();
    }
    return "".to_string().clone();
  }
  fn getTypeSignatureWithMatch(&mut self, mut match : RangerArgMatch) -> String {
    if  self.has_type_annotation {
      let mut nn : CodeNode = self.self.type_annotation.rebuildWithType(match.clone(), true);
      return format!("{}{}", "@".to_string(), nn.getCode()).clone();
    }
    return "".to_string().clone();
  }
  fn getTypeSignature(&mut self, ) -> String {
    if  self.has_type_annotation {
      return format!("{}{}", "@".to_string(), self.self.type_annotation.getCode()).clone();
    }
    return "".to_string().clone();
  }
  fn typeNameAsType(&mut self, mut ctx : RangerAppWriterContext) -> i64 {
    if  (self.value_type == 17) || (self.eval_type == 17) {
      return 17;
    }
    let conv : i64 = TTypes::nameToValue(self.type_name.clone());
    if  conv != 0 {
      return conv;
    }
    if  true == self.expression {
      return 17;
    }
    if  self.value_type == 11 {
      if  ctx.isEnumDefined(self.type_name.clone()) {
        return 13;
      }
      if  ctx.isDefinedClass(self.type_name.clone()) {
        return 10;
      }
    }
    return self.value_type;
  }
  fn copyEvalResFrom(&mut self, mut node : CodeNode) -> () {
    if  node.hasParamDesc {
      self.hasParamDesc = node.hasParamDesc;
      self.paramDesc = node.paramDesc.clone();
    }
    if  node.evalTypeClass.is_some() {
      self.evalTypeClass = node.evalTypeClass.clone();
    }
    self.eval_type = node.eval_type;
    self.eval_type_name = node.eval_type_name.clone();
    if  node.operator_node.is_some() {
      let mut nn : CodeNode = node.operator_node.children[1 as usize].clone();
      if  nn.hasFlag("optional".to_string()) {
        self.setFlag("optional".to_string());
      }
      if  nn.hasFlag("immutable".to_string()) {
        self.setFlag("immutable".to_string());
      }
    } else {
      if  node.hasFlag("optional".to_string()) {
        self.setFlag("optional".to_string());
      }
      if  node.hasFlag("immutable".to_string()) {
        self.setFlag("immutable".to_string());
      }
    }
    self.eval_key_type = node.eval_key_type.clone();
    self.eval_array_type = node.eval_array_type.clone();
    if  node.value_type == 7 {
      self.eval_type = 7;
    }
    if  node.value_type == 6 {
      self.eval_type = 6;
    }
    if  node.value_type == 17 {
      self.eval_type = 17;
      self.eval_function = node.eval_function.clone();
    }
  }
  fn defineNodeTypeTo(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext) -> () {
    if  (node.value_type == 17) || (node.eval_type == 17) {
      return;
    }
    switch (self.type_name ) { 
      case "double".to_string() : 
        node.value_type = 2;
        node.eval_type = 2;
        node.eval_type_name = "double".to_string();
        break;
      case "int".to_string() : 
        node.value_type = 3;
        node.eval_type = 3;
        node.eval_type_name = "int".to_string();
        break;
      case "char".to_string() : 
        node.value_type = 14;
        node.eval_type = 14;
        node.eval_type_name = "char".to_string();
        break;
      case "charbuffer".to_string() : 
        node.value_type = 15;
        node.eval_type = 15;
        node.eval_type_name = "charbuffer".to_string();
        break;
      case "string".to_string() : 
        node.value_type = 4;
        node.eval_type = 4;
        node.eval_type_name = "string".to_string();
        break;
      case "boolean".to_string() : 
        node.value_type = 5;
        node.eval_type = 5;
        node.eval_type_name = "string".to_string();
        break;
      default: 
        if  true == self.expression {
          node.value_type = 17;
          node.eval_type = 17;
          node.expression = true;
        }
        if  self.value_type == 6 {
          node.value_type = 6;
          node.eval_type = 6;
          node.eval_type_name = self.type_name.clone();
          node.eval_array_type = self.array_type.clone();
        }
        if  self.value_type == 7 {
          node.value_type = 7;
          node.eval_type = 7;
          node.eval_type_name = self.type_name.clone();
          node.eval_array_type = self.array_type.clone();
          node.key_type = self.key_type.clone();
        }
        if  self.value_type == 13 {
          node.value_type = 13;
          node.eval_type = 13;
          node.eval_type_name = self.type_name.clone();
        }
        if  self.value_type == 11 {
          if  ctx.isEnumDefined(self.type_name.clone()) {
            node.value_type = 13;
            node.eval_type = 13;
            node.eval_type_name = self.type_name.clone();
          }
          if  ctx.isDefinedClass(self.type_name.clone()) {
            node.value_type = 10;
            node.eval_type = 10;
            node.eval_type_name = self.type_name.clone();
          }
        }
        break;
    }
  }
  fn ifNoTypeSetToVoid(&mut self, ) -> () {
    if  (((self.type_name.len() as i64) == 0) && ((self.key_type.len() as i64) == 0)) && ((self.array_type.len() as i64) == 0) {
      self.type_name = "void".to_string();
    }
  }
  fn ifNoTypeSetToEvalTypeOf(&mut self, mut node : CodeNode) -> bool {
    if  (((self.type_name.len() as i64) == 0) && ((self.key_type.len() as i64) == 0)) && ((self.array_type.len() as i64) == 0) {
      self.type_name = node.eval_type_name.clone();
      self.array_type = node.eval_array_type.clone();
      self.key_type = node.eval_key_type.clone();
      self.value_type = node.eval_type;
      self.eval_type = node.eval_type;
      self.eval_type_name = node.eval_type_name.clone();
      self.eval_array_type = node.eval_array_type.clone();
      self.eval_key_type = node.eval_key_type.clone();
      if  node.value_type == 17 {
        if  self.expression_value.is_none() {
          let mut copyOf : CodeNode = node.rebuildWithType(RangerArgMatch::new(), false);
          copyOf.children.pop();
          self.expression_value = Some(Box::new(copyOf.clone()));
        }
      }
      return true;
    }
    return false;
  }
}
#[derive(Clone)]
struct TypeCounts { 
  b_counted : bool, 
  interface_cnt : i64, 
  operator_cnt : i64, 
  immutable_cnt : i64, 
  register_cnt : i64, 
  opfn_cnt : i64, 
}
impl TypeCounts { 
  
  pub fn new() ->  TypeCounts {
    let mut me = TypeCounts { 
      b_counted:false, 
      interface_cnt:0, 
      operator_cnt:0, 
      immutable_cnt:0, 
      register_cnt:0, 
      opfn_cnt:0, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerNodeValue { 
  double_value : Option<f64>, 
  string_value : Option<String>, 
  int_value : Option<i64>, 
  boolean_value : Option<bool>, 
  expression_value : Option<CodeNode>, 
}
impl RangerNodeValue { 
  
  pub fn new() ->  RangerNodeValue {
    let mut me = RangerNodeValue { 
      double_value: None, 
      string_value: None, 
      int_value: None, 
      boolean_value: None, 
      expression_value: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerBackReference { 
  from_class : Option<String>, 
  var_name : Option<String>, 
  ref_type : Option<String>, 
}
impl RangerBackReference { 
  
  pub fn new() ->  RangerBackReference {
    let mut me = RangerBackReference { 
      from_class: None, 
      var_name: None, 
      ref_type: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppEnum { 
  name : String, 
  cnt : i64, 
  values : HashMap<String,i64>, 
  node : Option<CodeNode>, 
}
impl RangerAppEnum { 
  
  pub fn new() ->  RangerAppEnum {
    let mut me = RangerAppEnum { 
      name:"".to_string(), 
      cnt:0, 
      values: None, 
      node: None, 
    };
    return me;
  }
  fn add(&mut self, n : String) -> () {
    self.values.insert(n, self.cnt);
    self.cnt = self.cnt + 1;
  }
}
#[derive(Clone)]
struct OpFindResult { 
  did_find : bool, 
  node : Option<CodeNode>, 
}
impl OpFindResult { 
  
  pub fn new() ->  OpFindResult {
    let mut me = OpFindResult { 
      did_find:false, 
      node: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerOperatorList { 
  items : Vec<RangerAppOperatorDesc>, 
}
impl RangerOperatorList { 
  
  pub fn new() ->  RangerOperatorList {
    let mut me = RangerOperatorList { 
      items: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerNodeList { 
  items : Vec<CodeNode>, 
}
impl RangerNodeList { 
  
  pub fn new() ->  RangerNodeList {
    let mut me = RangerNodeList { 
      items: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct ContextTransaction { 
  name : String, 
  desc : String, 
  ended : bool, 
  failed : bool, 
  ctx : Option<RangerAppWriterContext>, 
  mutations : Vec<ContextTransactionMutation>, 
  parent : Option<Box<ContextTransaction>>, 
  children : Vec<ContextTransaction>, 
}
impl ContextTransaction { 
  
  pub fn new() ->  ContextTransaction {
    let mut me = ContextTransaction { 
      name:"".to_string(), 
      desc:"".to_string(), 
      ended:false, 
      failed:false, 
      ctx: None, 
      mutations: Vec::new(), 
      parent: None, 
      children: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct ContextTransactionMutation { 
  sourceNode : Option<CodeNode>, 
  targetNode : Option<CodeNode>, 
  addedNode : Option<CodeNode>, 
}
impl ContextTransactionMutation { 
  
  pub fn new() ->  ContextTransactionMutation {
    let mut me = ContextTransactionMutation { 
      sourceNode: None, 
      targetNode: None, 
      addedNode: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerRegisteredPlugin { 
  name : String, 
  features : Vec<String>, 
}
impl RangerRegisteredPlugin { 
  
  pub fn new() ->  RangerRegisteredPlugin {
    let mut me = RangerRegisteredPlugin { 
      name:"".to_string(), 
      features: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerAppWriterContext { 
  langOperators : Option<CodeNode>, 
  stdCommands : Option<CodeNode>, 
  operators : Option<RangerActiveOperators>, 
  op_list : HashMap<String,RangerOperatorList>, 
  reservedWords : Option<CodeNode>, 
  intRootCounter : i64, 
  targetLangName : String, 
  parent : Option<Box<RangerAppWriterContext>>, 
  defined_imports : Vec<String>, 
  already_imported : HashMap<String,bool>, 
  fileSystem : Option<CodeFileSystem>, 
  is_function : bool, 
  class_level_context : bool, 
  function_level_context : bool, 
  in_main : bool, 
  is_block : bool, 
  is_lambda : bool, 
  is_capturing : bool, 
  is_catch_block : bool, 
  is_try_block : bool, 
  captured_variables : Vec<String>, 
  has_block_exited : bool, 
  in_expression : bool, 
  expr_stack : Vec<bool>, 
  expr_restart : bool, 
  expr_restart_block : bool, 
  in_method : bool, 
  method_stack : Vec<bool>, 
  typeNames : Vec<String>, 
  typeClasses : HashMap<String,RangerTypeClass>, 
  currentClassName : Option<String>, 
  in_class : bool, 
  in_static_method : bool, 
  currentClass : Option<RangerAppClassDesc>, 
  currentMethod : Option<RangerAppFunctionDesc>, 
  thisName : String, 
  definedEnums : HashMap<String,RangerAppEnum>, 
  definedInterfaces : HashMap<String,RangerAppClassDesc>, 
  definedInterfaceList : Vec<String>, 
  definedClasses : HashMap<String,RangerAppClassDesc>, 
  definedClassList : Vec<String>, 
  definedTasks : HashMap<String,RangerAppFunctionDesc>, 
  templateClassNodes : HashMap<String,CodeNode>, 
  templateClassList : Vec<String>, 
  classSignatures : HashMap<String,String>, 
  classToSignature : HashMap<String,String>, 
  templateClasses : HashMap<String,RangerAppClassDesc>, 
  classStaticWriters : HashMap<String,CodeWriter>, 
  localVariables : HashMap<String,RangerAppParamDesc>, 
  localVarNames : Vec<String>, 
  contextFlags : HashMap<String,bool>, 
  settings : HashMap<String,String>, 
  compilerFlags : HashMap<String,bool>, 
  compilerSettings : HashMap<String,String>, 
  parserErrors : Vec<RangerCompilerMessage>, 
  compilerErrors : Vec<RangerCompilerMessage>, 
  compilerMessages : Vec<RangerCompilerMessage>, 
  compilerLog : HashMap<String,RangerCompilerMessage>, 
  todoList : Vec<RangerAppTodo>, 
  definedMacro : HashMap<String,bool>, 
  defCounts : HashMap<String,i64>, 
  refTransform : HashMap<String,String>, 
  staticClassBodies : Vec<CodeNode>, 
  pluginSpecificOperators : HashMap<String,bool>, 
  viewClassBody : HashMap<String,CodeNode>, 
  appPages : HashMap<String,CodeNode>, 
  appServices : HashMap<String,CodeNode>, 
  opNs : Vec<String>, 
  langFilePath : String, 
  libraryPaths : Vec<String>, 
  outputPath : String, 
  counters : TypeCounts, 
  parser : Option<RangerFlowParser>, 
  compiler : Option<LiveCompiler>, 
  pluginNodes : HashMap<String,RangerNodeList>, 
  typedNodes : HashMap<String,RangerNodeList>, 
  registered_plugins : Vec<RangerRegisteredPlugin>, 
  operatorFunction : Option<>, 
  lastBlockOp : Option<CodeNode>, 
  opFnsList : HashMap<String,CodeNode>, 
  test_compile : Vec<bool>, 
  activeTransaction : Vec<ContextTransaction>, 
  transactions : Vec<ContextTransaction>, 
  env : Option<InputEnv>, 
  rust_moved_vars : HashMap<String,bool>, 
  rust_usage_count : HashMap<String,i64>, 
  rust_temp_counter : i64, 
  rootFile : String, 
}
impl RangerAppWriterContext { 
  
  pub fn new() ->  RangerAppWriterContext {
    let mut me = RangerAppWriterContext { 
      langOperators: None, 
      stdCommands: None, 
      operators: None, 
      op_list: None, 
      reservedWords: None, 
      intRootCounter:1, 
      targetLangName:"".to_string(), 
      parent: None, 
      defined_imports: Vec::new(), 
      already_imported: None, 
      fileSystem: None, 
      is_function:false, 
      class_level_context:false, 
      function_level_context:false, 
      in_main:false, 
      is_block:false, 
      is_lambda:false, 
      is_capturing:false, 
      is_catch_block:false, 
      is_try_block:false, 
      captured_variables: Vec::new(), 
      has_block_exited:false, 
      in_expression:false, 
      expr_stack: Vec::new(), 
      expr_restart:false, 
      expr_restart_block:false, 
      in_method:false, 
      method_stack: Vec::new(), 
      typeNames: Vec::new(), 
      typeClasses: None, 
      currentClassName: None, 
      in_class:false, 
      in_static_method:false, 
      currentClass: None, 
      currentMethod: None, 
      thisName:"this".to_string(), 
      definedEnums: None, 
      definedInterfaces: None, 
      definedInterfaceList: Vec::new(), 
      definedClasses: None, 
      definedClassList: Vec::new(), 
      definedTasks: None, 
      templateClassNodes: None, 
      templateClassList: Vec::new(), 
      classSignatures: None, 
      classToSignature: None, 
      templateClasses: None, 
      classStaticWriters: None, 
      localVariables: None, 
      localVarNames: Vec::new(), 
      contextFlags: None, 
      settings: None, 
      compilerFlags: None, 
      compilerSettings: None, 
      parserErrors: Vec::new(), 
      compilerErrors: Vec::new(), 
      compilerMessages: Vec::new(), 
      compilerLog: None, 
      todoList: Vec::new(), 
      definedMacro: None, 
      defCounts: None, 
      refTransform: None, 
      staticClassBodies: Vec::new(), 
      pluginSpecificOperators: None, 
      viewClassBody: None, 
      appPages: None, 
      appServices: None, 
      opNs: Vec::new(), 
      langFilePath:"".to_string(), 
      libraryPaths: Vec::new(), 
      outputPath:"".to_string(), 
      counters:TypeCounts::new(), 
      parser: None, 
      compiler: None, 
      pluginNodes: None, 
      typedNodes: None, 
      registered_plugins: Vec::new(), 
      operatorFunction: None, 
      lastBlockOp: None, 
      opFnsList: None, 
      test_compile: Vec::new(), 
      activeTransaction: Vec::new(), 
      transactions: Vec::new(), 
      env: None, 
      rust_moved_vars: None, 
      rust_usage_count: None, 
      rust_temp_counter:0, 
      rootFile:"--not-defined--".to_string(), 
    };
    return me;
  }
  fn rustMarkMoved(&mut self, varName : String) -> () {
    self.rust_moved_vars.insert(varName, true);
  }
  fn rustIsMoved(&mut self, varName : String) -> bool {
    if  self.rust_moved_vars.contains_key(&varName) {
      return (self.rust_moved_vars.get(varName)).unwrap();
    }
    if  self.parent.is_some() {
      return self.self.parent.rustIsMoved(varName.clone());
    }
    return false;
  }
  fn rustClearMoved(&mut self, varName : String) -> () {
    self.rust_moved_vars.insert(varName, false);
  }
  fn rustIncUsage(&mut self, varName : String) -> () {
    if  self.rust_usage_count.contains_key(&varName) {
      let cnt : i64 = (self.rust_usage_count.get(varName)).unwrap();
      self.rust_usage_count.insert(varName, cnt + 1);
    } else {
      self.rust_usage_count.insert(varName, 1);
    }
  }
  fn rustGetUsageCount(&mut self, varName : String) -> i64 {
    if  self.rust_usage_count.contains_key(&varName) {
      return (self.rust_usage_count.get(varName)).unwrap();
    }
    if  self.parent.is_some() {
      return self.self.parent.rustGetUsageCount(varName.clone());
    }
    return 0;
  }
  fn rustNeedsClone(&mut self, varName : String) -> bool {
    if  self.rustIsMoved(varName.clone()) {
      return true;
    }
    if  self.rustGetUsageCount(varName.clone()) > 0 {
      return true;
    }
    return false;
  }
  fn rustGetTempVar(&mut self, ) -> String {
    self.rust_temp_counter = self.rust_temp_counter + 1;
    return ["_tmp_".to_string() , (self.rust_temp_counter.to_string()) ].join("").clone();
  }
  fn getEnv(&mut self, ) -> Option<InputEnv> {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.env.clone();
  }
  fn setTestCompile(&mut self, ) -> () {
    self.test_compile.push(true);
  }
  fn unsetTestCompile(&mut self, ) -> () {
    self.test_compile.pop();
  }
  fn isTestCompile(&mut self, ) -> bool {
    if  ((self.test_compile.len() as i64)) > 0 {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.isTestCompile();
    }
    return false;
  }
  fn addOpFn(&mut self, name : String, mut code : CodeNode) -> () {
    if  false == (self.opFnsList.contains_key(&name)) {
      self.opFnsList.insert(name, CodeNode::expressionNode());
    }
    let mut rootNode : CodeNode = (self.opFnsList.get(name)).unwrap();
    rootNode.children.push(code.clone());
  }
  fn getOpFns(&mut self, name : String) -> Vec<CodeNode> {
    let mut rv : Vec<CodeNode> = Vec::new();
    if  self.opFnsList.contains_key(&name) {
      let mut ol : CodeNode = (self.opFnsList.get(name)).unwrap();
      operatorsOf::forEach_15(ol.children, (item, index) => { 
        let mut tmp : CodeNode = item;
        rv.push(tmp.clone());
      }
      );
    }
    if  self.parent.is_some() {
      let mut list2 : Vec<CodeNode> = self.parent.getOpFns(name.clone());
      operatorsOf::forEach_15(list2, (item, index) => { 
        let mut tmp_1 : CodeNode = item;
        rv.push(tmp_1.clone());
      }
      );
    }
    return rv;
  }
  fn getLastBlockOp(&mut self, ) -> Option<CodeNode> {
    if  self.isTestCompile() {
      let mut cn : Option<CodeNode> = None;
      cn = Some(CodeNode::expressionNode());
      return cn.clone();
    }
    if  self.lastBlockOp.is_some() {
      return self.lastBlockOp.clone();
    }
    if  self.parent.is_some() {
      return self.parent.getLastBlockOp().clone();
    }
    return self.lastBlockOp.clone();
  }
  fn removePluginOp(&mut self, name : String) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.pluginSpecificOperators.insert(name, false);
  }
  fn isPluginOp(&mut self, mut node : CodeNode) -> bool {
    if  ((node.children.len() as i64)) > 0 {
      let mut fc : CodeNode = node.getFirst();
      if  ((fc.ns.len() as i64)) > 0 {
        let firstNS : String = fc.ns[0 as usize].clone();
        let mut root : RangerAppWriterContext = self.getRoot();
        if  root.pluginSpecificOperators.contains_key(&firstNS) {
          return (root.pluginSpecificOperators.get(firstNS)).unwrap();
        }
      }
    }
    return false;
  }
  fn addPlugin(&mut self, mut p : RangerRegisteredPlugin) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.registered_plugins.push(p.clone());
  }
  fn findPluginsFor(&mut self, featureName : String) -> Vec<String> {
    let mut res : Vec<String> = Vec::new();
    for i in 0..self.registered_plugins.len() {
      let mut p = self.registered_plugins[i as usize].clone();
      if  (p.features.iter().position( |&r| r == featureName ).unwrap()) >= 0 {
        res.push(p.name);
      }
    }
    return res;
  }
  fn addTypeClass(&mut self, name : String) -> RangerTypeClass {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  false == (root.typeClasses.contains_key(&name)) {
      let mut newClass : RangerTypeClass = RangerTypeClass::new();
      root.typeClasses.insert(name, newClass);
      return newClass.clone();
    }
    return (root.typeClasses.get(name)).unwrap().clone();
  }
  fn getTypeClass(&mut self, name : String) -> Option<RangerTypeClass> {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.typeClasses.get(name).clone();
  }
  fn getParser(&mut self, ) -> Option<RangerFlowParser> {
    if  self.parser.is_none() {
      if  self.parent.is_some() {
        return self.self.parent.getParser().clone();
      }
    }
    return self.parser.clone();
  }
  fn getCompiler(&mut self, ) -> Option<LiveCompiler> {
    if  self.compiler.is_none() {
      if  self.parent.is_some() {
        return self.self.parent.getCompiler().clone();
      }
    }
    return self.compiler.clone();
  }
  fn getTypedNodes(&mut self, name : String) -> Vec<CodeNode> {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut res : Vec<CodeNode> = Vec::new();
    let mut list : Option<RangerNodeList> = root.typedNodes.get(name);
    if  list.is_some() {
      operatorsOf::forEach_15(list.items, (item, index) => { 
        let mut tmp : CodeNode = item;
        res.push(tmp.clone());
      }
      );
    }
    return res;
  }
  fn addTypedNode(&mut self, name : String, mut op : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  root.typedNodes.contains_key(&name) {
      let mut orig_list : RangerNodeList = (root.typedNodes.get(name)).unwrap();
      orig_list.items.push(op.clone());
    } else {
      let mut new_list : RangerNodeList = RangerNodeList::new();
      new_list.items.push(op.clone());
      root.typedNodes.insert(name, new_list);
    }
  }
  fn getPluginNodes(&mut self, name : String) -> Vec<CodeNode> {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut res : Vec<CodeNode> = Vec::new();
    let mut list : Option<RangerNodeList> = root.pluginNodes.get(name);
    if  list.is_some() {
      operatorsOf::forEach_15(list.items, (item, index) => { 
        let mut tmp : CodeNode = item;
        res.push(tmp.clone());
      }
      );
    }
    return res;
  }
  fn addPluginNode(&mut self, name : String, mut op : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  root.pluginNodes.contains_key(&name) {
      let mut orig_list : RangerNodeList = (root.pluginNodes.get(name)).unwrap();
      orig_list.items.push(op.clone());
    } else {
      let mut new_list : RangerNodeList = RangerNodeList::new();
      new_list.items.push(op.clone());
      root.pluginNodes.insert(name, new_list);
    }
  }
  fn addOperator(&mut self, mut op : RangerAppOperatorDesc) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  (op.name.len() as i64) > 0 {
      if  root.op_list.contains_key(&op.name) {
        let mut orig_list : RangerOperatorList = (root.op_list.get(op.name)).unwrap();
        orig_list.items.push(op.clone());
      } else {
        let mut new_list : RangerOperatorList = RangerOperatorList::new();
        new_list.items.push(op.clone());
        root.op_list.insert(op.name, new_list);
      }
    }
  }
  fn getAllOperators(&mut self, ) -> Vec<RangerAppOperatorDesc> {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut res : Vec<RangerAppOperatorDesc> = Vec::new();
    operatorsOf_13::forEach_16(root.op_list, (item, index) => { 
      operatorsOf::forEach_17(item.items, (item, index) => { 
        let mut tmp : RangerAppOperatorDesc = item;
        res.push(tmp.clone());
      }
      );
    }
    );
    return res;
  }
  fn getOperatorsOf(&mut self, name : String) -> Vec<RangerAppOperatorDesc> {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut res : Vec<RangerAppOperatorDesc> = Vec::new();
    let mut list : Option<RangerOperatorList> = root.op_list.get(name);
    if  list.is_some() {
      return operatorsOf::clone_18(list.items);
    }
    return res;
  }
  fn initOpList(&mut self, ) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  root.operators.is_some() {
      let mut op : RangerActiveOperators = root.operators.clone().unwrap();
      op.initializeOpCache();
      let mut foo : Vec<CodeNode> = op.getOperators("+".to_string());
      if  ((foo.len() as i64)) > 0 {
        operatorsOf_13::forEach_19(op.opHash, (item, index) => { 
          let op_name : String = index;
          operatorsOf::forEach_15(item.list, (item, index) => { 
            /** unused:  let mut fc : CodeNode = item.getFirst();   **/ 
            let mut nameNode : CodeNode = item.getSecond();
            let mut args : CodeNode = item.getThird();
            let mut newOp : RangerAppOperatorDesc = RangerAppOperatorDesc::new();
            newOp.name = op_name.clone();
            newOp.node = Some(item.clone());
            newOp.nameNode = Some(nameNode.clone());
            newOp.op_params = args.children.clone();
            if  ((args.children.len() as i64)) > 0 {
              newOp.firstArg = Some(args.children[0 as usize].clone());
            }
            self.addOperator(newOp.clone());
          }
          );
        }
        );
      }
    } else {
    }
  }
  fn incLambdaCnt(&mut self, ) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.counters.interface_cnt = root.counters.interface_cnt + 1;
  }
  fn createNewRegName(&mut self, ) -> String {
    let mut root : RangerAppWriterContext = self.findFunctionCtx();
    root.counters.register_cnt = root.counters.register_cnt + 1;
    return ["__REGx".to_string() , (root.counters.register_cnt.to_string()) ].join("").clone();
  }
  fn createNewOpFnName(&mut self, ) -> String {
    let mut root : RangerAppWriterContext = self.findFunctionCtx();
    root.counters.opfn_cnt = root.counters.opfn_cnt + 1;
    return ["__tmpOpFn".to_string() , (root.counters.opfn_cnt.to_string()) ].join("").clone();
  }
  fn isTryBlock(&mut self, ) -> bool {
    if  self.expr_restart {
      return false;
    }
    if  self.is_try_block {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.isTryBlock();
    }
    return false;
  }
  fn isCatchBlock(&mut self, ) -> bool {
    if  self.expr_restart {
      return false;
    }
    if  self.is_catch_block {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.isCatchBlock();
    }
    return false;
  }
  fn pushAndCollectAst(&mut self, mut rootNode : CodeNode, mut wr : CodeWriter) -> () {
    let mut myParser : RangerFlowParser = RangerFlowParser::new();
    myParser.CollectMethods(rootNode.clone(), self.clone(), wr.clone());
  }
  fn pushAndCompileAst(&mut self, mut rootNode : CodeNode, mut wr : CodeWriter) -> () {
    let mut myParser : RangerFlowParser = RangerFlowParser::new();
    myParser.CollectMethods(rootNode.clone(), self.clone(), wr.clone());
    myParser.StartWalk(rootNode.clone(), self.clone(), wr.clone());
  }
  fn pushAst(&mut self, source_code : String, mut node : CodeNode, mut wr : CodeWriter) -> () {
    let mut code : SourceCode = SourceCode::new(source_code.clone());
    code.filename = "dynamically_generated".to_string();
    let mut parser_1 : RangerLispParser = RangerLispParser::new(code.clone());
    parser_1.parse(self.hasCompilerFlag("no-op-transform".to_string()));
    if parser_1.rootNode.is_some() {
      let mut root : CodeNode = parser_1.rootNode.clone().unwrap();
      node.children.push(root.clone());
    }
  }
  fn pushAndCollectCode(&mut self, source_code : String, mut wr : CodeWriter) -> () {
    let mut code : SourceCode = SourceCode::new(source_code.clone());
    code.filename = "dynamically_generated".to_string();
    let mut parser_1 : RangerLispParser = RangerLispParser::new(code.clone());
    parser_1.parse(self.hasCompilerFlag("no-op-transform".to_string()));
    if parser_1.rootNode.is_some() {
      let mut root : CodeNode = parser_1.rootNode.clone().unwrap();
      let mut myParser : RangerFlowParser = RangerFlowParser::new();
      let mut rootCtx : RangerAppWriterContext = self.getRoot();
      myParser.CollectMethods(root.clone(), rootCtx.clone(), wr.clone());
    }
  }
  fn pushCode(&mut self, source_code : String, mut wr : CodeWriter) -> () {
    let mut code : SourceCode = SourceCode::new(source_code.clone());
    code.filename = "dynamically_generated".to_string();
    let mut parser_1 : RangerLispParser = RangerLispParser::new(code.clone());
    parser_1.parse(self.hasCompilerFlag("no-op-transform".to_string()));
    if parser_1.rootNode.is_some() {
      let mut root : CodeNode = parser_1.rootNode.clone().unwrap();
      let mut myParser : RangerFlowParser = RangerFlowParser::new();
      let mut rootCtx : RangerAppWriterContext = self.getRoot();
      myParser.CollectMethods(root.clone(), rootCtx.clone(), wr.clone());
      myParser.StartWalk(root.clone(), rootCtx.clone(), wr.clone());
    }
  }
  fn addViewClassBody(&mut self, name : String, mut classDef : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.viewClassBody.insert(name, classDef);
  }
  fn addPage(&mut self, name : String, mut classDef : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.appPages.insert(name, classDef);
  }
  fn addService(&mut self, name : String, mut classDef : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.appServices.insert(name, classDef);
  }
  fn getViewClass(&mut self, s_name : String) -> Option<CodeNode> {
    let mut res : Option<CodeNode> = None;
    if  self.viewClassBody.contains_key(&s_name) {
      res = Some(self.viewClassBody.get(s_name));
      return res.clone();
    }
    if  self.parent.is_none() {
      return res.clone();
    }
    return self.self.parent.getViewClass(s_name.clone()).clone();
  }
  fn addOpNs(&mut self, n : String) -> () {
    self.opNs.push(n);
  }
  fn removeOpNs(&mut self, n : String) -> () {
    let idx : i64 = self.opNs.iter().position( |&r| r == n ).unwrap();
    if  idx >= 0 {
      self.opNs.splice(idx, 1).pop();
    }
  }
  fn inLambda(&mut self, ) -> bool {
    if  self.is_lambda {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.inLambda();
    }
    return false;
  }
  fn variableTypeUsage(&mut self, ) -> Vec<String> {
    let mut res : HashMap<String,bool> = HashMap::new();
    let mut cc : Option<Box<RangerAppWriterContext>> = self;
    while cc.is_some() {
      operatorsOf_13::forEach_20(cc.localVariables, (item, index) => { 
        if  item.nameNode.is_some() {
          res.insert(item.nameNode.type_name, true);
          res.insert(item.nameNode.key_type, true);
          res.insert(item.nameNode.array_type, true);
        }
      }
      );
      cc = cc.parent.clone();
    }
    return keysres;
  }
  fn writeContextVars(&mut self, mut wr : CodeWriter) -> () {
    operatorsOf_13::forEach_20(self.localVariables, (item, index) => { 
      wr.out(format!("{}{}", (format!("{}{}", "def ".to_string(), index)), ":".to_string()), false);
      if  item.nameNode.is_some() {
        let mut r : RangerRangerClassWriter = RangerRangerClassWriter::new();
        r.writeTypeDef(item.nameNode.clone().unwrap(), self.clone(), wr.clone());
      }
      wr.out(format!("{}{}", (format!("{}{}", "(".to_string(), item.compiledName)), ")".to_string()), false);
      wr.out("".to_string(), true);
    }
    );
  }
  fn writeContextInfo(&mut self, mut wr : CodeWriter) -> () {
    let mut cList : Vec<RangerAppWriterContext> = Vec::new();
    let mut c : RangerAppWriterContext = self;
    cList.push(c.clone());
    while c.parent.is_some() {
      c = (*c.parent.clone().unwrap());
      cList.push(c.clone());
    }
    let mut idx : i64 = (cList.len() as i64);
    let mut cnt : i64 = idx;
    while idx > 0 {
      idx = idx - 1;
      wr.out("{".to_string(), true);
      wr.indent(1);
      let mut cc : RangerAppWriterContext = cList[idx as usize].clone();
      cc.writeContextVars(wr.clone());
    }
    while cnt > 0 {
      wr.indent(-1);
      wr.out("}".to_string(), true);
      cnt = cnt - 1;
    }
  }
  fn getContextInfo(&mut self, ) -> String {
    let mut wr : CodeWriter = CodeWriter::new();
    self.writeContextInfo(wr.clone());
    return wr.getCode().clone();
  }
  fn isCapturing(&mut self, ) -> bool {
    if  self.is_capturing {
      return true;
    }
    if self.parent.is_some() {
      return self.self.parent.isCapturing();
    }
    return false;
  }
  fn forkWithOps(&mut self, mut opNode : CodeNode) -> RangerAppWriterContext {
    let mut ops : RangerActiveOperators = self.getOperatorDef();
    let mut new_ops : RangerActiveOperators = ops.fork(opNode.clone());
    let mut new_ctx : RangerAppWriterContext = self.fork();
    new_ctx.operators = Some(new_ops.clone());
    return new_ctx.clone();
  }
  fn getOperatorDef(&mut self, ) -> RangerActiveOperators {
    if  self.operators.is_some() {
      return self.operators.clone().unwrap().clone();
    }
    if  self.parent.is_some() {
      return self.self.parent.getOperatorDef().clone();
    }
    let mut nothingFound : RangerActiveOperators = RangerActiveOperators::new();
    return nothingFound.clone();
  }
  fn getOperators(&mut self, name : String) -> Vec<CodeNode> {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut cc : RangerAppWriterContext = self;
    let mut opNamespace : Vec<String> = Vec::new();
    if  ((self.opNs.len() as i64)) > 0 {
      for i in 0..self.opNs.len() {
        let mut nsName = self.opNs[i as usize].clone();
        opNamespace.push(nsName);
      }
    }
    while cc.parent.is_some() {
      cc = (*cc.parent.clone().unwrap());
      if  ((cc.opNs.len() as i64)) > 0 {
        for i_1 in 0..cc.opNs.len() {
          let mut nsName_1 = cc.opNs[i_1 as usize].clone();
          opNamespace.push(nsName_1);
        }
      }
    }
    if  root.operators.is_some() {
      let mut op : RangerActiveOperators = root.operators.clone().unwrap();
      let mut listOfOps : Vec<CodeNode> = Vec::new();
      let mut handled : HashMap<String,bool> = HashMap::new();
      for i_2 in 0..opNamespace.len() {
        let mut ss = opNamespace[i_2 as usize].clone();
        if  handled.contains_key(&ss) {
          continue;
        }
        handled.insert(ss, true);
        let mut nsOps : Vec<CodeNode> = op.getOperators((format!("{}{}", (format!("{}{}", ss, ".".to_string())), name)));
        for i_3 in 0..nsOps.len() {
          let mut ns_op = nsOps[i_3 as usize].clone();
          listOfOps.push(ns_op.clone());
        }
      }
      let mut plainOps : Vec<CodeNode> = op.getOperators(name.clone());
      for i_4 in 0..plainOps.len() {
        let mut ppn = plainOps[i_4 as usize].clone();
        listOfOps.push(ppn.clone());
      }
      return listOfOps;
    }
    let mut nothingFound : Vec<CodeNode> = Vec::new();
    return nothingFound;
  }
  fn isLocalToCapture(&mut self, name : String) -> bool {
    if  self.localVariables.contains_key(&name) {
      return true;
    }
    if  self.is_capturing {
      return false;
    }
    if self.parent.is_some() {
      return self.self.parent.isLocalToCapture(name.clone());
    }
    return false;
  }
  fn addCapturedVariable(&mut self, name : String) -> () {
    if  self.is_capturing {
      if  (self.captured_variables.iter().position( |&r| r == name ).unwrap()) < 0 {
        self.captured_variables.push(name);
      }
      return;
    }
    if self.parent.is_some() {
      self.self.parent.addCapturedVariable(name.clone());
    }
  }
  fn getCapturedVariables(&mut self, ) -> Vec<String> {
    if  self.is_capturing {
      return self.captured_variables;
    }
    if self.parent.is_some() {
      let mut r : Vec<String> = self.self.parent.getCapturedVariables();
      return r;
    }
    let mut res : Vec<String> = Vec::new();
    return res;
  }
  fn transformOpNameWord(&mut self, input_word : String) -> String {
    let __len : i64 = input_word.len() as i64;
    let mut i : i64 = 0;
    let mut res : String = "".to_string();
    while i < __len {
      let cc : i64 = input_word.chars().nth(i as usize).unwrap_or('\0') as i64;
      if  ((cc >= (97)) && (cc <= (122))) || ((cc >= (65)) && (cc <= (89))) {
        res = format!("{}{}", res, (String.fromCharCode(cc)));
      } else {
        res = [(format!("{}{}", res, "c".to_string())) , (cc.to_string()) ].join("");
      }
      i = i + 1;
    }
    return res.clone();
  }
  fn transformWord(&mut self, input_word : String) -> String {
    switch (input_word ) { 
      case "map".to_string() : 
        return "_map".to_string().clone();
        break;
      default: 
        break;
    }
    let mut root : RangerAppWriterContext = self.getRoot();
    root.initReservedWords();
    if  root.refTransform.contains_key(&input_word) {
      return (root.refTransform.get(input_word)).unwrap().clone();
    }
    return input_word.clone();
  }
  fn initReservedWords(&mut self, ) -> bool {
    if  self.reservedWords.is_some() {
      return true;
    }
    let mut main : Option<CodeNode> = self.langOperators;
    let mut lang : Option<CodeNode> = None;
    for i in 0..main.children.len() {
      let mut m = main.children[i as usize].clone();
      let mut fc : CodeNode = m.getFirst();
      if  fc.vref == "language".to_string() {
        lang = Some(m.clone());
      }
    }
    /** unused:  let mut cmds : Option<CodeNode> = None;   **/ 
    let mut langNodes : CodeNode = lang.children[1 as usize].clone();
    let targetLang : String = operatorsOfRangerAppWriterContext_21::getTargetLang_22(self.clone());
    for i_1 in 0..langNodes.children.len() {
      let mut lch = langNodes.children[i_1 as usize].clone();
      let mut fc_1 : CodeNode = lch.getFirst();
      if  fc_1.vref == "reserved_words".to_string() {
        /** unused:  let mut n : CodeNode = lch.getSecond();   **/ 
        self.reservedWords = Some(lch.getSecond());
        for i_2 in 0..self.reservedWords.children.len() {
          let mut langBlock = self.reservedWords.children[i_2 as usize].clone();
          let mut langKey : CodeNode = langBlock.getFirst();
          let langKeyName : String = langKey.vref.clone();
          if  (langKeyName == "*".to_string()) || (langKeyName == targetLang) {
            let mut wordsNode : CodeNode = langBlock.getSecond();
            for i_3 in 0..wordsNode.children.len() {
              let mut ch = wordsNode.children[i_3 as usize].clone();
              let mut word : CodeNode = ch.getFirst();
              let mut transform : CodeNode = ch.getSecond();
              self.refTransform.insert(word.vref, transform.vref);
            }
          }
        }
      }
    }
    return true;
  }
  fn initStdCommands(&mut self, ) -> bool {
    if  self.stdCommands.is_some() {
      return true;
    }
    if  self.langOperators.is_none() {
      return true;
    }
    let mut main : Option<CodeNode> = self.langOperators;
    let mut lang : Option<CodeNode> = None;
    for i in 0..main.children.len() {
      let mut m = main.children[i as usize].clone();
      let mut fc : CodeNode = m.getFirst();
      if  fc.vref == "language".to_string() {
        lang = Some(m.clone());
      }
    }
    /** unused:  let mut cmds : Option<CodeNode> = None;   **/ 
    let mut langNodes : CodeNode = lang.children[1 as usize].clone();
    for i_1 in 0..langNodes.children.len() {
      let mut lch = langNodes.children[i_1 as usize].clone();
      let mut fc_1 : CodeNode = lch.getFirst();
      if  fc_1.vref == "commands".to_string() {
        /** unused:  let mut n : CodeNode = lch.getSecond();   **/ 
        self.stdCommands = Some(lch.getSecond());
      }
    }
    return true;
  }
  fn transformTypeName(&mut self, typeName : String) -> String {
    if  self.isPrimitiveType(typeName.clone()) {
      return typeName.clone();
    }
    if  self.isEnumDefined(typeName.clone()) {
      return typeName.clone();
    }
    if  self.isDefinedClass(typeName.clone()) {
      let mut cl : RangerAppClassDesc = self.findClass(typeName.clone());
      if  cl.is_system {
        return (cl.systemNames.get(operatorsOf_21::getTargetLang_22(self.clone()))).unwrap().clone();
      }
    }
    return typeName.clone();
  }
  fn isPrimitiveType(&mut self, typeName : String) -> bool {
    if  (((((typeName == "double".to_string()) || (typeName == "string".to_string())) || (typeName == "int".to_string())) || (typeName == "char".to_string())) || (typeName == "charbuffer".to_string())) || (typeName == "boolean".to_string()) {
      return true;
    }
    return false;
  }
  fn isDefinedType(&mut self, typeName : String) -> bool {
    if  typeName == "Any".to_string() {
      return true;
    }
    if  (((((typeName == "double".to_string()) || (typeName == "string".to_string())) || (typeName == "int".to_string())) || (typeName == "char".to_string())) || (typeName == "charbuffer".to_string())) || (typeName == "boolean".to_string()) {
      return true;
    }
    if  self.isEnumDefined(typeName.clone()) {
      return true;
    }
    if  self.isDefinedClass(typeName.clone()) {
      return true;
    }
    return false;
  }
  fn hadValidType(&mut self, mut node : CodeNode) -> bool {
    if  node.isPrimitiveType() || node.isPrimitive() {
      return true;
    }
    if  node.value_type == 6 {
      if  self.isDefinedType(node.array_type.clone()) {
        return true;
      } else {
        self.addError(node.clone(), format!("{}{}", "Unknown type for array values: ".to_string(), node.array_type));
        return false;
      }
    }
    if  node.value_type == 7 {
      if  self.isDefinedType(node.array_type.clone()) && self.isPrimitiveType(node.key_type.clone()) {
        return true;
      } else {
        if  self.isDefinedType(node.array_type.clone()) == false {
          self.addError(node.clone(), format!("{}{}", "Unknown type for map values: ".to_string(), node.array_type));
        }
        if  self.isDefinedType(node.key_type.clone()) == false {
          self.addError(node.clone(), format!("{}{}", "Unknown type for map keys: ".to_string(), node.key_type));
        }
        return false;
      }
    }
    if  self.isEnumDefined(node.type_name.clone()) {
      return true;
    }
    if  self.isDefinedType(node.type_name.clone()) {
      return true;
    } else {
      if  node.value_type == 17 {
      } else {
        self.addError(node.clone(), [(format!("{}{}", (format!("{}{}", "Unknown type: ".to_string(), node.type_name)), " type ID : ".to_string())) , (node.value_type.to_string()) ].join(""));
      }
    }
    return false;
  }
  fn findOperator(&mut self, mut node : CodeNode) -> CodeNode {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.initStdCommands();
    if  node.operator_node.is_some() {
      return (*node.operator_node.clone().unwrap()).clone();
    }
    return root.stdCommands.children[node.op_index as usize].clone().clone();
  }
  fn getStdCommands(&mut self, ) -> CodeNode {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.initStdCommands();
    return root.stdCommands.clone().unwrap().clone();
  }
  fn findOperatorsWithName(&mut self, name : String) -> Vec<CodeNode> {
    let mut res : Vec<CodeNode> = Vec::new();
    operatorsOf::forEach_15((self.getStdCommands()).children, (item, index) => { 
      if  item.isFirstVref(name.clone()) {
        res.push(item.clone());
      }
    }
    );
    return res;
  }
  fn findClassWithSign(&mut self, mut node : CodeNode) -> RangerAppClassDesc {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut tplArgs : Option<CodeNode> = node.vref_annotation;
    let sign : String = format!("{}{}", node.vref, tplArgs.getCode());
    let theName : Option<String> = root.classSignatures.get(sign);
    return self.findClass((theName.unwrap())).clone();
  }
  fn createSignature(&mut self, origClass : String, classSig : String) -> String {
    if  self.classSignatures.contains_key(&classSig) {
      return (self.classSignatures.get(classSig)).unwrap().clone();
    }
    let mut ii : i64 = 1;
    let mut sigName : String = [(format!("{}{}", origClass, "V".to_string())) , (ii.to_string()) ].join("");
    while self.classToSignature.contains_key(&sigName) {
      ii = ii + 1;
      sigName = [(format!("{}{}", origClass, "V".to_string())) , (ii.to_string()) ].join("");
    }
    self.classToSignature.insert(sigName, classSig);
    self.classSignatures.insert(classSig, sigName);
    return sigName.clone();
  }
  fn createStaticMethod(&mut self, withName : String, mut currC : RangerAppClassDesc, mut nameNode : CodeNode, mut argsNode : CodeNode, mut fnBody : CodeNode, mut parser : RangerFlowParser, mut wr : CodeWriter) -> RangerAppFunctionDesc {
    let s : String = withName;
    let mut m : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
    m.name = s.clone();
    m.compiledName = self.transformWord(s.clone());
    m.node = Some(nameNode.clone());
    m.nameNode = Some(nameNode.clone());
    let mut rCtx : RangerAppWriterContext = self.getRoot();
    m.fnCtx = Some(rCtx.fork());
    m.is_static = true;
    m.nameNode.ifNoTypeSetToVoid();
    let mut args : CodeNode = argsNode;
    m.fnBody = Some(fnBody.clone());
    parser.CheckTypeAnnotationOf(m.nameNode.clone().unwrap(), rCtx.clone(), wr.clone());
    for ii in 0..args.children.len() {
      let mut arg = args.children[ii as usize].clone();
      if  arg.hasFlag("noeval".to_string()) {
        continue;
      }
      let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
      p.name = arg.vref.clone();
      if  p.name == "self".to_string() {
        p.compiledName = "__self".to_string();
      }
      p.value_type = arg.value_type;
      p.node = Some(arg.clone());
      p.init_cnt = 1;
      p.nameNode = Some(arg.clone());
      parser.CheckTypeAnnotationOf(arg.clone(), rCtx.clone(), wr.clone());
      p.refType = 1;
      p.varType = 4;
      m.params.push(p.clone());
      arg.hasParamDesc = true;
      arg.paramDesc = Some(p.clone());
      arg.eval_type = arg.value_type;
      arg.eval_type_name = arg.type_name.clone();
      if  arg.hasFlag("strong".to_string()) {
        p.changeStrength(1, 1, p.nameNode.clone().unwrap());
      } else {
        arg.setFlag("lives".to_string());
        p.changeStrength(0, 1, p.nameNode.clone().unwrap());
      }
    }
    currC.addStaticMethod(m.clone());
    return m.clone();
  }
  fn canUseTypeInference(&mut self, mut nameNode : CodeNode) -> bool {
    let b_allow_ti : bool = self.hasCompilerFlag("allowti".to_string());
    let mut b_multitype : bool = false;
    if  b_allow_ti {
      let mut t_name : String = nameNode.type_name;
      if  (nameNode.eval_type_name.len() as i64) > 0 {
        t_name = nameNode.eval_type_name.clone();
      }
      if  self.isDefinedClass(t_name.clone()) {
        let mut cc : RangerAppClassDesc = self.findClass(t_name.clone());
        b_multitype = ((((cc.is_union || cc.is_system) || cc.is_system_union) || cc.is_trait) || cc.is_inherited) || (((cc.extends_classes.len() as i64)) > 0);
      }
    }
    return b_allow_ti && (false == b_multitype);
  }
  fn createOpStaticClass(&mut self, name : String) -> RangerAppClassDesc {
    let nameWillBe : String = format!("{}{}", "operatorsOf".to_string(), name);
    let mut str : String = "".to_string();
    let mut i : i64 = 0;
    let __len : i64 = nameWillBe.len() as i64;
    while i < __len {
      let c : i64 = nameWillBe.chars().nth(i as usize).unwrap_or('\0') as i64;
      if  c == (".".to_string().charCodeAt(0)) {
        str = format!("{}{}", str, "_".to_string());
      } else {
        str = format!("{}{}", str, (nameWillBe.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>()));
      }
      i = i + 1;
    }
    if  self.isDefinedClass(str.clone()) {
      return self.findClass(str.clone()).clone();
    }
    let tpl_code : String = format!("{}{}", (format!("{}{}", "class ".to_string(), str)), " {\r\n}".to_string());
    let mut code : SourceCode = SourceCode::new(tpl_code.clone());
    code.filename = format!("{}{}", str, ".ranger".to_string());
    let mut parser_1 : RangerLispParser = RangerLispParser::new(code.clone());
    parser_1.parse(false);
    let mut classRoot : CodeNode = parser_1.rootNode.children[0 as usize].clone();
    let mut classNameNode : CodeNode = classRoot.getSecond();
    classNameNode.vref = str.clone();
    let mut new_class : RangerAppClassDesc = RangerAppClassDesc::new();
    new_class.name = str.clone();
    new_class.compiledName = str.clone();
    new_class.is_operator_class = true;
    new_class.nameNode = Some(classNameNode.clone());
    new_class.classNode = Some(classRoot.clone());
    let mut subCtx : RangerAppWriterContext = self.fork();
    subCtx.setCurrentClass(new_class.clone());
    new_class.ctx = Some(subCtx.clone());
    let mut root : RangerAppWriterContext = self.getRoot();
    root.addClass(str.clone(), new_class.clone());
    classNameNode.clDesc = Some(new_class.clone());
    self.staticClassBodies.push(classRoot.clone());
    return new_class.clone();
  }
  fn createTraitInstanceClass(&mut self, traitName : String, instanceName : String, mut initParams : CodeNode, mut flowParser : RangerFlowParser, mut wr : CodeWriter) -> Option<RangerAppClassDesc> {
    let mut res : Option<RangerAppClassDesc> = None;
    let mut ctx : RangerAppWriterContext = self.fork();
    if  self.isDefinedClass(instanceName.clone()) {
      return res.clone();
    }
    if  self.isDefinedClass(traitName.clone()) == false {
      self.addError(initParams.clone(), format!("{}{}", "Could not find the trait ".to_string(), traitName));
      return res.clone();
    }
    let tpl_code : String = format!("{}{}", (format!("{}{}", "class ".to_string(), instanceName)), " {\r\n}".to_string());
    let mut code : SourceCode = SourceCode::new(tpl_code.clone());
    code.filename = format!("{}{}", instanceName, ".ranger".to_string());
    let mut parser_1 : RangerLispParser = RangerLispParser::new(code.clone());
    parser_1.parse(false);
    let mut classRoot : CodeNode = parser_1.rootNode.children[0 as usize].clone();
    let mut classNameNode : CodeNode = classRoot.getSecond();
    classNameNode.vref = instanceName.clone();
    let mut new_class : RangerAppClassDesc = RangerAppClassDesc::new();
    new_class.name = instanceName.clone();
    new_class.compiledName = instanceName.clone();
    new_class.nameNode = Some(classNameNode.clone());
    new_class.node = Some(classRoot.clone());
    new_class.classNode = Some(classRoot.clone());
    new_class.is_generic_instance = true;
    new_class.consumes_traits.push(traitName);
    let mut root : RangerAppWriterContext = self.getRoot();
    new_class.ctx = Some(root.fork());
    root.addClass(instanceName.clone(), new_class.clone());
    classNameNode.clDesc = Some(new_class.clone());
    let mut cl : RangerAppClassDesc = new_class;
    let mut t : RangerAppClassDesc = self.findClass(traitName.clone());
    let mut traitClassDef : CodeNode = t.node.clone().unwrap();
    let name : String = t.name.clone();
    let mut t_2 : RangerAppClassDesc = ctx.findClass(name.clone());
    if  ((t_2.extends_classes.len() as i64)) > 0 {
      ctx.addError(traitClassDef.clone(), format!("{}{}", (format!("{}{}", "Can not join trait ".to_string(), name)), " because it is inherited. Currently on base classes can be used as traits.".to_string()));
      return res.clone();
    }
    if  t_2.has_constructor {
      ctx.addError(traitClassDef.clone(), format!("{}{}", (format!("{}{}", "Can not join trait ".to_string(), name)), " because it has a constructor function".to_string()));
    } else {
      let mut origBody : CodeNode = cl.node.children[2 as usize].clone();
      let mut match : RangerArgMatch = RangerArgMatch::new();
      let mut params : Option<CodeNode> = t_2.node.getExpressionProperty("params".to_string());
      let mut traitParams : RangerTraitParams = RangerTraitParams::new();
      if  params.is_some() {
        for i in 0..params.children.len() {
          let mut typeName = params.children[i as usize].clone();
          let mut set_value : String = "".to_string();
          if  ((initParams.children.len() as i64)) > i {
            let mut pArg : CodeNode = initParams.children[i as usize].clone();
            r#match.add(typeName.vref.clone(), pArg.vref.clone(), ctx.clone());
            set_value = pArg.vref.clone();
          } else {
            r#match.add(typeName.vref.clone(), instanceName.clone(), ctx.clone());
            set_value = instanceName.clone();
          }
          traitParams.param_names.push(typeName.vref);
          traitParams.values.insert(typeName.vref, set_value);
        }
        cl.trait_params.insert(name, traitParams);
      } else {
        r#match.add("T".to_string(), cl.name.clone(), ctx.clone());
      }
      ctx.setCurrentClass(cl.clone());
      let mut traitClass : RangerAppClassDesc = t_2;
      for i_1 in 0..traitClass.variables.len() {
        let mut pvar = traitClass.variables[i_1 as usize].clone();
        let mut ccopy : CodeNode = pvar.node.rebuildWithType(match.clone(), true);
        flowParser.WalkCollectMethods(ccopy.clone(), ctx.clone(), wr.clone());
        origBody.children.push(ccopy.clone());
      }
      for i_2 in 0..traitClass.defined_variants.len() {
        let mut fnVar = traitClass.defined_variants[i_2 as usize].clone();
        let mut mVs : Option<RangerAppMethodVariants> = traitClass.method_variants.get(fnVar);
        for i_3 in 0..mVs.variants.len() {
          let mut variant = mVs.variants[i_3 as usize].clone();
          let mut ccopy_1 : CodeNode = variant.node.rebuildWithType(match.clone(), true);
          flowParser.WalkCollectMethods(ccopy_1.clone(), ctx.clone(), wr.clone());
          origBody.children.push(ccopy_1.clone());
        }
      }
      res = Some(new_class.clone());
      /** unused:  let mut rootCtx : RangerAppWriterContext = self.getRoot();   **/ 
      flowParser.WalkNode(new_class.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    return res.clone();
  }
  fn createOperator(&mut self, mut fromNode : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  root.initStdCommands() {
      root.stdCommands.children.push(fromNode.clone());
    }
  }
  fn findClassMethod(&mut self, cname : String, fname : String) -> Option<RangerAppFunctionDesc> {
    let mut res : Option<RangerAppFunctionDesc> = None;
    if  self.isDefinedClass(cname.clone()) {
      let mut cl : RangerAppClassDesc = self.findClass(cname.clone());
      for i in 0..cl.defined_variants.len() {
        let mut fnVar = cl.defined_variants[i as usize].clone();
        if  fnVar == fname {
          let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
          for i_1 in 0..mVs.variants.len() {
            let mut variant = mVs.variants[i_1 as usize].clone();
            res = Some(variant.clone());
            return res.clone();
          }
        }
      }
    }
    return res.clone();
  }
  fn getFileWriter(&mut self, path : String, fileName : String) -> CodeWriter {
    let mut root : RangerAppWriterContext = self.getRoot();
    let mut fs : Option<CodeFileSystem> = root.fileSystem;
    let mut file : CodeFile = fs.getFile(path.clone(), fileName.clone());
    let mut wr : Option<CodeWriter> = None;
    wr = Some(file.getWriter());
    return wr.unwrap().clone();
  }
  fn addTodo(&mut self, mut node : CodeNode, descr : String) -> () {
    let mut e : RangerAppTodo = RangerAppTodo::new();
    e.description = descr.clone();
    e.todonode = Some(node.clone());
    let mut root : RangerAppWriterContext = self.getRoot();
    root.todoList.push(e.clone());
  }
  fn setThisName(&mut self, the_name : String) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.thisName = the_name.clone();
  }
  fn getThisName(&mut self, ) -> String {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.thisName.clone();
  }
  fn printLogs(&mut self, logName : String) -> () {
  }
  fn log(&mut self, mut node : CodeNode, logName : String, descr : String) -> () {
  }
  fn addMessage(&mut self, mut node : CodeNode, descr : String) -> () {
    let mut e : RangerCompilerMessage = RangerCompilerMessage::new();
    e.description = descr.clone();
    e.node = Some(node.clone());
    let mut root : RangerAppWriterContext = self.getRoot();
    root.compilerMessages.push(e.clone());
  }
  fn errCnt(&mut self, ) -> i64 {
    let mut root : RangerAppWriterContext = self.getRoot();
    return (root.compilerErrors.len() as i64);
  }
  fn addError(&mut self, mut targetnode : CodeNode, descr : String) -> () {
    let mut e : RangerCompilerMessage = RangerCompilerMessage::new();
    e.description = descr.clone();
    e.node = Some(targetnode.clone());
    let mut root : RangerAppWriterContext = self.getRoot();
    root.compilerErrors.push(e.clone());
  }
  fn addParserError(&mut self, mut targetnode : CodeNode, descr : String) -> () {
    let mut e : RangerCompilerMessage = RangerCompilerMessage::new();
    e.description = descr.clone();
    e.node = Some(targetnode.clone());
    let mut root : RangerAppWriterContext = self.getRoot();
    root.parserErrors.push(e.clone());
  }
  fn addTemplateClass(&mut self, name : String, mut node : CodeNode) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.templateClassList.push(name);
    root.templateClassNodes.insert(name, node);
  }
  fn hasTemplateNode(&mut self, name : String) -> bool {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.templateClassNodes.contains_key(&name);
  }
  fn findTemplateNode(&mut self, name : String) -> CodeNode {
    let mut root : RangerAppWriterContext = self.getRoot();
    return (root.templateClassNodes.get(name)).unwrap().clone();
  }
  fn setStaticWriter(&mut self, className : String, mut writer : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.classStaticWriters.insert(className, writer);
  }
  fn getStaticWriter(&mut self, className : String) -> CodeWriter {
    let mut root : RangerAppWriterContext = self.getRoot();
    return (root.classStaticWriters.get(className)).unwrap().clone();
  }
  fn isEnumDefined(&mut self, n : String) -> bool {
    if  self.definedEnums.contains_key(&n) {
      return true;
    }
    if  self.parent.is_none() {
      return false;
    }
    return self.self.parent.isEnumDefined(n.clone());
  }
  fn getEnum(&mut self, n : String) -> Option<RangerAppEnum> {
    let mut res : Option<RangerAppEnum> = None;
    if  self.definedEnums.contains_key(&n) {
      res = Some(self.definedEnums.get(n));
      return res.clone();
    }
    if  self.parent.is_some() {
      return self.self.parent.getEnum(n.clone()).clone();
    }
    return res.clone();
  }
  fn isVarDefined(&mut self, name : String) -> bool {
    if  self.localVariables.contains_key(&name) {
      return true;
    }
    if  self.parent.is_none() {
      return false;
    }
    return self.self.parent.isVarDefined(name.clone());
  }
  fn setFlag(&mut self, name : String, value : bool) -> () {
    self.contextFlags.insert(name, value);
  }
  fn getFlag(&mut self, name : String) -> bool {
    if  self.contextFlags.contains_key(&name) {
      return (self.contextFlags.get(name)).unwrap();
    }
    if  self.parent.is_some() {
      return self.self.parent.getFlag(name.clone());
    }
    return false;
  }
  fn setSetting(&mut self, name : String, value : String) -> () {
    self.settings.insert(name, value);
  }
  fn hasSetting(&mut self, name : String) -> bool {
    if  self.settings.contains_key(&name) {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.hasSetting(name.clone());
    }
    return false;
  }
  fn getSetting(&mut self, name : String) -> String {
    if  self.settings.contains_key(&name) {
      return (self.settings.get(name)).unwrap().clone();
    }
    if  self.parent.is_some() {
      return self.self.parent.getSetting(name.clone()).clone();
    }
    return "".to_string().clone();
  }
  fn setCompilerFlag(&mut self, name : String, value : bool) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.compilerFlags.insert(name, value);
  }
  fn hasCompilerFlag(&mut self, s_name : String) -> bool {
    if  self.compilerFlags.contains_key(&s_name) {
      return (self.compilerFlags.get(s_name)).unwrap();
    }
    if  self.parent.is_none() {
      return false;
    }
    return self.self.parent.hasCompilerFlag(s_name.clone());
  }
  fn setCompilerSetting(&mut self, name : String, value : String) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.compilerSettings.insert(name, value);
  }
  fn getCompilerSetting(&mut self, s_name : String) -> String {
    if  self.compilerSettings.contains_key(&s_name) {
      return (self.compilerSettings.get(s_name)).unwrap().clone();
    }
    if  self.parent.is_none() {
      return "".to_string().clone();
    }
    return self.self.parent.getCompilerSetting(s_name.clone()).clone();
  }
  fn hasCompilerSetting(&mut self, s_name : String) -> bool {
    if  self.compilerSettings.contains_key(&s_name) {
      return true;
    }
    if  self.parent.is_none() {
      return false;
    }
    return self.self.parent.hasCompilerSetting(s_name.clone());
  }
  fn getVariableDef(&mut self, name : String) -> RangerAppParamDesc {
    if  self.localVariables.contains_key(&name) {
      return (self.localVariables.get(name)).unwrap().clone();
    }
    if  self.parent.is_none() {
      let mut tmp : RangerAppParamDesc = RangerAppParamDesc::new();
      return tmp.clone();
    }
    return self.self.parent.getVariableDef(name.clone()).clone();
  }
  fn findFunctionCtx(&mut self, ) -> RangerAppWriterContext {
    if  self.is_function {
      return self.clone();
    }
    if  self.parent.is_none() {
      return self.clone();
    }
    return self.self.parent.findFunctionCtx().clone();
  }
  fn getFnVarCnt(&mut self, name : String) -> i64 {
    let mut fnCtx : RangerAppWriterContext = self.findFunctionCtx();
    let mut ii : i64 = 0;
    if  fnCtx.defCounts.contains_key(&name) {
      ii = (fnCtx.defCounts.get(name)).unwrap();
      ii = 1 + ii;
    } else {
      fnCtx.defCounts.insert(name, ii);
      return 0;
    }
    let mut scope_has : bool = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    while scope_has {
      ii = 1 + ii;
      scope_has = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    }
    fnCtx.defCounts.insert(name, ii);
    return ii;
  }
  fn debugVars(&mut self, ) -> () {
    println!( "{}", "--- context vars ---".to_string() );
    for i in 0..self.localVarNames.len() {
      let mut na = self.localVarNames[i as usize].clone();
      println!( "{}", format!("{}{}", "var => ".to_string(), na) );
    }
    if  self.parent.is_some() {
      self.self.parent.debugVars();
    }
  }
  fn getVarTotalCnt(&mut self, name : String) -> i64 {
    let mut fnCtx : RangerAppWriterContext = self;
    let mut ii : i64 = 0;
    if  fnCtx.defCounts.contains_key(&name) {
      ii = (fnCtx.defCounts.get(name)).unwrap();
    }
    if  fnCtx.parent.is_some() {
      ii = ii + fnCtx.parent.getVarTotalCnt(name.clone());
    }
    if  self.isVarDefined(name.clone()) {
      ii = ii + 1;
    }
    return ii;
  }
  fn getFnVarCnt2(&mut self, name : String) -> i64 {
    let mut fnCtx : RangerAppWriterContext = self;
    let mut ii : i64 = 0;
    if  fnCtx.defCounts.contains_key(&name) {
      ii = (fnCtx.defCounts.get(name)).unwrap();
      ii = 1 + ii;
      fnCtx.defCounts.insert(name, ii);
    } else {
      fnCtx.defCounts.insert(name, 1);
    }
    if  fnCtx.parent.is_some() {
      ii = ii + fnCtx.parent.getFnVarCnt2(name.clone());
    }
    let scope_has : bool = self.isVarDefined(name.clone());
    if  scope_has {
      ii = 1 + ii;
    }
    let mut scope_has_2 : bool = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    while scope_has_2 {
      ii = 1 + ii;
      scope_has_2 = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    }
    return ii;
  }
  fn getFnVarCnt3(&mut self, name : String) -> i64 {
    let mut classLevel : Option<Box<RangerAppWriterContext>> = self.findMethodLevelContext();
    let mut fnCtx : RangerAppWriterContext = self;
    let mut ii : i64 = 0;
    if  fnCtx.defCounts.contains_key(&name) {
      ii = (fnCtx.defCounts.get(name)).unwrap();
      fnCtx.defCounts.insert(name, ii + 1);
    } else {
      fnCtx.defCounts.insert(name, 1);
    }
    if  classLevel.isVarDefined(name.clone()) {
      ii = ii + 1;
    }
    let mut scope_has : bool = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    while scope_has {
      ii = 1 + ii;
      scope_has = self.isVarDefined(([(format!("{}{}", name, "_".to_string())) , (ii.to_string()) ].join("")));
    }
    return ii;
  }
  fn isMemberVariable(&mut self, name : String) -> bool {
    if  self.isVarDefined(name.clone()) {
      let mut vDef : RangerAppParamDesc = self.getVariableDef(name.clone());
      if  vDef.varType == 8 {
        return true;
      }
    }
    return false;
  }
  fn defineVariable(&mut self, name : String, mut desc : RangerAppParamDesc) -> () {
    let mut cnt : i64 = 0;
    let mut fnLevel : Option<Box<RangerAppWriterContext>> = self.findMethodLevelContext();
    if  false == (((desc.varType == 8) || (desc.varType == 4)) || (desc.varType == 10)) {
      cnt = fnLevel.getFnVarCnt3(name.clone());
    }
    if  0 == cnt {
      switch (name ) { 
        case "self".to_string() : 
          desc.compiledName = "__self".to_string();
          break;
        case "process".to_string() : 
          desc.compiledName = "_process".to_string();
          break;
        case "len".to_string() : 
          desc.compiledName = "__len".to_string();
          break;
        default: 
          desc.compiledName = self.transformWord(name.clone());
          break;
      }
    } else {
      desc.compiledName = [(format!("{}{}", name, "_".to_string())) , (cnt.to_string()) ].join("");
    }
    if  desc.varType == 8 {
    }
    self.localVariables.insert(name, desc);
    self.localVarNames.push(name);
  }
  fn isDefinedClass(&mut self, name : String) -> bool {
    if  self.definedClasses.contains_key(&name) {
      return true;
    } else {
      if  self.parent.is_some() {
        return self.self.parent.isDefinedClass(name.clone());
      }
    }
    return false;
  }
  fn getRoot(&mut self, ) -> RangerAppWriterContext {
    if  self.parent.is_none() {
      return self.clone();
    }
    return self.self.parent.getRoot().clone();
  }
  fn getClasses(&mut self, ) -> Vec<RangerAppClassDesc> {
    let mut list : Vec<RangerAppClassDesc> = Vec::new();
    for i in 0..self.definedClassList.len() {
      let mut n = self.definedClassList[i as usize].clone();
      list.push((self.definedClasses.get(n)).unwrap());
    }
    return list;
  }
  fn addClass(&mut self, name : String, mut desc : RangerAppClassDesc) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    if  root.definedClasses.contains_key(&name) {
    } else {
      root.definedClasses.insert(name, desc);
      root.definedClassList.push(name);
    }
  }
  fn findClass(&mut self, name : String) -> RangerAppClassDesc {
    let mut root : RangerAppWriterContext = self.getRoot();
    return (root.definedClasses.get(name)).unwrap().clone();
  }
  fn hasClass(&mut self, name : String) -> bool {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.definedClasses.contains_key(&name);
  }
  fn getCurrentMethod(&mut self, ) -> RangerAppFunctionDesc {
    if  self.currentMethod.is_some() {
      return self.currentMethod.clone().unwrap().clone();
    }
    if  self.parent.is_some() {
      return self.self.parent.getCurrentMethod().clone();
    }
    return RangerAppFunctionDesc::new().clone();
  }
  fn setCurrentClass(&mut self, mut cc : RangerAppClassDesc) -> () {
    self.in_class = true;
    self.currentClass = Some(cc.clone());
  }
  fn disableCurrentClass(&mut self, ) -> () {
    if  self.in_class {
      self.in_class = false;
    }
    if  self.parent.is_some() {
      self.self.parent.disableCurrentClass();
    }
  }
  fn hasCurrentClass(&mut self, ) -> bool {
    if  self.in_class && (self.currentClass.is_some()) {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.hasCurrentClass();
    }
    return false;
  }
  fn getCurrentClass(&mut self, ) -> Option<RangerAppClassDesc> {
    let mut non : Option<RangerAppClassDesc> = self.currentClass;
    if  self.in_class && (non.is_some()) {
      return non.clone();
    }
    if  self.parent.is_some() {
      return self.self.parent.getCurrentClass().clone();
    }
    return non.clone();
  }
  fn restartExpressionLevel(&mut self, ) -> () {
    self.expr_restart = true;
  }
  fn newBlock(&mut self, ) -> () {
    self.expr_restart_block = true;
  }
  fn isInExpression(&mut self, ) -> bool {
    if  ((self.expr_stack.len() as i64)) > 0 {
      return true;
    }
    if  ((self.parent.is_some()) && (self.expr_restart_block == false)) && (self.expr_restart == false) {
      return self.self.parent.isInExpression();
    }
    return false;
  }
  fn expressionLevel(&mut self, ) -> i64 {
    let level : i64 = (self.expr_stack.len() as i64);
    if  ((self.parent.is_some()) && (self.expr_restart == false)) && (self.expr_restart_block == false) {
      return level + self.self.parent.expressionLevel();
    }
    return level;
  }
  fn setInExpr(&mut self, ) -> () {
    self.expr_stack.push(true);
  }
  fn unsetInExpr(&mut self, ) -> () {
    self.expr_stack.pop();
  }
  fn getErrorCount(&mut self, ) -> i64 {
    let mut cnt : i64 = (self.compilerErrors.len() as i64);
    if self.parent.is_some() {
      cnt = cnt + self.self.parent.getErrorCount();
    }
    return cnt;
  }
  fn isInStatic(&mut self, ) -> bool {
    if  self.in_static_method {
      return true;
    }
    if self.parent.is_some() {
      return self.self.parent.isInStatic();
    }
    return false;
  }
  fn isInMain(&mut self, ) -> bool {
    if  self.in_main {
      return true;
    }
    if self.parent.is_some() {
      return self.self.parent.isInMain();
    }
    return false;
  }
  fn isInMethod(&mut self, ) -> bool {
    if  ((self.method_stack.len() as i64)) > 0 {
      return true;
    }
    if  self.parent.is_some() {
      return self.self.parent.isInMethod();
    }
    return false;
  }
  fn setInMethod(&mut self, ) -> () {
    self.method_stack.push(true);
  }
  fn unsetInMethod(&mut self, ) -> () {
    self.method_stack.pop();
  }
  fn findMethodLevelContext(&mut self, ) -> Option<Box<RangerAppWriterContext>> {
    let mut res : Option<Box<RangerAppWriterContext>> = None;
    if  self.function_level_context {
      res = Some(self);
      return res.clone();
    }
    if self.parent.is_some() {
      return self.self.parent.findMethodLevelContext().clone();
    }
    res = Some(self);
    return res.clone();
  }
  fn findClassLevelContext(&mut self, ) -> Option<Box<RangerAppWriterContext>> {
    let mut res : Option<Box<RangerAppWriterContext>> = None;
    if  self.class_level_context {
      res = Some(self);
      return res.clone();
    }
    if self.parent.is_some() {
      return self.self.parent.findClassLevelContext().clone();
    }
    res = Some(self);
    return res.clone();
  }
  fn fork(&mut self, ) -> RangerAppWriterContext {
    let mut new_ctx : RangerAppWriterContext = RangerAppWriterContext::new();
    new_ctx.parent = Some(Box::new(self.clone()));
    return new_ctx.clone();
  }
  fn getRootFile(&mut self, ) -> String {
    let mut root : RangerAppWriterContext = self.getRoot();
    return root.rootFile.clone();
  }
  fn setRootFile(&mut self, file_name : String) -> () {
    let mut root : RangerAppWriterContext = self.getRoot();
    root.rootFile = file_name.clone();
  }
}
#[derive(Clone)]
struct CodeFile { 
  path_name : String, 
  name : String, 
  writer : Option<CodeWriter>, 
  import_list : HashMap<String,String>, 
  import_names : Vec<String>, 
  fileSystem : Option<CodeFileSystem>, 
}
impl CodeFile { 
  
  pub fn new(filePath : String, fileName : String) ->  CodeFile {
    let mut me = CodeFile { 
      path_name:"".to_string(), 
      name:"".to_string(), 
      writer: None, 
      import_list: None, 
      import_names: Vec::new(), 
      fileSystem: None, 
    };
    me.name = fileName.clone();
    me.path_name = filePath.clone();
    me.writer = Some(CodeWriter::new());
    me.me.writer.createTag("imports".to_string());
    return me;
  }
  fn addImport(&mut self, import_name : String) -> () {
    if  false == (self.import_list.contains_key(&import_name)) {
      self.import_list.insert(import_name, import_name);
      self.import_names.push(import_name);
    }
  }
  fn rewrite(&mut self, newString : String) -> () {
    self.self.writer.rewrite(newString.clone());
  }
  fn testCreateWriter(&mut self, ) -> CodeWriter {
    return CodeWriter::new().clone();
  }
  fn getImports(&mut self, ) -> Vec<String> {
    return self.import_names;
  }
  fn getWriter(&mut self, ) -> Option<CodeWriter> {
    self.writer.ownerFile = Some(self);
    return self.writer.clone();
  }
  fn getCode(&mut self, ) -> String {
    return self.self.writer.getCode().clone();
  }
}
#[derive(Clone)]
struct CodeFileSystem { 
  files : Vec<CodeFile>, 
}
impl CodeFileSystem { 
  
  pub fn new() ->  CodeFileSystem {
    let mut me = CodeFileSystem { 
      files: Vec::new(), 
    };
    return me;
  }
  fn getFile(&mut self, path : String, name : String) -> CodeFile {
    for idx in 0..self.files.len() {
      let mut file = self.files[idx as usize].clone();
      if  (file.path_name == path) && (file.name == name) {
        return file.clone();
      }
    }
    let mut new_file : CodeFile = CodeFile::new(path.clone(), name.clone());
    new_file.fileSystem = Some(self);
    self.files.push(new_file.clone());
    return new_file.clone();
  }
  fn mkdir(&mut self, path : String) -> () {
    let mut parts : Vec<String> = path.split("/".to_string());
    let mut curr_path : String = "".to_string();
    for i in 0..parts.len() {
      let mut p = parts[i as usize].clone();
      curr_path = format!("{}{}", (format!("{}{}", curr_path, p)), "/".to_string());
      if==falsedir_existscurr_pathcreate_dircurr_path
    }
  }
  fn saveTo(&mut self, path : String, verbose : bool) -> () {
    println!( "{}", format!("{}{}", "Saving results to path : ".to_string(), path) );
    for idx in 0..self.files.len() {
      let mut file = self.files[idx as usize].clone();
      let file_path : String = format!("{}{}", (format!("{}{}", path, "/".to_string())), file.path_name);
      self.mkdir(file_path.clone());
      if  verbose {
        println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", "Writing to file ".to_string(), file_path)), "/".to_string())), file.name) );
      }
      let file_content : String = file.getCode();
      if  (file_content.len() as i64) > 0 {
        r_write_file(&file_path, &file.name.trim(), &file_content);
      }
    }
  }
}
#[derive(Clone)]
struct CodeSlice { 
  code : String, 
  writer : Option<CodeWriter>, 
}
impl CodeSlice { 
  
  pub fn new() ->  CodeSlice {
    let mut me = CodeSlice { 
      code:"".to_string(), 
      writer: None, 
    };
    return me;
  }
  fn getCode(&mut self, ) -> String {
    if  self.writer.is_none() {
      return self.code.clone();
    }
    return self.self.writer.getCode().clone();
  }
}
#[derive(Clone)]
struct CodeWriter { 
  tagName : String, 
  codeStr : String, 
  currentLine : String, 
  tabStr : String, 
  nlStr : String, 
  lineNumber : i64, 
  indentAmount : i64, 
  compiledTags : HashMap<String,bool>, 
  tags : HashMap<String,i64>, 
  slices : Vec<CodeSlice>, 
  current_slice : Option<CodeSlice>, 
  ownerFile : Option<CodeFile>, 
  forks : Vec<CodeWriter>, 
  tagOffset : i64, 
  parent : Option<Box<CodeWriter>>, 
  had_nl : bool, 
}
impl CodeWriter { 
  
  pub fn new() ->  CodeWriter {
    let mut me = CodeWriter { 
      tagName:"".to_string(), 
      codeStr:"".to_string(), 
      currentLine:"".to_string(), 
      tabStr:"  ".to_string(), 
      nlStr:"\r\n".to_string(), 
      lineNumber:1, 
      indentAmount:0, 
      compiledTags: None, 
      tags: None, 
      slices: Vec::new(), 
      current_slice: None, 
      ownerFile: None, 
      forks: Vec::new(), 
      tagOffset:0, 
      parent: None, 
      had_nl:true, 
    };
    let mut new_slice : CodeSlice = CodeSlice::new();
    me.slices.push(new_slice.clone());
    me.current_slice = Some(new_slice.clone());
    return me;
  }
  pub fn emptyWithFS() -> CodeWriter {
    let mut wr : CodeWriter = CodeWriter::new();
    let mut file : CodeFile = CodeFile::new(".".to_string(), "emptyFile.txt".to_string());
    file.writer = Some(wr.clone());
    file.fileSystem = Some(CodeFileSystem::new());
    wr.ownerFile = Some(file.clone());
    return wr.clone();
  }
  fn rewrite(&mut self, newString : String) -> () {
    self.slices.length = 0;
    self.forks.length = 0;
    self.currentLine = "".to_string();
    let mut new_slice : CodeSlice = CodeSlice::new();
    self.slices.push(new_slice.clone());
    new_slice.code = newString.clone();
    self.current_slice = Some(new_slice.clone());
  }
  fn getFilesystem(&mut self, ) -> CodeFileSystem {
    if  self.ownerFile.is_none() {
      if  self.parent.is_some() {
        return self.self.parent.getFilesystem().clone();
      }
      return CodeFileSystem::new().clone();
    }
    let mut fs : Option<CodeFileSystem> = self.ownerFile.fileSystem;
    return fs.unwrap().clone();
  }
  fn getFileWriter(&mut self, path : String, fileName : String) -> CodeWriter {
    if  self.ownerFile.is_none() {
      if  self.parent.is_some() {
        return self.self.parent.getFileWriter(path.clone(), fileName.clone()).clone();
      }
    }
    let mut fs : Option<CodeFileSystem> = self.ownerFile.fileSystem;
    let mut file : CodeFile = fs.getFile(path.clone(), fileName.clone());
    let mut wr : Option<Box<CodeWriter>> = file.getWriter();
    return wr.unwrap().clone();
  }
  fn getImports(&mut self, ) -> Vec<String> {
    let mut p : CodeWriter = self;
    while (p.ownerFile.is_none()) && (p.parent.is_some()) {
      p = (*p.parent.clone().unwrap());
    }
    if  p.ownerFile.is_some() {
      let mut f : CodeFile = p.ownerFile.clone().unwrap();
      return f.import_names;
    }
    let mut nothing : Vec<String> = Vec::new();
    return nothing;
  }
  fn addImport(&mut self, name : String) -> () {
    if  self.ownerFile.is_some() {
      self.self.ownerFile.addImport(name.clone());
    } else {
      if  self.parent.is_some() {
        self.self.parent.addImport(name.clone());
      }
    }
  }
  fn indent(&mut self, delta : i64) -> () {
    self.indentAmount = self.indentAmount + delta;
    if  self.indentAmount < 0 {
      self.indentAmount = 0;
    }
  }
  fn addIndent(&mut self, ) -> () {
    let mut i : i64 = 0;
    if  0 == (self.currentLine.len() as i64) {
      while i < self.indentAmount {
        self.currentLine = format!("{}{}", self.currentLine, self.tabStr);
        i = i + 1;
      }
    }
  }
  fn createTag(&mut self, name : String) -> CodeWriter {
    let mut new_writer : CodeWriter = CodeWriter::new();
    let mut new_slice : CodeSlice = CodeSlice::new();
    self.tags.insert(name, (self.slices.len() as i64));
    self.slices.push(new_slice.clone());
    new_slice.writer = Some(new_writer.clone());
    new_writer.indentAmount = self.indentAmount;
    let mut new_active_slice : CodeSlice = CodeSlice::new();
    self.slices.push(new_active_slice.clone());
    self.current_slice = Some(new_active_slice.clone());
    new_writer.parent = Some(Box::new(self.clone()));
    return new_writer.clone();
  }
  fn getTag(&mut self, name : String) -> CodeWriter {
    if  self.tags.contains_key(&name) {
      let idx : i64 = (self.tags.get(name)).unwrap();
      let mut slice : CodeSlice = self.slices[idx as usize].clone();
      return slice.writer.clone().unwrap().clone();
    } else {
      if  self.parent.is_some() {
        return self.self.parent.getTag(name.clone()).clone();
      }
    }
    return self.clone();
  }
  fn hasTag(&mut self, name : String) -> bool {
    if  self.tags.contains_key(&name) {
      return true;
    } else {
      if  self.parent.is_some() {
        return self.self.parent.hasTag(name.clone());
      }
    }
    return false;
  }
  fn fork(&mut self, ) -> CodeWriter {
    let mut new_writer : CodeWriter = CodeWriter::new();
    let mut new_slice : CodeSlice = CodeSlice::new();
    self.slices.push(new_slice.clone());
    new_slice.writer = Some(new_writer.clone());
    new_writer.indentAmount = self.indentAmount;
    new_writer.parent = Some(Box::new(self.clone()));
    let mut new_active_slice : CodeSlice = CodeSlice::new();
    self.slices.push(new_active_slice.clone());
    self.current_slice = Some(new_active_slice.clone());
    return new_writer.clone();
  }
  fn newline(&mut self, ) -> () {
    if  (self.currentLine.len() as i64) > 0 {
      self.out("".to_string(), true);
    }
  }
  fn line_end(&mut self, str : String) -> () {
    if  (self.currentLine.len() as i64) > 0 {
      if  (str.charCodeAt(0)) != (self.currentLine.chars().nth(((self.currentLine.len() as i64) - 1) as usize).unwrap_or('\0') as i64) {
        self.out(str.clone(), false);
      }
    }
  }
  fn writeSlice(&mut self, str : String, newLine : bool) -> () {
    self.addIndent();
    self.currentLine = format!("{}{}", self.currentLine, str);
    if  newLine {
      self.current_slice.code = format!("{}{}", (format!("{}{}", self.current_slice.code, self.currentLine)), self.nlStr);
      self.currentLine = "".to_string();
    }
  }
  fn out(&mut self, str : String, newLine : bool) -> () {
    let mut lines : Vec<String> = str.split("\n".to_string());
    let rowCnt : i64 = (lines.len() as i64);
    if  rowCnt == 1 {
      self.writeSlice(str.clone(), newLine);
    } else {
      for idx in 0..lines.len() {
        let mut row = lines[idx as usize].clone();
        self.addIndent();
        if  idx < (rowCnt - 1) {
          self.writeSlice(row.trim(), true);
        } else {
          self.writeSlice(row.clone(), newLine);
        }
      }
    }
  }
  fn raw(&mut self, str : String, newLine : bool) -> () {
    let mut lines : Vec<String> = str.split("\n".to_string());
    let rowCnt : i64 = (lines.len() as i64);
    if  rowCnt == 1 {
      self.writeSlice(str.clone(), newLine);
    } else {
      for idx in 0..lines.len() {
        let mut row = lines[idx as usize].clone();
        let cleanRow : String = row.trim_end().to_string();
        self.addIndent();
        if  idx < (rowCnt - 1) {
          self.writeSlice(cleanRow.clone(), true);
        } else {
          self.writeSlice(cleanRow.clone(), newLine);
        }
      }
    }
  }
  fn getCode(&mut self, ) -> String {
    let mut res : String = "".to_string();
    for idx in 0..self.slices.len() {
      let mut slice = self.slices[idx as usize].clone();
      res = format!("{}{}", res, slice.getCode());
    }
    res = format!("{}{}", res, self.currentLine);
    return res.clone();
  }
}
#[derive(Clone)]
struct RangerLispParser { 
  code : Option<SourceCode>, 
  buff : Option<Vec<u8>>, 
  __len : i64, 
  i : i64, 
  last_line_start : i64, 
  current_line_index : i64, 
  parents : Vec<CodeNode>, 
  next : Option<CodeNode>, 
  paren_cnt : i64, 
  get_op_pred : i64, 
  rootNode : Option<CodeNode>, 
  curr_node : Option<CodeNode>, 
  had_error : bool, 
  disableOperators : bool, 
}
impl RangerLispParser { 
  
  pub fn new(code_module : SourceCode) ->  RangerLispParser {
    let mut me = RangerLispParser { 
      code: None, 
      buff: None, 
      __len:0, 
      i:0, 
      last_line_start:0, 
      current_line_index:0, 
      parents: Vec::new(), 
      next: None, 
      paren_cnt:0, 
      get_op_pred:0, 
      rootNode: None, 
      curr_node: None, 
      had_error:false, 
      disableOperators:false, 
    };
    me.buff = Some(code_module.code.into_bytes());
    me.code = Some(code_module.clone());
    me.__len = (me.buff.clone().unwrap()).len();
    me.rootNode = Some(CodeNode::new(me.code.clone().unwrap(), 0, 0));
    me.rootNode.is_block_node = true;
    me.rootNode.expression = true;
    me.curr_node = me.rootNode.clone();
    me.parents.push(me.curr_node.clone().unwrap());
    me.paren_cnt = 1;
    return me;
  }
  fn joo(&mut self, mut cm : SourceCode) -> () {
    /** unused:  let ll : i64 = cm.code.len() as i64;   **/ 
  }
  fn parse_raw_annotation(&mut self, ) -> CodeNode {
    let mut sp : i64 = self.i;
    let mut ep : i64 = self.i;
    self.i = self.i + 1;
    sp = self.i;
    ep = self.i;
    if  self.i < self.__len {
      let mut a_node2 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
      a_node2.expression = true;
      a_node2.row = self.current_line_index;
      self.curr_node = Some(a_node2.clone());
      self.parents.push(a_node2.clone());
      self.i = self.i + 1;
      self.paren_cnt = self.paren_cnt + 1;
      self.parse(false);
      return a_node2.clone();
    } else {
    }
    return CodeNode::new(self.code.clone().unwrap(), sp, ep).clone();
  }
  fn skip_space(&mut self, is_block_parent : bool) -> bool {
    let s : Vec<u8> = self.buff.clone().unwrap();
    let mut did_break : bool = false;
    if  self.i >= self.__len {
      return true;
    }
    let mut c : u8 = s.charCodeAt(self.i );
    /** unused:  let bb : bool = c == (46);   **/ 
    while (self.i < self.__len) && (c <= 32) {
      if  c < 8 {
        self.i = self.__len;
        return true;
      }
      if  is_block_parent && ((c == 10) || (c == 13)) {
        self.end_expression();
        self.current_line_index = self.current_line_index + 1;
        did_break = true;
        break;
      }
      let mut had_break : bool = false;
      while ((self.i < self.__len) && (c == 10)) || (c == 13) {
        had_break = true;
        self.i = self.i + 1;
        if  self.i >= self.__len {
          return true;
        }
        c = s.charCodeAt(self.i );
        if  (c == 10) || (c == 13) {
        }
      }
      if  had_break {
        self.current_line_index = self.current_line_index + 1;
      } else {
        self.i = 1 + self.i;
        if  self.i >= self.__len {
          return true;
        }
        c = s.charCodeAt(self.i );
      }
    }
    return did_break;
  }
  fn end_expression(&mut self, ) -> bool {
    self.i = 1 + self.i;
    if  self.i >= self.__len {
      return false;
    }
    self.paren_cnt = self.paren_cnt - 1;
    if  self.paren_cnt < 0 {
      println!( "{}", "Parser error ) mismatch".to_string() );
    }
    self.parents.pop();
    if  self.curr_node.is_some() {
      self.curr_node.ep = self.i;
      self.curr_node.infix_operator = false;
    }
    if  ((self.parents.len() as i64)) > 0 {
      self.curr_node = Some(self.parents[(((self.parents.len() as i64)) - 1) as usize].clone());
    } else {
      self.curr_node = self.rootNode.clone();
    }
    self.curr_node.infix_operator = false;
    return true;
  }
  fn getOperator(&mut self, disabled : bool) -> i64 {
    if  disabled {
      return 0;
    }
    let s : Vec<u8> = self.buff.clone().unwrap();
    if  (self.i + 2) >= self.__len {
      return 0;
    }
    let c : u8 = s.charCodeAt(self.i );
    let c2 : u8 = s.charCodeAt((self.i + 1) );
    switch (c ) { 
      case 42 : 
        self.i = self.i + 1;
        return 14;
        break;
      case 47 : 
        self.i = self.i + 1;
        return 14;
        break;
      case 37 : 
        self.i = self.i + 1;
        return 14;
        break;
      case 43 : 
        self.i = self.i + 1;
        return 13;
        break;
      case 45 : 
        self.i = self.i + 1;
        return 13;
        break;
      case 60 : 
        if  c2 == (61) {
          self.i = self.i + 2;
          return 11;
        }
        self.i = self.i + 1;
        return 11;
        break;
      case 62 : 
        if  c2 == (61) {
          self.i = self.i + 2;
          return 11;
        }
        self.i = self.i + 1;
        return 11;
        break;
      case 33 : 
        if  c2 == (61) {
          self.i = self.i + 2;
          return 10;
        }
        return 0;
        break;
      case 61 : 
        if  c2 == (61) {
          self.i = self.i + 2;
          return 10;
        }
        self.i = self.i + 1;
        return 3;
        break;
      case 38 : 
        if  c2 == (38) {
          self.i = self.i + 2;
          return 6;
        }
        return 0;
        break;
      case 124 : 
        if  c2 == (124) {
          self.i = self.i + 2;
          return 5;
        }
        return 0;
        break;
      default: 
        break;
    }
    return 0;
  }
  fn isOperator(&mut self, disabled : bool) -> i64 {
    if  disabled {
      return 0;
    }
    let s : Vec<u8> = self.buff.clone().unwrap();
    if  (self.i - 2) > self.__len {
      return 0;
    }
    let c : u8 = s.charCodeAt(self.i );
    let c2 : u8 = s.charCodeAt((self.i + 1) );
    switch (c ) { 
      case 42 : 
        return 1;
        break;
      case 47 : 
        return 14;
        break;
      case 43 : 
        return 13;
        break;
      case 37 : 
        return 14;
        break;
      case 45 : 
        return 13;
        break;
      case 60 : 
        if  c2 == (61) {
          return 11;
        }
        return 11;
        break;
      case 62 : 
        if  c2 == (61) {
          return 11;
        }
        return 11;
        break;
      case 33 : 
        if  c2 == (61) {
          return 10;
        }
        return 0;
        break;
      case 61 : 
        if  c2 == (61) {
          return 10;
        }
        return 3;
        break;
      case 38 : 
        if  c2 == (38) {
          return 6;
        }
        return 0;
        break;
      case 124 : 
        if  c2 == (124) {
          return 5;
        }
        return 0;
        break;
      default: 
        break;
    }
    return 0;
  }
  fn getOperatorPred(&mut self, str : String, disabled : bool) -> i64 {
    if  disabled {
      return 0;
    }
    switch (str ) { 
      case "<".to_string() : 
        return 11;
        break;
      case ">".to_string() : 
        return 11;
        break;
      case "<=".to_string() : 
        return 11;
        break;
      case ">=".to_string() : 
        return 11;
        break;
      case "==".to_string() : 
        return 10;
        break;
      case "!=".to_string() : 
        return 10;
        break;
      case "=".to_string() : 
        return 3;
        break;
      case "&&".to_string() : 
        return 6;
        break;
      case "||".to_string() : 
        return 5;
        break;
      case "+".to_string() : 
        return 13;
        break;
      case "-".to_string() : 
        return 13;
        break;
      case "%".to_string() : 
        return 14;
        break;
      case "*".to_string() : 
        return 14;
        break;
      case "/".to_string() : 
        return 14;
        break;
      default: 
        break;
    }
    return 0;
  }
  fn insert_node(&mut self, mut p_node : CodeNode) -> () {
    let mut push_target : Option<CodeNode> = self.curr_node;
    if  self.curr_node.infix_operator {
      push_target = self.curr_node.infix_node.clone();
      if  push_target.to_the_right {
        push_target = push_target.right_node.clone();
        p_node.parent = Some(Box::new(push_target.clone()));
      }
    }
    push_target.children.push(p_node.clone());
  }
  fn parse_attributes(&mut self, ) -> bool {
    let s : Vec<u8> = self.buff.clone().unwrap();
    let mut last_i : i64 = 0;
    let do_break : bool = false;
    /** unused:  let attr_name : String = "".to_string();   **/ 
    let mut sp : i64 = self.i;
    let mut ep : i64 = self.i;
    let mut c : u8 = 0;
    let mut cc1 : u8 = 0;
    let mut cc2 : u8 = 0;
    cc1 = s.charCodeAt(self.i );
    while self.i < self.__len {
      last_i = self.i;
      while (self.i < self.__len) && ((s.charCodeAt(self.i )) <= 32) {
        self.i = 1 + self.i;
      }
      cc1 = s.charCodeAt(self.i );
      cc2 = s.charCodeAt((self.i + 1) );
      if  self.i >= self.__len {
        break;
      }
      if  cc1 == (62) {
        return do_break;
      }
      if  (cc1 == (47)) && (cc2 == (62)) {
        self.i = 2 + self.i;
        return true;
      }
      sp = self.i;
      ep = self.i;
      c = s.charCodeAt(self.i );
      while (self.i < self.__len) && ((((((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122))) || ((c >= 48) && (c <= 57))) || (c == (95))) || (c == (45))) {
        self.i = 1 + self.i;
        c = s.charCodeAt(self.i );
      }
      self.i = self.i - 1;
      let an_sp : i64 = sp;
      let an_ep : i64 = self.i;
      c = s.charCodeAt(self.i );
      while (self.i < self.__len) && (c != (61)) {
        self.i = 1 + self.i;
        c = s.charCodeAt(self.i );
      }
      if  c == (61) {
        self.i = 1 + self.i;
      }
      while (self.i < self.__len) && ((s.charCodeAt(self.i )) <= 32) {
        self.i = 1 + self.i;
      }
      if  self.i >= self.__len {
        break;
      }
      c = s.charCodeAt(self.i );
      if  c == (123) {
        let mut cNode : Option<CodeNode> = self.curr_node;
        let mut new_attr : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
        new_attr.value_type = 21;
        new_attr.parsed_type = new_attr.value_type;
        new_attr.vref = s.substring(an_sp, (an_ep + 1) );
        new_attr.string_value = s.substring(sp, ep );
        self.curr_node.attrs.push(new_attr.clone());
        self.curr_node = Some(new_attr.clone());
        self.paren_cnt = self.paren_cnt + 1;
        let mut new_qnode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.i, self.i);
        new_qnode.expression = true;
        self.insert_node(new_qnode.clone());
        self.parents.push(new_qnode.clone());
        self.curr_node = Some(new_qnode.clone());
        self.i = 1 + self.i;
        self.parse(false);
        self.curr_node = Some(cNode.clone());
        continue;
      }
      if  (c == 34) || (c == (39)) {
        self.i = self.i + 1;
        sp = self.i;
        ep = self.i;
        c = s.charCodeAt(self.i );
        while ((self.i < self.__len) && (c != 34)) && (c != (39)) {
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
        }
        ep = self.i;
        if  (self.i < self.__len) && (ep > sp) {
          let mut new_attr_1 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
          new_attr_1.value_type = 21;
          new_attr_1.parsed_type = new_attr_1.value_type;
          new_attr_1.vref = s.substring(an_sp, (an_ep + 1) );
          new_attr_1.string_value = s.substring(sp, ep );
          self.curr_node.attrs.push(new_attr_1.clone());
        }
        self.i = 1 + self.i;
      }
      if  last_i == self.i {
        self.i = 1 + self.i;
      }
    }
    return do_break;
  }
  fn parseXML(&mut self, ) -> () {
    let s : Vec<u8> = self.buff.clone().unwrap();
    let mut c : u8 = 0;
    /** unused:  let next_c : u8 = 0;   **/ 
    /** unused:  let fc : u8 = 0;   **/ 
    /** unused:  let mut new_node : Option<CodeNode> = None;   **/ 
    let mut sp : i64 = self.i;
    let mut ep : i64 = self.i;
    let mut last_i : i64 = 0;
    let mut cc1 : u8 = 0;
    let mut cc2 : u8 = 0;
    let mut tag_depth : i64 = 0;
    while self.i < self.__len {
      last_i = self.i;
      if  self.i >= (self.__len - 1) {
        break;
      }
      cc1 = s.charCodeAt(self.i );
      cc2 = s.charCodeAt((self.i + 1) );
      if  cc1 == (123) {
        let mut cNode : Option<CodeNode> = self.curr_node;
        self.paren_cnt = self.paren_cnt + 1;
        let mut new_qnode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.i, self.i);
        new_qnode.expression = true;
        self.insert_node(new_qnode.clone());
        self.parents.push(new_qnode.clone());
        self.curr_node = Some(new_qnode.clone());
        self.i = 1 + self.i;
        self.parse(false);
        self.curr_node = Some(cNode.clone());
        continue;
      }
      if  cc1 == (62) {
        self.i = self.i + 1;
        cc1 = s.charCodeAt(self.i );
        cc2 = s.charCodeAt((self.i + 1) );
        continue;
      }
      if  ((47) == cc1) && (cc2 == (62)) {
        tag_depth = tag_depth - 1;
        self.i = self.i + 2;
        if  tag_depth <= 0 {
          self.parents.pop();
          let p_cnt : i64 = (self.parents.len() as i64);
          let mut last_parent : CodeNode = self.parents[(p_cnt - 1) as usize].clone();
          self.curr_node = Some(last_parent.clone());
          return;
        }
        continue;
      }
      if  self.i >= self.__len {
        break;
      }
      if  ((60) == cc1) && (cc2 == (47)) {
        tag_depth = tag_depth - 1;
        self.i = self.i + 2;
        sp = self.i;
        ep = self.i;
        c = s.charCodeAt(self.i );
        while ((self.i < self.__len) && (c > 32)) && (c != (62)) {
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
        }
        ep = self.i;
        self.parents.pop();
        let p_cnt_1 : i64 = (self.parents.len() as i64);
        let mut last_parent_1 : CodeNode = self.parents[(p_cnt_1 - 1) as usize].clone();
        self.curr_node = Some(last_parent_1.clone());
        if  tag_depth <= 0 {
          return;
        }
        continue;
      }
      if  cc1 == (60) {
        self.i = self.i + 1;
        sp = self.i;
        ep = self.i;
        c = s.charCodeAt(self.i );
        while ((self.i < self.__len) && (c != (62))) && (((((((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122))) || ((c >= 48) && (c <= 57))) || (c == 95)) || (c == 46)) || (c == 64)) {
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
        }
        tag_depth = tag_depth + 1;
        ep = self.i;
        let new_tag : String = s.substring(sp, ep );
        if  self.curr_node.is_none() {
          let mut new_rnode : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
          new_rnode.vref = new_tag.clone();
          new_rnode.value_type = 19;
          new_rnode.parsed_type = new_rnode.value_type;
          self.rootNode = Some(new_rnode.clone());
          self.parents.push(new_rnode.clone());
          self.curr_node = Some(new_rnode.clone());
        } else {
          let mut new_node_2 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
          new_node_2.vref = new_tag.clone();
          new_node_2.value_type = 19;
          new_node_2.parsed_type = new_node_2.value_type;
          self.curr_node.children.push(new_node_2.clone());
          new_node_2.parent = self.curr_node.clone();
          self.parents.push(new_node_2.clone());
          self.curr_node = Some(new_node_2.clone());
        }
        if  self.parse_attributes() {
          self.parents.pop();
          let p_cnt_2 : i64 = (self.parents.len() as i64);
          let mut last_parent_2 : CodeNode = self.parents[(p_cnt_2 - 1) as usize].clone();
          self.curr_node = Some(last_parent_2.clone());
          tag_depth = tag_depth - 1;
          if  tag_depth <= 0 {
            return;
          }
          continue;
        }
        continue;
      }
      if  self.curr_node.is_some() {
        sp = self.i;
        ep = self.i;
        c = s.charCodeAt(self.i );
        while ((self.i < self.__len) && (c != (60))) && (c != (123)) {
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
        }
        ep = self.i;
        if  ep > sp {
          let mut new_node_3 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
          new_node_3.string_value = s.substring(sp, ep );
          new_node_3.value_type = 20;
          new_node_3.parsed_type = new_node_3.value_type;
          self.curr_node.children.push(new_node_3.clone());
          new_node_3.parent = self.curr_node.clone();
        }
      }
      if  last_i == self.i {
        self.i = 1 + self.i;
      }
    }
  }
  fn parse(&mut self, disable_ops : bool) -> () {
    let s : Vec<u8> = self.buff.clone().unwrap();
    let mut c : u8 = s.charCodeAt(0 );
    /** unused:  let next_c : u8 = 0;   **/ 
    let mut fc : u8 = 0;
    let mut new_node : Option<CodeNode> = None;
    let mut sp : i64 = 0;
    let mut ep : i64 = 0;
    let mut last_i : i64 = 0;
    let mut had_lf : bool = false;
    let mut disable_ops_set : bool = disable_ops;
    while self.i < self.__len {
      if  self.curr_node.is_some() {
        if  self.curr_node.value_type == 21 {
          return;
        }
        if  self.curr_node.value_type == 19 {
          return;
        }
      }
      if  self.had_error {
        break;
      }
      last_i = self.i;
      let mut is_block_parent : bool = false;
      if  had_lf {
        had_lf = false;
        self.end_expression();
        break;
      }
      if  self.curr_node.is_some() {
        if  self.curr_node.parent.is_some() {
          let mut nodeParent : Option<CodeNode> = self.curr_node.parent;
          if  nodeParent.is_block_node {
            is_block_parent = true;
          }
        }
      }
      if  self.skip_space(is_block_parent) {
        break;
      }
      had_lf = false;
      c = s.charCodeAt(self.i );
      if  self.i < self.__len {
        c = s.charCodeAt(self.i );
        if  (60) == c {
          if  (self.i + 1) < self.__len {
            let next_c_2 : u8 = s.charCodeAt((self.i + 1) );
            if  ((65) < next_c_2) && ((122) > next_c_2) {
              /** unused:  let spos : i64 = self.i;   **/ 
              self.parseXML();
              self.i = self.i + 1;
              continue;
            }
          }
          if  self.i > 0 {
            let prev_c : u8 = s.charCodeAt((self.i - 1) );
            if  (62) == prev_c {
            }
          }
        }
        if  c == 59 {
          sp = self.i + 1;
          while (self.i < self.__len) && ((s.charCodeAt(self.i )) > 31) {
            self.i = 1 + self.i;
          }
          if  self.i >= self.__len {
            break;
          }
          new_node = Some(CodeNode::new(self.code.clone().unwrap(), sp, self.i));
          new_node.parsed_type = 12;
          new_node.value_type = 12;
          new_node.string_value = s.substring(sp, self.i );
          self.curr_node.comments.push(new_node.unwrap());
          continue;
        }
        if  self.i < (self.__len - 1) {
          fc = s.charCodeAt((self.i + 1) );
          if  (c == 40) || (c == (123)) {
            self.paren_cnt = self.paren_cnt + 1;
            if  self.curr_node.is_none() {
              self.rootNode = Some(CodeNode::new(self.code.clone().unwrap(), self.i, self.i));
              self.curr_node = self.rootNode.clone();
              self.curr_node.expression = true;
              self.parents.push(self.curr_node.clone().unwrap());
            } else {
              let mut new_qnode : CodeNode = CodeNode::new(self.code.clone().unwrap(), self.i, self.i);
              new_qnode.expression = true;
              self.insert_node(new_qnode.clone());
              self.parents.push(new_qnode.clone());
              self.curr_node = Some(new_qnode.clone());
            }
            if  c == (123) {
              self.curr_node.is_block_node = true;
            }
            self.i = 1 + self.i;
            self.parse(disable_ops_set);
            continue;
          }
        }
        sp = self.i;
        ep = self.i;
        fc = s.charCodeAt(self.i );
        if  (((fc == 45) && ((s.charCodeAt((self.i + 1) )) >= 46)) && ((s.charCodeAt((self.i + 1) )) <= 57)) || ((fc >= 48) && (fc <= 57)) {
          let mut is_double : bool = false;
          sp = self.i;
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
          while (self.i < self.__len) && ((((c >= 48) && (c <= 57)) || (c == (46))) || ((self.i == sp) && ((c == (43)) || (c == (45))))) {
            if  c == (46) {
              is_double = true;
            }
            self.i = 1 + self.i;
            c = s.charCodeAt(self.i );
          }
          ep = self.i;
          let mut new_num_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
          if  is_double {
            new_num_node.parsed_type = 2;
            new_num_node.value_type = 2;
            new_num_node.double_value = (isNaN( parseFloat((s.substring(sp, ep ))) ) ? undefined : parseFloat((s.substring(sp, ep )))).unwrap();
          } else {
            new_num_node.parsed_type = 3;
            new_num_node.value_type = 3;
            new_num_node.int_value = (isNaN( parseInt((s.substring(sp, ep ))) ) ? undefined : parseInt((s.substring(sp, ep )))).unwrap();
          }
          self.insert_node(new_num_node.clone());
          continue;
        }
        let str_limit : u8 = fc;
        let b_had_str : bool = ((fc == 34) || (fc == 96)) || (fc == 39);
        if  b_had_str {
          sp = self.i + 1;
          ep = sp;
          c = s.charCodeAt(self.i );
          let mut must_encode : bool = false;
          while self.i < self.__len {
            self.i = 1 + self.i;
            c = s.charCodeAt(self.i );
            if  c == str_limit {
              break;
            }
            if  c == 92 {
              self.i = 1 + self.i;
              if  self.i < self.__len {
                must_encode = true;
                c = s.charCodeAt(self.i );
              } else {
                break;
              }
            }
          }
          ep = self.i;
          if  self.i < self.__len {
            let mut encoded_str : String = "".to_string();
            if  must_encode {
              let subs : String = s.substring(sp, ep );
              let orig_str : Vec<u8> = subs.into_bytes();
              let str_length : i64 = orig_str.len();
              let mut ii : i64 = 0;
              while ii < str_length {
                let cc : u8 = orig_str.charCodeAt(ii );
                if  cc == 92 {
                  let next_ch : u8 = orig_str.charCodeAt((ii + 1) );
                  switch (next_ch ) { 
                    case 34 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(34)));
                      break;
                    case 92 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(92)));
                      break;
                    case 47 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(47)));
                      break;
                    case 98 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(8)));
                      break;
                    case 102 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(12)));
                      break;
                    case 110 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(10)));
                      break;
                    case 114 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(13)));
                      break;
                    case 116 : 
                      encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(9)));
                      break;
                    case 117 : 
                      ii = ii + 4;
                      break;
                    default: 
                      break;
                  }
                  ii = ii + 2;
                } else {
                  encoded_str = format!("{}{}", encoded_str, (orig_str.substring(ii, (1 + ii) )));
                  ii = ii + 1;
                }
              }
            } else {
            }
            let mut new_str_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
            new_str_node.parsed_type = 4;
            new_str_node.value_type = 4;
            if  must_encode {
              new_str_node.string_value = encoded_str.clone();
            } else {
              new_str_node.string_value = s.substring(sp, ep );
            }
            self.insert_node(new_str_node.clone());
            self.i = 1 + self.i;
            continue;
          }
        }
        if  (((fc == (116)) && ((s.charCodeAt((self.i + 1) )) == (114))) && ((s.charCodeAt((self.i + 2) )) == (117))) && ((s.charCodeAt((self.i + 3) )) == (101)) {
          let mut new_true_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, sp + 4);
          new_true_node.value_type = 5;
          new_true_node.parsed_type = 5;
          new_true_node.boolean_value = true;
          self.insert_node(new_true_node.clone());
          self.i = self.i + 4;
          continue;
        }
        if  ((((fc == (102)) && ((s.charCodeAt((self.i + 1) )) == (97))) && ((s.charCodeAt((self.i + 2) )) == (108))) && ((s.charCodeAt((self.i + 3) )) == (115))) && ((s.charCodeAt((self.i + 4) )) == (101)) {
          let mut new_f_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, sp + 5);
          new_f_node.value_type = 5;
          new_f_node.parsed_type = 5;
          new_f_node.boolean_value = false;
          self.insert_node(new_f_node.clone());
          self.i = self.i + 5;
          continue;
        }
        if  fc == (64) {
          self.i = self.i + 1;
          sp = self.i;
          ep = self.i;
          c = s.charCodeAt(self.i );
          while ((((self.i < self.__len) && ((s.charCodeAt(self.i )) > 32)) && (c != 40)) && (c != 41)) && (c != (125)) {
            self.i = 1 + self.i;
            c = s.charCodeAt(self.i );
          }
          ep = self.i;
          if  (self.i < self.__len) && (ep > sp) {
            let mut a_node2 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
            let a_name : String = s.substring(sp, ep );
            if  a_name == "noinfix".to_string() {
              disable_ops_set = true;
            }
            a_node2.expression = true;
            self.curr_node = Some(a_node2.clone());
            self.parents.push(a_node2.clone());
            self.i = self.i + 1;
            self.paren_cnt = self.paren_cnt + 1;
            self.parse(disable_ops_set);
            let mut use_first : bool = false;
            if  1 == ((a_node2.children.len() as i64)) {
              let mut ch1 : CodeNode = a_node2.children[0 as usize].clone();
              use_first = ch1.isPrimitive();
            }
            if  use_first {
              let mut theNode : CodeNode = a_node2.children.splice(0, 1).pop();
              self.curr_node.props.insert(a_name, theNode);
            } else {
              self.curr_node.props.insert(a_name, a_node2);
            }
            self.curr_node.prop_keys.push(a_name);
            continue;
          }
        }
        let mut ns_list : Vec<String> = Vec::new();
        let mut last_ns : i64 = self.i;
        let mut ns_cnt : i64 = 1;
        let mut vref_had_type_ann : bool = false;
        let mut vref_ann_node : Option<CodeNode> = None;
        let mut vref_end : i64 = self.i;
        if  (((((self.i < self.__len) && ((s.charCodeAt(self.i )) > 32)) && (c != 58)) && (c != 40)) && (c != 41)) && (c != (125)) {
          if  self.curr_node.is_block_node == true {
            let mut new_expr_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
            new_expr_node.parent = self.curr_node.clone();
            new_expr_node.expression = true;
            self.curr_node.children.push(new_expr_node.clone());
            self.curr_node = Some(new_expr_node.clone());
            self.parents.push(new_expr_node.clone());
            self.paren_cnt = 1 + self.paren_cnt;
            self.parse(disable_ops_set);
            continue;
          }
        }
        let mut op_c : i64 = 0;
        op_c = self.getOperator(disable_ops_set);
        let mut last_was_newline : bool = false;
        if  op_c > 0 {
        } else {
          while (((((self.i < self.__len) && ((s.charCodeAt(self.i )) > 32)) && (c != 58)) && (c != 40)) && (c != 41)) && (c != (125)) {
            if  self.i > sp {
              let is_opchar : i64 = self.isOperator(disable_ops_set);
              if  is_opchar > 0 {
                break;
              }
            }
            self.i = 1 + self.i;
            c = s.charCodeAt(self.i );
            if  (c == 10) || (c == 13) {
              last_was_newline = true;
              break;
            }
            if  c == (46) {
              ns_list.push(s.substring(last_ns, self.i ));
              last_ns = self.i + 1;
              ns_cnt = 1 + ns_cnt;
            }
            if  (self.i > vref_end) && (c == (64)) {
              vref_had_type_ann = true;
              vref_end = self.i;
              vref_ann_node = Some(self.parse_raw_annotation());
              c = s.charCodeAt(self.i );
              break;
            }
          }
        }
        ep = self.i;
        if  vref_had_type_ann {
          ep = vref_end;
        }
        ns_list.push(s.substring(last_ns, ep ));
        c = s.charCodeAt(self.i );
        while ((self.i < self.__len) && (c <= 32)) && (false == last_was_newline) {
          self.i = 1 + self.i;
          c = s.charCodeAt(self.i );
          if  is_block_parent && ((c == 10) || (c == 13)) {
            self.i = self.i - 1;
            c = s.charCodeAt(self.i );
            had_lf = true;
            break;
          }
        }
        if  (false == disable_ops_set) && (c == (58)) {
          self.i = self.i + 1;
          while (self.i < self.__len) && ((s.charCodeAt(self.i )) <= 32) {
            self.i = 1 + self.i;
          }
          let mut vt_sp : i64 = self.i;
          let mut vt_ep : i64 = self.i;
          c = s.charCodeAt(self.i );
          if  c == (40) {
            let mut vann_arr2 : CodeNode = self.parse_raw_annotation();
            vann_arr2.expression = true;
            let mut new_expr_node_1 : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, vt_ep);
            new_expr_node_1.vref = s.substring(sp, ep );
            new_expr_node_1.ns = ns_list.clone();
            new_expr_node_1.expression_value = Some(Box::new(vann_arr2.clone()));
            new_expr_node_1.parsed_type = 17;
            new_expr_node_1.value_type = 17;
            if  vref_had_type_ann {
              new_expr_node_1.vref_annotation = vref_ann_node.clone();
              new_expr_node_1.has_vref_annotation = true;
            }
            self.curr_node.children.push(new_expr_node_1.clone());
            continue;
          }
          if  c == (91) {
            self.i = self.i + 1;
            vt_sp = self.i;
            let mut hash_sep : i64 = 0;
            let mut had_array_type_ann : bool = false;
            c = s.charCodeAt(self.i );
            while ((self.i < self.__len) && (c > 32)) && (c != 93) {
              self.i = 1 + self.i;
              c = s.charCodeAt(self.i );
              if  c == (58) {
                hash_sep = self.i;
              }
              if  c == (64) {
                had_array_type_ann = true;
                break;
              }
            }
            vt_ep = self.i;
            if  hash_sep > 0 {
              vt_ep = self.i;
              let type_name : String = s.substring((1 + hash_sep), vt_ep );
              let key_type_name : String = s.substring(vt_sp, hash_sep );
              let mut new_hash_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, vt_ep);
              new_hash_node.vref = s.substring(sp, ep );
              new_hash_node.ns = ns_list.clone();
              new_hash_node.parsed_type = 7;
              new_hash_node.value_type = 7;
              new_hash_node.array_type = type_name.clone();
              new_hash_node.key_type = key_type_name.clone();
              if  vref_had_type_ann {
                new_hash_node.vref_annotation = vref_ann_node.clone();
                new_hash_node.has_vref_annotation = true;
              }
              if  had_array_type_ann {
                let mut vann_hash : CodeNode = self.parse_raw_annotation();
                new_hash_node.type_annotation = Some(Box::new(vann_hash.clone()));
                new_hash_node.has_type_annotation = true;
              }
              new_hash_node.parent = self.curr_node.clone();
              self.curr_node.children.push(new_hash_node.clone());
              self.i = 1 + self.i;
              continue;
            } else {
              vt_ep = self.i;
              let type_name_1 : String = s.substring(vt_sp, vt_ep );
              let mut new_arr_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, vt_ep);
              new_arr_node.vref = s.substring(sp, ep );
              new_arr_node.ns = ns_list.clone();
              new_arr_node.parsed_type = 6;
              new_arr_node.value_type = 6;
              new_arr_node.array_type = type_name_1.clone();
              new_arr_node.parent = self.curr_node.clone();
              self.curr_node.children.push(new_arr_node.clone());
              if  vref_had_type_ann {
                new_arr_node.vref_annotation = vref_ann_node.clone();
                new_arr_node.has_vref_annotation = true;
              }
              if  had_array_type_ann {
                let mut vann_arr : CodeNode = self.parse_raw_annotation();
                new_arr_node.type_annotation = Some(Box::new(vann_arr.clone()));
                new_arr_node.has_type_annotation = true;
                println!( "{}", "--> parsed ARRAY TYPE annotation".to_string() );
              }
              self.i = 1 + self.i;
              continue;
            }
          }
          let mut had_type_ann : bool = false;
          while (self.i < self.__len) && operatorsOfchar_23::isc95notc95limiter_24(c) {
            self.i = 1 + self.i;
            c = s.charCodeAt(self.i );
            if  c == (64) {
              had_type_ann = true;
              break;
            }
          }
          if  self.i < self.__len {
            vt_ep = self.i;
            /** unused:  let type_name_2 : String = s.substring(vt_sp, vt_ep );   **/ 
            let mut new_ref_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
            new_ref_node.vref = s.substring(sp, ep );
            new_ref_node.ns = ns_list.clone();
            new_ref_node.parsed_type = 11;
            new_ref_node.value_type = 11;
            new_ref_node.type_name = s.substring(vt_sp, vt_ep );
            new_ref_node.parent = self.curr_node.clone();
            if  vref_had_type_ann {
              new_ref_node.vref_annotation = vref_ann_node.clone();
              new_ref_node.has_vref_annotation = true;
            }
            self.curr_node.children.push(new_ref_node.clone());
            if  had_type_ann {
              let mut vann : CodeNode = self.parse_raw_annotation();
              new_ref_node.type_annotation = Some(Box::new(vann.clone()));
              new_ref_node.has_type_annotation = true;
            }
            continue;
          }
        } else {
          if  (self.i < self.__len) && (ep > sp) {
            let mut new_vref_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
            new_vref_node.vref = s.substring(sp, ep );
            new_vref_node.parsed_type = 11;
            new_vref_node.value_type = 11;
            new_vref_node.ns = ns_list.clone();
            new_vref_node.parent = self.curr_node.clone();
            let op_pred : i64 = self.getOperatorPred(new_vref_node.vref.clone(), disable_ops_set);
            if  new_vref_node.vref == ",".to_string() {
              self.curr_node.infix_operator = false;
              continue;
            }
            let mut pTarget : Option<CodeNode> = self.curr_node;
            if  self.curr_node.infix_operator {
              let mut iNode : Option<CodeNode> = self.curr_node.infix_node;
              if  (op_pred > 0) || (iNode.to_the_right == false) {
                pTarget = iNode.clone();
              } else {
                let mut rn : Option<CodeNode> = iNode.right_node;
                new_vref_node.parent = Some(Box::new(rn.clone()));
                pTarget = rn.clone();
              }
            }
            pTarget.children.push(new_vref_node.clone());
            if  vref_had_type_ann {
              new_vref_node.vref_annotation = vref_ann_node.clone();
              new_vref_node.has_vref_annotation = true;
            }
            if  (self.i + 1) < self.__len {
              if  ((s.charCodeAt((self.i + 1) )) == (40)) || ((s.charCodeAt((self.i + 0) )) == (40)) {
                if  ((0 == op_pred) && self.curr_node.infix_operator) && (1 == ((self.curr_node.children.len() as i64))) {
                }
              }
            }
            if  ((op_pred > 0) && self.curr_node.infix_operator) || ((op_pred > 0) && (((self.curr_node.children.len() as i64)) >= 2)) {
              if  (op_pred == 3) && (2 == ((self.curr_node.children.len() as i64))) {
                let mut n_ch : CodeNode = self.curr_node.children.splice(0, 1).pop();
                self.curr_node.children.push(n_ch.clone());
              } else {
                if  false == self.curr_node.infix_operator {
                  let mut if_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
                  self.curr_node.infix_node = Some(Box::new(if_node.clone()));
                  self.curr_node.infix_operator = true;
                  if_node.infix_subnode = true;
                  self.curr_node.value_type = 0;
                  self.curr_node.parsed_type = self.curr_node.value_type;
                  self.curr_node.expression = true;
                  if_node.expression = true;
                  let mut ch_cnt : i64 = (self.curr_node.children.len() as i64);
                  let mut ii_1 : i64 = 0;
                  let start_from : i64 = ch_cnt - 2;
                  let mut keep_nodes : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
                  while ch_cnt > 0 {
                    let mut n_ch_1 : CodeNode = self.curr_node.children.splice(0, 1).pop();
                    let mut p_target : CodeNode = if_node;
                    if  (ii_1 < start_from) || n_ch_1.infix_subnode {
                      p_target = keep_nodes.clone();
                    }
                    p_target.children.push(n_ch_1.clone());
                    ch_cnt = ch_cnt - 1;
                    ii_1 = 1 + ii_1;
                  }
                  for i2 in 0..keep_nodes.children.len() {
                    let mut keep = keep_nodes.children[i2 as usize].clone();
                    self.curr_node.children.push(keep.clone());
                  }
                  self.curr_node.children.push(if_node.clone());
                }
                let mut ifNode : Option<CodeNode> = self.curr_node.infix_node;
                let mut new_op_node : CodeNode = CodeNode::new(self.code.clone().unwrap(), sp, ep);
                new_op_node.expression = true;
                new_op_node.parent = Some(Box::new(ifNode.clone()));
                let mut until_index : i64 = ((ifNode.children.len() as i64)) - 1;
                let mut to_right : bool = false;
                let just_continue : bool = false;
                if  (ifNode.operator_pred > 0) && (ifNode.operator_pred < op_pred) {
                  to_right = true;
                }
                if  (ifNode.operator_pred > 0) && (ifNode.operator_pred > op_pred) {
                  ifNode.to_the_right = false;
                }
                if  (ifNode.operator_pred > 0) && (ifNode.operator_pred == op_pred) {
                  to_right = ifNode.to_the_right;
                }
                /** unused:  let mut opTarget : Option<CodeNode> = ifNode;   **/ 
                if  to_right {
                  let mut op_node : CodeNode = ifNode.children.splice(until_index, 1).pop();
                  let mut last_value : CodeNode = ifNode.children.splice((until_index - 1), 1).pop();
                  new_op_node.children.push(op_node.clone());
                  new_op_node.children.push(last_value.clone());
                } else {
                  if  false == just_continue {
                    while until_index > 0 {
                      let mut what_to_add : CodeNode = ifNode.children.splice(0, 1).pop();
                      new_op_node.children.push(what_to_add.clone());
                      until_index = until_index - 1;
                    }
                  }
                }
                if  to_right || (false == just_continue) {
                  ifNode.children.push(new_op_node.clone());
                }
                if  to_right {
                  ifNode.right_node = Some(Box::new(new_op_node.clone()));
                  ifNode.to_the_right = true;
                }
                ifNode.operator_pred = op_pred;
                continue;
              }
            }
            continue;
          }
        }
        if  (c == 41) || (c == (125)) {
          if  ((c == (125)) && is_block_parent) && (((self.curr_node.children.len() as i64)) > 0) {
            self.end_expression();
          }
          self.i = 1 + self.i;
          self.paren_cnt = self.paren_cnt - 1;
          if  self.paren_cnt < 0 {
            break;
          }
          self.parents.pop();
          if  self.curr_node.is_some() {
            self.curr_node.ep = self.i;
          }
          if  ((self.parents.len() as i64)) > 0 {
            self.curr_node = Some(self.parents[(((self.parents.len() as i64)) - 1) as usize].clone());
          } else {
            self.curr_node = self.rootNode.clone();
          }
          break;
        }
        if  last_i == self.i {
          self.i = 1 + self.i;
        }
      }
    }
  }
}
#[derive(Clone)]
struct RangerArgMatch { 
  _debug : bool, 
  matched : HashMap<String,String>, 
  nodes : HashMap<String,CodeNode>, 
  builtNodes : HashMap<String,CodeNode>, 
  matchedLambdas : HashMap<String,CodeNode>, 
}
impl RangerArgMatch { 
  
  pub fn new() ->  RangerArgMatch {
    let mut me = RangerArgMatch { 
      _debug:false, 
      matched: None, 
      nodes: None, 
      builtNodes: None, 
      matchedLambdas: None, 
    };
    return me;
  }
  fn matchArguments(&mut self, mut args : CodeNode, mut callArgs : CodeNode, mut ctx : RangerAppWriterContext, firstArgIndex : i64) -> bool {
    /** unused:  let mut fc : CodeNode = callArgs.children[0 as usize].clone();   **/ 
    let mut missed_args : Vec<String> = Vec::new();
    let mut all_matched : bool = true;
    if  (((args.children.len() as i64)) == 0) && (((callArgs.children.len() as i64)) > 1) {
      return false;
    }
    let mut lastArg : Option<CodeNode> = None;
    for i in 0..callArgs.children.len() {
      let mut callArg = callArgs.children[i as usize].clone();
      if  i == 0 {
        continue;
      }
      if  callArg.is_part_of_chain {
        continue;
      }
      let arg_index : i64 = i - 1;
      if  arg_index < ((args.children.len() as i64)) {
        lastArg = Some(args.children[arg_index as usize].clone());
      }
      let mut arg : CodeNode = lastArg.unwrap();
      if  arg.hasFlag("ignore".to_string()) {
        continue;
      }
      if  arg.hasFlag("keyword".to_string()) {
        if  callArg.vref == arg.vref {
          continue;
        } else {
          all_matched = false;
          break;
        }
      }
      if  arg.isPrimitiveType() {
        if  (callArg.value_type == 17) || (callArg.eval_type == 17) {
          all_matched = false;
          break;
        }
      }
      let mut call_arg_immutable : bool = false;
      if  callArg.hasParamDesc {
        let mut pa : Option<RangerAppParamDesc> = callArg.paramDesc;
        if  pa.nameNode.is_some() {
          let b_immutable : bool = pa.nameNode.hasFlag("immutable".to_string());
          if  arg.hasFlag("immutable".to_string()) != b_immutable {
            all_matched = false;
          }
          call_arg_immutable = b_immutable;
        } else {
          call_arg_immutable = pa.is_immutable;
        }
      }
      if  callArg.hasFlag("immutable".to_string()) {
        call_arg_immutable = true;
      }
      if  arg.hasFlag("immutable".to_string()) {
        if  false == call_arg_immutable {
          all_matched = false;
          break;
        }
      }
      if  true {
        if  (arg.type_name == "block".to_string()) || arg.hasFlag("block".to_string()) {
          if  callArg.is_block_node {
            continue;
          } else {
            all_matched = false;
          }
        }
      }
      if  arg.hasFlag("mutable".to_string()) {
        if  callArg.hasParamDesc {
          let mut pa_1 : Option<RangerAppParamDesc> = callArg.paramDesc;
          let b : bool = pa_1.nameNode.hasFlag("mutable".to_string());
          if  b == false {
            missed_args.push("was mutable".to_string().to_string());
            all_matched = false;
          }
        } else {
          all_matched = false;
        }
      }
      if  arg.hasFlag("union".to_string()) {
        if  ctx.isDefinedClass(callArg.eval_type_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(callArg.eval_type_name.clone());
          if  (cc.is_union == false) && (cc.is_system_union == false) {
            all_matched = false;
          }
        } else {
          all_matched = false;
        }
      }
      if  arg.hasFlag("optional".to_string()) {
        if  callArg.hasParamDesc {
          let mut pa_2 : Option<RangerAppParamDesc> = callArg.paramDesc;
          let b_1 : bool = pa_2.nameNode.hasFlag("optional".to_string());
          if  b_1 == false {
            missed_args.push("optional was missing".to_string().to_string());
            all_matched = false;
          }
        } else {
          if  callArg.hasFlag("optional".to_string()) {
          } else {
            all_matched = false;
          }
        }
      }
      if  callArg.hasFlag("optional".to_string()) {
        if  false == arg.hasFlag("optional".to_string()) {
          if  callArg.is_block_node {
          } else {
            all_matched = false;
          }
        }
      }
      if  (arg.value_type != 7) && (arg.value_type != 6) {
        if  callArg.paramDesc.is_some() {
          if  (callArg.paramDesc.nameNode.is_some()) && (callArg.paramDesc.nameNode.expression_value.is_some()) {
            self.matched.insert(arg.type_name, "".to_string());
            self.matchedLambdas.insert(arg.type_name, (*callArg.paramDesc.nameNode.expression_value.clone().unwrap()));
            continue;
          }
        }
        if  callArg.eval_type == 13 {
          if  arg.type_name == "enum".to_string() {
            continue;
          }
        }
        if  self._debug {
          println!( "{}", format!("{}{}", "-> trying to add type ".to_string(), arg.type_name) );
        }
        if  false == self.add(arg.type_name.clone(), callArg.eval_type_name.clone(), ctx.clone()) {
          all_matched = false;
          return all_matched;
        }
      }
      if  arg.value_type == 6 {
        if  false == self.add_atype(arg.array_type.clone(), callArg.eval_array_type.clone(), ctx.clone()) {
          all_matched = false;
        }
      }
      if  arg.value_type == 7 {
        if  false == self.add(arg.key_type.clone(), callArg.eval_key_type.clone(), ctx.clone()) {
          all_matched = false;
        }
        if  false == self.add_atype(arg.array_type.clone(), callArg.eval_array_type.clone(), ctx.clone()) {
          all_matched = false;
        }
      }
      let mut did_match : bool = false;
      if  self.doesMatch(arg.clone(), callArg.clone(), ctx.clone()) {
        did_match = true;
      } else {
        missed_args.push(format!("{}{}", (format!("{}{}", (format!("{}{}", "matching arg ".to_string(), arg.vref)), " faileg against ".to_string())), callArg.vref));
      }
      if  false == did_match {
        all_matched = false;
      }
    }
    return all_matched;
  }
  fn force_add(&mut self, tplKeyword : String, typeName : String, mut ctx : RangerAppWriterContext) -> () {
    self.matched.insert(tplKeyword, typeName);
  }
  fn addNode(&mut self, name : String, mut node : CodeNode) -> () {
    self.nodes.insert(name, node);
  }
  fn add(&mut self, tplKeyword : String, typeName : String, mut ctx : RangerAppWriterContext) -> bool {
    switch (tplKeyword ) { 
      case "string".to_string() : 
        return true;
        break;
      case "int".to_string() : 
        return true;
        break;
      case "double".to_string() : 
        return true;
        break;
      case "boolean".to_string() : 
        return true;
        break;
      case "enum".to_string() : 
        return true;
        break;
      case "char".to_string() : 
        return true;
        break;
      case "charbuffer".to_string() : 
        return true;
        break;
    }
    if  (tplKeyword.len() as i64) > 1 {
      return true;
    }
    if  self.matched.contains_key(&tplKeyword) {
      let s : String = (self.matched.get(tplKeyword)).unwrap();
      if  self.areEqualTypes(s.clone(), typeName.clone(), ctx.clone()) {
        return true;
      }
      if  s == typeName {
        return true;
      } else {
        return false;
      }
    }
    self.matched.insert(tplKeyword, typeName);
    return true;
  }
  fn add_atype(&mut self, tplKeyword : String, typeName : String, mut ctx : RangerAppWriterContext) -> bool {
    switch (tplKeyword ) { 
      case "string".to_string() : 
        return true;
        break;
      case "int".to_string() : 
        return true;
        break;
      case "double".to_string() : 
        return true;
        break;
      case "boolean".to_string() : 
        return true;
        break;
      case "enum".to_string() : 
        return true;
        break;
      case "char".to_string() : 
        return true;
        break;
      case "charbuffer".to_string() : 
        return true;
        break;
    }
    if  (tplKeyword.len() as i64) > 1 {
      return true;
    }
    if  self.matched.contains_key(&tplKeyword) {
      let s : String = (self.matched.get(tplKeyword)).unwrap();
      if  self.areEqualATypes(s.clone(), typeName.clone(), ctx.clone()) {
        return true;
      }
      if  s == typeName {
        return true;
      } else {
        return false;
      }
    }
    self.matched.insert(tplKeyword, typeName);
    return true;
  }
  fn doesDefsMatch(&mut self, mut arg : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext) -> bool {
    if  node.value_type == 13 {
      if  arg.type_name == "enum".to_string() {
        return true;
      } else {
        return false;
      }
    }
    if  (arg.value_type != 7) && (arg.value_type != 6) {
      let eq : bool = self.areEqualTypes(arg.type_name.clone(), node.type_name.clone(), ctx.clone());
      let t_name : String = arg.type_name.clone();
      switch (t_name ) { 
        case "expression".to_string() : 
          return node.expression;
          break;
        case "block".to_string() : 
          return node.expression;
          break;
        case "arguments".to_string() : 
          return node.expression;
          break;
        case "keyword".to_string() : 
          return node.eval_type == 11;
          break;
        case "T.name".to_string() : 
          return node.eval_type_name == t_name;
          break;
      }
      return eq;
    }
    if  (arg.value_type == 6) && (node.eval_type == 6) {
      let same_arrays : bool = self.areEqualTypes(arg.array_type.clone(), node.array_type.clone(), ctx.clone());
      return same_arrays;
    }
    if  (arg.value_type == 7) && (node.eval_type == 7) {
      let same_arrays_1 : bool = self.areEqualTypes(arg.array_type.clone(), node.array_type.clone(), ctx.clone());
      let same_keys : bool = self.areEqualTypes(arg.key_type.clone(), node.key_type.clone(), ctx.clone());
      return same_arrays_1 && same_keys;
    }
    return false;
  }
  fn doesMatch(&mut self, mut arg : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext) -> bool {
    if  node.value_type == 13 {
      if  arg.type_name == "enum".to_string() {
        return true;
      } else {
        return false;
      }
    }
    if  (arg.value_type != 7) && (arg.value_type != 6) {
      let eq : bool = self.areEqualTypes(arg.type_name.clone(), node.eval_type_name.clone(), ctx.clone());
      let t_name : String = arg.type_name.clone();
      switch (t_name ) { 
        case "expression".to_string() : 
          return node.expression;
          break;
        case "block".to_string() : 
          return node.expression;
          break;
        case "arguments".to_string() : 
          return node.expression;
          break;
        case "keyword".to_string() : 
          return node.eval_type == 11;
          break;
        case "T.name".to_string() : 
          return node.eval_type_name == t_name;
          break;
      }
      return eq;
    }
    if  (arg.value_type == 6) && (node.eval_type == 6) {
      let same_arrays : bool = self.areEqualTypes(arg.array_type.clone(), node.eval_array_type.clone(), ctx.clone());
      return same_arrays;
    }
    if  (arg.value_type == 7) && (node.eval_type == 7) {
      let same_arrays_1 : bool = self.areEqualTypes(arg.array_type.clone(), node.eval_array_type.clone(), ctx.clone());
      let same_keys : bool = self.areEqualTypes(arg.key_type.clone(), node.eval_key_type.clone(), ctx.clone());
      return same_arrays_1 && same_keys;
    }
    return false;
  }
  fn areEqualTypes(&mut self, type1 : String, type2 : String, mut ctx : RangerAppWriterContext) -> bool {
    let mut t_name : String = type1;
    if  self.matched.contains_key(&type1) {
      t_name = (self.matched.get(type1)).unwrap();
    }
    switch (t_name ) { 
      case "string".to_string() : 
        return type2 == "string".to_string();
        break;
      case "int".to_string() : 
        return type2 == "int".to_string();
        break;
      case "double".to_string() : 
        return type2 == "double".to_string();
        break;
      case "boolean".to_string() : 
        return type2 == "boolean".to_string();
        break;
      case "enum".to_string() : 
        return type2 == "enum".to_string();
        break;
      case "char".to_string() : 
        return type2 == "char".to_string();
        break;
      case "charbuffer".to_string() : 
        return type2 == "charbuffer".to_string();
        break;
    }
    if  ctx.isDefinedClass(t_name.clone()) && ctx.isDefinedClass(type2.clone()) {
      let mut c1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
      let mut c2 : RangerAppClassDesc = ctx.findClass(type2.clone());
      let mut trait1 : Option<RangerAppClassDesc> = c1.hasTrait(type2.clone(), ctx.clone());
      if  (c2.is_union == true) && (c1.is_union == false) {
        return false;
      }
      if  (c2.is_system_union == true) && (c1.is_system_union == false) {
        return false;
      }
      if  trait1.is_some() {
        self.force_add(type2.clone(), c1.name.clone(), ctx.clone());
        if  c1.trait_params.contains_key(&type2) {
          let mut pms : RangerTraitParams = (c1.trait_params.get(type2)).unwrap();
          for i in 0..pms.param_names.len() {
            let mut pn = pms.param_names[i as usize].clone();
            let pn_value : String = (pms.values.get(pn)).unwrap();
            self.add(pn.clone(), pn_value.clone(), ctx.clone());
          }
        }
      }
      let mut trait1_1 : Option<RangerAppClassDesc> = c2.hasTrait(t_name.clone(), ctx.clone());
      if  trait1_1.is_some() {
        self.force_add(t_name.clone(), c2.name.clone(), ctx.clone());
        if  c2.trait_params.contains_key(&t_name) {
          let mut pms_1 : RangerTraitParams = (c2.trait_params.get(t_name)).unwrap();
          for i_1 in 0..pms_1.param_names.len() {
            let mut pn_1 = pms_1.param_names[i_1 as usize].clone();
            let pn_value_1 : String = (pms_1.values.get(pn_1)).unwrap();
            self.add(pn_1.clone(), pn_value_1.clone(), ctx.clone());
          }
        } else {
        }
      }
      if  c1.isSameOrParentClass(type2.clone(), ctx.clone()) {
        return true;
      }
      if  c2.isSameOrParentClass(t_name.clone(), ctx.clone()) {
        return true;
      }
    } else {
      if  ctx.isDefinedClass(t_name.clone()) {
        let mut c1_1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
        if  c1_1.isSameOrParentClass(type2.clone(), ctx.clone()) {
          return true;
        }
      }
    }
    return t_name == type2;
  }
  fn areEqualATypes(&mut self, type1 : String, type2 : String, mut ctx : RangerAppWriterContext) -> bool {
    let mut t_name : String = type1;
    if  self.matched.contains_key(&type1) {
      t_name = (self.matched.get(type1)).unwrap();
    }
    switch (t_name ) { 
      case "string".to_string() : 
        return type2 == "string".to_string();
        break;
      case "int".to_string() : 
        return type2 == "int".to_string();
        break;
      case "double".to_string() : 
        return type2 == "double".to_string();
        break;
      case "boolean".to_string() : 
        return type2 == "boolean".to_string();
        break;
      case "enum".to_string() : 
        return type2 == "enum".to_string();
        break;
      case "char".to_string() : 
        return type2 == "char".to_string();
        break;
      case "charbuffer".to_string() : 
        return type2 == "charbuffer".to_string();
        break;
    }
    if  ctx.isDefinedClass(t_name.clone()) && ctx.isDefinedClass(type2.clone()) {
      let mut c1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
      let mut c2 : RangerAppClassDesc = ctx.findClass(type2.clone());
      let mut trait1 : Option<RangerAppClassDesc> = c1.hasTrait(type2.clone(), ctx.clone());
      if  (c2.is_union == true) && (c1.is_union == false) {
        return false;
      }
      if  (c2.is_system_union == true) && (c1.is_system_union == false) {
        return false;
      }
      if  trait1.is_some() {
        self.force_add(type2.clone(), c1.name.clone(), ctx.clone());
        if  c1.trait_params.contains_key(&type2) {
          let mut pms : RangerTraitParams = (c1.trait_params.get(type2)).unwrap();
          for i in 0..pms.param_names.len() {
            let mut pn = pms.param_names[i as usize].clone();
            let pn_value : String = (pms.values.get(pn)).unwrap();
            self.add(pn.clone(), pn_value.clone(), ctx.clone());
          }
        }
      }
      let mut trait1_1 : Option<RangerAppClassDesc> = c2.hasTrait(t_name.clone(), ctx.clone());
      if  trait1_1.is_some() {
        self.force_add(t_name.clone(), c2.name.clone(), ctx.clone());
        if  c2.trait_params.contains_key(&t_name) {
          let mut pms_1 : RangerTraitParams = (c2.trait_params.get(t_name)).unwrap();
          for i_1 in 0..pms_1.param_names.len() {
            let mut pn_1 = pms_1.param_names[i_1 as usize].clone();
            let pn_value_1 : String = (pms_1.values.get(pn_1)).unwrap();
            self.add(pn_1.clone(), pn_value_1.clone(), ctx.clone());
          }
        } else {
        }
      }
      if  c1.isSameOrParentClass(type2.clone(), ctx.clone()) {
        return true;
      }
      if  c2.isSameOrParentClass(t_name.clone(), ctx.clone()) {
        return true;
      }
    } else {
    }
    return t_name == type2;
  }
  fn getTypeName(&mut self, n : String) -> String {
    let mut t_name : String = n;
    if  self.matched.contains_key(&t_name) {
      t_name = (self.matched.get(t_name)).unwrap();
    }
    if  0 == (t_name.len() as i64) {
      return "".to_string().clone();
    }
    return t_name.clone();
  }
  fn getType(&mut self, n : String) -> i64 {
    let mut t_name : String = n;
    if  self.matched.contains_key(&t_name) {
      t_name = (self.matched.get(t_name)).unwrap();
    }
    if  0 == (t_name.len() as i64) {
      return 0;
    }
    switch (t_name ) { 
      case "expression".to_string() : 
        return 16;
        break;
      case "block".to_string() : 
        return 16;
        break;
      case "arguments".to_string() : 
        return 16;
        break;
      case "string".to_string() : 
        return 4;
        break;
      case "int".to_string() : 
        return 3;
        break;
      case "char".to_string() : 
        return 14;
        break;
      case "charbuffer".to_string() : 
        return 15;
        break;
      case "boolean".to_string() : 
        return 5;
        break;
      case "double".to_string() : 
        return 2;
        break;
      case "enum".to_string() : 
        return 13;
        break;
    }
    return 10;
  }
  fn setRvBasedOn(&mut self, mut arg : CodeNode, mut node : CodeNode) -> bool {
    if  arg.hasFlag("optional".to_string()) {
      node.setFlag("optional".to_string());
    }
    if  arg.hasFlag("immutable".to_string()) {
      node.setFlag("immutable".to_string());
    }
    if  (arg.value_type != 7) && (arg.value_type != 6) {
      if  self.matchedLambdas.contains_key(&arg.type_name) {
        let mut lam : Option<CodeNode> = self.matchedLambdas.get(arg.type_name);
        node.eval_type = 17;
        node.expression_value = Some(Box::new(lam.copy().clone()));
        return true;
      }
      node.eval_type = self.getType(arg.type_name.clone());
      node.eval_type_name = self.getTypeName(arg.type_name.clone());
      return true;
    }
    if  arg.value_type == 6 {
      node.eval_type = 6;
      node.eval_array_type = self.getTypeName(arg.array_type.clone());
      return true;
    }
    if  arg.value_type == 7 {
      node.eval_type = 7;
      node.eval_key_type = self.getTypeName(arg.key_type.clone());
      node.eval_array_type = self.getTypeName(arg.array_type.clone());
      return true;
    }
    return false;
  }
}
#[derive(Clone)]
struct DictNode { 
  is_property : bool, 
  is_property_value : bool, 
  vref : String, 
  value_type : i64, 
  double_value : f64, 
  int_value : i64, 
  string_value : String, 
  boolean_value : bool, 
  object_value : Option<Box<DictNode>>, 
  children : Vec<DictNode>, 
  objects : HashMap<String,DictNode>, 
  dict_keys : Vec<String>, 
}
impl DictNode { 
  
  pub fn new() ->  DictNode {
    let mut me = DictNode { 
      is_property:false, 
      is_property_value:false, 
      vref:"".to_string(), 
      value_type:6, 
      double_value:0_f64, 
      int_value:0, 
      string_value:"".to_string(), 
      boolean_value:false, 
      object_value: None, 
      children: Vec::new(), 
      objects: None, 
      dict_keys: Vec::new(), 
    };
    return me;
  }
  pub fn createEmptyObject() -> DictNode {
    let mut v : DictNode = DictNode::new();
    v.value_type = 6;
    return v.clone();
  }
  fn EncodeString(&mut self, orig_str : String) -> String {
    let mut encoded_str : String = "".to_string();
    /** unused:  let str_length : i64 = orig_str.len() as i64;   **/ 
    let mut ii : i64 = 0;
    let buff : Vec<u8> = orig_str.into_bytes();
    let cb_len : i64 = buff.len();
    while ii < cb_len {
      let cc : u8 = buff.charCodeAt(ii );
      switch (cc ) { 
        case 8 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(98)));
          break;
        case 9 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(116)));
          break;
        case 10 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(110)));
          break;
        case 12 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(102)));
          break;
        case 13 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(114)));
          break;
        case 34 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), "\"".to_string());
          break;
        case 92 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(92)));
          break;
        case 47 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(47)));
          break;
        default: 
          encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(cc)));
          break;
      }
      ii = 1 + ii;
    }
    return encoded_str.clone();
  }
  fn addString(&mut self, key : String, value : String) -> () {
    if  self.value_type == 6 {
      let mut v : DictNode = DictNode::new();
      v.string_value = value.clone();
      v.value_type = 3;
      v.vref = key.clone();
      v.is_property = true;
      self.dict_keys.push(key);
      self.objects.insert(key, v);
    }
  }
  fn addDouble(&mut self, key : String, value : f64) -> () {
    if  self.value_type == 6 {
      let mut v : DictNode = DictNode::new();
      v.double_value = value;
      v.value_type = 1;
      v.vref = key.clone();
      v.is_property = true;
      self.dict_keys.push(key);
      self.objects.insert(key, v);
    }
  }
  fn addInt(&mut self, key : String, value : i64) -> () {
    if  self.value_type == 6 {
      let mut v : DictNode = DictNode::new();
      v.int_value = value;
      v.value_type = 2;
      v.vref = key.clone();
      v.is_property = true;
      self.dict_keys.push(key);
      self.objects.insert(key, v);
    }
  }
  fn addBoolean(&mut self, key : String, value : bool) -> () {
    if  self.value_type == 6 {
      let mut v : DictNode = DictNode::new();
      v.boolean_value = value;
      v.value_type = 4;
      v.vref = key.clone();
      v.is_property = true;
      self.dict_keys.push(key);
      self.objects.insert(key, v);
    }
  }
  fn addObject(&mut self, key : String) -> Option<Box<DictNode>> {
    let mut v : Option<Box<DictNode>> = None;
    if  self.value_type == 6 {
      let mut p : DictNode = DictNode::new();
      v = Some(DictNode::new());
      p.value_type = 6;
      p.vref = key.clone();
      p.is_property = true;
      v.value_type = 6;
      v.vref = key.clone();
      v.is_property_value = true;
      p.object_value = v.clone();
      self.dict_keys.push(key);
      self.objects.insert(key, p);
      return v.clone();
    }
    return v.clone();
  }
  fn setObject(&mut self, key : String, mut value : DictNode) -> () {
    if  self.value_type == 6 {
      let mut p : DictNode = DictNode::new();
      p.value_type = 6;
      p.vref = key.clone();
      p.is_property = true;
      value.is_property_value = true;
      value.vref = key.clone();
      p.object_value = Some(Box::new(value.clone()));
      self.dict_keys.push(key);
      self.objects.insert(key, p);
    }
  }
  fn addArray(&mut self, key : String) -> Option<Box<DictNode>> {
    let mut v : Option<Box<DictNode>> = None;
    if  self.value_type == 6 {
      v = Some(DictNode::new());
      v.value_type = 5;
      v.vref = key.clone();
      v.is_property = true;
      self.dict_keys.push(key);
      self.objects.insert(key, v.unwrap());
      return v.clone();
    }
    return v.clone();
  }
  fn push(&mut self, mut obj : DictNode) -> () {
    if  self.value_type == 5 {
      self.children.push(obj.clone());
    }
  }
  fn getDoubleAt(&mut self, index : i64) -> f64 {
    if  index < ((self.children.len() as i64)) {
      let mut k : DictNode = self.children[index as usize].clone();
      return k.double_value;
    }
    return 0_f64;
  }
  fn getStringAt(&mut self, index : i64) -> String {
    if  index < ((self.children.len() as i64)) {
      let mut k : DictNode = self.children[index as usize].clone();
      return k.string_value.clone();
    }
    return "".to_string().clone();
  }
  fn getIntAt(&mut self, index : i64) -> i64 {
    if  index < ((self.children.len() as i64)) {
      let mut k : DictNode = self.children[index as usize].clone();
      return k.int_value;
    }
    return 0;
  }
  fn getBooleanAt(&mut self, index : i64) -> bool {
    if  index < ((self.children.len() as i64)) {
      let mut k : DictNode = self.children[index as usize].clone();
      return k.boolean_value;
    }
    return false;
  }
  fn getString(&mut self, key : String) -> Option<String> {
    let mut res : Option<String> = None;
    if  self.objects.contains_key(&key) {
      let mut k : Option<Box<DictNode>> = self.objects.get(key);
      res = Some(k.string_value.clone());
    }
    return res.clone();
  }
  fn getDouble(&mut self, key : String) -> Option<f64> {
    let mut res : Option<f64> = None;
    if  self.objects.contains_key(&key) {
      let mut k : Option<Box<DictNode>> = self.objects.get(key);
      res = Some(k.double_value);
    }
    return res;
  }
  fn getInt(&mut self, key : String) -> Option<i64> {
    let mut res : Option<i64> = None;
    if  self.objects.contains_key(&key) {
      let mut k : Option<Box<DictNode>> = self.objects.get(key);
      res = Some(k.int_value);
    }
    return res;
  }
  fn getBoolean(&mut self, key : String) -> Option<bool> {
    let mut res : Option<bool> = None;
    if  self.objects.contains_key(&key) {
      let mut k : Option<Box<DictNode>> = self.objects.get(key);
      res = Some(k.boolean_value);
    }
    return res;
  }
  fn getArray(&mut self, key : String) -> Option<Box<DictNode>> {
    let mut res : Option<Box<DictNode>> = None;
    if  self.objects.contains_key(&key) {
      let mut obj : Option<Box<DictNode>> = self.objects.get(key);
      if  obj.is_property {
        res = obj.object_value.clone();
      }
    }
    return res.clone();
  }
  fn getArrayAt(&mut self, index : i64) -> Option<Box<DictNode>> {
    let mut res : Option<Box<DictNode>> = None;
    if  index < ((self.children.len() as i64)) {
      res = Some(self.children[index as usize].clone());
    }
    return res.clone();
  }
  fn getObject(&mut self, key : String) -> Option<Box<DictNode>> {
    let mut res : Option<Box<DictNode>> = None;
    if  self.objects.contains_key(&key) {
      let mut obj : Option<Box<DictNode>> = self.objects.get(key);
      if  obj.is_property {
        res = obj.object_value.clone();
      }
    }
    return res.clone();
  }
  fn getObjectAt(&mut self, index : i64) -> Option<Box<DictNode>> {
    let mut res : Option<Box<DictNode>> = None;
    if  index < ((self.children.len() as i64)) {
      res = Some(self.children[index as usize].clone());
    }
    return res.clone();
  }
  fn stringify(&mut self, ) -> String {
    if  self.is_property {
      if  self.value_type == 7 {
        return format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":null".to_string()).clone();
      }
      if  self.value_type == 4 {
        if  self.boolean_value {
          return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())), "true".to_string()).clone();
        } else {
          return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())), "false".to_string()).clone();
        }
      }
      if  self.value_type == 1 {
        return [(format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())) , (self.double_value.to_string()) ].join("").clone();
      }
      if  self.value_type == 2 {
        return [(format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())) , (self.int_value.to_string()) ].join("").clone();
      }
      if  self.value_type == 3 {
        return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())), "\"".to_string())), self.EncodeString(self.string_value.clone()))), "\"".to_string()).clone();
      }
    } else {
      if  self.value_type == 7 {
        return "null".to_string().clone();
      }
      if  self.value_type == 1 {
        return ["".to_string() , (self.double_value.to_string()) ].join("").clone();
      }
      if  self.value_type == 2 {
        return ["".to_string() , (self.int_value.to_string()) ].join("").clone();
      }
      if  self.value_type == 3 {
        return format!("{}{}", (format!("{}{}", "\"".to_string(), self.EncodeString(self.string_value.clone()))), "\"".to_string()).clone();
      }
      if  self.value_type == 4 {
        if  self.boolean_value {
          return "true".to_string().clone();
        } else {
          return "false".to_string().clone();
        }
      }
    }
    if  self.value_type == 5 {
      let mut str : String = "".to_string();
      if  self.is_property {
        str = format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":[".to_string());
      } else {
        str = "[".to_string();
      }
      for i in 0..self.children.len() {
        let mut item = self.children[i as usize].clone();
        if  i > 0 {
          str = format!("{}{}", str, ",".to_string());
        }
        str = format!("{}{}", str, item.stringify());
      }
      str = format!("{}{}", str, "]".to_string());
      return str.clone();
    }
    if  self.value_type == 6 {
      let mut str_1 : String = "".to_string();
      if  self.is_property {
        return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), self.vref)), "\"".to_string())), ":".to_string())), self.self.object_value.stringify()).clone();
      } else {
        str_1 = "{".to_string();
        for i_1 in 0..self.dict_keys.len() {
          let mut key = self.dict_keys[i_1 as usize].clone();
          if  i_1 > 0 {
            str_1 = format!("{}{}", str_1, ",".to_string());
          }
          let mut item_1 : Option<Box<DictNode>> = self.objects.get(key);
          str_1 = format!("{}{}", str_1, item_1.stringify());
        }
        str_1 = format!("{}{}", str_1, "}".to_string());
        return str_1.clone();
      }
    }
    return "".to_string().clone();
  }
}
fn main() {
  let mut oo : DictNode = DictNode::createEmptyObject();
  let mut fb : Option<Box<DictNode>> = oo.addObject("foobar".to_string());
  fb.addString("key".to_string(), "Somevalue".to_string());
  println!( "{}", oo.stringify() );
}
#[derive(Clone)]
struct RangerSerializeClass { 
}
impl RangerSerializeClass { 
  
  pub fn new() ->  RangerSerializeClass {
    let mut me = RangerSerializeClass { 
    };
    return me;
  }
  fn isSerializedClass(&mut self, cName : String, mut ctx : RangerAppWriterContext) -> bool {
    if  ctx.hasClass(cName.clone()) {
      let mut clDecl : RangerAppClassDesc = ctx.findClass(cName.clone());
      if  clDecl.is_serialized {
        return true;
      }
    }
    return false;
  }
  fn createWRWriter(&mut self, mut pvar : RangerAppParamDesc, mut nn : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("def key@(lives):DictNode (new DictNode())".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "key.addString(\"n\" \"".to_string(), pvar.name)), "\")".to_string()), true);
    if  nn.value_type == 6 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out(format!("{}{}", (format!("{}{}", "def values:DictNode (obj_keys.addArray(\"".to_string(), pvar.compiledName)), "\"))".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "for this.".to_string(), pvar.compiledName)), " item:".to_string())), nn.array_type)), " i {".to_string()), true);
        wr.indent(1);
        wr.out("def obj@(lives):DictNode (item.serializeToDict())".to_string(), true);
        wr.out("values.push( obj )".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      return;
    }
    if  nn.value_type == 7 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out(format!("{}{}", (format!("{}{}", "def values:DictNode (obj_keys.addObject(\"".to_string(), pvar.compiledName)), "\"))".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", "for this.".to_string(), pvar.compiledName)), " keyname {".to_string()), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def item:DictNode (unwrap (get this.".to_string(), pvar.compiledName)), " keyname))".to_string()), true);
        wr.out("def obj@(lives):DictNode (item.serializeToDict())".to_string(), true);
        wr.out("values.setObject( obj )".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      if  nn.key_type == "string".to_string() {
        wr.out(format!("{}{}", (format!("{}{}", "def values:DictNode (obj_keys.addObject(\"".to_string(), pvar.compiledName)), "\"))".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", "for this.".to_string(), pvar.compiledName)), " keyname {".to_string()), true);
        wr.indent(1);
        if  nn.array_type == "string".to_string() {
          wr.out(format!("{}{}", (format!("{}{}", "values.addString(keyname (unwrap (get this.".to_string(), pvar.compiledName)), " keyname)))".to_string()), true);
        }
        if  nn.array_type == "int".to_string() {
          wr.out(format!("{}{}", (format!("{}{}", "values.addInt(keyname (unwrap (get this.".to_string(), pvar.compiledName)), " keyname)))".to_string()), true);
        }
        if  nn.array_type == "boolean".to_string() {
          wr.out(format!("{}{}", (format!("{}{}", "values.addBoolean(keyname (unwrap (get this.".to_string(), pvar.compiledName)), " keyname)))".to_string()), true);
        }
        if  nn.array_type == "double".to_string() {
          wr.out(format!("{}{}", (format!("{}{}", "values.addDouble(keyname (unwrap (get this.".to_string(), pvar.compiledName)), " keyname)))".to_string()), true);
        }
        wr.indent(-1);
        wr.out("}".to_string(), true);
        return;
      }
      return;
    }
    if  nn.type_name == "string".to_string() {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "obj_keys.addString(\"".to_string(), pvar.compiledName)), "\" (this.".to_string())), pvar.compiledName)), "))".to_string()), true);
      return;
    }
    if  nn.type_name == "double".to_string() {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "obj_keys.addDouble(\"".to_string(), pvar.compiledName)), "\" (this.".to_string())), pvar.compiledName)), "))".to_string()), true);
      return;
    }
    if  nn.type_name == "int".to_string() {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "obj_keys.addInt(\"".to_string(), pvar.compiledName)), "\" (this.".to_string())), pvar.compiledName)), "))".to_string()), true);
      return;
    }
    if  nn.type_name == "boolean".to_string() {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "obj_keys.addBoolean(\"".to_string(), pvar.compiledName)), "\" (this.".to_string())), pvar.compiledName)), "))".to_string()), true);
      return;
    }
    if  nn.value_type == 13 {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "obj_keys.addInt(\"".to_string(), pvar.compiledName)), "\" (this.".to_string())), pvar.compiledName)), "))".to_string()), true);
      return;
    }
    if  self.isSerializedClass(nn.type_name.clone(), ctx.clone()) {
      wr.out(format!("{}{}", (format!("{}{}", "def value@(lives):DictNode (this.".to_string(), pvar.compiledName)), ".serializeToDict())".to_string()), true);
      wr.out(format!("{}{}", (format!("{}{}", "obj_keys.setObject(\"".to_string(), pvar.compiledName)), "\" value)".to_string()), true);
    }
  }
  fn createJSONSerializerFn(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    wr.out("Import \"ng_DictNode.clj\"".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "extension ".to_string(), cl.name)), " {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", "fn unserializeFromDict@(strong):".to_string(), cl.name)), " (dict:DictNode) {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "def obj:".to_string(), cl.name)), " (new ".to_string())), cl.name)), "())".to_string()), true);
    wr.out("return obj".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.newline();
    wr.out("fn serializeToDict:DictNode () {".to_string(), true);
    wr.indent(1);
    wr.out("def res:DictNode (new DictNode ())".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "res.addString(\"n\" \"".to_string(), cl.name)), "\")".to_string()), true);
    wr.out("def obj_keys:DictNode (res.addObject(\"data\"))".to_string(), true);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..pC.variables.len() {
          let mut pvar = pC.variables[i_1 as usize].clone();
          declaredVariable.insert(pvar.name, true);
          let mut nn : CodeNode = pvar.nameNode.clone().unwrap();
          if  nn.isPrimitive() {
            wr.out("; extended ".to_string(), true);
            wr.out("def key@(lives):DictNode (new DictNode())".to_string(), true);
            wr.out(format!("{}{}", (format!("{}{}", "key.addString(\"n\" \"".to_string(), pvar.name)), "\")".to_string()), true);
            wr.out(format!("{}{}", (["key.addString(\"t\" \"".to_string() , (pvar.value_type.to_string()) ].join("")), "\")".to_string()), true);
            wr.out("obj_keys.push(key)".to_string(), true);
          }
        }
      }
    }
    for i_2 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_2 as usize].clone();
      if  declaredVariable.contains_key(&pvar_1.name) {
        continue;
      }
      let mut nn_1 : CodeNode = pvar_1.nameNode.clone().unwrap();
      if  nn_1.hasFlag("optional".to_string()) {
        wr.out("; optional variable".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "if (!null? this.".to_string(), pvar_1.name)), ") {".to_string()), true);
        wr.indent(1);
        self.createWRWriter(pvar_1.clone(), nn_1.clone(), ctx.clone(), wr.clone());
        wr.indent(-1);
        wr.out("} {".to_string(), true);
        wr.indent(1);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        continue;
      }
      wr.out("; not extended ".to_string(), true);
      self.createWRWriter(pvar_1.clone(), nn_1.clone(), ctx.clone(), wr.clone());
    }
    wr.out("return res".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
  fn createWRWriter2(&mut self, mut pvar : RangerAppParamDesc, mut nn : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  nn.value_type == 6 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out("def values:JSONArrayObject (json_array)".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "for this.".to_string(), pvar.compiledName)), " item:".to_string())), nn.array_type)), " i {".to_string()), true);
        wr.indent(1);
        wr.out("def obj@(lives):JSONDataObject (item.toDictionary())".to_string(), true);
        wr.out("push values obj".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" values ".to_string()), true);
      } else {
        wr.out("def values:JSONArrayObject (json_array)".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "for this.".to_string(), pvar.compiledName)), " item:".to_string())), nn.array_type)), " i {".to_string()), true);
        wr.indent(1);
        wr.out("push values item".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" values ".to_string()), true);
      }
      return;
    }
    if  nn.value_type == 7 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out("def values:JSONDataObject (json_object)".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "def keyList (keys this.".to_string(), pvar.compiledName)), ")".to_string()), true);
        wr.out("for keyList keyname:string index {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def item (unwrap (get this.".to_string(), pvar.compiledName)), " keyname))".to_string()), true);
        if  ctx.isDefinedClass(nn.array_type.clone()) {
          wr.out("def obj@(lives):JSONDataObject (item.toDictionary())".to_string(), true);
          wr.out("set values keyname obj ".to_string(), true);
        } else {
          wr.out("set values keyname item ".to_string(), true);
        }
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" values ".to_string()), true);
      } else {
        if  ctx.isDefinedClass(nn.array_type.clone()) == false {
          wr.out("def values:JSONDataObject (json_object)".to_string(), true);
          wr.out(format!("{}{}", (format!("{}{}", "def keyList (keys this.".to_string(), pvar.compiledName)), ")".to_string()), true);
          wr.out("for keyList keyname:string index {".to_string(), true);
          wr.indent(1);
          wr.out(format!("{}{}", (format!("{}{}", "def item (unwrap (get this.".to_string(), pvar.compiledName)), " keyname))".to_string()), true);
          wr.out("set values keyname item ".to_string(), true);
          wr.indent(-1);
          wr.out("}".to_string(), true);
          wr.out(format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" values ".to_string()), true);
        }
      }
      return;
    }
    if  nn.hasFlag("optional".to_string()) {
      if  ctx.isDefinedClass(nn.type_name.clone()) == false {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" (unwrap this.".to_string())), pvar.compiledName)), ") ".to_string()), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" (call (unwrap this.".to_string())), pvar.compiledName)), ") toDictionary ()) ".to_string()), true);
      }
    } else {
      if  ctx.isDefinedClass(nn.type_name.clone()) == false {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" (this.".to_string())), pvar.compiledName)), ") ".to_string()), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "set res  \"".to_string(), pvar.name)), "\" (this.".to_string())), pvar.compiledName)), ".toDictionary()) ".to_string()), true);
      }
    }
  }
  fn createWRReader2(&mut self, mut pvar : RangerAppParamDesc, mut nn : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  nn.value_type == 6 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out(format!("{}{}", (format!("{}{}", "def values:JSONArrayObject (getArray dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? values) {".to_string(), true);
        wr.indent(1);
        wr.out("def arr (unwrap values)".to_string(), true);
        wr.out("arr.forEach({".to_string(), true);
        wr.indent(1);
        wr.out("case item oo:JSONDataObject {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def newObj (".to_string(), nn.array_type)), ".fromDictionary(oo))".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", "push obj.".to_string(), pvar.name)), " newObj".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.indent(-1);
        wr.out("})".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "def values:JSONArrayObject (getArray dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? values) {".to_string(), true);
        wr.indent(1);
        wr.out("def arr (unwrap values)".to_string(), true);
        wr.out("arr.forEach({".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "case item oo:".to_string(), nn.array_type)), " {".to_string()), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "push obj.".to_string(), pvar.name)), " oo".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.indent(-1);
        wr.out("})".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      return;
    }
    if  nn.value_type == 7 {
      if  self.isSerializedClass(nn.array_type.clone(), ctx.clone()) {
        wr.out(format!("{}{}", (format!("{}{}", "def values (getObject dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? values) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def theObj".to_string(), pvar.name)), " (unwrap values)".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", "def obj_keys (keys theObj".to_string(), pvar.name)), ")".to_string()), true);
        wr.out("obj_keys.forEach({".to_string(), true);
        wr.indent(1);
        if  ctx.isDefinedClass(nn.array_type.clone()) {
          wr.out(format!("{}{}", (format!("{}{}", "def theValue (getObject theObj".to_string(), pvar.name)), " item ) ".to_string()), true);
          wr.out("if(!null? theValue) {".to_string(), true);
          wr.indent(1);
          wr.out(format!("{}{}", (format!("{}{}", "def newObj@(lives) (".to_string(), nn.array_type)), ".fromDictionary((unwrap theValue)))".to_string()), true);
          wr.out(format!("{}{}", (format!("{}{}", "set obj.".to_string(), pvar.name)), " item newObj ".to_string()), true);
          wr.indent(-1);
          wr.out("}".to_string(), true);
        } else {
        }
        wr.indent(-1);
        wr.out("})".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "def values (getObject dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? values) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def theObj".to_string(), pvar.name)), " (unwrap values)".to_string()), true);
        wr.out(format!("{}{}", (format!("{}{}", "def obj_keys (keys theObj".to_string(), pvar.name)), ")".to_string()), true);
        wr.out("obj_keys.forEach({".to_string(), true);
        wr.indent(1);
        if  ctx.isDefinedClass(nn.array_type.clone()) {
        } else {
          switch (nn.array_type ) { 
            case "string".to_string() : 
              wr.out(format!("{}{}", (format!("{}{}", "def v (getStr theObj".to_string(), pvar.name)), " item)".to_string()), true);
              wr.out("if(!null? v) {".to_string(), true);
              wr.indent(1);
              wr.out(format!("{}{}", (format!("{}{}", "set obj.".to_string(), pvar.name)), " item (unwrap v) ".to_string()), true);
              wr.indent(-1);
              wr.out("}".to_string(), true);
              break;
            case "int".to_string() : 
              wr.out(format!("{}{}", (format!("{}{}", "def v (getInt theObj".to_string(), pvar.name)), " item)".to_string()), true);
              wr.out("if(!null? v) {".to_string(), true);
              wr.indent(1);
              wr.out(format!("{}{}", (format!("{}{}", "set obj.".to_string(), pvar.name)), " item (unwrap v) ".to_string()), true);
              wr.indent(-1);
              wr.out("}".to_string(), true);
              break;
            case "double".to_string() : 
              wr.out(format!("{}{}", (format!("{}{}", "def v (getDouble theObj".to_string(), pvar.name)), " item)".to_string()), true);
              wr.out("if(!null? v) {".to_string(), true);
              wr.indent(1);
              wr.out(format!("{}{}", (format!("{}{}", "set obj.".to_string(), pvar.name)), " item (unwrap v) ".to_string()), true);
              wr.indent(-1);
              wr.out("}".to_string(), true);
              break;
            case "boolean".to_string() : 
              wr.out(format!("{}{}", (format!("{}{}", "def v (getBoolean theObj".to_string(), pvar.name)), " item)".to_string()), true);
              wr.out("if(!null? v) {".to_string(), true);
              wr.indent(1);
              wr.out(format!("{}{}", (format!("{}{}", "set obj.".to_string(), pvar.name)), " item (unwrap v) ".to_string()), true);
              wr.indent(-1);
              wr.out("}".to_string(), true);
              break;
          }
        }
        wr.indent(-1);
        wr.out("})".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      return;
    }
    switch (nn.type_name ) { 
      case "string".to_string() : 
        wr.out(format!("{}{}", (format!("{}{}", "def v (getStr dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? v) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = (unwrap v) ".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        break;
      case "int".to_string() : 
        wr.out(format!("{}{}", (format!("{}{}", "def v (getInt dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? v) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = (unwrap v) ".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        break;
      case "double".to_string() : 
        wr.out(format!("{}{}", (format!("{}{}", "def v (getDouble dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? v) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = (unwrap v) ".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        break;
      case "boolean".to_string() : 
        wr.out(format!("{}{}", (format!("{}{}", "def v (getBoolean dict \"".to_string(), pvar.name)), "\")".to_string()), true);
        wr.out("if(!null? v) {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = (unwrap v) ".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        break;
    }
    if  ctx.isDefinedClass(nn.type_name.clone()) {
      wr.out(format!("{}{}", (format!("{}{}", "def theValue (getObject dict \"".to_string(), pvar.name)), "\") ".to_string()), true);
      wr.out("if(!null? theValue) {".to_string(), true);
      wr.indent(1);
      wr.out(format!("{}{}", (format!("{}{}", "def newObj@(lives) (".to_string(), nn.type_name)), ".fromDictionary((unwrap theValue)))".to_string()), true);
      wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = newObj ".to_string()), true);
      wr.indent(-1);
      wr.out("}".to_string(), true);
    } else {
    }
    if  nn.value_type == 13 {
      wr.out(format!("{}{}", (format!("{}{}", "def v (getInt dict \"".to_string(), pvar.name)), "\")".to_string()), true);
      wr.out("if(!null? v) {".to_string(), true);
      wr.indent(1);
      wr.out(format!("{}{}", (format!("{}{}", "obj.".to_string(), pvar.name)), " = (unwrap v) ".to_string()), true);
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
  }
  fn createJSONSerializerFn2(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let use_exceptions : bool = operatorsOf_21::getTargetLang_22(ctx.clone()) != "swift3".to_string();
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    wr.out(format!("{}{}", (format!("{}{}", "extension ".to_string(), cl.name)), " {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", "static fn fromDictionary@(strong):".to_string(), cl.name)), " (dict:JSONDataObject) {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "def obj:".to_string(), cl.name)), " (new ".to_string())), cl.name)), "())".to_string()), true);
    if  use_exceptions {
      wr.out("try {".to_string(), true);
      wr.indent(1);
    }
    for i in 0..cl.variables.len() {
      let mut pvar = cl.variables[i as usize].clone();
      if  declaredVariable.contains_key(&pvar.name) {
        continue;
      }
      let mut nn : CodeNode = pvar.nameNode.clone().unwrap();
      self.createWRReader2(pvar.clone(), nn.clone(), ctx.clone(), wr.clone());
    }
    if  use_exceptions {
      wr.indent(-1);
      wr.out("} {".to_string(), true);
      wr.out("}".to_string(), true);
    }
    wr.out("return obj".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.newline();
    wr.out("fn toDictionary:JSONDataObject () {".to_string(), true);
    wr.indent(1);
    wr.out("def res:JSONDataObject (json_object)".to_string(), true);
    if  use_exceptions {
      wr.out("try {".to_string(), true);
      wr.indent(1);
    }
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i_1 in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i_1 as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_2 in 0..pC.variables.len() {
          let mut pvar_1 = pC.variables[i_2 as usize].clone();
          declaredVariable.insert(pvar_1.name, true);
          /** unused:  let mut nn_1 : CodeNode = pvar_1.nameNode.clone().unwrap();   **/ 
        }
      }
    }
    for i_3 in 0..cl.variables.len() {
      let mut pvar_2 = cl.variables[i_3 as usize].clone();
      if  declaredVariable.contains_key(&pvar_2.name) {
        continue;
      }
      let mut nn_2 : CodeNode = pvar_2.nameNode.clone().unwrap();
      if  nn_2.hasFlag("optional".to_string()) {
        wr.out("; optional variable".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "if (!null? this.".to_string(), pvar_2.compiledName)), ") {".to_string()), true);
        wr.indent(1);
        self.createWRWriter2(pvar_2.clone(), nn_2.clone(), ctx.clone(), wr.clone());
        wr.indent(-1);
        wr.out("}".to_string(), true);
        continue;
      }
      wr.out("; not extended ".to_string(), true);
      self.createWRWriter2(pvar_2.clone(), nn_2.clone(), ctx.clone(), wr.clone());
    }
    if  use_exceptions {
      wr.indent(-1);
      wr.out("} {".to_string(), true);
      wr.indent(1);
      wr.out("".to_string(), true);
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    wr.out("return res".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct RangerImmutableExtension { 
}
impl RangerImmutableExtension { 
  
  pub fn new() ->  RangerImmutableExtension {
    let mut me = RangerImmutableExtension { 
    };
    return me;
  }
  fn typeDefOf(&mut self, mut p : RangerAppParamDesc) -> String {
    let mut nn : Option<CodeNode> = p.nameNode;
    if  p.value_type == 6 {
      return format!("{}{}", (format!("{}{}", "[".to_string(), nn.array_type)), "]".to_string()).clone();
    }
    if  p.value_type == 7 {
      return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), nn.key_type)), ":".to_string())), nn.array_type)), "]".to_string()).clone();
    }
    if  nn.value_type == 6 {
      return format!("{}{}", (format!("{}{}", "[".to_string(), nn.array_type)), "]".to_string()).clone();
    }
    if  nn.value_type == 7 {
      return format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), nn.key_type)), ":".to_string())), nn.array_type)), "]".to_string()).clone();
    }
    return nn.type_name.clone();
  }
  fn createImmutableExtension(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    wr.out(format!("{}{}", (format!("{}{}", "extension ".to_string(), cl.name)), " {".to_string()), true);
    wr.indent(1);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..pC.variables.len() {
          let mut pvar = pC.variables[i_1 as usize].clone();
          declaredVariable.insert(pvar.name, true);
          /** unused:  let mut nn : CodeNode = pvar.nameNode.clone().unwrap();   **/ 
        }
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", "fn __CopySelf:".to_string(), cl.name)), " () {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", "def res (new ".to_string(), cl.name)), ")".to_string()), true);
    for ii in 0..cl.variables.len() {
      let mut ivar = cl.variables[ii as usize].clone();
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", "res.".to_string(), ivar.compiledName)), " = this.".to_string())), ivar.compiledName), true);
    }
    wr.out("return res".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_2 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_2 as usize].clone();
      if  declaredVariable.contains_key(&pvar_1.name) {
        continue;
      }
      /** unused:  let mut nn_1 : CodeNode = pvar_1.nameNode.clone().unwrap();   **/ 
      if  true {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "fn set_".to_string(), pvar_1.name)), ":".to_string())), cl.name)), " (new_value_of_".to_string())), pvar_1.name)), ":".to_string())), self.typeDefOf(pvar_1.clone()))), ") {".to_string()), true);
        wr.indent(1);
        wr.out("def res (this.__CopySelf())".to_string(), true);
        for ii_1 in 0..cl.variables.len() {
          let mut ivar_1 = cl.variables[ii_1 as usize].clone();
          if  ivar_1 == pvar_1 {
            wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", "res.".to_string(), pvar_1.compiledName)), " = new_value_of_".to_string())), pvar_1.name), true);
          }
        }
        wr.out("return res".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      } else {
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct RangerServiceBuilder { 
}
impl RangerServiceBuilder { 
  
  pub fn new() ->  RangerServiceBuilder {
    let mut me = RangerServiceBuilder { 
    };
    return me;
  }
  fn createOpStaticClass(&mut self, mut ctx : RangerAppWriterContext, name : String) -> RangerAppClassDesc {
    let nameWillBe : String = name;
    let mut str : String = "".to_string();
    let mut i : i64 = 0;
    let __len : i64 = nameWillBe.len() as i64;
    while i < __len {
      let c : i64 = nameWillBe.chars().nth(i as usize).unwrap_or('\0') as i64;
      if  c == (".".to_string().charCodeAt(0)) {
        str = format!("{}{}", str, "_".to_string());
      } else {
        str = format!("{}{}", str, (nameWillBe.chars().skip(i as usize).take(((i + 1) - i) as usize).collect::<String>()));
      }
      i = i + 1;
    }
    if  ctx.isDefinedClass(str.clone()) {
      return ctx.findClass(str.clone()).clone();
    }
    let tpl_code : String = format!("{}{}", (format!("{}{}", "class ".to_string(), str)), " {\r\n}".to_string());
    let mut code : SourceCode = SourceCode::new(tpl_code.clone());
    code.filename = format!("{}{}", str, ".ranger".to_string());
    let mut parser : RangerLispParser = RangerLispParser::new(code.clone());
    parser.parse(false);
    let mut classRoot : CodeNode = parser.rootNode.children[0 as usize].clone();
    let mut classNameNode : CodeNode = classRoot.getSecond();
    classNameNode.vref = str.clone();
    let mut new_class : RangerAppClassDesc = RangerAppClassDesc::new();
    new_class.name = str.clone();
    new_class.is_operator_class = true;
    new_class.nameNode = Some(classNameNode.clone());
    new_class.classNode = Some(classRoot.clone());
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    subCtx.setCurrentClass(new_class.clone());
    new_class.ctx = Some(subCtx.clone());
    let mut root : RangerAppWriterContext = ctx.getRoot();
    root.addClass(str.clone(), new_class.clone());
    classNameNode.clDesc = Some(new_class.clone());
    root.staticClassBodies.push(classRoot.clone());
    return new_class.clone();
  }
  fn CreateServices(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    if  ctx.hasCompilerFlag("client".to_string()) || ctx.hasCompilerSetting("client".to_string()) {
      println!( "{}", "--> could create Client services for Java here...".to_string() );
      let mut root : RangerAppWriterContext = ctx.getRoot();
      let mut cl : RangerAppClassDesc = self.createOpStaticClass(ctx.clone(), "RangerAppService".to_string());
      println!( "{}", format!("{}{}", "created ".to_string(), cl.name) );
      operatorsOf_13::forEach_25(root.appServices, (item, index) => { 
        println!( "{}", format!("{}{}", " - service ".to_string(), index) );
      }
      );
    }
  }
}
#[derive(Clone)]
struct RangerAppOperatorDesc { 
  name : String, 
  ref_cnt : i64, 
  node : Option<CodeNode>, 
  nameNode : Option<CodeNode>, 
  fnBody : Option<CodeNode>, 
  op_params : Vec<CodeNode>, 
  firstArg : Option<CodeNode>, 
}
impl RangerAppOperatorDesc { 
  
  pub fn new() ->  RangerAppOperatorDesc {
    let mut me = RangerAppOperatorDesc { 
      name:"".to_string(), 
      ref_cnt:0, 
      node: None, 
      nameNode: None, 
      fnBody: None, 
      op_params: Vec::new(), 
      firstArg: None, 
    };
    return me;
  }
  fn isOperator(&mut self, ) -> bool {
    return true;
  }
  fn isProperty(&mut self, ) -> bool {
    return false;
  }
}
#[derive(Clone)]
struct TFiles { 
}
impl TFiles { 
  
  pub fn new() ->  TFiles {
    let mut me = TFiles { 
    };
    return me;
  }
  pub fn searchEnv(mut env : InputEnv, mut paths : Vec<String>, fileName : String) -> String {
    for i in 0..paths.len() {
      let mut path = paths[i as usize].clone();
      if  operatorsOf_8::filec95exists_9(env.clone(), path.clone(), fileName.clone()) {
        return path.clone();
      }
    }
    return "".to_string().clone();
  }
  pub fn search(mut paths : Vec<String>, fileName : String) -> String {
    for i in 0..paths.len() {
      let mut path = paths[i as usize].clone();
      iffile_existspathfileName
      return path.clone();
    }
    return "".to_string().clone();
  }
}
#[derive(Clone)]
struct TTypes { 
}
impl TTypes { 
  
  pub fn new() ->  TTypes {
    let mut me = TTypes { 
    };
    return me;
  }
  pub fn nameToValue(name : String) -> i64 {
    switch (name ) { 
      case "double".to_string() : 
        return 2;
        break;
      case "int".to_string() : 
        return 3;
        break;
      case "string".to_string() : 
        return 4;
        break;
      case "boolean".to_string() : 
        return 5;
        break;
      case "char".to_string() : 
        return 14;
        break;
      case "charbuffer".to_string() : 
        return 15;
        break;
    }
    return 0;
  }
  pub fn isPrimitive(valueType : i64) -> bool {
    switch (valueType ) { 
      case 2 : 
        return true;
        break;
      case 4 : 
        return true;
        break;
      case 3 : 
        return true;
        break;
      case 5 : 
        return true;
        break;
      case 14 : 
        return true;
        break;
      case 15 : 
        return true;
        break;
      case 13 : 
        return true;
        break;
    }
    return false;
  }
  pub fn valueAsString(valueType : i64) -> String {
    switch (valueType ) { 
      case 2 : 
        return "double".to_string().clone();
        break;
      case 4 : 
        return "string".to_string().clone();
        break;
      case 3 : 
        return "int".to_string().clone();
        break;
      case 5 : 
        return "boolean".to_string().clone();
        break;
      case 14 : 
        return "char".to_string().clone();
        break;
      case 15 : 
        return "charbuffer".to_string().clone();
        break;
      case 0 : 
        return "<no type>".to_string().clone();
        break;
      case 1 : 
        return "<invalid type>".to_string().clone();
        break;
      case 6 : 
        return "[]".to_string().clone();
        break;
      case 7 : 
        return "[:]".to_string().clone();
        break;
      case 8 : 
        return "ImmutableArray".to_string().clone();
        break;
      case 9 : 
        return "ImmutableHash".to_string().clone();
        break;
      case 10 : 
        return "Object".to_string().clone();
        break;
      case 11 : 
        return "VRef".to_string().clone();
        break;
      case 13 : 
        return "Enum".to_string().clone();
        break;
      case 12 : 
        return "Comment".to_string().clone();
        break;
      case 16 : 
        return "Expression".to_string().clone();
        break;
      case 17 : 
        return "ExpressionType".to_string().clone();
        break;
      case 18 : 
        return "Lambda".to_string().clone();
        break;
      case 19 : 
        return "XMLNode".to_string().clone();
        break;
      case 20 : 
        return "XMLText".to_string().clone();
        break;
      case 21 : 
        return "XMLAttr".to_string().clone();
        break;
      case 22 : 
        return "XMLAttr".to_string().clone();
        break;
      case 23 : 
        return "Dictionary".to_string().clone();
        break;
      case 24 : 
        return "Any".to_string().clone();
        break;
      case 25 : 
        return "Class".to_string().clone();
        break;
      case 26 : 
        return "GenericClass".to_string().clone();
        break;
      case 27 : 
        return "ClassRef".to_string().clone();
        break;
      case 28 : 
        return "Method".to_string().clone();
        break;
      case 29 : 
        return "ClassVar".to_string().clone();
        break;
      case 30 : 
        return "ClassVar".to_string().clone();
        break;
      case 31 : 
        return "Literal".to_string().clone();
        break;
      case 32 : 
        return "Quasiliteral".to_string().clone();
        break;
      case 33 : 
        return "Null".to_string().clone();
        break;
      case 34 : 
        return "ArrayLiteral".to_string().clone();
        break;
      default: 
        return "InvalidValueTypeEnum".to_string().clone();
        break;
    }
    return "".to_string().clone();
  }
  pub fn baseTypeAsEval(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let vType : i64 = node.value_type;
    node.eval_type = vType;
    if  TTypes::isPrimitive(node.value_type) {
      node.eval_type_name = TTypes::valueAsString(node.value_type);
    } else {
      let vType_2 : String = node.type_name.clone();
      node.eval_type_name = vType_2.clone();
    }
    let vType1 : String = node.array_type.clone();
    let vType2 : String = node.key_type.clone();
    node.eval_array_type = vType1.clone();
    node.eval_key_type = vType2.clone();
  }
}
#[derive(Clone)]
struct ClassJoinPoint { 
  class_def : Option<RangerAppClassDesc>, 
  node : Option<CodeNode>, 
}
impl ClassJoinPoint { 
  
  pub fn new() ->  ClassJoinPoint {
    let mut me = ClassJoinPoint { 
      class_def: None, 
      node: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct WalkLater { 
  arg : Option<CodeNode>, 
  callArg : Option<CodeNode>, 
}
impl WalkLater { 
  
  pub fn new() ->  WalkLater {
    let mut me = WalkLater { 
      arg: None, 
      callArg: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerFlowParser { 
  hasRootPath : bool, 
  rootPath : String, 
  _debug : bool, 
  stdCommands : Option<CodeNode>, 
  lastProcessedNode : Option<CodeNode>, 
  collectWalkAtEnd : Vec<CodeNode>, 
  walkAlso : Vec<CodeNode>, 
  serializedClasses : Vec<RangerAppClassDesc>, 
  immutableClasses : Vec<RangerAppClassDesc>, 
  classesWithTraits : Vec<ClassJoinPoint>, 
  collectedIntefaces : Vec<RangerAppClassDesc>, 
  definedInterfaces : HashMap<String,bool>, 
  signatureCnt : i64, 
  argSignatureCnt : i64, 
  mainCnt : i64, 
  isDefinedSignature : HashMap<String,i64>, 
  isDefinedArgSignature : HashMap<String,i64>, 
  extendedClasses : HashMap<String,String>, 
  allNewRNodes : Vec<CodeNode>, 
  infinite_recursion : bool, 
  match_types : HashMap<String,String>, 
}
impl RangerFlowParser { 
  
  pub fn new() ->  RangerFlowParser {
    let mut me = RangerFlowParser { 
      hasRootPath:false, 
      rootPath:"".to_string(), 
      _debug:false, 
      stdCommands: None, 
      lastProcessedNode: None, 
      collectWalkAtEnd: Vec::new(), 
      walkAlso: Vec::new(), 
      serializedClasses: Vec::new(), 
      immutableClasses: Vec::new(), 
      classesWithTraits: Vec::new(), 
      collectedIntefaces: Vec::new(), 
      definedInterfaces: None, 
      signatureCnt:0, 
      argSignatureCnt:0, 
      mainCnt:0, 
      isDefinedSignature: None, 
      isDefinedArgSignature: None, 
      extendedClasses: None, 
      allNewRNodes: Vec::new(), 
      infinite_recursion:false, 
      match_types: None, 
    };
    return me;
  }
  fn WalkNodeChildren(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasStringProperty("todo".to_string()) {
      ctx.addTodo(node.clone(), node.getStringProperty("todo".to_string()));
    }
    if  node.expression {
      let mut is_chaining : bool = false;
      let mut last_is_assign : bool = false;
      let mut chainRoot : Option<CodeNode> = None;
      let mut innerNode : Option<CodeNode> = None;
      let mut assignNode : Option<CodeNode> = None;
      let mut newNode : Option<CodeNode> = None;
      let ch_len : i64 = (node.children.len() as i64);
      for i in 0..node.children.len() {
        let mut item = node.children[i as usize].clone();
        let mut did_find : bool = false;
        if  ((item.children.len() as i64)) > 0 {
          let mut fc : CodeNode = item.getFirst();
          let name : String = fc.vref;
          if  ((name.len() as i64) > 0) && ((name.chars().nth(0 as usize).unwrap_or('\0') as i64) == (".".to_string().charCodeAt(0))) {
            did_find = true;
            if  i > 0 {
              let mut last_line : CodeNode = node.children[(i - 1) as usize].clone();
              if  is_chaining == false {
                last_line.createChainTarget();
                is_chaining = true;
                if  last_line.chainTarget.is_some() {
                  chainRoot = last_line.chainTarget.clone();
                  innerNode = last_line.chainTarget.clone();
                  assignNode = Some(last_line.clone());
                  last_is_assign = true;
                } else {
                  chainRoot = Some(last_line.clone());
                  innerNode = Some(last_line.clone());
                }
              }
              let method_name : String = name.chars().skip(1 as usize).take(((name.len() as i64) - 1) as usize).collect::<String>();
              let mut mArgs : CodeNode = item.getSecond();
              if  last_is_assign {
                assignNode.children.push(fc.copy());
                assignNode.children.push(mArgs.copy());
              } else {
                newNode = Some(node.newExpressionNode());
                newNode.add(node.newVRefNode("call".to_string()));
                newNode.add(innerNode.copy());
                newNode.add(node.newVRefNode(method_name.clone()));
                newNode.add(mArgs.copy());
                innerNode = newNode.clone();
              }
              item.is_part_of_chain = true;
            }
          }
        }
        if  (did_find == false) || (i == (ch_len - 1)) {
          if  is_chaining && (last_is_assign == false) {
            chainRoot.getChildrenFrom(innerNode.unwrap());
            chainRoot.tag = "chainroot".to_string();
          }
          is_chaining = false;
          last_is_assign = false;
        }
      }
      for i_1 in 0..node.children.len() {
        let mut item_1 = node.children[i_1 as usize].clone();
        if  ctx.expressionLevel() == 0 {
          ctx.lastBlockOp = Some(item_1.clone());
        }
        item_1.parent = Some(Box::new(node.clone()));
        self.WalkNode(item_1.clone(), ctx.clone(), wr.clone());
        node.copyEvalResFrom(item_1.clone());
      }
    }
  }
  fn WalkNode(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    /** unused:  let line_index : i64 = node.getLine();   **/ 
    if  node.flow_done {
      return true;
    }
    if  ctx.isPluginOp(node.clone()) {
      return true;
    }
    node.flow_ctx = Some(ctx.clone());
    node.flow_done = true;
    self.lastProcessedNode = Some(node.clone());
    if  node.hasStringProperty("todo".to_string()) {
      ctx.addTodo(node.clone(), node.getStringProperty("todo".to_string()));
    }
    if  node.is_part_of_chain {
      return true;
    }
    if  node.isPrimitive() {
      if  ctx.expressionLevel() == 0 {
        if==falsectx.hasCompilerFlag"voidexpr".to_string()ctx.addErrornode"Primitive element at top level!".to_string()
      }
      self.WriteScalarValue(node.clone(), ctx.clone(), wr.clone());
      return true;
    }
    if  ((node.value_type == 11) || (node.value_type == 7)) || (node.value_type == 6) {
      self.WriteVRef(node.clone(), ctx.clone(), wr.clone());
      return true;
    }
    if  node.value_type == 12 {
      return true;
    }
    if  (node.register_name.len() as i64) > 0 {
      if  ctx.isVarDefined(node.register_name.clone()) {
        let mut regInfo : RangerAppParamDesc = ctx.getVariableDef(node.register_name.clone());
        if  regInfo.nameNode.is_some() {
          node.copyEvalResFrom(regInfo.nameNode.clone().unwrap());
          return true;
        } else {
        }
      } else {
      }
      return true;
    }
    if  node.value_type == 19 {
      let mut fc : CodeNode = node;
      if  fc.value_type == 19 {
        let mut opBody : CodeNode = CodeNode::blockNode();
        let mut opTpl : CodeNode = CodeNode::fromList([CodeNode::vref1("defn".to_string()), CodeNode::vref1("tmp_create".to_string()), CodeNode::expressionNode()]);
        let mut currCnt : i64 = 1;
        let mut walk_xml :  = (xmlNode, regName) => { 
        }
        ;
        walk_xml = (xmlNode, regName) => { 
          let mut rootClassDef : RangerAppClassDesc = ctx.findClass(xmlNode.vref.clone());
          if  rootClassDef.is_system {
            opBody.children.push(CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName.clone()), CodeNode::fromList([CodeNode::vref1("create".to_string()), CodeNode::vref1(xmlNode.vref.clone())])]));
            operatorsOf::forEach_15(xmlNode.attrs, (item, index) => { 
              if  ((item.children.len() as i64)) > 0 {
                let mut fc_1 : CodeNode = item.children[0 as usize].clone();
                opBody.children.push(CodeNode::fromList([CodeNode::vref1("attr".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1(item.vref.clone()), fc_1.copy()]));
                return;
              }
              if  (item.string_value.len() as i64) > 0 {
                opBody.children.push(CodeNode::fromList([CodeNode::vref1("attr".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1(item.vref.clone()), CodeNode::newStr(item.string_value.clone())]));
              }
            }
            );
            operatorsOf::forEach_15(xmlNode.children, (item, index) => { 
              if  item.value_type != 19 {
                if  item.expression {
                  let mut itemCopy : CodeNode = item.copy();
                  let mut theNode : CodeNode = item;
                  ctx.setTestCompile();
                  self.WalkNode(itemCopy.clone(), ctx.clone(), wr.clone());
                  ctx.unsetTestCompile();
                  if  ctx.hasClass(itemCopy.eval_array_type.clone()) {
                    /** unused:  let mut paramClassDef : RangerAppClassDesc = ctx.findClass(itemCopy.eval_array_type.clone());   **/ 
                    /** unused:  let mut chNode : CodeNode = item;   **/ 
                    let mut t : CodeNode = CodeNode::vref1("tmp".to_string());
                    t.setFlag("temp".to_string());
                    opBody.children.push(CodeNode::fromList([CodeNode::vref1("forEach".to_string()), theNode.copy(), CodeNode::blockFromList([CodeNode::fromList([CodeNode::vref1("def".to_string()), t, CodeNode::vref1("item".to_string())]), CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1("tmp".to_string())])])]));
                  } else {
                    if  ctx.hasClass(itemCopy.eval_type_name.clone()) {
                      opBody.children.push(CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1(regName.clone()), theNode.copy()]));
                    }
                  }
                } else {
                }
              }
              if  item.value_type == 19 {
                if  ctx.hasClass(item.vref.clone()) {
                  /** unused:  let mut paramClassDef_1 : RangerAppClassDesc = ctx.findClass(item.vref.clone());   **/ 
                  let mut chNode_1 : CodeNode = item;
                  currCnt = currCnt + 1;
                  let regN : String = ["r".to_string() , (currCnt.to_string()) ].join("");
                  walk_xml(chNode_1, regN);
                  opBody.children.push(CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1(regN.clone())]));
                }
              }
            }
            );
          } else {
            let mut match : RangerArgMatch = RangerArgMatch::new();
            opBody.children.push(CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName.clone()), CodeNode::fromList([CodeNode::vref1("new".to_string()), CodeNode::vref1(xmlNode.vref.clone())])]));
            operatorsOf::forEach_15(xmlNode.attrs, (item, index) => { 
              if  ((item.children.len() as i64)) > 0 {
                let mut fc_2 : CodeNode = item.children[0 as usize].clone();
                opBody.children.push(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.vref))), fc_2.copy()]));
                return;
              }
              if  (item.string_value.len() as i64) > 0 {
                opBody.children.push(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.vref))), CodeNode::newStr(item.string_value.clone())]));
              }
              if  item.parsed_type == 3 {
                opBody.children.push(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.vref))), CodeNode::newInt(item.int_value)]));
              }
            }
            );
            operatorsOf::forEach_15(xmlNode.children, (item, index) => { 
              if  item.value_type != 19 {
                if  item.expression {
                  let mut itemCopy_1 : CodeNode = item.copy();
                  let mut theNode_1 : CodeNode = item;
                  ctx.setTestCompile();
                  self.WalkNode(itemCopy_1.clone(), ctx.clone(), wr.clone());
                  ctx.unsetTestCompile();
                  if  ctx.hasClass(itemCopy_1.eval_array_type.clone()) {
                    /** unused:  let mut paramClassDef_2 : RangerAppClassDesc = ctx.findClass(itemCopy_1.eval_array_type.clone());   **/ 
                    /** unused:  let mut chNode_2 : CodeNode = item;   **/ 
                    operatorsOf::forEach_11(rootClassDef.variables, (item, index) => { 
                      if  r#match.areEqualATypes(item.nameNode.array_type.clone(), itemCopy_1.eval_array_type.clone(), ctx.clone()) {
                        let mut t_1 : CodeNode = CodeNode::vref1("tmp".to_string());
                        t_1.setFlag("temp".to_string());
                        opBody.children.push(CodeNode::fromList([CodeNode::vref1("forEach".to_string()), theNode_1.copy(), CodeNode::blockFromList([CodeNode::fromList([CodeNode::vref1("def".to_string()), t_1, CodeNode::vref1("item".to_string())]), CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.name))), CodeNode::vref1("tmp".to_string())])])]));
                      }
                    }
                    );
                  } else {
                    println!( "{}", format!("{}{}", "could not find class".to_string(), itemCopy_1.eval_array_type) );
                  }
                }
              }
              if  item.value_type == 19 {
                if  ctx.hasClass(item.vref.clone()) {
                  let mut paramClassDef_3 : RangerAppClassDesc = ctx.findClass(item.vref.clone());
                  let mut chNode_3 : CodeNode = item;
                  operatorsOf::forEach_11(rootClassDef.variables, (item, index) => { 
                    if  r#match.areEqualATypes(item.nameNode.array_type.clone(), chNode_3.vref.clone(), ctx.clone()) {
                      currCnt = currCnt + 1;
                      let regN_1 : String = ["r".to_string() , (currCnt.to_string()) ].join("");
                      walk_xml(chNode_3, regN_1);
                      if  paramClassDef_3.is_immutable {
                        opBody.children.push(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.name))), CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.name))), CodeNode::vref1(regN_1.clone())])]));
                      } else {
                        opBody.children.push(CodeNode::fromList([CodeNode::vref1("push".to_string()), CodeNode::vref1((format!("{}{}", (format!("{}{}", regName, ".".to_string())), item.name))), CodeNode::vref1(regN_1.clone())]));
                      }
                    }
                  }
                  );
                }
              }
            }
            );
          }
        }
        ;
        walk_xml(fc, "r1".to_string());
        opBody.children.push(CodeNode::fromList([CodeNode::vref1("ret".to_string()), CodeNode::vref1("r1".to_string())]));
        opTpl.children.push(opBody.clone());
        node.value_type = 0;
        node.getChildrenFrom(CodeNode::fromList([CodeNode::vref1("tmp_create".to_string())]));
        node.value_type = 0;
        node.expression = true;
        self.TransformOpFn([opTpl], node.clone(), ctx.clone(), wr.clone());
        return true;
      }
    }
    if  ((node.children.len() as i64)) > 0 {
      let mut fc_3 : CodeNode = node.getFirst();
      if  ((fc_3.ns.len() as i64)) > 1 {
        if  (fc_3.ns[0 as usize].clone()) == "plugin".to_string() {
          if  node.is_plugin {
            return true;
          }
          node.is_plugin = true;
          let pName : String = fc_3.ns[1 as usize].clone();
          ctx.addPluginNode(pName.clone(), node.clone());
          return true;
        }
      }
    }
    if  ((node.children.len() as i64)) == 1 {
      let mut fc_4 : CodeNode = node.children[0 as usize].clone();
      if  ctx.isVarDefined(fc_4.vref.clone()) {
        fc_4.parent = Some(Box::new(node.clone()));
        if  fc_4.evalCtx.is_some() {
          self.WalkNode(fc_4.clone(), fc_4.evalCtx.clone().unwrap(), wr.clone());
        } else {
          self.WalkNode(fc_4.clone(), ctx.clone(), wr.clone());
        }
        node.copyEvalResFrom(fc_4.clone());
        return true;
      }
    }
    let mut skip_if : Vec<String> = ["Extends".to_string(), "operator".to_string(), "extends".to_string(), "operators".to_string(), "systemclass".to_string(), "systemunion".to_string(), "union".to_string(), "flag".to_string(), "trait".to_string(), "enum".to_string(), "Import".to_string()];
    if  ((node.children.len() as i64)) > 0 {
      let mut fc_5 : CodeNode = node.children[0 as usize].clone();
      if  (skip_if.iter().position( |&r| r == fc_5.vref ).unwrap()) >= 0 {
        return true;
      }
      if  fc_5.vref == "#".to_string() {
        let mut fnCtx : RangerAppWriterContext = ctx.findFunctionCtx();
        self.DefineArrowOpFn(node.clone(), fnCtx.clone(), wr.clone());
        node.value_type = 11;
        node.expression = false;
        node.is_block_node = false;
        node.ns.length = 0;
        node.ns.push(node.vref);
        node.children.length = 0;
        nullifynode.paramDesc
        node.hasParamDesc = false;
        return true;
      } else {
        if  fc_5.expression && (((fc_5.children.len() as i64)) > 0) {
          let mut exprFc : CodeNode = fc_5.children[0 as usize].clone();
          if  exprFc.vref == "#".to_string() {
            self.DefineArrowOpFn(fc_5.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      let mut b_found : bool = true;
      let mut opFn : Vec<CodeNode> = ctx.getOpFns(fc_5.vref.clone());
      if  ((opFn.len() as i64)) > 0 {
        self.TransformOpFn(opFn, node.clone(), ctx.clone(), wr.clone());
        return true;
      }
      switch (fc_5.vref ) { 
        case "page".to_string() : 
          let mut sc : CodeNode = node.getSecond();
          ctx.addPage(sc.vref.clone(), node.clone());
          break;
        case "def".to_string() : 
          operatorsOfRangerFlowParser_26::EnterVarDef_27(self.clone(), node.clone(), ctx.clone(), wr.clone());
          break;
        case "var".to_string() : 
          operatorsOf_26::EnterVarDef_27(self.clone(), node.clone(), ctx.clone(), wr.clone());
          break;
        case "let".to_string() : 
          operatorsOf_26::EnterVarDef_27(self.clone(), node.clone(), ctx.clone(), wr.clone());
          break;
        case "property".to_string() : 
          self.GetProperty(node.clone(), ctx.clone(), wr.clone());
          break;
        case "CreateClass".to_string() : 
          self.EnterClass(node.clone(), ctx.clone(), wr.clone());
          break;
        case "class".to_string() : 
          self.EnterClass(node.clone(), ctx.clone(), wr.clone());
          break;
        case "defn".to_string() : 
          self.DefineOpFn(node.clone(), ctx.clone(), wr.clone());
          break;
        case "fn".to_string() : 
          if  ctx.isInMethod() {
            self.EnterLambdaMethod(node.clone(), ctx.clone(), wr.clone());
          } else {
            self.EnterMethod(node.clone(), ctx.clone(), wr.clone());
          }
          break;
        case "sfn".to_string() : 
          self.EnterStaticMethod(node.clone(), ctx.clone(), wr.clone());
          break;
        case "static".to_string() : 
          self.EnterStaticMethod(node.clone(), ctx.clone(), wr.clone());
          break;
        case "=".to_string() : 
          self.cmdAssign(node.clone(), ctx.clone(), wr.clone());
          break;
        case "constructor".to_string() : 
          self.Constructor(node.clone(), ctx.clone(), wr.clone());
          break;
        case "Constructor".to_string() : 
          self.Constructor(node.clone(), ctx.clone(), wr.clone());
          break;
        case "new".to_string() : 
          self.cmdNew(node.clone(), ctx.clone(), wr.clone());
          break;
        case "[]".to_string() : 
          self.cmdArray(node.clone(), ctx.clone(), wr.clone());
          break;
        case "call".to_string() : 
          self.cmdCall(node.clone(), ctx.clone(), wr.clone());
          break;
        case "fun".to_string() : 
          self.EnterLambdaMethod(node.clone(), ctx.clone(), wr.clone());
          break;
        case "extension".to_string() : 
          self.EnterClass(node.clone(), ctx.clone(), wr.clone());
          break;
        case "service".to_string() : 
          try {
            let mut sc_1 : CodeNode = node.getSecond();
            let mut params : CodeNode = node.getThird();
            ctx.addService(sc_1.vref.clone(), node.clone());
            let mut paramClass : CodeNode = params.getFirst();
            /** unused:  let mut rvClassDef : RangerAppClassDesc = ctx.findClass(sc_1.type_name.clone());   **/ 
            /** unused:  let mut paramClassDef_4 : RangerAppClassDesc = ctx.findClass(paramClass.type_name.clone());   **/ 
            =node.appGUID+
            format!("{}{}", sc_1.vref, "_".to_string())
            sha256+rvClassDef.node.getCodeparamClassDef.node.getCode
          } catch(e) {
            ctx.addError(node.clone(), "invalid service definition".to_string());
          }
          break;
        default: 
          b_found = false;
          break;
      }
      if  b_found {
        return true;
      }
    }
    if  self.matchNode(node.clone(), ctx.clone(), wr.clone()) {
      return true;
    }
    if  ((node.children.len() as i64)) > 0 {
      let mut fc_6 : CodeNode = node.children[0 as usize].clone();
      if  fc_6.expression && (((node.children.len() as i64)) == 2) {
        let mut sec : CodeNode = node.getSecond();
        if  ((sec.vref.len() as i64) > 0) && ((sec.vref.chars().nth(0 as usize).map(|c| c.to_string()).unwrap_or_default()) == ".".to_string()) {
          self.WalkNode(fc_6.clone(), ctx.clone(), wr.clone());
          if  ((fc_6.eval_type_name.len() as i64) > 0) && ctx.isDefinedClass(fc_6.eval_type_name.clone()) {
            let mut parts : Vec<String> = (sec.vref.chars().skip(1 as usize).take(((sec.vref.len() as i64) - 1) as usize).collect::<String>()).split(".".to_string());
            let mut method_name : String = parts[0 as usize].clone();
            let mut classDesc : RangerAppClassDesc = ctx.findClass(fc_6.eval_type_name.clone());
            /** unused:  let mut objExpr : CodeNode = fc_6.copy();   **/ 
            let mut calledItem : CodeNode = CodeNode::fromList([CodeNode::vref1("property".to_string()), fc_6.copy(), CodeNode::vref1(method_name.clone())]);
            operatorsOf::forEach_12(parts, (item, index) => { 
              if  index > 0 {
                try {
                  let mut p : Option<RangerAppParamDesc> = classDesc.findVariable(method_name.clone());
                  classDesc = ctx.findClass(p.nameNode.type_name.clone());
                  calledItem = CodeNode::fromList([CodeNode::vref1("property".to_string()), calledItem.copy(), CodeNode::vref1(item.clone())]);
                  method_name = item.clone();
                } catch(e) {
                  ctx.addError(sec.clone(), "invalid property".to_string());
                }
              }
            }
            );
            let mut m : Option<RangerAppParamDesc> = classDesc.findVariable(method_name.clone());
            if  m.is_some() {
              node.getChildrenFrom(calledItem.clone());
              node.flow_done = false;
              self.WalkNode(node.clone(), ctx.clone(), wr.clone());
              return true;
            }
            let mut m_1 : Option<RangerAppFunctionDesc> = classDesc.findMethod(method_name.clone());
            if  m_1.is_some() {
              node.getChildrenFrom(calledItem.clone());
              node.flow_done = false;
              self.transformMethodToLambda(node.clone(), m_1.unwrap(), ctx.clone(), wr.clone());
              return true;
            }
          }
        }
      }
      if  fc_6.expression && (((node.children.len() as i64)) == 3) {
        let mut sec_1 : CodeNode = node.getSecond();
        let mut third : CodeNode = node.getThird();
        if  ((sec_1.vref.len() as i64) > 0) && ((sec_1.vref.chars().nth(0 as usize).map(|c| c.to_string()).unwrap_or_default()) == ".".to_string()) {
          self.WalkNode(fc_6.clone(), ctx.clone(), wr.clone());
          let mut parts_1 : Vec<String> = (sec_1.vref.chars().skip(1 as usize).take(((sec_1.vref.len() as i64) - 1) as usize).collect::<String>()).split(".".to_string());
          let method_name_1 : String = parts_1[(((parts_1.len() as i64)) - 1) as usize].clone();
          let mut classDesc_1 : RangerAppClassDesc = ctx.findClass(fc_6.eval_type_name.clone());
          /** unused:  let mut objExpr_1 : CodeNode = fc_6.copy();   **/ 
          let mut calledItem_1 : CodeNode = fc_6.copy();
          operatorsOf::forEach_12(parts_1, (item, index) => { 
            if  index < (((parts_1.len() as i64)) - 1) {
              try {
                calledItem_1 = CodeNode::fromList([CodeNode::vref1("property".to_string()), calledItem_1.copy(), CodeNode::vref1(item.clone())]);
                let mut p_1 : Option<RangerAppParamDesc> = classDesc_1.findVariable(item.clone());
                classDesc_1 = ctx.findClass(p_1.nameNode.type_name.clone());
              } catch(e) {
                ctx.addError(sec_1.clone(), format!("{}{}", "invalid property ".to_string(), item));
              }
            }
          }
          );
          let mut calledItem_2 : CodeNode = CodeNode::fromList([CodeNode::vref1("call".to_string()), calledItem_1, CodeNode::vref1(method_name_1.clone()), third.copy()]);
          node.getChildrenFrom(calledItem_2.clone());
          node.flow_done = false;
          self.WalkNode(node.clone(), ctx.clone(), wr.clone());
          return true;
        }
      }
      if  fc_6.value_type == 11 {
        let mut was_called : bool = true;
        switch (fc_6.vref ) { 
          case "Enum".to_string() : 
            was_called = true;
            break;
          default: 
            was_called = false;
            break;
        }
        if  was_called {
          return true;
        }
        if  ((node.children.len() as i64)) > 1 {
          if  self.cmdLocalCall(node.clone(), ctx.clone(), wr.clone()) {
            return true;
          }
        }
      }
    }
    if  node.expression {
      for i in 0..node.children.len() {
        let mut item = node.children[i as usize].clone();
        if  ctx.expressionLevel() == 0 {
          ctx.lastBlockOp = Some(item.clone());
        }
        item.parent = Some(Box::new(node.clone()));
        if  item.evalCtx.is_some() {
          self.WalkNode(item.clone(), item.evalCtx.clone().unwrap(), wr.clone());
        } else {
          self.WalkNode(item.clone(), ctx.clone(), wr.clone());
        }
        node.copyEvalResFrom(item.clone());
        if  (i == 0) && (((node.children.len() as i64)) == 2) {
          if  (item.eval_type == 28) && (item.paramDesc.is_some()) {
            let mut mDesc : RangerAppParamDesc = item.paramDesc.clone().unwrap();
            node.eval_type = mDesc.nameNode.value_type;
            node.eval_type_name = mDesc.nameNode.type_name.clone();
            node.eval_array_type = mDesc.nameNode.array_type.clone();
            node.eval_key_type = mDesc.nameNode.eval_key_type.clone();
            node.is_direct_method_call = true;
            return true;
          }
        }
        if  ((item.expression_value.is_some()) || (item.value_type == 17)) || (item.eval_type == 17) {
          if  (i == 0) && (((node.children.len() as i64)) == 2) {
            node.has_lambda_call = true;
            let mut second : CodeNode = node.children[1 as usize].clone();
            ctx.setInExpr();
            self.WalkNode(second.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            if  item.expression_value.is_some() {
              let mut lambdaNode : CodeNode = (*item.expression_value.clone().unwrap());
              let mut nn : CodeNode = lambdaNode.children[0 as usize].clone();
              node.eval_type = nn.typeNameAsType(ctx.clone());
              node.eval_type_name = nn.type_name.clone();
              node.eval_array_type = nn.array_type.clone();
              node.eval_key_type = nn.key_type.clone();
              if  node.eval_type == 17 {
                node.expression_value = Some(Box::new(nn.expression_value.copy().clone()));
              }
              if  nn.hasFlag("optional".to_string()) {
                node.setFlag("optional".to_string());
              }
              self.testLambdaCallArgs(lambdaNode.clone(), second.clone(), ctx.clone(), wr.clone());
            }
            break;
          }
        }
      }
      return true;
    }
    ctx.addError(node.clone(), "Could not understand this part".to_string());
    return true;
  }
  fn getVoidNameSignature(&mut self, ) -> String {
    let s : String = "void".to_string();
    if  self.isDefinedSignature.contains_key(&s) {
      let cc : i64 = (self.isDefinedSignature.get(s)).unwrap();
      return ["void_".to_string() , (cc.to_string()) ].join("").clone();
    }
    self.signatureCnt = self.signatureCnt + 1;
    self.isDefinedSignature.insert(s, self.signatureCnt);
    return ["void_".to_string() , (self.signatureCnt.to_string()) ].join("").clone();
  }
  fn getNameSignature(&mut self, mut node : CodeNode) -> String {
    let s : String = format!("{}{}", node.type_name, node.buildTypeSignature());
    if  self.isDefinedSignature.contains_key(&s) {
      let cc : i64 = (self.isDefinedSignature.get(s)).unwrap();
      if  cc == 1 {
        return node.type_name.clone();
      }
      return ["_".to_string() , (cc.to_string()) ].join("").clone();
    }
    self.signatureCnt = self.signatureCnt + 1;
    self.isDefinedSignature.insert(s, self.signatureCnt);
    if  self.signatureCnt == 1 {
      return node.type_name.clone();
    }
    return [(format!("{}{}", node.type_name, "_".to_string())) , (self.signatureCnt.to_string()) ].join("").clone();
  }
  fn getArgsSignature(&mut self, mut node : CodeNode) -> String {
    let mut exp_s : String = "".to_string();
    for i in 0..node.children.len() {
      let mut arg = node.children[i as usize].clone();
      exp_s = format!("{}{}", exp_s, arg.buildTypeSignature());
      exp_s = format!("{}{}", exp_s, ",".to_string());
    }
    if  self.isDefinedArgSignature.contains_key(&exp_s) {
      let cc : i64 = (self.isDefinedArgSignature.get(exp_s)).unwrap();
      if  cc == 1 {
        return "".to_string().clone();
      }
      return ["_".to_string() , (cc.to_string()) ].join("").clone();
    }
    self.signatureCnt = self.signatureCnt + 1;
    self.isDefinedArgSignature.insert(exp_s, self.signatureCnt);
    if  self.signatureCnt == 1 {
      return "".to_string().clone();
    }
    return ["_".to_string() , (self.signatureCnt.to_string()) ].join("").clone();
  }
  fn getThisName(&mut self, ) -> String {
    return "this".to_string().clone();
  }
  fn GetProperty(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((node.children.len() as i64)) != 3 {
      ctx.addError(node.clone(), "Invalid property descriptor".to_string());
      return;
    }
    let mut obj : CodeNode = node.getSecond();
    let mut prop : CodeNode = node.getThird();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    if  ctx.isDefinedClass(obj.eval_type_name.clone()) {
      try {
        let mut currC : RangerAppClassDesc = ctx.findClass(obj.eval_type_name.clone());
        let mut varDef : Option<RangerAppParamDesc> = currC.findVariable(prop.vref.clone());
        if  varDef.is_some() {
          prop.flow_done = true;
          prop.eval_type = 11;
          node.hasParamDesc = true;
          node.ownParamDesc = Some(varDef.clone());
          node.paramDesc = Some(varDef.clone());
          varDef.ref_cnt = 1 + varDef.ref_cnt;
          let mut vNameNode : Option<CodeNode> = varDef.nameNode;
          if  vNameNode.is_some() {
            if  vNameNode.hasFlag("optional".to_string()) {
              node.setFlag("optional".to_string());
            }
            node.eval_type = vNameNode.typeNameAsType(ctx.clone());
            node.eval_type_name = vNameNode.type_name.clone();
            if  vNameNode.value_type == 6 {
              node.eval_type = 6;
              node.eval_array_type = vNameNode.array_type.clone();
            }
            if  vNameNode.value_type == 7 {
              node.eval_type = 7;
              node.eval_key_type = vNameNode.key_type.clone();
              node.eval_array_type = vNameNode.array_type.clone();
            }
          }
          return;
        }
        let mut mDef : Option<RangerAppFunctionDesc> = currC.findMethod(prop.vref.clone());
        if  mDef.is_some() {
          node.eval_type = 28;
          node.hasParamDesc = true;
          node.ownParamDesc = Some(mDef.clone());
          node.paramDesc = Some(mDef.clone());
          mDef.ref_cnt = 1 + mDef.ref_cnt;
          return;
        }
        ctx.addError(node.clone(), format!("{}{}", "Did not find property from class ".to_string(), currC.name));
      } catch(e) {
        ctx.addError(node.clone(), "Not valid property access".to_string());
      }
    } else {
      ctx.addError(obj.clone(), "Can not access property of a non-class value".to_string());
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "_".to_string() {
      return;
    }
    if  node.vref == "#".to_string() {
      return;
    }
    let rootObjName : String = node.ns[0 as usize].clone();
    if  ctx.isInStatic() {
      if  rootObjName == "this".to_string() {
        ctx.addError(node.clone(), "This can not be used in static context".to_string());
      }
    }
    if  ctx.isEnumDefined(rootObjName.clone()) {
      let enumName : String = node.ns[1 as usize].clone();
      let mut ee : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
      let mut e : RangerAppEnum = ee.unwrap();
      if  e.values.contains_key(&enumName) {
        node.eval_type = 13;
        node.eval_type_name = rootObjName.clone();
        node.int_value = (e.values.get(enumName)).unwrap();
      } else {
        ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", "Undefined Enum ".to_string(), rootObjName)), ".".to_string())), enumName));
        node.eval_type = 1;
      }
      return;
    }
    if  node.vref == self.getThisName() {
      let mut cd : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      let mut thisClassDesc : Option<RangerAppClassDesc> = cd;
      node.eval_type = 10;
      node.eval_type_name = thisClassDesc.name.clone();
      node.ref_type = 4;
      return;
    }
    if  ctx.isCapturing() {
      if  ctx.isVarDefined(rootObjName.clone()) {
        if  ctx.isLocalToCapture(rootObjName.clone()) == false {
          let mut captDef : RangerAppParamDesc = ctx.getVariableDef(rootObjName.clone());
          let mut cd_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          cd_1.capturedLocals.push(captDef.clone());
          captDef.is_captured = true;
          ctx.addCapturedVariable(rootObjName.clone());
        }
      }
    }
    if  (rootObjName == "this".to_string()) || ctx.isVarDefined(rootObjName.clone()) {
      /** unused:  let mut vDef2 : RangerAppParamDesc = ctx.getVariableDef(rootObjName.clone());   **/ 
      /** unused:  let mut activeFn : RangerAppFunctionDesc = ctx.getCurrentMethod();   **/ 
      let mut vDef : Option<RangerAppParamDesc> = self.findParamDesc(node.clone(), ctx.clone(), wr.clone());
      if  vDef.is_some() {
        node.hasParamDesc = true;
        node.ownParamDesc = Some(vDef.clone());
        node.paramDesc = Some(vDef.clone());
        vDef.ref_cnt = 1 + vDef.ref_cnt;
        let mut vNameNode : Option<CodeNode> = vDef.nameNode;
        if  ctx.isDefinedClass(node.type_name.clone()) {
          let mut m : RangerAppFunctionDesc = ctx.getCurrentMethod();
          m.addClassUsage(ctx.findClass(node.type_name.clone()), ctx.clone());
        }
        if  ctx.isDefinedClass(node.eval_type_name.clone()) {
          let mut m_1 : RangerAppFunctionDesc = ctx.getCurrentMethod();
          m_1.addClassUsage(ctx.findClass(node.eval_type_name.clone()), ctx.clone());
        }
        if  vNameNode.is_some() {
          if  vNameNode.hasFlag("optional".to_string()) {
            node.setFlag("optional".to_string());
          }
          node.eval_type = vNameNode.typeNameAsType(ctx.clone());
          node.eval_type_name = vNameNode.type_name.clone();
          if  vNameNode.value_type == 6 {
            node.eval_type = 6;
            node.eval_array_type = vNameNode.array_type.clone();
          }
          if  vNameNode.value_type == 7 {
            node.eval_type = 7;
            node.eval_key_type = vNameNode.key_type.clone();
            node.eval_array_type = vNameNode.array_type.clone();
          }
        }
      } else {
        ctx.addError(node.clone(), "Undefined variable".to_string());
      }
    } else {
      let mut class_or_this : bool = rootObjName == self.getThisName();
      if  ctx.isDefinedClass(rootObjName.clone()) {
        class_or_this = true;
        node.eval_type = 25;
        node.eval_type_name = rootObjName.clone();
        let mut m_2 : RangerAppFunctionDesc = ctx.getCurrentMethod();
        m_2.addClassUsage(ctx.findClass(rootObjName.clone()), ctx.clone());
      }
      if  ctx.hasTemplateNode(rootObjName.clone()) {
        class_or_this = true;
      }
      if  false == class_or_this {
        let mut udesc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut desc : RangerAppClassDesc = udesc.unwrap();
        let mut opList : Vec<CodeNode> = ctx.getOpFns(node.vref.clone());
        if  (((((opList.len() as i64)) > 0) || (node.vref == "fun".to_string())) || (node.vref == "fn".to_string())) || node.hasFlag("keyword".to_string()) {
        } else {
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "WriteVREF -> Undefined variable ".to_string(), node.vref)), " in class ".to_string())), desc.name)), " node : ".to_string())), node.getCode()));
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "WriteVREF -> Undefined variable ".to_string(), rootObjName)), " in class ".to_string())), desc.name)), " node : ".to_string())), node.parent.getCode()));
          if  node.parent.parent.is_some() {
            ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "WriteVREF -> Undefined variable ".to_string(), rootObjName)), " in class ".to_string())), desc.name)), " node : ".to_string())), node.parent.parent.getCode()));
          }
        }
      }
      return;
    }
  }
  fn EnterFn(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter, callback : ) -> () {
    try {
      if  ((node.children.len() as i64)) < 4 {
        ctx.addError(node.clone(), "Function has too few arguments".to_string());
        return;
      }
      /** unused:  let mut nameNode : Option<CodeNode> = None;   **/ 
      let mut idx : i64 = 0;
      operatorsOf::forEach_15(node.children, (item, index) => { 
        if  item.vref == "static".to_string() {
          idx = idx + 1;
        }
      }
      );
      let mut currClass : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      if  currClass.is_none() {
        ctx.addError(node.clone(), "Current class was not defined when entering method".to_string());
        return;
      }
      callback(node, ctx, wr, node.children[(idx + 1) as usize].clone(), node.children[(idx + 2) as usize].clone(), node.children[(idx + 3) as usize].clone(), currClass.unwrap());
    } catch(e) {
      ctx.addError(node.clone(), +"Error parsing function ".to_string()error_msg);
    }
  }
  fn Constructor(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.shouldHaveChildCnt(3, node.clone(), ctx.clone(), "Method expexts four arguments".to_string());
    /** unused:  let mut cn : CodeNode = node.children[1 as usize].clone();   **/ 
    let mut fnBody : CodeNode = node.children[2 as usize].clone();
    let mut udesc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    let mut desc : RangerAppClassDesc = udesc.unwrap();
    let mut m : Option<RangerAppFunctionDesc> = desc.constructor_fn;
    let mut subCtx : RangerAppWriterContext = m.fnCtx.clone().unwrap();
    subCtx.is_function = true;
    subCtx.currentMethod = Some(m.clone());
    subCtx.setInMethod();
    for i in 0..m.params.len() {
      let mut v = m.params[i as usize].clone();
      subCtx.defineVariable(v.name.clone(), v.clone());
    }
    self.WalkNodeChildren(fnBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInMethod();
    if  fnBody.didReturnAtIndex >= 0 {
      ctx.addError(node.clone(), "constructor should not return any values!".to_string());
    }
    for i_1 in 0..subCtx.localVarNames.len() {
      let mut n = subCtx.localVarNames[i_1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = subCtx.localVariables.get(n);
      if  p.set_cnt > 0 {
        if  p.is_immutable {
          ctx.addError(node.clone(), "Immutable variable was assigned a value".to_string());
        }
        let mut defNode : Option<CodeNode> = p.node;
        defNode.setFlag("mutable".to_string());
        let mut nNode : Option<CodeNode> = p.nameNode;
        nNode.setFlag("mutable".to_string());
      }
    }
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    TTypes::baseTypeAsEval(node.clone(), ctx.clone(), wr.clone());
    node.evalTypeClass = Some(TFactory::new_scalar_signature(node.clone(), ctx.clone(), wr.clone()));
  }
  fn cmdNew(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((node.children.len() as i64)) < 2 {
      ctx.addError(node.clone(), "the new operator expects at lest two arguments".to_string());
      return;
    }
    if  ((node.children.len() as i64)) < 3 {
      let mut expr : CodeNode = CodeNode::new(node.code.clone().unwrap(), node.sp, node.ep);
      expr.expression = true;
      node.children.push(expr.clone());
    }
    let mut obj : CodeNode = node.getSecond();
    let mut params : CodeNode = node.getThird();
    let mut currC : Option<RangerAppClassDesc> = None;
    let b_template : bool = false;
    let mut expects_error : bool = false;
    let err_cnt : i64 = ctx.getErrorCount();
    if  node.hasBooleanProperty("error".to_string()) {
      expects_error = true;
    }
    if  obj.has_vref_annotation {
      self.CheckVRefTypeAnnotationOf(obj.clone(), ctx.clone(), wr.clone());
    }
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    for i in 0..params.children.len() {
      let mut arg = params.children[i as usize].clone();
      ctx.setInExpr();
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
    }
    node.eval_type = 10;
    node.eval_type_name = obj.vref.clone();
    if  b_template == false {
      currC = Some(ctx.findClass(obj.vref.clone()));
      let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
      currM.addClassUsage(currC.unwrap(), ctx.clone());
    }
    node.hasNewOper = true;
    node.clDesc = currC.clone();
    let mut fnDescr : Option<RangerAppFunctionDesc> = currC.constructor_fn;
    if  fnDescr.is_some() {
      if  ((fnDescr.params.len() as i64)) > ((params.children.len() as i64)) {
        ctx.addError(node.clone(), format!("{}{}", "Not enough arguments for class constructor ".to_string(), fnDescr.node.getLineAsString()));
        return;
      }
      for i_1 in 0..fnDescr.params.len() {
        let mut param = fnDescr.params[i_1 as usize].clone();
        let mut has_default : bool = false;
        if  param.nameNode.hasFlag("default".to_string()) {
          has_default = true;
        }
        if  param.nameNode.hasFlag("keyword".to_string()) {
          continue;
        }
        if  ((params.children.len() as i64)) <= i_1 {
          if  has_default {
            continue;
          }
          ctx.addError(node.clone(), "Missing arguments for function".to_string());
          ctx.addError(param.nameNode.clone().unwrap(), "To fix the previous error: Check original function declaration".to_string());
        }
        let mut argNode : CodeNode = params.children[i_1 as usize].clone();
        if  false == self.areEqualTypes((param.nameNode.clone().unwrap()), argNode.clone(), ctx.clone(), wr.clone()) {
          ctx.addError(argNode.clone(), format!("{}{}", (format!("{}{}", "ERROR, invalid argument type for ".to_string(), currC.name)), " constructor ".to_string()));
        }
        let mut pNode : CodeNode = param.nameNode.clone().unwrap();
        if  pNode.hasFlag("optional".to_string()) {
          if  false == argNode.hasFlag("optional".to_string()) {
            ctx.addError(node.clone(), format!("{}{}", "new parameter optionality does not match, expected optional parameter".to_string(), argNode.getCode()));
          }
        }
        if  argNode.hasFlag("optional".to_string()) {
          if  false == pNode.hasFlag("optional".to_string()) {
            ctx.addError(node.clone(), format!("{}{}", "new parameter optionality does not match, expected non-optional, optional given".to_string(), argNode.getCode()));
          }
        }
      }
    }
    if  expects_error {
      let cnt_now : i64 = ctx.getErrorCount();
      if  cnt_now == err_cnt {
        ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: expected generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now.to_string()) ].join(""));
      }
    } else {
      let cnt_now_1 : i64 = ctx.getErrorCount();
      if  cnt_now_1 > err_cnt {
        ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: did not expect generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_1.to_string()) ].join(""));
      }
    }
  }
  fn transformParams(&mut self, mut list : Vec<CodeNode>, mut fnArgs : Vec<RangerAppParamDesc>, mut ctx : RangerAppWriterContext) -> Vec<CodeNode> {
    let mut res : Vec<CodeNode> = Vec::new();
    for i in 0..list.len() {
      let mut item = list[i as usize].clone();
      if  item.is_block_node {
        /** unused:  let mut newNode : CodeNode = CodeNode::new(item.code.clone().unwrap(), item.sp, item.ep);   **/ 
        let mut fnArg : RangerAppParamDesc = fnArgs[i as usize].clone();
        let mut nn : Option<CodeNode> = fnArg.nameNode;
        if  nn.expression_value.is_none() {
          ctx.addError(item.clone(), "Parameter is not lambda expression".to_string());
          break;
        }
        let mut fnDef : CodeNode = (*nn.expression_value.clone().unwrap());
        let mut match : RangerArgMatch = RangerArgMatch::new();
        let mut copyOf : CodeNode = fnDef.rebuildWithType(match.clone(), false);
        let mut fc : CodeNode = copyOf.children[0 as usize].clone();
        fc.vref = "fun".to_string();
        let mut itemCopy : CodeNode = item.rebuildWithType(match.clone(), false);
        copyOf.children.push(itemCopy.clone());
        let mut cnt : i64 = (item.children.len() as i64);
        while cnt > 0 {
          item.children.pop();
          cnt = cnt - 1;
        }
        for i_1 in 0..copyOf.children.len() {
          let mut ch = copyOf.children[i_1 as usize].clone();
          item.children.push(ch.clone());
        }
      }
      res.push(item.clone());
    }
    return res;
  }
  fn transformParams2(&mut self, mut list : Vec<CodeNode>, mut fnArgs : Vec<CodeNode>, mut ctx : RangerAppWriterContext) -> Vec<CodeNode> {
    let mut res : Vec<CodeNode> = Vec::new();
    for i in 0..list.len() {
      let mut item = list[i as usize].clone();
      if  item.is_block_node {
        println!( "{}", format!("{}{}", "Transforming --> ".to_string(), item.getCode()) );
        /** unused:  let mut newNode : CodeNode = CodeNode::new(item.code.clone().unwrap(), item.sp, item.ep);   **/ 
        let mut nn : CodeNode = fnArgs[i as usize].clone();
        if  nn.expression_value.is_none() {
          ctx.addError(item.clone(), "Parameter is not lambda expression".to_string());
          break;
        }
        let mut fnDef : CodeNode = (*nn.expression_value.clone().unwrap());
        let mut match : RangerArgMatch = RangerArgMatch::new();
        let mut copyOf : CodeNode = fnDef.rebuildWithType(match.clone(), false);
        let mut fc : CodeNode = copyOf.children[0 as usize].clone();
        fc.vref = "fun".to_string();
        let mut itemCopy : CodeNode = item.rebuildWithType(match.clone(), false);
        copyOf.children.push(itemCopy.clone());
        let mut cnt : i64 = (item.children.len() as i64);
        while cnt > 0 {
          item.children.pop();
          cnt = cnt - 1;
        }
        for i_1 in 0..copyOf.children.len() {
          let mut ch = copyOf.children[i_1 as usize].clone();
          item.children.push(ch.clone());
        }
      }
      res.push(item.clone());
    }
    return res;
  }
  fn CreateCTTI(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    let mut wr : CodeWriter = CodeWriter::new();
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  item.isNormalClass() {
        wr.raw(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\r\n      operators {\r\n        class_name _:string ( ".to_string(), item.name)), "@(keyword) ) {\r\n          templates {\r\n            * ( '\"".to_string())), item.name)), "\"' )\r\n          }\r\n        }\r\n      }    \r\n          ".to_string()), true);
      }
    }
    );
    root.pushAndCollectCode(wr.getCode(), orig_wr.clone());
  }
  fn CreateRTTI(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    let mut wr : CodeWriter = CodeWriter::new();
    wr.out("operator type:void all {".to_string(), true);
    wr.indent(1);
    wr.out("fn rtti_get_classes:[string] () {".to_string(), true);
    wr.indent(1);
    wr.out("return ([] ".to_string(), false);
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  item.isNormalClass() {
        wr.out(format!("{}{}", (format!("{}{}", "'".to_string(), item.name)), "' ".to_string()), false);
      }
    }
    );
    wr.out(")".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out("fn rtti_get_fields:[RTTIClassField] (className:string) {".to_string(), true);
    wr.indent(1);
    wr.out("def fields:[RTTIClassField]".to_string(), true);
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  item.isNormalClass() {
        wr.out(format!("{}{}", (format!("{}{}", "if(className == '".to_string(), item.name)), "') {".to_string()), true);
        wr.indent(1);
        operatorsOf::forEach_11(item.variables, (item, index) => { 
          wr.out("def f (new RTTIClassField)".to_string(), true);
          wr.out(format!("{}{}", (format!("{}{}", "f.name = `".to_string(), item.compiledName)), "`".to_string()), true);
          wr.out(format!("{}{}", (format!("{}{}", "f.type_name = `".to_string(), item.nameNode.type_name)), "`".to_string()), true);
          wr.out("push fields f".to_string(), true);
        }
        );
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    );
    wr.out("return fields".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    root.pushAndCollectCode(wr.getCode(), orig_wr.clone());
  }
  fn SolveAsyncFuncs(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      operatorsOf::forEach_29(item.static_methods, (item, index) => { 
        /** unused:  let mut thisFn : RangerAppFunctionDesc = item;   **/ 
        let mut set_async :  = (f) => { 
        }
        ;
        let mut visited : Vec<RangerAppFunctionDesc> = Vec::new();
        set_async = (f) => { 
          if  (visited.iter().position( |&r| r == f ).unwrap()) >= 0 {
            return;
          }
          visited.push(f.clone());
          if  f.nameNode.is_some() {
            f.nameNode.setFlag("async".to_string());
          }
          operatorsOf::forEach_29(f.isCalledBy, (item, index) => { 
            set_async(item);
          }
          );
          if  f.insideFn.is_some() {
            set_async((*f.insideFn.clone().unwrap()));
          }
        }
        ;
        if  item.nameNode.is_some() {
          if  item.nameNode.hasFlag("async".to_string()) {
            operatorsOf::forEach_29(item.isCalledBy, (item, index) => { 
              set_async(item);
            }
            );
            item.forOtherVersions(ctx.clone(), (item) => { 
              set_async(item);
            }
            );
            if  item.insideFn.is_some() {
              set_async((*item.insideFn.clone().unwrap()));
            }
          }
        }
        operatorsOf::forEach_29(item.myLambdas, (item, index) => { 
          if  item.nameNode.is_some() {
            if  item.nameNode.hasFlag("async".to_string()) {
              operatorsOf::forEach_29(item.isCalledBy, (item, index) => { 
                set_async(item);
              }
              );
              if  item.insideFn.is_some() {
                set_async((*item.insideFn.clone().unwrap()));
              }
            }
          }
        }
        );
      }
      );
      operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
        operatorsOf::forEach_29(item.variants, (item, index) => { 
          /** unused:  let mut thisFn_1 : RangerAppFunctionDesc = item;   **/ 
          let mut set_async_1 :  = (f) => { 
          }
          ;
          let mut visited_1 : Vec<RangerAppFunctionDesc> = Vec::new();
          set_async_1 = (f) => { 
            if  (visited_1.iter().position( |&r| r == f ).unwrap()) >= 0 {
              return;
            }
            visited_1.push(f.clone());
            if  f.nameNode.is_some() {
              f.nameNode.setFlag("async".to_string());
            }
            f.forOtherVersions(ctx.clone(), (item) => { 
              set_async_1(item);
            }
            );
            operatorsOf::forEach_29(f.isCalledBy, (item, index) => { 
              set_async_1(item);
            }
            );
            if  f.insideFn.is_some() {
              set_async_1((*f.insideFn.clone().unwrap()));
            }
          }
          ;
          if  item.nameNode.is_some() {
            if  item.nameNode.hasFlag("async".to_string()) {
              operatorsOf::forEach_29(item.isCalledBy, (item, index) => { 
                set_async_1(item);
              }
              );
              item.forOtherVersions(ctx.clone(), (item) => { 
                set_async_1(item);
              }
              );
              if  item.insideFn.is_some() {
                set_async_1((*item.insideFn.clone().unwrap()));
              }
            }
          }
          operatorsOf::forEach_29(item.myLambdas, (item, index) => { 
            if  item.nameNode.is_some() {
              if  item.nameNode.hasFlag("async".to_string()) {
                operatorsOf::forEach_29(item.isCalledBy, (item, index) => { 
                  set_async_1(item);
                }
                );
                if  item.insideFn.is_some() {
                  set_async_1((*item.insideFn.clone().unwrap()));
                }
              }
            }
          }
          );
        }
        );
      }
      );
    }
    );
    let mut notUsedFunctionCnt : i64 = 0;
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
        operatorsOf::forEach_29(item.variants, (item, index) => { 
          if  ((item.isCalledBy.len() as i64)) == 0 {
            if  item.container_class.is_some() {
              let mut cc : RangerAppClassDesc = item.container_class.clone().unwrap();
              if  (((cc.extends_classes.len() as i64)) > 0) || cc.is_inherited {
                let eC : String = cc.extends_classes[0 as usize].clone();
                ctx.findClass(eC.clone());
              } else {
                notUsedFunctionCnt = notUsedFunctionCnt + 1;
                item.is_unsed = true;
              }
            }
          }
        }
        );
      }
      );
    }
    );
    let add_dce_fn :  = (theFn) => { 
      let mut set_called :  = (f) => { 
      }
      ;
      set_called = (f) => { 
        if  f.is_called_from_main {
          return;
        }
        f.is_called_from_main = true;
        operatorsOf::forEach_31(f.isUsingClasses, (item, index) => { 
          item.is_used_by_main = true;
          if  item.constructor_fn.is_some() {
            set_called(item.constructor_fn.clone().unwrap());
          }
        }
        );
        f.forOtherVersions(ctx.clone(), (item) => { 
          set_called(item);
        }
        );
        operatorsOf::forEach_29(f.isCalling, (item, index) => { 
          set_called(item);
        }
        );
        operatorsOf::forEach_29(f.myLambdas, (item, index) => { 
          set_called(item);
        }
        );
        if  f.container_class.is_some() {
          if  f.container_class.constructor_fn.is_some() {
            set_called(f.container_class.constructor_fn.clone().unwrap());
          }
        }
      }
      ;
      set_called(theFn);
    }
    ;
    let mut use_dce : bool = false;
    if  ctx.hasCompilerFlag("dead4main".to_string()) {
      let mut mainFn : Option<RangerAppFunctionDesc> = None;
      operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
        let mut cl : RangerAppClassDesc = item;
        for i in 0..cl.static_methods.len() {
          let mut variant = cl.static_methods[i as usize].clone();
          ctx.disableCurrentClass();
          if  variant.nameNode.hasFlag("main".to_string()) && (variant.nameNode.code.filename == ctx.getRootFile()) {
            mainFn = Some(variant.clone());
            mainFn.addClassUsage(cl.clone(), ctx.clone());
          }
        }
      }
      );
      if  mainFn.is_some() {
        add_dce_fn(mainFn.unwrap());
        use_dce = true;
      }
    }
    if  ctx.hasCompilerSetting("dceclass".to_string()) {
      let dc : String = ctx.getCompilerSetting("dceclass".to_string());
      println!( "{}", format!("{}{}", "DCE : ".to_string(), dc) );
      operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
        let mut cl_1 : RangerAppClassDesc = item;
        if  cl_1.name == dc {
          use_dce = true;
          cl_1.is_used_by_main = true;
          for i_1 in 0..cl_1.static_methods.len() {
            let mut variant_1 = cl_1.static_methods[i_1 as usize].clone();
            add_dce_fn(variant_1);
          }
          operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
            operatorsOf::forEach_29(item.variants, (item, index) => { 
              add_dce_fn(item);
            }
            );
          }
          );
        }
      }
      );
    }
    if  use_dce {
      let verbose : bool = ctx.hasCompilerFlag("verbose".to_string());
      operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
        if  (item.is_used_by_main == false) && verbose {
          println!( "{}", format!("{}{}", "class not used by main : ".to_string(), item.name) );
        }
        item.static_methods = operatorsOf::filter_32(item.static_methods, (item, index) => { 
          let mut cc_1 : RangerAppClassDesc = item.container_class.clone().unwrap();
          if  item.is_called_from_main == false {
            if  verbose {
              println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", "removing as dead ".to_string(), item.name)), " from ".to_string())), cc_1.name) );
            }
          }
          return item.is_called_from_main;
        }
        );
        operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
          item.variants = operatorsOf::filter_32(item.variants, (item, index) => { 
            let mut cc_2 : RangerAppClassDesc = item.container_class.clone().unwrap();
            if  item.is_called_from_main == false {
              if  verbose {
                println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", "removing as dead ".to_string(), item.name)), " from ".to_string())), cc_2.name) );
              }
            }
            return item.is_called_from_main;
          }
          );
        }
        );
      }
      );
    }
    if  ctx.hasCompilerFlag("deadcode".to_string()) {
      operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
        operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
          item.variants = operatorsOf::filter_32(item.variants, (item, index) => { 
            return item.is_unsed == false;
          }
          );
        }
        );
      }
      );
    }
  }
  fn cmdCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    let mut obj : CodeNode = node.getSecond();
    let mut method : CodeNode = node.getThird();
    let mut callArgs : CodeNode = node.children[3 as usize].clone();
    let possible_cmd : String = method.vref.clone();
    let mut altVersion : CodeNode = node.newExpressionNode();
    let mut origCopy : CodeNode = node.copy();
    altVersion.add(node.newVRefNode(possible_cmd.clone()));
    altVersion.add(obj.copy());
    for i in 0..callArgs.children.len() {
      let mut ca = callArgs.children[i as usize].clone();
      altVersion.add(ca.copy());
    }
    altVersion.parent = Some(Box::new(node.clone()));
    node.getChildrenFrom(altVersion.clone());
    if  self.stdParamMatch(node.clone(), ctx.clone(), wr.clone(), false) {
      return true;
    } else {
      node.getChildrenFrom(origCopy.clone());
    }
    let mut obj_2 : CodeNode = node.getSecond();
    let mut method_2 : CodeNode = node.getThird();
    let mut callArgs_2 : CodeNode = node.children[3 as usize].clone();
    self.WalkNode(obj_2.clone(), ctx.clone(), wr.clone());
    if  ctx.isDefinedClass(obj_2.eval_type_name.clone()) {
      let mut cl : RangerAppClassDesc = ctx.findClass(obj_2.eval_type_name.clone());
      let mut m : Option<RangerAppFunctionDesc> = cl.findMethod(method_2.vref.clone());
      if  m.is_some() {
        node.has_call = true;
        let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
        currM.addCallTo(m.unwrap());
        ctx.setInExpr();
        for i_1 in 0..callArgs_2.children.len() {
          let mut callArg = callArgs_2.children[i_1 as usize].clone();
          self.WalkNode(callArg.clone(), ctx.clone(), wr.clone());
        }
        ctx.unsetInExpr();
        let mut nn : Option<CodeNode> = m.nameNode;
        node.eval_type = nn.typeNameAsType(ctx.clone());
        node.eval_type_name = nn.type_name.clone();
        node.eval_array_type = nn.array_type.clone();
        node.eval_key_type = nn.key_type.clone();
        if  m.nameNode.hasFlag("throws".to_string()) {
          if  false == ctx.isTryBlock() {
            ctx.addError(obj_2.clone(), format!("{}{}", (format!("{}{}", "The method ".to_string(), m.name)), " potentially throws an exception, try { } block is required".to_string()));
          }
        }
        if  nn.value_type == 17 {
          node.expression_value = Some(Box::new(nn.expression_value.copy().clone()));
        }
        if  nn.hasFlag("optional".to_string()) {
          node.setFlag("optional".to_string());
        }
        return true;
      } else {
        ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", "Class ".to_string(), obj_2.eval_type_name)), " does not have method ".to_string())), method_2.vref));
        return false;
      }
    } else {
      ctx.addError(node.clone(), "can not call non-class type".to_string());
    }
    return true;
  }
  fn matchLambdaArgs(&mut self, mut n1 : CodeNode, mut n2 : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    let chLen1 : i64 = (n1.children.len() as i64);
    let chLen2 : i64 = (n2.children.len() as i64);
    if  chLen1 < 2 {
      ctx.addError(n1.clone(), "Invalid Lambda definition, missing args or return value".to_string());
      ctx.addError(n2.clone(), "^ Invalid Lambda definition, missing args or return value".to_string());
      return false;
    }
    if  chLen2 < 2 {
      ctx.addError(n1.clone(), "Invalid Lambda definition, missing args or return value".to_string());
      ctx.addError(n2.clone(), "^ Invalid Lambda definition, missing args or return value".to_string());
      return false;
    }
    let mut rv1 : CodeNode = n1.getFirst();
    let mut args1 : CodeNode = n1.getSecond();
    let mut rv2 : CodeNode = n2.getFirst();
    let mut args2 : CodeNode = n2.getSecond();
    let mut rvExpr1 : CodeNode = n1.newExpressionNode();
    (rvExpr1).push(rv1.copy());
    let mut rvExpr2 : CodeNode = n2.newExpressionNode();
    (rvExpr2).push(rv2.copy());
    let mut argsExpr1 : CodeNode = args1.copy();
    let mut argsExpr2 : CodeNode = args2.copy();
    let mut all_matched : bool = true;
    if  ctx.hasCompilerFlag("notreallyexistingflag".to_string()) {
      all_matched = false;
    }
    if  ((argsExpr1.children.len() as i64)) != ((argsExpr2.children.len() as i64)) {
      ctx.addError(n2.clone(), "Invalid parameter count for the lambda expression".to_string());
      return false;
    }
    operatorsOf::forEach_15(argsExpr1.children, (item, index) => { 
      let mut item2 : CodeNode = argsExpr2.children[index as usize].clone();
      if  item2.value_type != item.value_type {
        all_matched = false;
      }
      if  item2.type_name != item.type_name {
        all_matched = false;
      }
      if  item2.array_type != item.array_type {
        all_matched = false;
      }
      if  item2.key_type != item.key_type {
        all_matched = false;
      }
      if  all_matched && (item.value_type == 17) {
        if  false == self.matchLambdaArgs(((*item.expression_value.clone().unwrap())), ((*item2.expression_value.clone().unwrap())), ctx.clone(), wr.clone()) {
          all_matched = false;
        }
      }
    }
    );
    if  all_matched == false {
      ctx.addError(n2.clone(), "Invalid lambda argument types".to_string());
      return false;
    }
    operatorsOf::forEach_15(rvExpr1.children, (item, index) => { 
      let mut item2_1 : CodeNode = rvExpr2.children[index as usize].clone();
      if  item2_1.value_type != item.value_type {
        all_matched = false;
      }
      if  item2_1.type_name != item.type_name {
        all_matched = false;
      }
      if  item2_1.array_type != item.array_type {
        all_matched = false;
      }
      if  item2_1.key_type != item.key_type {
        all_matched = false;
      }
      if  all_matched && (item.value_type == 17) {
        if  false == self.matchLambdaArgs(((*item.expression_value.clone().unwrap())), ((*item2_1.expression_value.clone().unwrap())), ctx.clone(), wr.clone()) {
          all_matched = false;
        }
      }
    }
    );
    if  ctx.hasCompilerFlag("notreallyexistingflag".to_string()) {
      all_matched = false;
    }
    if  all_matched == false {
      ctx.addError(n2.clone(), "Invalid lambda return value type".to_string());
      return false;
    }
    return true;
  }
  fn testLambdaCallArgs(&mut self, mut lambda_expression : CodeNode, mut callParams : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    /** unused:  let mut lambdaDef : CodeNode = lambda_expression.children[0 as usize].clone();   **/ 
    let mut lambdaArgs : CodeNode = lambda_expression.children[1 as usize].clone();
    let mut all_matched : bool = true;
    if  ((callParams.children.len() as i64)) != ((lambdaArgs.children.len() as i64)) {
      ctx.addError(callParams.clone(), "Invalid parameter count for the lambda expression ".to_string());
      ctx.addError(callParams.clone(), format!("{}{}", " ^ expected : ".to_string(), lambdaArgs.getCode()));
      all_matched = false;
    }
    operatorsOf::forEach_15(lambdaArgs.children, (item, index) => { 
      let mut item2 : CodeNode = callParams.children[index as usize].clone();
      if  item2.eval_type_name != item.type_name {
        if  item.type_name != "Any".to_string() {
          ctx.addError(item2.clone(), ["Argument of wrong type given for the lambda parameter ".to_string() , (index.to_string()) ].join(""));
          all_matched = false;
        }
      }
      if  item2.eval_array_type != item.array_type {
        ctx.addError(item2.clone(), ["Argument of wrong type given for the lambda parameter ".to_string() , (index.to_string()) ].join(""));
        all_matched = false;
      }
      if  item2.eval_key_type != item.key_type {
        ctx.addError(item2.clone(), ["Argument of wrong type given for the lambda parameter ".to_string() , (index.to_string()) ].join(""));
        all_matched = false;
      }
    }
    );
    if  all_matched == false {
      ctx.addError(callParams.clone(), "Invalid types for lambda call".to_string());
    }
    return all_matched;
  }
  fn cmdLocalCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    let mut fnNode : CodeNode = node.getFirst();
    let mut udesc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    let mut desc : RangerAppClassDesc = udesc.unwrap();
    let mut expects_error : bool = false;
    let err_cnt : i64 = ctx.getErrorCount();
    if  node.hasBooleanProperty("error".to_string()) {
      expects_error = true;
    }
    let chlen : i64 = (node.children.len() as i64);
    if  chlen > 2 {
      let mut i : i64 = 2;
      /** unused:  let mut chainRoot : CodeNode = node;   **/ 
      let mut innerNode : Option<CodeNode> = None;
      let mut newNode : CodeNode = node.newExpressionNode();
      let mut sc : CodeNode = node.getSecond();
      newNode.add(fnNode.copy());
      newNode.add(sc.copy());
      innerNode = Some(newNode.clone());
      let mut chain_cnt : i64 = 0;
      let mut b_valid : bool = true;
      while i < (chlen - 1) {
        let mut fc : CodeNode = node.children[i as usize].clone();
        let mut args : CodeNode = node.children[(i + 1) as usize].clone();
        let name : String = fc.vref;
        if  ((name.len() as i64) > 0) && ((name.chars().nth(0 as usize).unwrap_or('\0') as i64) == (".".to_string().charCodeAt(0))) {
          let method_name : String = name.chars().skip(1 as usize).take(((name.len() as i64) - 1) as usize).collect::<String>();
          let mut newNode_1 : CodeNode = node.newExpressionNode();
          newNode_1.add(node.newVRefNode("call".to_string()));
          newNode_1.add(innerNode.copy());
          newNode_1.add(node.newVRefNode(method_name.clone()));
          newNode_1.add(args.copy());
          innerNode = Some(newNode_1.clone());
          chain_cnt = chain_cnt + 1;
        } else {
          b_valid = false;
        }
        i = i + 2;
      }
      if  b_valid && (chain_cnt > 0) {
        node.getChildrenFrom(innerNode.unwrap());
        node.tag = "chainroot".to_string();
        node.flow_done = false;
        self.WalkNode(node.clone(), ctx.clone(), wr.clone());
        return true;
      }
    }
    if  ((fnNode.ns.len() as i64)) > 1 {
      let rootName : String = fnNode.ns[0 as usize].clone();
      let mut vDef2 : RangerAppParamDesc = ctx.getVariableDef(rootName.clone());
      if  ((rootName != "this".to_string()) && (vDef2.init_cnt == 0)) && (vDef2.set_cnt == 0) {
        if  (vDef2.is_class_variable == false) && (ctx.isDefinedClass(rootName.clone()) == false) {
          ctx.addError(node.clone(), format!("{}{}", "Call to uninitialized object ".to_string(), rootName));
        }
      }
      let mut vFnDef : Option<RangerAppFunctionDesc> = self.findFunctionDesc(fnNode.clone(), ctx.clone(), wr.clone());
      if  vFnDef.is_some() {
        if  vFnDef.nameNode.hasFlag("throws".to_string()) {
          if  false == ctx.isTryBlock() {
            ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "The method ".to_string(), vFnDef.name)), " potentially throws an exception, try { } block is required".to_string()));
          }
        }
        let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
        currM.addCallTo(vFnDef.unwrap());
        vFnDef.ref_cnt = vFnDef.ref_cnt + 1;
        let mut subCtx : RangerAppWriterContext = ctx.fork();
        node.hasFnCall = true;
        node.fnDesc = Some(vFnDef.clone());
        let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
        p.name = fnNode.vref.clone();
        p.value_type = fnNode.value_type;
        p.node = Some(fnNode.clone());
        p.nameNode = Some(fnNode.clone());
        p.varType = 10;
        subCtx.defineVariable(p.name.clone(), p.clone());
        self.WalkNode(fnNode.clone(), subCtx.clone(), wr.clone());
        let mut callParams : CodeNode = node.children[1 as usize].clone();
        let mut keyword_cnt : i64 = 0;
        operatorsOf::forEach_11(vFnDef.params, (item, index) => { 
          if  item.nameNode.hasFlag("keyword".to_string()) {
            keyword_cnt = keyword_cnt + 1;
            (callParams.children[index as usize].clone()).setFlag("keyword".to_string());
          }
        }
        );
        let mut nodeList : Vec<CodeNode> = self.transformParams(callParams.children, vFnDef.params, subCtx.clone());
        if  ctx.hasCompilerFlag("dbg".to_string()) {
          println!( "{}", format!("{}{}", "Local: ".to_string(), vFnDef.name) );
        }
        for i_1 in 0..nodeList.len() {
          let mut arg = nodeList[i_1 as usize].clone();
          ctx.setInExpr();
          let mut was_lambda : bool = false;
          if  arg.isFirstVref("fun".to_string()) {
            arg.flow_done = false;
            arg.forTree((item, i) => { 
              item.flow_done = false;
            }
            );
            was_lambda = true;
          }
          self.WalkNode(arg.clone(), subCtx.clone(), wr.clone());
          if  was_lambda {
            let mut currM_1 : RangerAppFunctionDesc = ctx.getCurrentMethod();
            if  arg.lambdaFnDesc.is_some() {
              vFnDef.addCallTo(arg.lambdaFnDesc.clone().unwrap());
              currM_1.addCallTo(vFnDef.unwrap());
              currM_1.myLambdas.push(arg.lambdaFnDesc.clone().unwrap());
              vFnDef.myLambdas.push(arg.lambdaFnDesc.clone().unwrap());
            }
            arg.forTree((item, i) => { 
              if  item.lambdaFnDesc.is_some() {
                item.lambdaFnDesc.insideFn = Some(Box::new(currM_1.clone()));
              }
              if  item.fnDesc.is_some() {
                if  arg.lambdaFnDesc.is_some() {
                  arg.lambdaFnDesc.addCallTo(item.fnDesc.clone().unwrap());
                }
                vFnDef.addCallTo(item.fnDesc.clone().unwrap());
              }
            }
            );
          }
          ctx.unsetInExpr();
          if  ((vFnDef.params.len() as i64)) > i_1 {
            let mut fnArg : RangerAppParamDesc = vFnDef.params[i_1 as usize].clone();
            let mut callArgP : Option<RangerAppParamDesc> = arg.paramDesc;
            if  callArgP.is_some() {
              callArgP.moveRefTo(node.clone(), fnArg.clone(), ctx.clone());
            }
          }
        }
        let cp_len : i64 = ((callParams.children.len() as i64)) - keyword_cnt;
        if  cp_len > ((vFnDef.params.len() as i64)) {
          let mut lastCallParam : CodeNode = callParams.children[(cp_len - 1) as usize].clone();
          ctx.addError(lastCallParam.clone(), "Too many arguments for function".to_string());
          ctx.addError(vFnDef.nameNode.clone().unwrap(), "NOTE: To fix the previous error: Check original function declaration which was".to_string());
        }
        for i_2 in 0..vFnDef.params.len() {
          let mut param = vFnDef.params[i_2 as usize].clone();
          if  ((callParams.children.len() as i64)) <= i_2 {
            if  param.nameNode.hasFlag("default".to_string()) {
              continue;
            }
            ctx.addError(node.clone(), "Missing arguments for function".to_string());
            ctx.addError(param.nameNode.clone().unwrap(), "NOTE: To fix the previous error: Check original function declaration which was".to_string());
            break;
          }
          if  param.nameNode.hasFlag("keyword".to_string()) {
            continue;
          }
          let mut argNode : CodeNode = callParams.children[i_2 as usize].clone();
          if  false == self.areEqualTypes((param.nameNode.clone().unwrap()), argNode.clone(), ctx.clone(), wr.clone()) {
            ctx.addError(argNode.clone(), format!("{}{}", "ERROR, invalid argument type for method ".to_string(), vFnDef.name));
          }
          let mut pNode : CodeNode = param.nameNode.clone().unwrap();
          if  pNode.hasFlag("optional".to_string()) {
            if  false == argNode.hasFlag("optional".to_string()) {
              ctx.addError(node.clone(), format!("{}{}", "function parameter optionality does not match, consider making parameter optional ".to_string(), argNode.getCode()));
            }
          }
          if  argNode.hasFlag("optional".to_string()) {
            if  false == pNode.hasFlag("optional".to_string()) {
              ctx.addError(node.clone(), format!("{}{}", "function parameter optionality does not match, consider unwrapping ".to_string(), argNode.getCode()));
            }
          }
        }
        let mut nn : Option<CodeNode> = vFnDef.nameNode;
        node.eval_type = nn.typeNameAsType(ctx.clone());
        node.eval_type_name = nn.type_name.clone();
        node.eval_array_type = nn.array_type.clone();
        node.eval_key_type = nn.key_type.clone();
        if  node.eval_type == 17 {
          node.expression_value = Some(Box::new(nn.expression_value.copy().clone()));
        }
        if  nn.hasFlag("optional".to_string()) {
          node.setFlag("optional".to_string());
        }
        if  expects_error {
          let cnt_now : i64 = ctx.getErrorCount();
          if  cnt_now == err_cnt {
            ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: expected generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now.to_string()) ].join(""));
          }
        } else {
          let cnt_now_1 : i64 = ctx.getErrorCount();
          if  cnt_now_1 > err_cnt {
            ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: did not expect generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_1.to_string()) ].join(""));
          }
        }
        return true;
      } else {
        ctx.addError(node.clone(), "Called Object or Property was not defined".to_string());
      }
    }
    if  desc.hasMethod(fnNode.vref.clone()) {
      let mut fnDescr : Option<RangerAppFunctionDesc> = desc.findMethod(fnNode.vref.clone());
      if  fnDescr.nameNode.hasFlag("throws".to_string()) {
        if  false == ctx.isTryBlock() {
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "The method ".to_string(), fnDescr.name)), " potentially throws an exception, try { } block is required".to_string()));
        }
      }
      let mut currM_2 : RangerAppFunctionDesc = ctx.getCurrentMethod();
      currM_2.addCallTo(fnDescr.unwrap());
      if  ctx.hasCompilerFlag("dbg".to_string()) {
        println!( "{}", format!("{}{}", "Local 2 : ".to_string(), fnDescr.name) );
      }
      let mut subCtx_1 : RangerAppWriterContext = ctx.fork();
      node.hasFnCall = true;
      node.fnDesc = Some(fnDescr.clone());
      let mut p_1 : RangerAppParamDesc = RangerAppParamDesc::new();
      p_1.name = fnNode.vref.clone();
      p_1.value_type = fnNode.value_type;
      p_1.node = Some(fnNode.clone());
      p_1.nameNode = Some(fnNode.clone());
      p_1.varType = 10;
      subCtx_1.defineVariable(p_1.name.clone(), p_1.clone());
      self.WalkNode(fnNode.clone(), subCtx_1.clone(), wr.clone());
      for i_3 in 0..node.children.len() {
        let mut arg_1 = node.children[i_3 as usize].clone();
        if  i_3 < 1 {
          continue;
        }
        ctx.setInExpr();
        self.WalkNode(arg_1.clone(), subCtx_1.clone(), wr.clone());
        ctx.unsetInExpr();
      }
      for i_4 in 0..fnDescr.params.len() {
        let mut param_1 = fnDescr.params[i_4 as usize].clone();
        if  ((node.children.len() as i64)) <= (i_4 + 1) {
          ctx.addError(node.clone(), "Argument was not defined".to_string());
          break;
        }
        let mut argNode_1 : CodeNode = node.children[(i_4 + 1) as usize].clone();
        if  false == self.areEqualTypes((param_1.nameNode.clone().unwrap()), argNode_1.clone(), ctx.clone(), wr.clone()) {
          ctx.addError(argNode_1.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", "ERROR, invalid argument type for ".to_string(), desc.name)), " method ".to_string())), fnDescr.name));
        }
      }
      let mut nn_1 : Option<CodeNode> = fnDescr.nameNode;
      nn_1.defineNodeTypeTo(node.clone(), ctx.clone());
      if  expects_error {
        let cnt_now_2 : i64 = ctx.getErrorCount();
        if  cnt_now_2 == err_cnt {
          ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: expected generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_2.to_string()) ].join(""));
        }
      } else {
        let cnt_now_3 : i64 = ctx.getErrorCount();
        if  cnt_now_3 > err_cnt {
          ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: did not expect generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_3.to_string()) ].join(""));
        }
      }
      return true;
    }
    if  ctx.isVarDefined(fnNode.vref.clone()) {
      let mut d : RangerAppParamDesc = ctx.getVariableDef(fnNode.vref.clone());
      d.ref_cnt = 1 + d.ref_cnt;
      if  d.nameNode.hasFlag("optional".to_string()) {
        ctx.addError(node.clone(), "Can not call optional lambda function, unwrap the function first!".to_string());
      }
      if  d.nameNode.value_type == 17 {
        let mut cnNode1 : CodeNode = node.children[0 as usize].clone();
        self.WalkNode(cnNode1.clone(), ctx.clone(), wr.clone());
        /** unused:  let mut lambdaDefArgs : CodeNode = d.nameNode.expression_value.children[1 as usize].clone();   **/ 
        let mut callParams_1 : CodeNode = node.children[1 as usize].clone();
        for i_5 in 0..callParams_1.children.len() {
          let mut arg_2 = callParams_1.children[i_5 as usize].clone();
          ctx.setInExpr();
          self.WalkNode(arg_2.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
        }
        self.testLambdaCallArgs((*d.nameNode.expression_value.clone().unwrap()), callParams_1.clone(), ctx.clone(), wr.clone());
        let mut lambdaDef : CodeNode = d.nameNode.expression_value.children[0 as usize].clone();
        node.has_lambda_call = true;
        node.eval_type = lambdaDef.typeNameAsType(ctx.clone());
        node.eval_type_name = lambdaDef.type_name.clone();
        node.eval_array_type = lambdaDef.array_type.clone();
        node.eval_key_type = lambdaDef.key_type.clone();
        if  node.eval_type == 17 {
          if  lambdaDef.expression_value.is_some() {
            node.expression_value = Some(Box::new(lambdaDef.expression_value.copy().clone()));
          }
        }
        return true;
      }
    }
    return false;
    ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", "ERROR, could not find class ".to_string(), desc.name)), " method ".to_string())), fnNode.vref));
    ctx.addError(node.clone(), format!("{}{}", "definition : ".to_string(), node.getCode()));
    if  expects_error {
      let cnt_now_4 : i64 = ctx.getErrorCount();
      if  cnt_now_4 == err_cnt {
        ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: expected generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_4.to_string()) ].join(""));
      }
    } else {
      let cnt_now_5 : i64 = ctx.getErrorCount();
      if  cnt_now_5 > err_cnt {
        ctx.addParserError(node.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: did not expect generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_5.to_string()) ].join(""));
      }
    }
    return false;
  }
  fn transformImmutableAssigment(&mut self, mut node : CodeNode) -> CodeNode {
    let mut target : CodeNode = node.getSecond();
    let mut assign_value : CodeNode = node.getThird();
    let mut root : CodeNode = node.newExpressionNode();
    root.add(node.newVRefNode("=".to_string()));
    root.add(node.newVRefNode((target.ns[0 as usize].clone())));
    let mut i : i64 = 1;
    let cnt : i64 = (target.ns.len() as i64);
    /** unused:  let mut valueExpression : CodeNode = node.newExpressionNode();   **/ 
    let mut obj_ref : String = target.ns[0 as usize].clone();
    let mut currentParent : CodeNode = root;
    while i < cnt {
      let mut callExpr : CodeNode = node.newExpressionNode();
      callExpr.add(node.newVRefNode("call".to_string()));
      callExpr.add(node.newVRefNode(obj_ref.clone()));
      let next_ref : String = target.ns[i as usize].clone();
      let set_ref : String = format!("{}{}", "set_".to_string(), next_ref);
      callExpr.add(node.newVRefNode(set_ref.clone()));
      i = i + 1;
      if  i < cnt {
        obj_ref = format!("{}{}", (format!("{}{}", obj_ref, ".".to_string())), next_ref);
        let mut paramsNode : CodeNode = node.newExpressionNode();
        paramsNode.add(callExpr.clone());
        currentParent.add(paramsNode.clone());
        currentParent = callExpr.clone();
      } else {
        let mut callParams : CodeNode = node.newExpressionNode();
        callParams.add(assign_value.copy());
        callExpr.add(callParams.clone());
        let mut paramsNode_1 : CodeNode = node.newExpressionNode();
        paramsNode_1.add(callExpr.copy());
        currentParent.add(paramsNode_1.clone());
      }
    }
    return root.clone();
  }
  fn cmdAssign(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut target : CodeNode = node.getSecond();
    self.WalkNode(target.clone(), ctx.clone(), wr.clone());
    if  target.hasParamDesc {
      if  target.paramDesc.propertyClass.is_some() {
        let mut nn : CodeNode = target.paramDesc.propertyClass.nameNode.clone().unwrap();
        if  nn.hasFlag("immutable".to_string()) {
          let mut do_transform : bool = false;
          let mut propC : Option<RangerAppClassDesc> = target.paramDesc.propertyClass;
          let mut currC : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          if  (currC.unwrap()) == (propC.unwrap()) {
            if  (target.ns[0 as usize].clone()) == "this".to_string() {
              do_transform = true;
            }
          } else {
            do_transform = true;
          }
          if  do_transform {
            let mut n1 : CodeNode = node.getSecond();
            let mut n2 : CodeNode = node.getThird();
            self.WalkNode(n1.clone(), ctx.clone(), wr.clone());
            ctx.setInExpr();
            self.WalkNode(n2.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            self.convertToUnion(n1.eval_type_name.clone(), n2.clone(), ctx.clone(), wr.clone());
            self.shouldBeEqualTypes(n1.clone(), n2.clone(), ctx.clone(), "Can not assign variable.".to_string());
            let mut immAss : CodeNode = self.transformImmutableAssigment(node.clone());
            node.getChildrenFrom(immAss.clone());
            self.cmdAssign(node.clone(), ctx.clone(), wr.clone());
            return;
          }
        }
      }
    }
    /** unused:  let chlen : i64 = (node.children.len() as i64);   **/ 
    wr.newline();
    let mut n1_1 : CodeNode = node.getSecond();
    let mut n2_1 : CodeNode = node.getThird();
    self.WalkNode(n1_1.clone(), ctx.clone(), wr.clone());
    ctx.setInExpr();
    self.WalkNode(n2_1.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    if  n1_1.hasParamDesc {
      n1_1.paramDesc.ref_cnt = n1_1.paramDesc.ref_cnt + 1;
      n1_1.paramDesc.set_cnt = n1_1.paramDesc.set_cnt + 1;
    }
    if  n2_1.hasParamDesc {
      n2_1.paramDesc.ref_cnt = n2_1.paramDesc.ref_cnt + 1;
    }
    if  n2_1.hasFlag("optional".to_string()) {
      if  false == n1_1.hasFlag("optional".to_string()) {
        ctx.addError(node.clone(), "Can not assign optional to non-optional type".to_string());
      }
    }
    self.stdParamMatch(node.clone(), ctx.clone(), wr.clone(), true);
    self.convertToUnion(n1_1.eval_type_name.clone(), n2_1.clone(), ctx.clone(), wr.clone());
    self.shouldBeEqualTypes(n1_1.clone(), n2_1.clone(), ctx.clone(), "Can not assign variable.".to_string());
  }
  fn EnterTemplateClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn EnterClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let body_index : i64 = node.chlen() - 1;
    if  ((node.children.len() as i64)) != 3 {
      if  node.chlen() == 5 {
      } else {
        ctx.addError(node.clone(), "Invalid class declaration".to_string());
        return;
      }
    }
    if  node.hasBooleanProperty("trait".to_string()) {
      return;
    }
    let mut cn : CodeNode = node.children[1 as usize].clone();
    let mut cBody : CodeNode = node.children[body_index as usize].clone();
    let mut desc : RangerAppClassDesc = ctx.findClass(cn.vref.clone());
    let mut subCtx : RangerAppWriterContext = desc.ctx.clone().unwrap();
    subCtx.setCurrentClass(desc.clone());
    subCtx.class_level_context = true;
    for i in 0..desc.variables.len() {
      let mut p = desc.variables[i as usize].clone();
      let mut vNode : Option<CodeNode> = p.node;
      if  ((vNode.children.len() as i64)) > 2 {
        let mut value : CodeNode = vNode.children[2 as usize].clone();
        ctx.setInExpr();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      }
      p.is_class_variable = true;
      p.nameNode.eval_type = p.nameNode.typeNameAsType(ctx.clone());
      p.nameNode.eval_type_name = p.nameNode.type_name.clone();
    }
    for i_1 in 0..cBody.children.len() {
      let mut fNode = cBody.children[i_1 as usize].clone();
      if  (fNode.isFirstVref("fn".to_string()) || fNode.isFirstVref("constructor".to_string())) || fNode.isFirstVref("Constructor".to_string()) {
        self.WalkNode(fNode.clone(), subCtx.clone(), wr.clone());
      }
    }
    for i_2 in 0..cBody.children.len() {
      let mut fNode_1 = cBody.children[i_2 as usize].clone();
      if  fNode_1.isFirstVref("fn".to_string()) || fNode_1.isFirstVref("PublicMethod".to_string()) {
        self.WalkNode(fNode_1.clone(), subCtx.clone(), wr.clone());
      }
    }
    let mut staticCtx : RangerAppWriterContext = ctx.fork();
    staticCtx.setCurrentClass(desc.clone());
    for i_3 in 0..cBody.children.len() {
      let mut fNode_2 = cBody.children[i_3 as usize].clone();
      if  (fNode_2.isFirstVref("sfn".to_string()) || fNode_2.isFirstVref("StaticMethod".to_string())) || fNode_2.isFirstVref("static".to_string()) {
        self.WalkNode(fNode_2.clone(), staticCtx.clone(), wr.clone());
      }
    }
    operatorsOf::forEach_15(cBody.children, (item, index) => { 
      try {
        if  item.isFirstVref("doc".to_string()) {
          let mut sc : CodeNode = item.getSecond();
          let mut fndesc : Option<RangerAppFunctionDesc> = desc.findMethod(sc.vref.clone());
          if fndesc.is_some() {
            let mut third : CodeNode = item.getThird();
            fndesc.git_doc = third.string_value.clone();
          }
        }
      } catch(e) {
      }
    }
    );
    node.hasClassDescription = true;
    node.clDesc = Some(desc.clone());
    desc.classNode = Some(node.clone());
  }
  fn walkFunctionBody(&mut self, mut m : RangerAppFunctionDesc, mut fnBody : CodeNode, mut ctx : RangerAppWriterContext, mut subCtx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    /** unused:  let prev_fnc : bool = subCtx.function_level_context;   **/ 
    /** unused:  let prev_isfn : bool = subCtx.is_function;   **/ 
    subCtx.function_level_context = true;
    subCtx.is_function = true;
    subCtx.currentMethod = Some(m.clone());
    for i in 0..m.params.len() {
      let mut v = m.params[i as usize].clone();
      if  false == subCtx.isVarDefined(v.name.clone()) {
        subCtx.defineVariable(v.name.clone(), v.clone());
      }
      v.nameNode.eval_type = v.nameNode.typeNameAsType(subCtx.clone());
      v.nameNode.eval_type_name = v.nameNode.type_name.clone();
      ctx.hadValidType(v.nameNode.clone().unwrap());
      if  ctx.isDefinedClass(v.nameNode.type_name.clone()) {
        let mut cl : RangerAppClassDesc = ctx.findClass(v.nameNode.type_name.clone());
        m.addClassUsage(cl.clone(), ctx.clone());
      }
      if  ctx.isDefinedClass(v.nameNode.array_type.clone()) {
        let mut cl_1 : RangerAppClassDesc = ctx.findClass(v.nameNode.array_type.clone());
        m.addClassUsage(cl_1.clone(), ctx.clone());
      }
    }
    subCtx.setInMethod();
    self.WalkNodeChildren(fnBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInMethod();
    if  fnBody.didReturnAtIndex == -1 {
      if  m.nameNode.type_name != "void".to_string() {
        if  false == ctx.getFlag("in_task".to_string()) {
          ctx.addError(m.nameNode.clone().unwrap(), "Function does not return any values!".to_string());
        }
      }
    } else {
      if  (m.nameNode.type_name == "void".to_string()) || ((((m.nameNode.type_name.len() as i64) > 0) == false) && (((m.nameNode.array_type.len() as i64) > 0) == false)) {
        if  false == ctx.getFlag("in_task".to_string()) {
          let mut rvNode : CodeNode = fnBody.children[fnBody.didReturnAtIndex as usize].clone();
          if  ((rvNode.children.len() as i64)) > 1 {
            ctx.addError(m.nameNode.clone().unwrap(), "No return value type defined for a function which returns value".to_string());
            ctx.addError(rvNode.clone(), "Returning value from a function without set return value".to_string());
          }
        }
      }
    }
    for i_1 in 0..subCtx.localVarNames.len() {
      let mut n = subCtx.localVarNames[i_1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = subCtx.localVariables.get(n);
      if  p.set_cnt > 0 {
        if  p.is_immutable {
          ctx.addError(p.nameNode.clone().unwrap(), "Immutable variable was assigned a value".to_string());
        }
        let mut defNode : Option<CodeNode> = p.node;
        defNode.setFlag("mutable".to_string());
        let mut nNode : Option<CodeNode> = p.nameNode;
        nNode.setFlag("mutable".to_string());
      }
    }
  }
  fn EnterMethod(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.EnterFn(node.clone(), ctx.clone(), wr.clone(), (node, ctx, wr, nameNode, fnArgs, fnBody, desc) => { 
      let mut m : RangerAppFunctionDesc = desc.findMethod(nameNode.vref.clone()).unwrap();
      let mut subCtx : RangerAppWriterContext = m.fnCtx.clone().unwrap();
      self.walkFunctionBody(m.clone(), fnBody.clone(), ctx.clone(), subCtx.clone(), wr.clone());
    }
    );
  }
  fn EnterStaticMethod(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.EnterFn(node.clone(), ctx.clone(), wr.clone(), (node, ctx, wr, nameNode, fnArgs, fnBody, desc) => { 
      let mut m : RangerAppFunctionDesc = desc.findStaticMethod(nameNode.vref.clone()).unwrap();
      let mut subCtx : RangerAppWriterContext = ctx.fork();
      m.fnCtx = Some(subCtx.clone());
      subCtx.in_static_method = true;
      self.walkFunctionBody(m.clone(), fnBody.clone(), ctx.clone(), subCtx.clone(), wr.clone());
      subCtx.in_static_method = false;
    }
    );
  }
  fn DefineArrowOpFn(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let myName : String = ctx.createNewOpFnName();
    let mut argsNode : CodeNode = CodeNode::expressionNode();
    let mut fBody : CodeNode = node.copy();
    removefBody.children0let mut opNode : CodeNode = CodeNode::fromList([CodeNode::vref1("defn".to_string()), CodeNode::vref1(myName.clone()), argsNode, fBody]);
    let setArg :  = (idx) => { 
      let mut i : i64 = (argsNode.children.len() as i64);
      while i <= idx {
        argsNode.children.push(CodeNode::vref1(([(format!("{}{}", myName, "_arg".to_string())) , (i.to_string()) ].join(""))));
        i = i + 1;
      }
    }
    ;
    fBody.forTree((item, i) => { 
      operatorsOf::forEach_15(item.attrs, (item, index) => { 
        item.forTree((item, i) => { 
          if  (item.vref.len() as i64) > 0 {
            if  item.vref == "_".to_string() {
              setArg(0);
              item.vref = format!("{}{}", myName, "_arg0".to_string());
            }
            let mut parts : Vec<String> = item.vref.split("_".to_string());
            if  ((parts.len() as i64)) == 2 {
              let rest : String = parts[1 as usize].clone();
              let nbr : Option<i64> = isNaN( parseInt(rest) ) ? undefined : parseInt(rest);
              if  nbr.is_some() {
                let n : i64 = nbr.unwrap();
                setArg(n - 1);
                item.vref = [(format!("{}{}", myName, "_arg".to_string())) , ((n - 1).to_string()) ].join("");
              }
            }
          }
        }
        );
      }
      );
      if  (item.vref.len() as i64) > 0 {
        if  item.vref == "_".to_string() {
          setArg(0);
          item.vref = format!("{}{}", myName, "_arg0".to_string());
        }
        let mut parts_1 : Vec<String> = item.vref.split("_".to_string());
        if  ((parts_1.len() as i64)) == 2 {
          let rest_1 : String = parts_1[1 as usize].clone();
          let nbr_1 : Option<i64> = isNaN( parseInt(rest_1) ) ? undefined : parseInt(rest_1);
          if  nbr_1.is_some() {
            let n_1 : i64 = nbr_1.unwrap();
            setArg(n_1 - 1);
            item.vref = [(format!("{}{}", myName, "_arg".to_string())) , ((n_1 - 1).to_string()) ].join("");
          }
        }
      }
    }
    );
    ctx.addOpFn(myName.clone(), opNode.clone());
    node.children.length = 0;
    node.vref = myName.clone();
    node.expression = false;
  }
  fn DefineOpFn(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((node.children.len() as i64)) < 4 {
      ctx.addError(node.clone(), "invalid operator function".to_string());
      return;
    }
    let mut fnName : CodeNode = node.children[1 as usize].clone();
    if  false == ((fnName.vref.len() as i64) > 0) {
      ctx.addError(node.clone(), "operator function has no name".to_string());
      return;
    }
    ctx.addOpFn(fnName.vref.clone(), node.clone());
    node.disabled_node = true;
    node.flow_done = true;
  }
  fn testCompile(&mut self, mut opFn : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> HashMap<String,CodeNode> {
    /** unused:  let ok : bool = false;   **/ 
    let mut rootCtx : RangerAppWriterContext = ctx.getRoot();
    /** unused:  let errCnt : i64 = (rootCtx.compilerErrors.len() as i64);   **/ 
    let mut opParams : CodeNode = opFn.children[2 as usize].clone();
    let mut opBody : CodeNode = opFn.children[3 as usize].clone();
    let mut xValue : CodeNode = node.copy();
    removexValue.children0let mut regToArg : HashMap<String,CodeNode> = HashMap::new();
    let mut am : RangerArgMatch = RangerArgMatch::new();
    opParams.parallelTree(xValue.clone(), (left, right, i) => { 
      if  (left.is_some()) && (right.is_some()) {
        if  (left.vref.len() as i64) > 0 {
          let mut v : CodeNode = right.unwrap();
          if  v.expression {
            regToArg.insert(left.vref, right.unwrap());
          }
          am.nodes.insert(left.vref, right.unwrap());
        }
      }
    }
    );
    let mut opParamSet : HashMap<String,bool> = HashMap::new();
    let mut regParams : HashMap<String,bool> = HashMap::new();
    let mut regNames : HashMap<String,String> = HashMap::new();
    if  false == ((node.register_name.len() as i64) > 0) {
      opBody.forTree((item, i) => { 
        if  regToArg.contains_key(&item.vref) {
          if  opParamSet.contains_key(&item.vref) {
            if  false == (regParams.contains_key(&item.vref)) {
              let mut realArg : CodeNode = (regToArg.get(item.vref)).unwrap();
              if  (realArg.register_name.len() as i64) > 0 {
              } else {
                let regName : String = ctx.createNewRegName();
                regNames.insert(item.vref, regName);
                let mut argCopy : CodeNode = realArg.copy();
                let mut regExpr : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName.clone()), argCopy]);
                self.WalkNode(regExpr.clone(), ctx.clone(), wr.clone());
                let mut regArg : CodeNode = regExpr.children[1 as usize].clone();
                let realRegName : String = (((regExpr.children[1 as usize].clone())).paramDesc).compiledName;
                regArg.paramDesc.set_cnt = 1;
                regArg.paramDesc.ref_cnt = 1;
                let mut BlockOP : Option<CodeNode> = ctx.getLastBlockOp();
                BlockOP.register_expressions.push(regExpr.clone());
                realArg.register_name = regName.clone();
                realArg.reg_compiled_name = realRegName.clone();
              }
            }
            regParams.insert(item.vref, true);
          }
          opParamSet.insert(item.vref, true);
        }
      }
      );
    }
    /** unused:  let mut bodyCopy : CodeNode = opBody.copy();   **/ 
    let mut newNode : CodeNode = opBody.rebuildWithType(am.clone(), true);
    node.children.length = 0;
    operatorsOf::forEach_15(newNode.children, (item, index) => { 
      let mut tmp : CodeNode = item;
      node.children.push(tmp.clone());
    }
    );
    node.flow_done = false;
    if  opBody.is_block_node {
      println!( "{}", format!("{}{}", "Block -> ".to_string(), opBody.getCode()) );
      let mut blockCtx : RangerAppWriterContext = ctx.fork();
      blockCtx.newBlock();
      self.WalkNode(node.clone(), blockCtx.clone(), wr.clone());
    } else {
      self.WalkNode(node.clone(), ctx.clone(), wr.clone());
    }
    return am.builtNodes;
  }
  fn TransformOpFn(&mut self, mut opFnList : Vec<CodeNode>, mut origNode : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  self.infinite_recursion {
      return;
    }
    let mut ok : bool = false;
    let mut rootCtx : RangerAppWriterContext = ctx.getRoot();
    let errCnt : i64 = (rootCtx.compilerErrors.len() as i64);
    let use_delta : bool = true;
    let mut least_err_cnt : i64 = 99999;
    let mut least_errs : Vec<RangerCompilerMessage> = Vec::new();
    let depth : i64 = operatorsOfstring_33::transactionc95depth_34("TransformOpFn".to_string(), ctx.clone());
    if  depth > 20 {
      ctx.addError(origNode.clone(), "Error: recursive operator function detected".to_string());
      self.infinite_recursion = true;
      return;
    }
    if  (origNode.register_name.len() as i64) > 0 {
      if  ctx.isVarDefined(origNode.register_name.clone()) {
        let mut regInfo : RangerAppParamDesc = ctx.getVariableDef(origNode.register_name.clone());
        if  regInfo.nameNode.is_some() {
          origNode.copyEvalResFrom(regInfo.nameNode.clone().unwrap());
          return;
        } else {
        }
      } else {
      }
    }
    let mut fc : CodeNode = origNode.children[0 as usize].clone();
    let mut myT : ContextTransaction = operatorsOf_33::startc95transaction_35("TransformOpFn".to_string(), fc.vref.clone(), ctx.clone());
    let mut newOps : Vec<CodeNode> = Vec::new();
    let mut tryTypes : Vec<String> = ["string".to_string(), "int".to_string(), "double".to_string(), "boolean".to_string()];
    let codeStrHash : String = origNode.getSource();
    if  self.match_types.contains_key(&codeStrHash) {
      tryTypes.insert(0 as usize, (self.match_types.get(codeStrHash)).unwrap());
    }
    let cList :  = reversectx.getRoot.getClasses;
    callcListforEachif||item.isNormalClassitem.is_systemif>=indexOfcodeStrHashitem.name0inserttryTypes0item.namepushtryTypesitem.nameoperatorsOf::forEach_15(opFnList, (item, index) => { 
      let mut had_v : bool = false;
      item.forTree((item, i) => { 
        if  ((item.array_type == "?".to_string()) || (item.key_type == "?".to_string())) || (item.type_name == "?".to_string()) {
          had_v = true;
        }
      }
      );
      if  had_v {
        let mut opFn : CodeNode = item.copy();
        /** unused:  let mut opParams : CodeNode = opFn.children[2 as usize].clone();   **/ 
        /** unused:  let mut opBody : CodeNode = opFn.children[3 as usize].clone();   **/ 
        let mut typeName : String = "".to_string();
        operatorsOf::forEach_12(tryTypes, (item, index) => { 
          let mut copyOfFn : CodeNode = opFn.copy();
          typeName = item.clone();
          copyOfFn.forTree((item, i) => { 
            if  item.array_type == "?".to_string() {
              item.array_type = typeName.clone();
            }
            if  item.key_type == "?".to_string() {
              item.key_type = typeName.clone();
            }
            if  item.type_name == "?".to_string() {
              item.type_name = typeName.clone();
            }
          }
          );
          copyOfFn.matched_type = typeName.clone();
          newOps.push(copyOfFn.clone());
        }
        );
      }
    }
    );
    if  ((newOps.len() as i64)) > 0 {
      operatorsOf::forEach_15(newOps, (item, index) => { 
        /** unused:  let mut tmp : CodeNode = item;   **/ 
        opFnList.push(item.clone());
      }
      );
    }
    let oNodeParams : i64 = (origNode.children.len() as i64);
    operatorsOf::filter_36(opFnList, (item, index) => { 
      let mut opParams_1 : CodeNode = item.children[2 as usize].clone();
      return oNodeParams == (((opParams_1.children.len() as i64)) - 1);
    }
    );
    operatorsOf::forEach_15(opFnList, (item, index) => { 
      if  ok {
        return;
      } else {
        let currentErrCnt : i64 = (rootCtx.compilerErrors.len() as i64);
        let errDelta : i64 = currentErrCnt - errCnt;
        if  errDelta > 0 {
          if  errDelta < least_err_cnt {
            least_err_cnt = errDelta;
            let mut i : i64 = errCnt;
            least_errs.length = 0;
            while i < currentErrCnt {
              let mut tmp_1 : RangerCompilerMessage = rootCtx.compilerErrors[i as usize].clone();
              least_errs.push(tmp_1.clone());
              i = i + 1;
            }
          }
          let mut i_1 : i64 = errCnt;
          while i_1 < currentErrCnt {
            rootCtx.compilerErrors.pop();
            i_1 = i_1 + 1;
          }
        }
      }
      let mut originalOpFn : CodeNode = item;
      let mut node : CodeNode = origNode.copy();
      let mut opFn_1 : CodeNode = item;
      let mut opParams_2 : CodeNode = opFn_1.children[2 as usize].clone();
      let mut opBody_1 : CodeNode = opFn_1.children[3 as usize].clone();
      let mut xValue : CodeNode = node.copy();
      removexValue.children0opBody_1.forTree((item, i) => { 
        if  item.vref == "return".to_string() {
        }
      }
      );
      let mut regToArg : HashMap<String,CodeNode> = HashMap::new();
      let mut am : RangerArgMatch = RangerArgMatch::new();
      opParams_2.parallelTree(xValue.clone(), (left, right, i) => { 
        if  (left.is_some()) && (right.is_some()) {
          if  (left.vref.len() as i64) > 0 {
            let mut v : CodeNode = right.unwrap();
            if  v.expression {
              regToArg.insert(left.vref, right.unwrap());
            }
            am.nodes.insert(left.vref, right.unwrap());
          }
        }
      }
      );
      let mut opParamSet : HashMap<String,bool> = HashMap::new();
      let mut regParams : HashMap<String,bool> = HashMap::new();
      let mut regNames : HashMap<String,String> = HashMap::new();
      let mut BlockOP : Option<CodeNode> = ctx.getLastBlockOp();
      let mut newDefNodes : Vec<CodeNode> = Vec::new();
      let mut newRNodes : Vec<CodeNode> = Vec::new();
      if  false == ((node.register_name.len() as i64) > 0) {
        opBody_1.forTree((item, i) => { 
          if  regToArg.contains_key(&item.vref) {
            if  opParamSet.contains_key(&item.vref) {
              if  false == (regParams.contains_key(&item.vref)) {
                let mut realArg : CodeNode = (regToArg.get(item.vref)).unwrap();
                if  (realArg.register_name.len() as i64) > 0 {
                } else {
                  let regName : String = ctx.createNewRegName();
                  regNames.insert(item.vref, regName);
                  let mut argCopy : CodeNode = realArg.copy();
                  let mut regExpr : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName.clone()), argCopy]);
                  let cnt : i64 = (BlockOP.register_expressions.len() as i64);
                  self.WalkNode(regExpr.clone(), ctx.clone(), wr.clone());
                  let opCntDelta : i64 = ((BlockOP.register_expressions.len() as i64)) - cnt;
                  if  use_delta && (opCntDelta > 0) {
                    let opCnt : i64 = (BlockOP.register_expressions.len() as i64);
                    let mut i_2 : i64 = cnt;
                    while i_2 < opCnt {
                      let mut tmp_2 : CodeNode = BlockOP.register_expressions[i_2 as usize].clone();
                      newRNodes.push(tmp_2.clone());
                      i_2 = i_2 + 1;
                    }
                    i_2 = cnt;
                    while i_2 < opCnt {
                      BlockOP.register_expressions.pop();
                      i_2 = i_2 + 1;
                    }
                  }
                  let mut regArg : CodeNode = regExpr.children[1 as usize].clone();
                  let realRegName : String = (((regExpr.children[1 as usize].clone())).paramDesc).compiledName;
                  regArg.paramDesc.set_cnt = 1;
                  regArg.paramDesc.ref_cnt = 1;
                  if  use_delta {
                    newRNodes.push(regExpr.clone());
                  } else {
                    let mut BlockOP_1 : Option<CodeNode> = ctx.getLastBlockOp();
                    BlockOP_1.register_expressions.push(regExpr.clone());
                  }
                  realArg.register_name = regName.clone();
                  realArg.reg_compiled_name = realRegName.clone();
                }
              }
              regParams.insert(item.vref, true);
            }
            opParamSet.insert(item.vref, true);
          }
        }
        );
      }
      let mut newNode : CodeNode = opBody_1.rebuildWithType(am.clone(), true);
      node.getChildrenFrom(newNode.clone());
      node.flow_done = false;
      ctx.setTestCompile();
      if  opBody_1.is_block_node {
        let mut blockCtx : RangerAppWriterContext = ctx.fork();
        blockCtx.newBlock();
        self.WalkNode(node.clone(), blockCtx.clone(), wr.clone());
      } else {
        self.WalkNode(node.clone(), ctx.clone(), wr.clone());
      }
      if  errCnt == ((rootCtx.compilerErrors.len() as i64)) {
        ctx.unsetTestCompile();
        if  (originalOpFn.matched_type.len() as i64) > 0 {
          self.match_types.insert(codeStrHash, originalOpFn.matched_type);
        }
        if  false == ctx.isTestCompile() {
          operatorsOf::forEach_15(newDefNodes, (item, index) => { 
            let mut tmp_3 : CodeNode = item;
            BlockOP.register_expressions.push(tmp_3.clone());
          }
          );
          operatorsOf::forEach_15(newRNodes, (item, index) => { 
            let mut tmp_4 : CodeNode = item;
            BlockOP.register_expressions.push(tmp_4.clone());
          }
          );
        }
        ok = true;
        let mut newNode_1 : CodeNode = opBody_1.rebuildWithType(am.clone(), true);
        origNode.getChildrenFrom(newNode_1.clone());
        origNode.flow_done = false;
        if  opBody_1.is_block_node {
          let mut blockCtx_1 : RangerAppWriterContext = ctx.fork();
          blockCtx_1.newBlock();
          self.WalkNode(origNode.clone(), blockCtx_1.clone(), wr.clone());
          let mut lastLine : CodeNode = origNode.children[(((origNode.children.len() as i64)) - 1) as usize].clone();
          if  (lastLine.isFirstVref("ret".to_string()) || ((lastLine.eval_array_type.len() as i64) > 0)) || (((lastLine.eval_type_name.len() as i64) > 0) && (lastLine.eval_type_name != "void".to_string())) {
            let mut argVal : CodeNode = lastLine.children[1 as usize].clone();
            self.WalkNode(argVal.clone(), blockCtx_1.clone(), wr.clone());
            origNode.copyEvalResFrom(argVal.clone());
            let regName_1 : String = ctx.createNewRegName();
            regNames.insert(item.vref, regName_1);
            let mut argCopy_1 : CodeNode = argVal.copy();
            let mut nameNode : CodeNode = CodeNode::vref1(regName_1.clone());
            nameNode.value_type = origNode.eval_type;
            nameNode.type_name = origNode.eval_type_name.clone();
            nameNode.array_type = origNode.eval_array_type.clone();
            nameNode.key_type = origNode.eval_key_type.clone();
            if  argVal.eval_type == 17 {
              if  argVal.expression_value.is_some() {
                nameNode.expression_value = Some(Box::new(argVal.expression_value.copy().clone()));
              } else {
                nameNode.expression_value = Some(Box::new(argVal.copy().clone()));
              }
            }
            nameNode.setFlag("unwrap".to_string());
            let mut regExpr_1 : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), nameNode]);
            self.WalkNode(regExpr_1.clone(), ctx.clone(), wr.clone());
            let mut regArg_1 : CodeNode = regExpr_1.children[1 as usize].clone();
            let realRegName_1 : String = (((regExpr_1.children[1 as usize].clone())).paramDesc).compiledName;
            regArg_1.paramDesc.set_cnt = 1;
            regArg_1.paramDesc.ref_cnt = 1;
            let mut BlockOP_2 : Option<CodeNode> = ctx.getLastBlockOp();
            if  false == ctx.isTestCompile() {
            }
            origNode.register_name = regName_1.clone();
            origNode.reg_compiled_name = realRegName_1.clone();
            lastLine.flow_done = false;
            lastLine.children.length = 0;
            lastLine.getChildrenFrom(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName_1.clone()), argCopy_1]));
            /** unused:  let mut regE : CodeNode = regExpr_1.children[1 as usize].clone();   **/ 
            self.WalkNode(lastLine.clone(), blockCtx_1.clone(), wr.clone());
            let mut myBlock : CodeNode = CodeNode::expressionNode();
            myBlock.getChildrenFrom(origNode.clone());
            if  false == ctx.isTestCompile() {
              myBlock.children.insert(0 as usize, regExpr_1);
              BlockOP_2.register_expressions.push(myBlock.clone());
            }
            origNode.children.length = 0;
            origNode.flow_done = true;
          }
        } else {
          self.WalkNode(origNode.clone(), ctx.clone(), wr.clone());
          origNode.flow_done = true;
        }
      } else {
        ctx.unsetTestCompile();
      }
    }
    );
    /** unused:  let depth_2 : i64 = operatorsOf_33::transactionc95depth_34("TransformOpFn".to_string(), ctx.clone());   **/ 
    /** unused:  let errDelta_1 : i64 = ((rootCtx.compilerErrors.len() as i64)) - errCnt;   **/ 
    let currentErrCnt_1 : i64 = (rootCtx.compilerErrors.len() as i64);
    let errDelta_3 : i64 = currentErrCnt_1 - errCnt;
    if  errDelta_3 > 0 {
      if  errDelta_3 < least_err_cnt {
        let mut i_3 : i64 = errCnt;
        least_errs.length = 0;
        while i_3 < currentErrCnt_1 {
          let mut tmp_5 : RangerCompilerMessage = rootCtx.compilerErrors[i_3 as usize].clone();
          least_errs.push(tmp_5.clone());
          i_3 = i_3 + 1;
        }
      }
      let mut i_4 : i64 = errCnt;
      while i_4 < currentErrCnt_1 {
        rootCtx.compilerErrors.pop();
        i_4 = i_4 + 1;
      }
    }
    if  errDelta_3 > 0 {
      operatorsOf::forEach_37(least_errs, (item, index) => { 
        let mut tmp_6 : RangerCompilerMessage = item;
        rootCtx.compilerErrors.push(tmp_6.clone());
      }
      );
      println!( "{}", "^ had errors...".to_string() );
      ctx.addError(origNode.clone(), "Could not find suitable match for the operator node".to_string());
    }
    if  self.infinite_recursion {
      ctx.addError(origNode.clone(), "Error: max recursiion depth of > 20 for inline operators detected".to_string());
    }
    operatorsOfContextTransaction_38::endc95transaction_39(myT.clone());
  }
  fn cmdArray(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((node.children.len() as i64)) == 3 {
      let mut sc : CodeNode = node.getSecond();
      if  ((sc.vref.len() as i64) > 0) && ((sc.type_name.len() as i64) > 0) {
        node.eval_array_type = sc.type_name.clone();
        node.eval_type = 6;
        let mut items : CodeNode = node.getThird();
        let mut b_union : bool = false;
        let mut union_types : Vec<String> = Vec::new();
        if  ctx.isDefinedClass(sc.type_name.clone()) {
          let mut cl : RangerAppClassDesc = ctx.findClass(sc.type_name.clone());
          if  cl.is_union {
            b_union = true;
            union_types = cl.is_union_of.clone();
          }
        }
        let mut arrayItems : CodeNode = node.newExpressionNode();
        for i in 0..items.children.len() {
          let mut it = items.children[i as usize].clone();
          let mut itemCopy : CodeNode = it.copy();
          self.WalkNode(itemCopy.clone(), ctx.clone(), wr.clone());
          if  itemCopy.eval_type_name != sc.type_name {
            if  b_union {
              if  (union_types.iter().position( |&r| r == itemCopy.eval_type_name ).unwrap()) >= 0 {
              } else {
                ctx.addError(it.clone(), format!("{}{}", (format!("{}{}", itemCopy.eval_type_name, " is Not part of union ".to_string())), sc.type_name));
                break;
              }
            } else {
              ctx.addError(it.clone(), format!("{}{}", "The array type should be ".to_string(), sc.type_name));
              break;
            }
          }
          arrayItems.children.push(itemCopy.clone());
        }
        node.getChildrenFrom(arrayItems.clone());
        node.is_array_literal = true;
        return;
      }
    }
    let mut arrayItems_1 : CodeNode = node.newExpressionNode();
    let mut types : Vec<String> = Vec::new();
    for i_1 in 0..node.children.len() {
      let mut it_1 = node.children[i_1 as usize].clone();
      if  i_1 == 0 {
        continue;
      }
      let mut itemCopy_1 : CodeNode = it_1.copy();
      self.WalkNode(itemCopy_1.clone(), ctx.clone(), wr.clone());
      if  (types.iter().position( |&r| r == itemCopy_1.eval_type_name ).unwrap()) < 0 {
        types.push(itemCopy_1.eval_type_name);
      }
      arrayItems_1.children.push(itemCopy_1.clone());
    }
    let typeCnt : i64 = (types.len() as i64);
    if  typeCnt == 0 {
      ctx.addError(node.clone(), "Invalid array types".to_string());
      return;
    }
    node.eval_type = 6;
    if  ((types.len() as i64)) > 1 {
      node.eval_array_type = "Any".to_string();
    } else {
      node.eval_array_type = types[0 as usize].clone();
    }
    node.is_array_literal = true;
    node.getChildrenFrom(arrayItems_1.clone());
  }
  fn EnterLambdaMethod(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    if  false == args.expression {
      ctx.addError(node.clone(), "Invalid anonymous function: second param should be an expression".to_string());
    }
    ctx.incLambdaCnt();
    subCtx.is_capturing = true;
    node.evalTypeClass = Some(TFactory::new_lambda_signature(node.clone(), ctx.clone(), wr.clone()));
    let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
    let mut cn : CodeNode = node.children[0 as usize].clone();
    let mut m : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
    m.name = "lambda".to_string();
    m.node = Some(node.clone());
    m.is_lambda = true;
    m.nameNode = Some(node.children[0 as usize].clone());
    m.insideFn = Some(Box::new(currM.clone()));
    subCtx.newBlock();
    currM.myLambdas.push(m.clone());
    subCtx.is_function = true;
    subCtx.currentMethod = Some(m.clone());
    if  cn.hasFlag("weak".to_string()) {
      m.changeStrength(0, 1, node.clone());
    } else {
      m.changeStrength(1, 1, node.clone());
    }
    m.fnBody = Some(node.children[2 as usize].clone());
    for ii in 0..args.children.len() {
      let mut arg = args.children[ii as usize].clone();
      self.CheckTypeAnnotationOf(arg.clone(), subCtx.clone(), wr.clone());
      let mut p2 : RangerAppParamDesc = RangerAppParamDesc::new();
      p2.name = arg.vref.clone();
      p2.value_type = arg.value_type;
      p2.node = Some(arg.clone());
      p2.nameNode = Some(arg.clone());
      p2.init_cnt = 1;
      p2.refType = 1;
      p2.initRefType = 1;
      if  args.hasBooleanProperty("strong".to_string()) {
        p2.refType = 2;
        p2.initRefType = 2;
      }
      p2.varType = 4;
      m.params.push(p2.clone());
      arg.hasParamDesc = true;
      arg.paramDesc = Some(p2.clone());
      arg.eval_type = arg.value_type;
      arg.eval_type_name = arg.type_name.clone();
      if  arg.hasFlag("strong".to_string()) {
        p2.changeStrength(1, 1, p2.nameNode.clone().unwrap());
      } else {
        arg.setFlag("lives".to_string());
        p2.changeStrength(0, 1, p2.nameNode.clone().unwrap());
      }
      subCtx.defineVariable(p2.name.clone(), p2.clone());
    }
    /** unused:  let cnt : i64 = (body.children.len() as i64);   **/ 
    for i in 0..body.children.len() {
      let mut item = body.children[i as usize].clone();
      let mut tmp : CodeNode = item;
      subCtx.lastBlockOp = Some(tmp.clone());
      self.WalkNode(item.clone(), subCtx.clone(), wr.clone());
      if  i == (((body.children.len() as i64)) - 1) {
        if  ((item.children.len() as i64)) > 0 {
          let mut fc : CodeNode = item.getFirst();
          if  fc.vref != "return".to_string() {
            cn.type_name = "void".to_string();
          }
        }
      }
    }
    node.has_lambda = true;
    node.lambda_ctx = Some(subCtx.clone());
    node.eval_type = 17;
    node.eval_function = Some(Box::new(node.clone()));
    node.expression_value = Some(Box::new(node.copy().clone()));
    node.lambdaFnDesc = Some(m.clone());
    if  ctx.isCapturing() {
      operatorsOf::forEach_12(node.lambda_ctx.captured_variables, (item, index) => { 
        if  ctx.isVarDefined(item.clone()) {
          if  ctx.isLocalToCapture(item.clone()) == false {
            ctx.addCapturedVariable(item.clone());
          }
        }
      }
      );
    }
  }
  fn CheckVRefTypeAnnotationOf(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    if  node.has_vref_annotation {
      let mut tAnn : Option<CodeNode> = node.vref_annotation;
      if  false == ctx.isDefinedClass(node.vref.clone()) {
        ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "Trait class ".to_string(), node.vref)), " is not defined".to_string()));
      } else {
        let mut testC : RangerAppClassDesc = ctx.findClass(node.vref.clone());
        if  testC.is_trait {
          if  testC.node.hasExpressionProperty("params".to_string()) {
            /** unused:  let mut params : Option<CodeNode> = testC.node.getExpressionProperty("params".to_string());   **/ 
            /** unused:  let cnt : i64 = (tAnn.children.len() as i64);   **/ 
            let mut tstr : String = "".to_string();
            for i in 0..tAnn.children.len() {
              let mut ch = tAnn.children[i as usize].clone();
              self.CheckVRefTypeAnnotationOf(ch.clone(), ctx.clone(), wr.clone());
              tstr = format!("{}{}", (format!("{}{}", tstr, "_".to_string())), ch.vref);
            }
            let my_class_name : String = format!("{}{}", testC.name, tstr);
            let mut ann : CodeNode = tAnn.unwrap();
            ctx.createTraitInstanceClass(testC.name.clone(), my_class_name.clone(), ann.clone(), self.clone(), wr.clone());
            node.vref = my_class_name.clone();
            node.has_vref_annotation = false;
            return true;
          }
        }
      }
    }
    return false;
  }
  fn CheckTypeAnnotationOf(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    if  node.has_type_annotation {
      let mut tAnn : Option<CodeNode> = node.type_annotation;
      if  false == ctx.isDefinedClass(node.type_name.clone()) {
        ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "Trait class ".to_string(), node.type_name)), " is not defined".to_string()));
      } else {
        let mut testC : RangerAppClassDesc = ctx.findClass(node.type_name.clone());
        if  testC.is_trait {
          if  testC.node.hasExpressionProperty("params".to_string()) {
            /** unused:  let mut params : Option<CodeNode> = testC.node.getExpressionProperty("params".to_string());   **/ 
            /** unused:  let cnt : i64 = (tAnn.children.len() as i64);   **/ 
            let mut tstr : String = "".to_string();
            for i in 0..tAnn.children.len() {
              let mut ch = tAnn.children[i as usize].clone();
              self.CheckVRefTypeAnnotationOf(ch.clone(), ctx.clone(), wr.clone());
              tstr = format!("{}{}", (format!("{}{}", tstr, "_".to_string())), ch.vref);
            }
            let my_class_name : String = format!("{}{}", testC.name, tstr);
            let mut ann : CodeNode = tAnn.unwrap();
            ctx.createTraitInstanceClass(testC.name.clone(), my_class_name.clone(), ann.clone(), self.clone(), wr.clone());
            node.type_name = my_class_name.clone();
            node.has_type_annotation = false;
            return true;
          }
        }
      }
    }
    return false;
  }
  fn matchNode(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    if  0 == ((node.children.len() as i64)) {
      return false;
    }
    let mut fc : CodeNode = node.getFirst();
    self.stdCommands = Some(ctx.getStdCommands());
    let mut op_list : Vec<CodeNode> = ctx.getOperators(fc.vref.clone());
    for i in 0..op_list.len() {
      let mut cmd = op_list[i as usize].clone();
      let mut cmdName : CodeNode = cmd.getFirst();
      if  (cmdName.vref == fc.vref) && (false == ctx.isVarDefined(cmdName.vref.clone())) {
        self.stdParamMatch(node.clone(), ctx.clone(), wr.clone(), true);
        if  node.parent.is_some() {
        }
        return true;
      }
    }
    if  (((fc.ns.len() as i64)) > 1) && (((node.children.len() as i64)) > 1) {
      let possible_cmd : String = fc.ns[(((fc.ns.len() as i64)) - 1) as usize].clone();
      let mut op_list_2 : Vec<CodeNode> = ctx.getOperators(possible_cmd.clone());
      if  ((op_list_2.len() as i64)) > 0 {
        let mut args : CodeNode = node.getSecond();
        let mut nn : CodeNode = fc.copy();
        nn.ns.pop();
        let objName : String = nn.ns.join(".".to_string());
        let mut newNode : CodeNode = node.newExpressionNode();
        newNode.add(node.newVRefNode("call".to_string()));
        newNode.add(node.newVRefNode(objName.clone()));
        newNode.add(node.newVRefNode(possible_cmd.clone()));
        newNode.add(args.copy());
        node.getChildrenFrom(newNode.clone());
        if  ctx.expressionLevel() == 0 {
          ctx.lastBlockOp = Some(node.clone());
        }
        node.flow_done = false;
        self.WalkNode(node.clone(), ctx.clone(), wr.clone());
        return true;
      }
    }
    return false;
  }
  fn StartWalk(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.WalkNode(node.clone(), ctx.clone(), wr.clone());
    for i in 0..self.walkAlso.len() {
      let mut ch = self.walkAlso[i as usize].clone();
      self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
    }
  }
  fn clearImports(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.isFirstVref("Import".to_string()) {
      node.expression = true;
      node.vref = "".to_string();
      node.children.pop();
      node.children.pop();
    } else {
      for i in 0..node.children.len() {
        let mut item = node.children[i as usize].clone();
        self.clearImports(item.clone(), ctx.clone(), wr.clone());
      }
    }
  }
  fn mergeImports(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut envOpt : Option<InputEnv> = ctx.getEnv();
    if  envOpt.is_none() {
      ctx.addError(node.clone(), "Environment not defined".to_string());
      return;
    }
    let mut env : InputEnv = envOpt.unwrap();
    if  node.isFirstVref("Import".to_string()) {
      let mut fNameNode : CodeNode = node.children[1 as usize].clone();
      let import_file : String = fNameNode.string_value.clone();
      if  ctx.already_imported.contains_key(&import_file) {
        return;
      }
      let mut source_code : String = "".to_string();
      ctx.already_imported.insert(import_file, true);
      let mut rootCtx : RangerAppWriterContext = ctx.getRoot();
      if  (source_code.len() as i64) == 0 {
        let filePathIs : String = TFiles::searchEnv(env.clone(), rootCtx.libraryPaths, import_file.clone());
        if  operatorsOf_8::filec95exists_9(env.clone(), filePathIs.clone(), import_file.clone()) == false {
          if  ctx.hasCompilerFlag("verbose".to_string()) {
            println!( "{}", format!("{}{}", "import did not find the file: ".to_string(), import_file) );
          }
          ctx.addError(node.clone(), format!("{}{}", "Could not import file ".to_string(), import_file));
          return;
        }
        if  ctx.hasCompilerFlag("verbose".to_string()) {
          println!( "{}", format!("{}{}", "importing ".to_string(), import_file) );
        }
        let c : Option<String> = operatorsOf_8::readc95file_9(env.clone(), filePathIs.clone(), import_file.clone());
        source_code = c.unwrap();
      }
      let mut code : SourceCode = SourceCode::new(source_code.clone());
      code.filename = import_file.clone();
      let mut parser : RangerLispParser = RangerLispParser::new(code.clone());
      parser.parse(ctx.hasCompilerFlag("no-op-transform".to_string()));
      node.expression = true;
      node.vref = "".to_string();
      node.children.pop();
      node.children.pop();
      if  ctx.hasCompilerFlag("copysrc".to_string()) {
        println!( "{}", format!("{}{}", "--> copying ".to_string(), import_file) );
        let mut fileWr : CodeWriter = wr.getFileWriter(".".to_string(), import_file.clone());
        fileWr.raw(source_code.clone(), false);
      }
      let mut rn : CodeNode = parser.rootNode.clone().unwrap();
      self.mergeImports(rn.clone(), ctx.clone(), wr.clone());
      node.children.push(rn.clone());
    } else {
      for i in 0..node.children.len() {
        let mut item = node.children[i as usize].clone();
        self.mergeImports(item.clone(), ctx.clone(), wr.clone());
      }
    }
  }
  fn CollectMethods(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.WalkCollectMethods(node.clone(), ctx.clone(), wr.clone());
    let mut allTypes : Vec<String> = Vec::new();
    let mut serviceBuilder : RangerServiceBuilder = RangerServiceBuilder::new();
    serviceBuilder.CreateServices(self.clone(), ctx.clone(), wr.clone());
    operatorsOf_13::forEach_40(self.extendedClasses, (item, index) => { 
      let mut ch : RangerAppClassDesc = ctx.findClass(index.clone());
      let mut parent : RangerAppClassDesc = ctx.findClass(item.clone());
      ch.addParentClass(item.clone());
      parent.is_inherited = true;
      operatorsOf::forEach_11(parent.variables, (item, index) => { 
        ch.ctx.defineVariable(item.name.clone(), item.clone());
      }
      );
    }
    );
    for i in 0..self.classesWithTraits.len() {
      let mut point = self.classesWithTraits[i as usize].clone();
      let mut cl : RangerAppClassDesc = point.class_def.clone().unwrap();
      /** unused:  let mut joinPoint : CodeNode = point.node.clone().unwrap();   **/ 
      let mut traitClassDef : CodeNode = point.node.children[1 as usize].clone();
      let name : String = traitClassDef.vref;
      let mut t : RangerAppClassDesc = ctx.findClass(name.clone());
      if  ((t.extends_classes.len() as i64)) > 0 {
        ctx.addError(point.node.clone().unwrap(), format!("{}{}", (format!("{}{}", "Can not join class ".to_string(), name)), " because it is inherited. Currently on base classes can be used as traits.".to_string()));
        continue;
      }
      if  t.has_constructor {
        ctx.addError(point.node.clone().unwrap(), format!("{}{}", (format!("{}{}", "Can not join class ".to_string(), name)), " because it has a constructor function".to_string()));
      } else {
        let mut origBody : CodeNode = cl.node.children[2 as usize].clone();
        let mut match : RangerArgMatch = RangerArgMatch::new();
        let mut params : Option<CodeNode> = t.node.getExpressionProperty("params".to_string());
        let mut initParams : Option<CodeNode> = point.node.getExpressionProperty("params".to_string());
        let mut traitParams : RangerTraitParams = RangerTraitParams::new();
        if  (params.is_some()) && (initParams.is_some()) {
          for i_1 in 0..params.children.len() {
            let mut typeName = params.children[i_1 as usize].clone();
            let mut pArg : CodeNode = initParams.children[i_1 as usize].clone();
            if  0 == (pArg.vref.len() as i64) {
              r#match.addNode(typeName.vref.clone(), pArg.clone());
            } else {
              r#match.add(typeName.vref.clone(), pArg.vref.clone(), ctx.clone());
            }
            traitParams.param_names.push(typeName.vref);
            traitParams.values.insert(typeName.vref, pArg.vref);
          }
          cl.trait_params.insert(name, traitParams);
        } else {
          r#match.add("T".to_string(), cl.name.clone(), ctx.clone());
        }
        ctx.setCurrentClass(cl.clone());
        let mut traitClass : RangerAppClassDesc = ctx.findClass(traitClassDef.vref.clone());
        for i_2 in 0..traitClass.variables.len() {
          let mut pvar = traitClass.variables[i_2 as usize].clone();
          let mut ccopy : CodeNode = pvar.node.rebuildWithType(match.clone(), true);
          self.WalkCollectMethods(ccopy.clone(), ctx.clone(), wr.clone());
          origBody.children.push(ccopy.clone());
        }
        for i_3 in 0..traitClass.defined_variants.len() {
          let mut fnVar = traitClass.defined_variants[i_3 as usize].clone();
          let mut mVs : Option<RangerAppMethodVariants> = traitClass.method_variants.get(fnVar);
          for i_4 in 0..mVs.variants.len() {
            let mut variant = mVs.variants[i_4 as usize].clone();
            let mut ccopy_1 : CodeNode = variant.node.rebuildWithType(match.clone(), true);
            self.WalkCollectMethods(ccopy_1.clone(), ctx.clone(), wr.clone());
            origBody.children.push(ccopy_1.clone());
          }
        }
        for i_5 in 0..traitClass.static_methods.len() {
          let mut variant_1 = traitClass.static_methods[i_5 as usize].clone();
          let mut ccopy_2 : CodeNode = variant_1.node.rebuildWithType(match.clone(), true);
          self.WalkCollectMethods(ccopy_2.clone(), ctx.clone(), wr.clone());
          origBody.children.push(ccopy_2.clone());
        }
      }
    }
    let cClassList :  = sortself.serializedClassesdefleft_hadfalsedefright_hadfalseforEachleft.variablesif||==item.nameNode.type_nameright.name==item.nameNode.array_typeright.name=left_hadtrueforEachright.variablesif||==item.nameNode.type_nameleft.name==item.nameNode.array_typeleft.name=right_hadtrueifleft_hadreturn1ifright_hadreturn-1return0;
    forcClassListcl_1i_6
    cl_1.is_serialized = true;
    let mut ser : RangerSerializeClass = RangerSerializeClass::new();
    let mut extWr : CodeWriter = CodeWriter::new();
    ser.createJSONSerializerFn2(cl_1.clone(), cl_1.ctx.clone().unwrap(), extWr.clone());
    let theCode : String = extWr.getCode();
    let mut code : SourceCode = SourceCode::new(theCode.clone());
    code.filename = format!("{}{}", "extension ".to_string(), ctx.currentClass.name);
    let mut parser : RangerLispParser = RangerLispParser::new(code.clone());
    parser.parse(ctx.hasCompilerFlag("no-op-transform".to_string()));
    let mut rn : CodeNode = parser.rootNode.clone().unwrap();
    self.WalkCollectMethods(rn.clone(), cl_1.ctx.clone().unwrap(), wr.clone());
    self.walkAlso.push(rn.clone());
    for i_7 in 0..self.immutableClasses.len() {
      let mut cl_2 = self.immutableClasses[i_7 as usize].clone();
      let mut ser_1 : RangerImmutableExtension = RangerImmutableExtension::new();
      let mut extWr_1 : CodeWriter = CodeWriter::new();
      ser_1.createImmutableExtension(cl_2.clone(), cl_2.ctx.clone().unwrap(), extWr_1.clone());
      let theCode_1 : String = extWr_1.getCode();
      let mut code_1 : SourceCode = SourceCode::new(theCode_1.clone());
      code_1.filename = format!("{}{}", "extension ".to_string(), cl_2.name);
      let mut parser_1 : RangerLispParser = RangerLispParser::new(code_1.clone());
      parser_1.parse(ctx.hasCompilerFlag("no-op-transform".to_string()));
      let mut rn_1 : CodeNode = parser_1.rootNode.clone().unwrap();
      self.WalkCollectMethods(rn_1.clone(), cl_2.ctx.clone().unwrap(), wr.clone());
      self.walkAlso.push(rn_1.clone());
    }
    for i_8 in 0..ctx.definedClassList.len() {
      let mut cname = ctx.definedClassList[i_8 as usize].clone();
      allTypes.push(cname);
      let mut c : RangerAppClassDesc = (ctx.definedClasses.get(cname)).unwrap();
      if  ((c.is_system || c.is_interface) || c.is_template) || c.is_trait {
        continue;
      }
      let mut varNames : HashMap<String,bool> = HashMap::new();
      for i_9 in 0..c.variables.len() {
        let mut p = c.variables[i_9 as usize].clone();
        ctx.hadValidType(p.nameNode.clone().unwrap());
        varNames.insert(p.name, true);
      }
      operatorsOf_13::forEach_30(c.method_variants, (item, index) => { 
        operatorsOf::forEach_29(item.variants, (item, index) => { 
          if  varNames.contains_key(&item.name) {
            ctx.addError(item.nameNode.clone().unwrap(), "Class has defined method and variable of the same name.".to_string());
          }
        }
        );
      }
      );
    }
    for i_10 in 0..ctx.definedClassList.len() {
      let mut cname_1 = ctx.definedClassList[i_10 as usize].clone();
      allTypes.push(cname_1);
    }
    allTypes.push("int".to_string().to_string());
    allTypes.push("string".to_string().to_string());
    allTypes.push("boolean".to_string().to_string());
    allTypes.push("double".to_string().to_string());
    let mut Anynn : CodeNode = node.newVRefNode("Any".to_string());
    let mut rootCtx : RangerAppWriterContext = ctx.getRoot();
    let mut new_class : RangerAppClassDesc = RangerAppClassDesc::new();
    new_class.name = "Any".to_string();
    new_class.nameNode = Some(Anynn.clone());
    rootCtx.addClass("Any".to_string(), new_class.clone());
    new_class.is_union = true;
    let mut did_push : HashMap<String,bool> = HashMap::new();
    for i_11 in 0..allTypes.len() {
      let mut typeName_1 = allTypes[i_11 as usize].clone();
      if  did_push.contains_key(&typeName_1) {
        continue;
      }
      new_class.is_union_of.push(typeName_1);
      did_push.insert(typeName_1, true);
    }
    Anynn.clDesc = Some(new_class.clone());
  }
  fn defineFunctionParam(&mut self, mut method : RangerAppFunctionDesc, mut arg : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.CheckTypeAnnotationOf(arg.clone(), ctx.clone(), wr.clone());
    let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
    p.name = arg.vref.clone();
    p.value_type = arg.value_type;
    p.node = Some(arg.clone());
    p.init_cnt = 1;
    p.nameNode = Some(arg.clone());
    p.refType = 1;
    p.varType = 4;
    method.params.push(p.clone());
    arg.hasParamDesc = true;
    arg.paramDesc = Some(p.clone());
    arg.eval_type = arg.value_type;
    arg.eval_type_name = arg.type_name.clone();
    if  arg.hasFlag("strong".to_string()) {
      p.changeStrength(1, 1, p.nameNode.clone().unwrap());
    } else {
      arg.setFlag("lives".to_string());
      p.changeStrength(0, 1, p.nameNode.clone().unwrap());
    }
  }
  fn spliceFunctionBody(&mut self, startIndex : i64, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> CodeNode {
    let mut block_index : i64 = startIndex;
    let ch_len : i64 = ((node.children.len() as i64)) - 1;
    if  ch_len == startIndex {
      return node.clone();
    }
    for i in 0..node.children.len() {
      let mut cb = node.children[i as usize].clone();
      if  i > startIndex {
        if  (cb.vref.len() as i64) > 0 {
          if  ctx.hasCompilerFlag(cb.vref.clone()) && (i < ch_len) {
            block_index = i + 1;
          }
        }
      }
    }
    let mut copyOf : CodeNode = node.copy();
    while ((node.children.len() as i64)) > (startIndex + 1) {
      node.children.pop();
    }
    if  block_index > startIndex {
      let mut replacer : CodeNode = copyOf.children[block_index as usize].clone();
      node.children.pop();
      node.children.push(replacer.copy());
    }
    return node.clone();
  }
  fn CreateFunctionObject(&mut self, mut orig_node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerAppFunctionDesc {
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    let mut node : CodeNode = self.spliceFunctionBody(3, orig_node.clone(), subCtx.clone(), wr.clone());
    let mut cn : CodeNode = node.getSecond();
    /** unused:  let s : String = node.getVRefAt(1);   **/ 
    cn.ifNoTypeSetToVoid();
    let mut m : RangerAppFunctionDesc = operatorsOfCodeNode_41::rc46funcdesc_42(node.clone(), ctx.clone());
    subCtx.is_function = true;
    subCtx.currentMethod = Some(m.clone());
    m.fnCtx = Some(subCtx.clone());
    if  cn.hasFlag("weak".to_string()) {
      m.changeStrength(0, 1, node.clone());
    } else {
      m.changeStrength(1, 1, node.clone());
    }
    let mut args : CodeNode = node.children[2 as usize].clone();
    m.fnBody = Some(node.children[3 as usize].clone());
    self.CheckTypeAnnotationOf(m.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    for ii in 0..args.children.len() {
      let mut arg = args.children[ii as usize].clone();
      self.CheckTypeAnnotationOf(arg.clone(), subCtx.clone(), wr.clone());
      let mut p2 : RangerAppParamDesc = RangerAppParamDesc::new();
      p2.name = arg.vref.clone();
      p2.value_type = arg.value_type;
      p2.node = Some(arg.clone());
      p2.nameNode = Some(arg.clone());
      p2.init_cnt = 1;
      p2.refType = 1;
      p2.initRefType = 1;
      p2.debugString = "--> collected ".to_string();
      if  args.hasBooleanProperty("strong".to_string()) {
        p2.refType = 2;
        p2.initRefType = 2;
      }
      p2.varType = 4;
      m.params.push(p2.clone());
      arg.hasParamDesc = true;
      arg.paramDesc = Some(p2.clone());
      arg.eval_type = arg.value_type;
      arg.eval_type_name = arg.type_name.clone();
      if  arg.hasFlag("strong".to_string()) {
        p2.changeStrength(1, 1, p2.nameNode.clone().unwrap());
      } else {
        arg.setFlag("lives".to_string());
        p2.changeStrength(0, 1, p2.nameNode.clone().unwrap());
      }
      subCtx.defineVariable(p2.name.clone(), p2.clone());
    }
    return m.clone();
  }
  fn WalkCollectMethods(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut find_more : bool = true;
    if  ((node.children.len() as i64)) > 0 {
      let mut fc : CodeNode = node.getFirst();
      if  ((fc.ns.len() as i64)) > 1 {
        if  (fc.ns[0 as usize].clone()) == "plugin".to_string() {
          if  node.is_plugin {
            return;
          }
          node.is_plugin = true;
          let pName : String = fc.ns[1 as usize].clone();
          ctx.addPluginNode(pName.clone(), node.clone());
          return;
        }
      }
    }
    if  node.isFirstVref("defn".to_string()) {
      return;
    }
    if  node.isFirstVref("flag".to_string()) {
      return;
    }
    if  node.isFirstVref("page".to_string()) {
      return;
    }
    if  node.isFirstVref("service".to_string()) {
      return;
    }
    if  node.isFirstVref("operator".to_string()) {
      let mut opRef : CodeNode = node.children[0 as usize].clone();
      let mut nameNode : CodeNode = node.getSecond();
      /** unused:  let opClassName : String = nameNode.vref;   **/ 
      if  nameNode.vref == "class".to_string() {
        let mut new_class : RangerAppClassDesc = RangerAppClassDesc::new();
        new_class.name = nameNode.type_name.clone();
        new_class.nameNode = Some(nameNode.clone());
        nameNode.vref = nameNode.type_name.clone();
        ctx.addClass(nameNode.vref.clone(), new_class.clone());
        let mut cSig : RangerTypeClass = TFactory::new_class_signature(nameNode.clone(), ctx.clone(), wr.clone());
        cSig.is_system = true;
        new_class.is_system = true;
        nameNode.clDesc = Some(new_class.clone());
      }
      let b_is_void : bool = (nameNode.type_name == "void".to_string()) || nameNode.is_block_node;
      let mut langRef : CodeNode = CodeNode::vref1(operatorsOf_21::getTargetLang_22(ctx.clone()));
      if  (opRef.type_name.len() as i64) > 0 {
        langRef.vref = opRef.type_name.clone();
        println!( "{}", format!("{}{}", "OP type ".to_string(), opRef.type_name) );
      }
      let mut opLang : CodeNode = if (((node.children.len() as i64)) > 2) { (node.children[2 as usize].clone()) } else { langRef };
      let mut opsList : CodeNode = node.children[(((node.children.len() as i64)) - 1) as usize].clone();
      for i in 0..opsList.children.len() {
        let mut op = opsList.children[i as usize].clone();
        let mut fc_1 : CodeNode = op.getFirst();
        if  fc_1.vref == "fn".to_string() {
          let mut nn : CodeNode = op.getSecond();
          let mut args : CodeNode = op.getThird();
          let mut opCode : CodeNode = op.children[3 as usize].clone();
          let mut opN : CodeNode = CodeNode::new(op.code.clone().unwrap(), op.sp, op.ep);
          let mut opName : CodeNode = nn.copy();
          let mut opSig : CodeNode = nn.rebuildWithType(RangerArgMatch::new(), false);
          let mut opArgs : CodeNode = args.rebuildWithType(RangerArgMatch::new(), false);
          let mut opTpls : CodeNode = CodeNode::new(op.code.clone().unwrap(), op.sp, op.ep);
          opTpls.is_block_node = true;
          let mut opTemplatesMain : CodeNode = CodeNode::new(op.code.clone().unwrap(), op.sp, op.ep);
          let mut opTemplatesVRef : CodeNode = CodeNode::new(op.code.clone().unwrap(), op.sp, op.ep);
          let mut opTemplatesList : CodeNode = CodeNode::new(op.code.clone().unwrap(), op.sp, op.ep);
          opTemplatesVRef.vref = "templates".to_string();
          opTemplatesMain.children.push(opTemplatesVRef.clone());
          opTemplatesMain.children.push(opTemplatesList.clone());
          opTpls.children.push(opTemplatesMain.clone());
          opN.children.push(opName.clone());
          if  nn.hasFlag("newcontext".to_string()) {
            opName.setFlag("newcontext".to_string());
          }
          opSig.vref = nn.vref.clone();
          opN.children.push(opSig.clone());
          let mut opThisNode : CodeNode = nameNode.rebuildWithType(RangerArgMatch::new(), false);
          opThisNode.vref = "self".to_string();
          if  nameNode.hasFlag("mutates".to_string()) {
            opThisNode.setFlag("mutates".to_string());
          }
          if  nameNode.hasFlag("immutable".to_string()) {
            opThisNode.setFlag("immutable".to_string());
          }
          if  b_is_void {
          } else {
            opArgs.children.insert(0 as usize, opThisNode);
          }
          opN.children.push(opArgs.clone());
          opN.children.push(opTpls.clone());
          if  op.hasStringProperty("doc".to_string()) {
            opN.setStringProperty("doc".to_string(), op.getStringProperty("doc".to_string()));
          }
          let mut opCodeNode : CodeNode = opCode.rebuildWithType(RangerArgMatch::new(), false);
          let mut actualCode : CodeNode = CodeNode::new(opCode.code.clone().unwrap(), op.sp, op.ep);
          let mut opLangDef : CodeNode = opLang.rebuildWithType(RangerArgMatch::new(), false);
          if  opLangDef.vref == "all".to_string() {
            opLangDef.vref = "*".to_string();
          }
          actualCode.children.push(opLangDef.clone());
          actualCode.children.push(opCodeNode.clone());
          if  opLangDef.vref == "*".to_string() {
            if  opCode.is_block_node == false {
              opSig.setFlag("macro".to_string());
            }
          }
          if  nameNode.hasFlag("macro".to_string()) {
            opSig.setFlag("macro".to_string());
          }
          if  nn.hasFlag("pure".to_string()) {
            opSig.setFlag("pure".to_string());
          }
          opTemplatesList.children.push(actualCode.clone());
          ctx.createOperator(opN.clone());
        }
      }
      return;
      let mut instances : CodeNode = node.getThird();
      let mut new_class_1 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_1.name = nameNode.vref.clone();
      new_class_1.nameNode = Some(nameNode.clone());
      ctx.addClass(nameNode.vref.clone(), new_class_1.clone());
      new_class_1.is_system_union = true;
      for i_1 in 0..instances.children.len() {
        let mut ch = instances.children[i_1 as usize].clone();
        new_class_1.is_union_of.push(ch.vref);
      }
      nameNode.clDesc = Some(new_class_1.clone());
      return;
    }
    if  node.isFirstVref("union".to_string()) {
      let mut nameNode_1 : CodeNode = node.getSecond();
      let mut instances_1 : CodeNode = node.getThird();
      let mut new_class_2 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_2.name = nameNode_1.vref.clone();
      new_class_2.nameNode = Some(nameNode_1.clone());
      ctx.addClass(nameNode_1.vref.clone(), new_class_2.clone());
      new_class_2.is_union = true;
      for i_2 in 0..instances_1.children.len() {
        let mut ch_1 = instances_1.children[i_2 as usize].clone();
        new_class_2.is_union_of.push(ch_1.vref);
      }
      nameNode_1.clDesc = Some(new_class_2.clone());
      return;
    }
    if  node.isFirstVref("systemunion".to_string()) {
      let mut nameNode_2 : CodeNode = node.getSecond();
      if  ctx.isDefinedClass(nameNode_2.vref.clone()) {
        let mut cl : RangerAppClassDesc = ctx.findClass(nameNode_2.vref.clone());
        if  cl.is_system == false {
          ctx.addError(node.clone(), "Only system classes can be systemunions".to_string());
        }
        cl.is_system_union = true;
        let mut instances_2 : CodeNode = node.getThird();
        for i_3 in 0..instances_2.children.len() {
          let mut ch_2 = instances_2.children[i_3 as usize].clone();
          cl.is_union_of.push(ch_2.vref);
        }
        return;
      }
      let mut nameNode_3 : CodeNode = node.getSecond();
      let mut instances_3 : CodeNode = node.getThird();
      let mut new_class_3 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_3.name = nameNode_3.vref.clone();
      new_class_3.nameNode = Some(nameNode_3.clone());
      ctx.addClass(nameNode_3.vref.clone(), new_class_3.clone());
      new_class_3.is_system_union = true;
      for i_4 in 0..instances_3.children.len() {
        let mut ch_3 = instances_3.children[i_4 as usize].clone();
        new_class_3.is_union_of.push(ch_3.vref);
      }
      nameNode_3.clDesc = Some(new_class_3.clone());
      return;
    }
    if  node.isFirstVref("systemclass".to_string()) {
      let mut nameNode_4 : CodeNode = node.getSecond();
      if  ctx.isDefinedClass(nameNode_4.vref.clone()) {
        let mut cl_1 : RangerAppClassDesc = ctx.findClass(nameNode_4.vref.clone());
        if  cl_1.is_system_union == false {
          ctx.addError(node.clone(), "Class already defined and it was not a systemunion.".to_string());
        }
        cl_1.is_system = true;
        let mut instances_4 : CodeNode = node.getThird();
        for i_5 in 0..instances_4.children.len() {
          let mut ch_4 = instances_4.children[i_5 as usize].clone();
          let mut langName : CodeNode = ch_4.getFirst();
          let mut langClassName : CodeNode = ch_4.getSecond();
          cl_1.systemNodes.insert(langName.vref, ch_4);
          if  (langClassName.vref.len() as i64) > 0 {
            cl_1.systemNames.insert(langName.vref, langClassName.vref);
          }
          if  (langClassName.string_value.len() as i64) > 0 {
            cl_1.systemNames.insert(langName.vref, langClassName.string_value);
          }
        }
        return;
      }
      let mut instances_5 : CodeNode = node.getThird();
      let mut new_class_4 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_4.name = nameNode_4.vref.clone();
      new_class_4.nameNode = Some(nameNode_4.clone());
      ctx.addClass(nameNode_4.vref.clone(), new_class_4.clone());
      new_class_4.is_system = true;
      for i_6 in 0..instances_5.children.len() {
        let mut ch_5 = instances_5.children[i_6 as usize].clone();
        let mut langName_1 : CodeNode = ch_5.getFirst();
        let mut langClassName_1 : CodeNode = ch_5.getSecond();
        new_class_4.systemNodes.insert(langName_1.vref, ch_5);
        if  (langClassName_1.vref.len() as i64) > 0 {
          new_class_4.systemNames.insert(langName_1.vref, langClassName_1.vref);
        }
        if  (langClassName_1.string_value.len() as i64) > 0 {
          new_class_4.systemNames.insert(langName_1.vref, langClassName_1.string_value);
        }
      }
      nameNode_4.is_system_class = true;
      nameNode_4.clDesc = Some(new_class_4.clone());
      return;
    }
    if  node.isFirstVref("extends".to_string()) {
      if  ((node.children.len() as i64)) > 1 {
        let mut ee : CodeNode = node.getSecond();
        let mut currC : Option<RangerAppClassDesc> = ctx.currentClass;
        currC.addParentClass(ee.vref.clone());
        let mut ParentClass : RangerAppClassDesc = ctx.findClass(ee.vref.clone());
        ParentClass.is_inherited = true;
      }
      find_more = false;
    }
    if  node.isFirstVref("Extends".to_string()) {
      let mut extList : CodeNode = node.children[1 as usize].clone();
      let mut currC_1 : Option<RangerAppClassDesc> = ctx.currentClass;
      for ii in 0..extList.children.len() {
        let mut ee_1 = extList.children[ii as usize].clone();
        currC_1.addParentClass(ee_1.vref.clone());
        let mut ParentClass_1 : RangerAppClassDesc = ctx.findClass(ee_1.vref.clone());
        ParentClass_1.is_inherited = true;
      }
    }
    if  node.isFirstVref("constructor".to_string()) || node.isFirstVref("Constructor".to_string()) {
      let mut currC_2 : Option<RangerAppClassDesc> = ctx.currentClass;
      let mut subCtx : RangerAppWriterContext = currC_2.ctx.fork();
      currC_2.has_constructor = true;
      currC_2.constructor_node = Some(node.clone());
      let mut m : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
      m.name = "Constructor".to_string();
      m.node = Some(node.clone());
      m.nameNode = Some(node.children[0 as usize].clone());
      m.fnBody = Some(node.children[2 as usize].clone());
      m.fnCtx = Some(subCtx.clone());
      let mut args_1 : CodeNode = node.children[1 as usize].clone();
      for ii_1 in 0..args_1.children.len() {
        let mut arg = args_1.children[ii_1 as usize].clone();
        let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
        p.name = arg.vref.clone();
        p.value_type = arg.value_type;
        p.node = Some(arg.clone());
        p.nameNode = Some(arg.clone());
        p.refType = 1;
        p.varType = 4;
        m.params.push(p.clone());
        arg.hasParamDesc = true;
        arg.paramDesc = Some(p.clone());
        arg.eval_type = arg.value_type;
        arg.eval_type_name = arg.type_name.clone();
        subCtx.defineVariable(p.name.clone(), p.clone());
      }
      currC_2.constructor_fn = Some(m.clone());
      find_more = false;
    }
    if  node.isFirstVref("enum".to_string()) {
      let mut fNameNode : CodeNode = node.children[1 as usize].clone();
      let mut enumList : CodeNode = node.children[2 as usize].clone();
      let mut new_enum : RangerAppEnum = RangerAppEnum::new();
      for i_7 in 0..enumList.children.len() {
        let mut item = enumList.children[i_7 as usize].clone();
        let mut fc_2 : CodeNode = item.getFirst();
        new_enum.add(fc_2.vref.clone());
      }
      ctx.definedEnums.insert(fNameNode.vref, new_enum);
      find_more = false;
    }
    if  node.isFirstVref("Enum".to_string()) {
      let mut fNameNode_1 : CodeNode = node.children[1 as usize].clone();
      let mut enumList_1 : CodeNode = node.children[2 as usize].clone();
      let mut new_enum_1 : RangerAppEnum = RangerAppEnum::new();
      for i_8 in 0..enumList_1.children.len() {
        let mut item_1 = enumList_1.children[i_8 as usize].clone();
        new_enum_1.add(item_1.vref.clone());
      }
      ctx.definedEnums.insert(fNameNode_1.vref, new_enum_1);
      find_more = false;
    }
    if  node.isFirstVref("trait".to_string()) {
      let s : String = node.getVRefAt(1);
      let mut classNameNode : CodeNode = node.getSecond();
      let mut new_class_5 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_5.name = s.clone();
      let mut subCtx_1 : RangerAppWriterContext = ctx.fork();
      ctx.setCurrentClass(new_class_5.clone());
      subCtx_1.setCurrentClass(new_class_5.clone());
      new_class_5.ctx = Some(subCtx_1.clone());
      new_class_5.nameNode = Some(classNameNode.clone());
      ctx.addClass(s.clone(), new_class_5.clone());
      new_class_5.classNode = Some(node.clone());
      new_class_5.node = Some(node.clone());
      new_class_5.is_trait = true;
    }
    if  node.isFirstVref("CreateClass".to_string()) || node.isFirstVref("class".to_string()) {
      if  ((node.children.len() as i64)) < 3 {
        ctx.addError(node.clone(), "Not enough arguments for creating a class".to_string());
        return;
      }
      let s_1 : String = node.getVRefAt(1);
      let mut classNameNode_1 : CodeNode = node.getSecond();
      let mut new_class_6 : RangerAppClassDesc = RangerAppClassDesc::new();
      new_class_6.name = s_1.clone();
      new_class_6.compiledName = s_1.clone();
      classNameNode_1.evalTypeClass = Some(TFactory::new_class_signature(classNameNode_1.clone(), ctx.clone(), wr.clone()));
      let mut notOkNames : Vec<String> = ["main".to_string()];
      if  (notOkNames.iter().position( |&r| r == s_1 ).unwrap()) >= 0 {
        ctx.addError(classNameNode_1.clone(), format!("{}{}", "Unfortunately this class name not allowed: ".to_string(), s_1));
      }
      switch (s_1 ) { 
        case "_".to_string() : 
          new_class_6.compiledName = "utiltyClass".to_string();
          break;
      }
      let mut subCtx_2 : RangerAppWriterContext = ctx.fork();
      ctx.setCurrentClass(new_class_6.clone());
      subCtx_2.setCurrentClass(new_class_6.clone());
      new_class_6.ctx = Some(subCtx_2.clone());
      new_class_6.nameNode = Some(classNameNode_1.clone());
      ctx.addClass(s_1.clone(), new_class_6.clone());
      new_class_6.classNode = Some(node.clone());
      new_class_6.node = Some(node.clone());
      if  node.hasBooleanProperty("trait".to_string()) {
        new_class_6.is_trait = true;
      }
      if  classNameNode_1.hasFlag("immutable".to_string()) {
        self.immutableClasses.push(new_class_6.clone());
        new_class_6.is_immutable = true;
      }
      let mut third : CodeNode = node.getThird();
      if  third.vref == "extends".to_string() {
        if  node.chlen() >= 4 {
          let mut extClass : CodeNode = node.children[3 as usize].clone();
          if  (extClass.vref.len() as i64) > 0 {
            self.extendedClasses.insert(s_1, extClass.vref);
          } else {
            ctx.addError(node.clone(), "Invalid classname given for the extends keyword".to_string());
          }
        }
      }
    }
    if  node.isFirstVref("TemplateClass".to_string()) {
      let s_2 : String = node.getVRefAt(1);
      ctx.addTemplateClass(s_2.clone(), node.clone());
      find_more = false;
    }
    if  node.isFirstVref("Extends".to_string()) {
      let mut list : CodeNode = node.children[1 as usize].clone();
      for i_9 in 0..list.children.len() {
        let mut cname = list.children[i_9 as usize].clone();
        let mut extC : RangerAppClassDesc = ctx.findClass(cname.vref.clone());
        for i_10 in 0..extC.variables.len() {
          let mut vv = extC.variables[i_10 as usize].clone();
          let mut currC_3 : Option<RangerAppClassDesc> = ctx.currentClass;
          let mut subCtx_3 : Option<RangerAppWriterContext> = currC_3.ctx;
          subCtx_3.defineVariable(vv.name.clone(), vv.clone());
        }
      }
      find_more = false;
    }
    if  node.isFirstVref("def".to_string()) || node.isFirstVref("let".to_string()) {
      let s_3 : String = node.getVRefAt(1);
      let mut vDef : CodeNode = node.children[1 as usize].clone();
      let mut p_1 : RangerAppParamDesc = RangerAppParamDesc::new();
      if  vDef.has_type_annotation {
        self.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
      }
      if  s_3 != ctx.transformWord(s_3.clone()) {
      }
      let mut currC_4 : Option<RangerAppClassDesc> = ctx.currentClass;
      if  currC_4.is_immutable {
        vDef.setFlag("weak".to_string());
        if  vDef.value_type == 6 {
          let mut initNode : CodeNode = node.newExpressionNode();
          (initNode).push(node.newVRefNode("new".to_string()));
          let mut tDef : CodeNode = node.newVRefNode("Vector".to_string());
          let mut vAnn : CodeNode = node.newExpressionNode();
          (vAnn).push(node.newVRefNode(vDef.array_type.clone()));
          tDef.has_vref_annotation = true;
          tDef.vref_annotation = Some(Box::new(vAnn.clone()));
          (initNode).push(tDef);
          node.children[2 as usize] = initNode;
          vDef.value_type = 11;
          vDef.type_name = "Vector".to_string();
          let mut tAnn : CodeNode = node.newExpressionNode();
          (tAnn).push(node.newVRefNode(vDef.array_type.clone()));
          vDef.has_type_annotation = true;
          vDef.type_annotation = Some(Box::new(tAnn.clone()));
          self.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
          self.CheckVRefTypeAnnotationOf(tDef.clone(), ctx.clone(), wr.clone());
        }
        if  vDef.value_type == 7 {
          let mut initNode_1 : CodeNode = node.newExpressionNode();
          (initNode_1).push(node.newVRefNode("new".to_string()));
          let mut tDef_1 : CodeNode = node.newVRefNode("Map".to_string());
          let mut vAnn_1 : CodeNode = node.newExpressionNode();
          (vAnn_1).push(node.newVRefNode(vDef.key_type.clone()));
          (vAnn_1).push(node.newVRefNode(vDef.array_type.clone()));
          tDef_1.has_vref_annotation = true;
          tDef_1.vref_annotation = Some(Box::new(vAnn_1.clone()));
          (initNode_1).push(tDef_1);
          node.children[2 as usize] = initNode_1;
          vDef.value_type = 11;
          vDef.type_name = "Map".to_string();
          let mut tAnn_1 : CodeNode = node.newExpressionNode();
          (tAnn_1).push(node.newVRefNode(vDef.key_type.clone()));
          (tAnn_1).push(node.newVRefNode(vDef.array_type.clone()));
          vDef.has_type_annotation = true;
          vDef.type_annotation = Some(Box::new(tAnn_1.clone()));
          self.CheckTypeAnnotationOf(vDef.clone(), ctx.clone(), wr.clone());
          self.CheckVRefTypeAnnotationOf(tDef_1.clone(), ctx.clone(), wr.clone());
        }
      }
      p_1.name = s_3.clone();
      p_1.value_type = vDef.value_type;
      p_1.node = Some(node.clone());
      p_1.is_class_variable = true;
      p_1.varType = 8;
      p_1.node = Some(node.clone());
      p_1.nameNode = Some(vDef.clone());
      vDef.hasParamDesc = true;
      vDef.ownParamDesc = Some(p_1.clone());
      vDef.paramDesc = Some(p_1.clone());
      node.hasParamDesc = true;
      node.paramDesc = Some(p_1.clone());
      if  vDef.hasFlag("weak".to_string()) {
        p_1.changeStrength(0, 2, p_1.nameNode.clone().unwrap());
      } else {
        p_1.changeStrength(2, 2, p_1.nameNode.clone().unwrap());
      }
      if  ((node.children.len() as i64)) > 2 {
        p_1.set_cnt = 1;
        p_1.init_cnt = 1;
        p_1.def_value = Some(node.children[2 as usize].clone());
        p_1.is_optional = false;
        if  p_1.def_value.value_type == 4 {
          vDef.type_name = "string".to_string();
        }
        if  p_1.def_value.value_type == 3 {
          vDef.type_name = "int".to_string();
        }
        if  p_1.def_value.value_type == 2 {
          vDef.type_name = "double".to_string();
        }
        if  p_1.def_value.value_type == 5 {
          vDef.type_name = "boolean".to_string();
        }
        let mut valueNode : CodeNode = node.children[2 as usize].clone();
        if  ((valueNode.children.len() as i64)) > 0 {
          let mut fc_3 : CodeNode = valueNode.getFirst();
          if  fc_3.vref == "new".to_string() {
            let mut second : CodeNode = valueNode.getSecond();
            self.CheckVRefTypeAnnotationOf(second.clone(), ctx.clone(), wr.clone());
          }
        }
      } else {
        p_1.is_optional = true;
        if  false == ((vDef.value_type == 6) || (vDef.value_type == 7)) {
          vDef.setFlag("optional".to_string());
        }
      }
      currC_4.addVariable(p_1.clone());
      let mut subCtx_4 : Option<RangerAppWriterContext> = currC_4.ctx;
      subCtx_4.defineVariable(p_1.name.clone(), p_1.clone());
      p_1.is_class_variable = true;
      find_more = false;
    }
    if  node.isFirstVref("operators".to_string()) {
      let mut listOf : CodeNode = node.getSecond();
      for i_11 in 0..listOf.children.len() {
        let mut item_2 = listOf.children[i_11 as usize].clone();
        ctx.createOperator(item_2.clone());
      }
      find_more = false;
    }
    if  node.isFirstVref("Import".to_string()) || node.isFirstVref("import".to_string()) {
      let mut fNameNode_2 : CodeNode = node.children[1 as usize].clone();
      let import_file : String = fNameNode_2.string_value.clone();
      if  ctx.already_imported.contains_key(&import_file) {
        return;
      } else {
        ctx.already_imported.insert(import_file, true);
      }
      let mut envOpt : Option<InputEnv> = ctx.getEnv();
      if  envOpt.is_none() {
        ctx.addError(node.clone(), "Environment not defined".to_string());
        return;
      }
      let mut env : InputEnv = envOpt.unwrap();
      let mut rootCtx : RangerAppWriterContext = ctx.getRoot();
      let filePathIs : String = TFiles::searchEnv(env.clone(), rootCtx.libraryPaths, import_file.clone());
      if  operatorsOf_8::filec95exists_9(env.clone(), filePathIs.clone(), import_file.clone()) == false {
        ctx.addError(node.clone(), format!("{}{}", "Could not import file ".to_string(), import_file));
        return;
      }
      let c : Option<String> = operatorsOf_8::readc95file_9(env.clone(), filePathIs.clone(), import_file.clone());
      let mut code : SourceCode = SourceCode::new(c.unwrap());
      code.filename = import_file.clone();
      let mut parser : RangerLispParser = RangerLispParser::new(code.clone());
      parser.parse(ctx.hasCompilerFlag("no-op-transform".to_string()));
      let mut rnode : Option<CodeNode> = parser.rootNode;
      self.WalkCollectMethods(rnode.unwrap(), ctx.clone(), wr.clone());
      find_more = false;
    }
    if  node.isFirstVref("does".to_string()) {
      let mut defName : CodeNode = node.getSecond();
      let mut currC_5 : Option<RangerAppClassDesc> = ctx.currentClass;
      currC_5.consumes_traits.push(defName.vref);
      let mut joinPoint : ClassJoinPoint = ClassJoinPoint::new();
      joinPoint.class_def = Some(currC_5.clone());
      joinPoint.node = Some(node.clone());
      self.classesWithTraits.push(joinPoint.clone());
    }
    let mut b_is_main : bool = false;
    if  node.code.filename == ctx.getRootFile() {
      b_is_main = true;
    }
    if  node.isFirstVref("static".to_string()) {
      if  node.chlen() < 5 {
        ctx.addError(node.clone(), "Invalid static function declaration".to_string());
        return;
      }
      node = self.spliceFunctionBody(4, node.clone(), ctx.clone(), wr.clone());
      let s_4 : String = node.getVRefAt(2);
      if  s_4 == "main".to_string() {
        if  b_is_main {
          self.mainCnt = self.mainCnt + 1;
          if  self.mainCnt > 1 {
            ctx.addError(node.clone(), "main function can be declared only once".to_string());
          }
        }
      }
      let mut currC_6 : Option<RangerAppClassDesc> = ctx.currentClass;
      let mut m_1 : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
      m_1.name = s_4.clone();
      m_1.compiledName = ctx.transformWord(s_4.clone());
      m_1.node = Some(node.clone());
      m_1.is_static = true;
      m_1.nameNode = Some(node.children[2 as usize].clone());
      m_1.nameNode.ifNoTypeSetToVoid();
      let mut args_2 : CodeNode = node.children[3 as usize].clone();
      m_1.fnBody = Some(node.children[4 as usize].clone());
      self.CheckTypeAnnotationOf(m_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      operatorsOf::forEach_15(args_2.children, (item, index) => { 
        self.defineFunctionParam(m_1.clone(), item.clone(), ctx.clone(), wr.clone());
      }
      );
      currC_6.addStaticMethod(m_1.clone());
      find_more = false;
      return;
    }
    if  node.isFirstVref("StaticMethod".to_string()) || node.isFirstVref("sfn".to_string()) {
      node = self.spliceFunctionBody(3, node.clone(), ctx.clone(), wr.clone());
      let s_5 : String = node.getVRefAt(1);
      let mut currC_7 : Option<RangerAppClassDesc> = ctx.currentClass;
      let mut m_2 : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
      m_2.name = s_5.clone();
      m_2.compiledName = ctx.transformWord(s_5.clone());
      m_2.node = Some(node.clone());
      m_2.is_static = true;
      m_2.nameNode = Some(node.children[1 as usize].clone());
      m_2.nameNode.ifNoTypeSetToVoid();
      let mut args_3 : CodeNode = node.children[2 as usize].clone();
      m_2.fnBody = Some(node.children[3 as usize].clone());
      self.CheckTypeAnnotationOf(m_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      operatorsOf::forEach_15(args_3.children, (item, index) => { 
        self.defineFunctionParam(m_2.clone(), item.clone(), ctx.clone(), wr.clone());
      }
      );
      currC_7.addStaticMethod(m_2.clone());
      find_more = false;
      if  m_2.nameNode.hasFlag("main".to_string()) {
        if  b_is_main {
          self.mainCnt = self.mainCnt + 1;
          if  self.mainCnt > 1 {
            ctx.addError(node.clone(), "main function can be declared only once".to_string());
          }
        }
      }
      return;
    }
    if  node.isFirstVref("extension".to_string()) {
      let s_6 : String = node.getVRefAt(1);
      let mut old_class : RangerAppClassDesc = ctx.findClass(s_6.clone());
      ctx.setCurrentClass(old_class.clone());
    }
    if  node.isFirstVref("PublicMethod".to_string()) || node.isFirstVref("fn".to_string()) {
      let mut currC_8 : Option<RangerAppClassDesc> = ctx.currentClass;
      let mut fnObj : RangerAppFunctionDesc = operatorsOf_41::rc46func_43(node.clone(), (currC_8.ctx.clone().unwrap()), wr.clone());
      let mut cn : Option<CodeNode> = fnObj.nameNode;
      if  currC_8.hasOwnMethod(fnObj.name.clone()) && (false == cn.hasFlag("override".to_string())) {
        ctx.addError(node.clone(), "Error: method of same name declared earlier. Overriding function declarations is not currently allowed!".to_string());
        return;
      }
      if  cn.hasFlag("main".to_string()) {
        ctx.addError(node.clone(), "Error: dynamic method declared as @(main). Use static 'sfn' instead of 'fn'.".to_string());
        return;
      }
      currC_8.addMethod(fnObj.clone());
      find_more = false;
      return;
    }
    if  find_more {
      for i_12 in 0..node.children.len() {
        let mut item_3 = node.children[i_12 as usize].clone();
        self.WalkCollectMethods(item_3.clone(), ctx.clone(), wr.clone());
      }
    }
    if  node.hasBooleanProperty("serialize".to_string()) {
      self.serializedClasses.push(ctx.currentClass.clone().unwrap());
    }
  }
  fn findFunctionDesc(&mut self, mut obj : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> Option<RangerAppFunctionDesc> {
    let mut varDesc : Option<RangerAppParamDesc> = None;
    let mut varFnDesc : Option<RangerAppFunctionDesc> = None;
    if  obj.vref != self.getThisName() {
      if  ((obj.ns.len() as i64)) > 1 {
        let cnt : i64 = (obj.ns.len() as i64);
        let mut classRefDesc : Option<RangerAppParamDesc> = None;
        let mut classDesc : Option<RangerAppClassDesc> = None;
        for i in 0..obj.ns.len() {
          let mut strname = obj.ns[i as usize].clone();
          if  i == 0 {
            if  strname == self.getThisName() {
              classDesc = Some(ctx.getCurrentClass());
            } else {
              if  ctx.isDefinedClass(strname.clone()) {
                classDesc = Some(ctx.findClass(strname.clone()));
                continue;
              }
              classRefDesc = Some(ctx.getVariableDef(strname.clone()));
              if  (classRefDesc.is_none()) || (classRefDesc.nameNode.is_none()) {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for called object: ".to_string(), strname));
                break;
              }
              classRefDesc.ref_cnt = 1 + classRefDesc.ref_cnt;
              classDesc = Some(ctx.findClass(classRefDesc.nameNode.type_name.clone()));
              if  classDesc.is_none() {
                return varFnDesc.clone();
              }
            }
          } else {
            if  classDesc.is_none() {
              return varFnDesc.clone();
            }
            if  i < (cnt - 1) {
              varDesc = Some(classDesc.findVariable(strname.clone()));
              if  varDesc.is_none() {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for refenced obj: ".to_string(), strname));
              }
              let subClass : String = varDesc.getTypeName();
              classDesc = Some(ctx.findClass(subClass.clone()));
              continue;
            }
            if  classDesc.is_some() {
              varFnDesc = Some(classDesc.findMethod(strname.clone()));
              if  varFnDesc.is_none() {
                varFnDesc = Some(classDesc.findStaticMethod(strname.clone()));
                if  varFnDesc.is_none() {
                  ctx.addError(obj.clone(), format!("{}{}", " function variable not found ".to_string(), strname));
                }
              }
            }
          }
        }
        return varFnDesc.clone();
      }
      let mut udesc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      let mut currClass : RangerAppClassDesc = udesc.unwrap();
      varFnDesc = Some(currClass.findMethod(obj.vref.clone()));
      if  varFnDesc.is_some() {
        if  varFnDesc.nameNode.is_some() {
        } else {
          ctx.addError(obj.clone(), format!("{}{}", "Error, no description for called function: ".to_string(), obj.vref));
        }
      }
      return varFnDesc.clone();
    }
    return varFnDesc.clone();
  }
  fn findParamDesc(&mut self, mut obj : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> Option<RangerAppParamDesc> {
    let mut varDesc : Option<RangerAppParamDesc> = None;
    let mut set_nsp : bool = false;
    let mut classDesc : Option<RangerAppClassDesc> = None;
    if  0 == ((obj.nsp.len() as i64)) {
      set_nsp = true;
    }
    if  obj.vref != self.getThisName() {
      if  ((obj.ns.len() as i64)) > 1 {
        let cnt : i64 = (obj.ns.len() as i64);
        let mut classRefDesc : Option<RangerAppParamDesc> = None;
        for i in 0..obj.ns.len() {
          let mut strname = obj.ns[i as usize].clone();
          if  i == 0 {
            if  strname == self.getThisName() {
              classDesc = Some(ctx.getCurrentClass());
              if  set_nsp {
                obj.nsp.push(classDesc.unwrap());
              }
            } else {
              if  ctx.isDefinedClass(strname.clone()) {
                classDesc = Some(ctx.findClass(strname.clone()));
                if  set_nsp {
                  obj.nsp.push(classDesc.unwrap());
                }
                continue;
              }
              classRefDesc = Some(ctx.getVariableDef(strname.clone()));
              if  classRefDesc.is_none() {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for called object: ".to_string(), strname));
                break;
              }
              if  set_nsp {
                obj.nsp.push(classRefDesc.unwrap());
              }
              if  classRefDesc.nameNode.hasFlag("optional".to_string()) {
                if  ctx.hasCompilerFlag("strict".to_string()) {
                  if  false == ctx.isTryBlock() {
                    ctx.addError(obj.clone(), "Optional automatically unwrapped outside try block".to_string());
                  }
                }
              }
              classRefDesc.ref_cnt = 1 + classRefDesc.ref_cnt;
              classDesc = Some(ctx.findClass(classRefDesc.nameNode.type_name.clone()));
            }
          } else {
            if  i < (cnt - 1) {
              varDesc = Some(classDesc.findVariable(strname.clone()));
              if  i > 0 {
                if  varDesc.nameNode.hasFlag("optional".to_string()) {
                  if  ctx.hasCompilerFlag("strict".to_string()) {
                    if  false == ctx.isTryBlock() {
                      ctx.addError(obj.clone(), "Optional automatically unwrapped outside try block".to_string());
                    }
                  }
                }
              }
              if  varDesc.is_none() {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for refenced obj: ".to_string(), strname));
              }
              let subClass : String = varDesc.getTypeName();
              classDesc = Some(ctx.findClass(subClass.clone()));
              if  set_nsp {
                obj.nsp.push(varDesc.unwrap());
              }
              continue;
            }
            if  classDesc.is_some() {
              varDesc = Some(classDesc.findVariable(strname.clone()));
              if  varDesc.is_none() {
                let mut classMethod : Option<RangerAppFunctionDesc> = classDesc.findMethod(strname.clone());
                if  classMethod.is_none() {
                  classMethod = classDesc.findStaticMethod(strname.clone());
                  if  classMethod.is_none() {
                    ctx.addError(obj.clone(), format!("{}{}", "variable not found ".to_string(), strname));
                  }
                }
                if  classMethod.is_some() {
                  if  set_nsp {
                    obj.nsp.push(classMethod.unwrap());
                  }
                  return classMethod.clone();
                }
              }
              if  set_nsp {
                obj.nsp.push(varDesc.unwrap());
              }
            }
          }
        }
        return varDesc.clone();
      }
      varDesc = Some(ctx.getVariableDef(obj.vref.clone()));
      if  varDesc.nameNode.is_some() {
      } else {
      }
      return varDesc.clone();
    }
    let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    return cc.clone();
  }
  fn convertToUnion(&mut self, unionName : String, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ctx.isDefinedClass(unionName.clone()) {
      let mut c1 : RangerAppClassDesc = ctx.findClass(unionName.clone());
      if  c1.is_union {
        if  (node.type_name != c1.name) && (node.eval_type_name != c1.name) {
          let mut toEx : CodeNode = node.newExpressionNode();
          let mut toVref : CodeNode = node.newVRefNode("to".to_string());
          let mut argType : CodeNode = node.newVRefNode("_".to_string());
          let mut targetNode : CodeNode = node.copy();
          argType.type_name = unionName.clone();
          (toEx).push(toVref);
          (toEx).push(argType);
          (toEx).push(targetNode);
          node.expression = true;
          node.flow_done = false;
          node.value_type = 0;
          node.getChildrenFrom(toEx.clone());
          let mut wr_1 : CodeWriter = CodeWriter::new();
          self.WalkNode(node.clone(), ctx.clone(), wr_1.clone());
        }
      }
    }
  }
  fn transformMethodToLambda(&mut self, mut node : CodeNode, mut vFnDef : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  vFnDef.isFunction() {
      let mut args : Vec<CodeNode> = operatorsOf::map_44(vFnDef.params, (item, index) => { 
        return item.nameNode.copy().clone();
      }
      );
      let mut fnArg : CodeNode = vFnDef.nameNode.copy();
      fnArg.vref = "fn".to_string();
      let mut subNode : CodeNode = node.copy();
      subNode.flow_done = false;
      let mut argsExpr : Vec<CodeNode> = operatorsOf::map_45(args, (item, index) => { 
        return item.copy().clone();
      }
      );
      if  (((vFnDef.nameNode.type_name.len() as i64) > 0) && (vFnDef.nameNode.type_name != "void".to_string())) || ((vFnDef.nameNode.array_type.len() as i64) > 0) {
        let mut staticLambda : CodeNode = CodeNode::fromList([fnArg, CodeNode::fromList(args), CodeNode::blockFromList([CodeNode::fromList([CodeNode::vref1("return".to_string()), CodeNode::fromList([subNode, CodeNode::fromList(argsExpr)])])])]);
        node.getChildrenFrom(staticLambda.clone());
      } else {
        let mut staticLambda_1 : CodeNode = CodeNode::fromList([fnArg, CodeNode::fromList(args), CodeNode::blockFromList([CodeNode::fromList([subNode, CodeNode::fromList(argsExpr)])])]);
        node.getChildrenFrom(staticLambda_1.clone());
      }
      node.flow_done = false;
      node.expression = true;
      node.value_type = 0;
      node.vref = "".to_string();
      self.WalkNode(node.clone(), ctx.clone(), wr.clone());
    }
  }
  fn areEqualTypes(&mut self, mut n1 : CodeNode, mut n2 : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    if  n1.eval_type == 17 {
      let mut n1Expr : Option<CodeNode> = n1.expression_value;
      let mut n2Expr : Option<CodeNode> = n2.expression_value;
      if  n1Expr.is_none() {
        if  (n1.hasParamDesc && (n1.paramDesc.nameNode.is_some())) && (n1.paramDesc.nameNode.expression_value.is_some()) {
          n1Expr = n1.paramDesc.nameNode.expression_value.clone();
        }
      }
      if  n2Expr.is_none() {
        if  (n2.hasParamDesc && (n2.paramDesc.nameNode.is_some())) && (n2.paramDesc.nameNode.expression_value.is_some()) {
          n2Expr = n2.paramDesc.nameNode.expression_value.clone();
        }
      }
      if  (n1Expr.is_some()) && (n2Expr.is_some()) {
        return self.matchLambdaArgs((n1Expr.unwrap()), (n2Expr.unwrap()), ctx.clone(), CodeWriter::new());
      }
      if  n1Expr.is_some() {
        let mut opList : Vec<CodeNode> = ctx.getOpFns(n2.vref.clone());
        if  ((opList.len() as i64)) > 0 {
          let mut newCall : CodeNode = CodeNode::fromList([CodeNode::vref1(n2.vref.clone())]);
          let mut newExpr : CodeNode = CodeNode::blockNode();
          let mut proto : CodeNode = n1Expr.copy();
          let mut fc : CodeNode = proto.children[0 as usize].clone();
          fc.vref = "fn".to_string();
          let mut eParams : CodeNode = n1Expr.children[1 as usize].clone();
          operatorsOf::forEach_15(eParams.children, (item, index) => { 
            newCall.children.push(CodeNode::vref1(item.vref.clone()));
          }
          );
          if  fc.type_name != "void".to_string() {
            newExpr.children.push(CodeNode::fromList([CodeNode::vref1("return".to_string()), newCall]));
          } else {
            newExpr.children.push(newCall.clone());
          }
          proto.children.push(newExpr.clone());
          n2.value_type = 0;
          n2.expression_value = Some(Box::new(proto.copy().clone()));
          n2.expression = true;
          n2.flow_done = false;
          n2.vref = "".to_string();
          n2.ns.length = 0;
          n2.getChildrenFrom(proto.copy());
          self.WalkNode(n2.clone(), ctx.clone(), wr.clone());
          n2.expression_value = Some(Box::new(proto.clone()));
          return self.areEqualTypes(n1.clone(), n2.clone(), ctx.clone(), wr.clone());
        }
      }
      if  n2.eval_type == 28 {
        let mut pDesc : RangerAppFunctionDesc = castunwrapn2.paramDescto;
        self.transformMethodToLambda(n2.clone(), pDesc.clone(), ctx.clone(), wr.clone());
        return true;
      }
      let mut vFnDef : Option<RangerAppFunctionDesc> = self.findFunctionDesc(n2.clone(), ctx.clone(), wr.clone());
      if  vFnDef.is_some() {
        self.transformMethodToLambda(n2.clone(), vFnDef.unwrap(), ctx.clone(), wr.clone());
        return true;
      }
      ctx.addError(n2.clone(), "Was not able to evaluate lambda expression types!".to_string());
      if  n1Expr.is_some() {
        ctx.addError(n1.clone(), format!("{}{}", "^ ".to_string(), n1Expr.getCode()));
      } else {
        ctx.addError(n1.clone(), "^ expression_value not found (1)".to_string());
      }
      if  n2Expr.is_some() {
        ctx.addError(n2.clone(), format!("{}{}", "^ ".to_string(), n2Expr.getCode()));
      } else {
        ctx.addError(n2.clone(), "^ expression_value not found (2)".to_string());
      }
      return false;
    }
    if  (((n1.eval_type != 0) && (n2.eval_type != 0)) && ((n1.eval_type_name.len() as i64) > 0)) && ((n2.eval_type_name.len() as i64) > 0) {
      if  n1.eval_type_name == n2.eval_type_name {
      } else {
        let mut b_ok : bool = false;
        if  ctx.isEnumDefined(n1.eval_type_name.clone()) && (n2.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  ctx.isEnumDefined(n2.eval_type_name.clone()) && (n1.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  (n1.eval_type_name == "char".to_string()) && (n2.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  (n1.eval_type_name == "int".to_string()) && (n2.eval_type_name == "char".to_string()) {
          b_ok = true;
        }
        if  ctx.isDefinedClass(n1.eval_type_name.clone()) && ctx.isDefinedClass(n2.eval_type_name.clone()) {
          let mut c1 : RangerAppClassDesc = ctx.findClass(n1.eval_type_name.clone());
          let mut c2 : RangerAppClassDesc = ctx.findClass(n2.eval_type_name.clone());
          if  c1.is_union {
            if  c2.is_union == false {
              self.convertToUnion(n1.eval_type_name.clone(), n2.clone(), ctx.clone(), CodeWriter::new());
              if  n2.eval_type_name == n1.eval_type_name {
                return true;
              } else {
                return false;
              }
            }
          }
          if  c2.is_union != c1.is_union {
            ctx.addError(n1.clone(), "Can not convert union to type ".to_string());
            return false;
          }
          if  (c2.is_union == true) && (c1.is_union == true) {
            ctx.addError(n1.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", "Union types must be the same =>  ".to_string(), n1.eval_type_name)), " <> ".to_string())), n2.eval_type_name));
            return false;
          }
          if  c1.isSameOrParentClass(n2.eval_type_name.clone(), ctx.clone()) {
            return true;
          }
          if  c2.isSameOrParentClass(n1.eval_type_name.clone(), ctx.clone()) {
            return true;
          }
        }
        if  b_ok == false {
          if  n1.eval_type_name == "Any".to_string() {
            self.convertToUnion("Any".to_string(), n2.clone(), ctx.clone(), CodeWriter::new());
            if  n2.eval_type_name == n1.eval_type_name {
              return true;
            } else {
              return false;
            }
          }
          return false;
        }
      }
    }
    return true;
  }
  fn shouldBeEqualTypes(&mut self, mut n1 : CodeNode, mut n2 : CodeNode, mut ctx : RangerAppWriterContext, msg : String) -> () {
    if  (((n1.eval_type != 0) && (n2.eval_type != 0)) && ((n1.eval_type_name.len() as i64) > 0)) && ((n2.eval_type_name.len() as i64) > 0) {
      if  n1.eval_type_name == n2.eval_type_name {
      } else {
        let mut b_ok : bool = false;
        if  ctx.isEnumDefined(n1.eval_type_name.clone()) && (n2.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  ctx.isEnumDefined(n2.eval_type_name.clone()) && (n1.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  ctx.isDefinedClass(n2.eval_type_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(n2.eval_type_name.clone());
          if  cc.isSameOrParentClass(n1.eval_type_name.clone(), ctx.clone()) {
            b_ok = true;
          }
        }
        if  (n1.eval_type_name == "char".to_string()) && (n2.eval_type_name == "int".to_string()) {
          b_ok = true;
        }
        if  (n1.eval_type_name == "int".to_string()) && (n2.eval_type_name == "char".to_string()) {
          b_ok = true;
        }
        if  b_ok == false {
          ctx.addError(n1.clone(), format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "Type mismatch ".to_string(), n2.eval_type_name)), " <> ".to_string())), n1.eval_type_name)), ". ".to_string())), msg));
        }
      }
    }
  }
  fn shouldBeExpression(&mut self, mut n1 : CodeNode, mut ctx : RangerAppWriterContext, msg : String) -> () {
    if  n1.expression == false {
      ctx.addError(n1.clone(), msg);
    }
  }
  fn shouldHaveChildCnt(&mut self, cnt : i64, mut n1 : CodeNode, mut ctx : RangerAppWriterContext, msg : String) -> () {
    if  ((n1.children.len() as i64)) != cnt {
      ctx.addError(n1.clone(), msg);
    }
  }
  fn findLanguageOper(&mut self, mut details : CodeNode, mut ctx : RangerAppWriterContext, mut opDef : CodeNode) -> Option<CodeNode> {
    let langName : String = operatorsOf_21::getTargetLang_22(ctx.clone());
    let mut rv : Option<CodeNode> = None;
    for i in 0..details.children.len() {
      let mut det = details.children[i as usize].clone();
      if  ((det.children.len() as i64)) > 0 {
        let mut fc : CodeNode = det.children[0 as usize].clone();
        if  fc.vref == "templates".to_string() {
          let mut tplList : CodeNode = det.children[1 as usize].clone();
          for i_1 in 0..tplList.children.len() {
            let mut tpl = tplList.children[i_1 as usize].clone();
            if  tpl.hasExpressionProperty("flags".to_string()) {
              let mut flagList : Option<CodeNode> = tpl.getExpressionProperty("flags".to_string());
              let mut b_matched : bool = false;
              operatorsOf::forEach_15(flagList.children, (item, index) => { 
                println!( "{}", format!("{}{}", "FLAG ".to_string(), item.vref) );
                b_matched = b_matched || ctx.hasCompilerFlag(item.vref.clone());
              }
              );
              if  b_matched == false {
                continue;
              }
            }
            let mut tplName : CodeNode = tpl.getFirst();
            let is_ts : bool = ctx.hasCompilerFlag("typescript".to_string());
            if  is_ts && ((tplName.vref == "typescript".to_string()) || (tplName.vref == "ts".to_string())) {
              rv = Some(tpl.clone());
              return rv.clone();
            }
            if  (tplName.vref != "*".to_string()) && (tplName.vref != langName) {
              continue;
            }
            rv = Some(tpl.clone());
            return rv.clone();
          }
          if  langName == "ranger".to_string() {
            let mut opNameNode : CodeNode = opDef.getFirst();
            let mut opArgs : CodeNode = opDef.getThird();
            let mut rangerTpl : CodeNode = CodeNode::fromList([CodeNode::newStr((format!("{}{}", (format!("{}{}", "(".to_string(), opNameNode.vref)), " ".to_string())))]);
            let mut cnt : i64 = 1;
            operatorsOf::forEach_15(opArgs.children, (item, index) => { 
              if  item.type_name == "block".to_string() {
                rangerTpl.children.push(CodeNode::fromList([CodeNode::vref1("block".to_string()), CodeNode::newInt(cnt)]));
              } else {
                rangerTpl.children.push(CodeNode::fromList([CodeNode::vref1("e".to_string()), CodeNode::newInt(cnt)]));
              }
              cnt = cnt + 1;
            }
            );
            rangerTpl.children.push(CodeNode::newStr(")".to_string()));
            rv = Some(CodeNode::fromList([CodeNode::vref1("ranger".to_string()), rangerTpl]));
          }
        }
      }
    }
    return rv.clone();
  }
  fn buildMacro(&mut self, mut langOper : Option<CodeNode>, mut args : CodeNode, mut ctx : RangerAppWriterContext) -> CodeNode {
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    let mut wr : CodeWriter = CodeWriter::new();
    let mut lcc : LiveCompiler = LiveCompiler::new();
    lcc.langWriter = Some(RangerRangerClassWriter::new());
    lcc.langWriter.compiler = Some(lcc.clone());
    subCtx.targetLangName = "ranger".to_string();
    subCtx.restartExpressionLevel();
    let mut macroNode : CodeNode = langOper.unwrap();
    let mut cmdList : CodeNode = macroNode.getSecond();
    if  ctx.hasCompilerFlag("show-macros".to_string()) {
      println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", "Building macro ".to_string(), macroNode.vref)), " : ".to_string())), cmdList.getCode()) );
      println!( "{}", format!("{}{}", "Arguments : ".to_string(), args.getCode()) );
    }
    lcc.walkCommandList(cmdList.clone(), args.clone(), subCtx.clone(), wr.clone());
    let lang_str : String = wr.getCode();
    let mut lang_code : SourceCode = SourceCode::new(lang_str.clone());
    lang_code.filename = format!("{}{}", (format!("{}{}", "<macro ".to_string(), macroNode.vref)), ">".to_string());
    let mut lang_parser : RangerLispParser = RangerLispParser::new(lang_code.clone());
    lang_parser.parse(ctx.hasCompilerFlag("no-op-transform".to_string()));
    let mut node : CodeNode = lang_parser.rootNode.clone().unwrap();
    if  ((args.register_expressions.len() as i64)) > 0 {
      node.register_expressions = operatorsOf::clone_46(args.register_expressions);
    }
    operatorsOf::forEach_15(args.children, (item, index) => { 
      operatorsOf::forEach_15(item.register_expressions, (item, index) => { 
        let mut re : CodeNode = item;
        node.register_expressions.push(re.clone());
      }
      );
    }
    );
    return node.clone();
  }
  fn stdParamMatch(&mut self, mut callArgs : CodeNode, mut inCtx : RangerAppWriterContext, mut wr : CodeWriter, require_all_match : bool) -> bool {
    self.stdCommands = Some(inCtx.getStdCommands());
    let mut callFnName : CodeNode = callArgs.getFirst();
    /** unused:  let mut cmds : Option<CodeNode> = self.stdCommands;   **/ 
    let mut some_matched : bool = false;
    /** unused:  let found_fn : bool = false;   **/ 
    let mut added_ns : String = "".to_string();
    /** unused:  let mut missed_args : Vec<String> = Vec::new();   **/ 
    let mut ctx : RangerAppWriterContext = inCtx.fork();
    /** unused:  let lang_name : String = operatorsOf_21::getTargetLang_22(ctx.clone());   **/ 
    let mut expects_error : bool = false;
    let err_cnt : i64 = inCtx.getErrorCount();
    let mut arg_eval_start : i64 = 0;
    if  callArgs.hasBooleanProperty("error".to_string()) {
      expects_error = true;
    }
    if  inCtx.expressionLevel() == 0 {
      inCtx.lastBlockOp = Some(callArgs.clone());
    } else {
    }
    /** unused:  let in_chain : bool = false;   **/ 
    let call_arg_cnt : i64 = (callArgs.children.len() as i64);
    let mut op_list : Vec<CodeNode> = ctx.getOperators(callFnName.vref.clone());
    for main_index in 0..op_list.len() {
      let mut ch = op_list[main_index as usize].clone();
      let mut fc : CodeNode = ch.getFirst();
      let mut nameNode : CodeNode = ch.getSecond();
      let mut args : CodeNode = ch.getThird();
      if  inCtx.isVarDefined(fc.vref.clone()) {
        return false;
      }
      ctx.removeOpNs(added_ns.clone());
      ctx.addOpNs(fc.vref.clone());
      added_ns = fc.vref.clone();
      /** unused:  let line_index : i64 = callArgs.getLine();   **/ 
      let callerArgCnt : i64 = call_arg_cnt - 1;
      let fnArgCnt : i64 = (args.children.len() as i64);
      let mut has_eval_ctx : bool = false;
      let mut is_macro : bool = false;
      let mut plugin_name : String = "operator".to_string();
      let mut plugin_fn : String = "".to_string();
      let mut is_plugin : bool = false;
      let mut is_pure : bool = false;
      let mut is_static_fn : bool = false;
      let mut static_fn_name : String = "".to_string();
      let mut static_class_name : String = "".to_string();
      let mut static_nameNode : Option<CodeNode> = None;
      if  nameNode.hasFlag("newcontext".to_string()) {
        ctx = inCtx.fork();
        has_eval_ctx = true;
      }
      let throws_exception : bool = nameNode.hasFlag("throws".to_string());
      let is_async : bool = nameNode.hasFlag("async".to_string());
      let expanding_node : bool = nameNode.hasFlag("expands".to_string());
      if  (callerArgCnt == fnArgCnt) || expanding_node {
        let mut details_list : CodeNode = ch.children[3 as usize].clone();
        let mut langOper : Option<CodeNode> = self.findLanguageOper(details_list.clone(), ctx.clone(), ch.clone());
        if  langOper.is_none() {
          continue;
        }
        is_pure = nameNode.hasFlag("pure".to_string());
        if  langOper.hasBooleanProperty("macro".to_string()) || nameNode.hasFlag("macro".to_string()) {
          is_macro = true;
        }
        if  langOper.hasStringProperty("plugin".to_string()) {
          plugin_name = langOper.getStringProperty("plugin".to_string());
          is_plugin = true;
          let pluginFn : String = langOper.getStringProperty("fn".to_string());
          if  (pluginFn.len() as i64) > 0 {
            plugin_fn = pluginFn.clone();
            println!( "{}", format!("{}{}", "Function : ".to_string(), plugin_fn) );
          }
        }
        let mut codeDef : CodeNode = langOper.getSecond();
        let mut match : RangerArgMatch = RangerArgMatch::new();
        let mut last_walked : i64 = 0;
        let mut last_was_block : bool = false;
        let mut walk_later : Vec<WalkLater> = Vec::new();
        let mut not_enough_args : bool = false;
        let mut blocksToWalkLater : Vec<CodeNode> = Vec::new();
        if  ch.hasExpressionProperty("flags".to_string()) {
          let mut flagList : Option<CodeNode> = ch.getExpressionProperty("flags".to_string());
          let mut b_matched : bool = false;
          operatorsOf::forEach_15(flagList.children, (item, index) => { 
            b_matched = b_matched || ctx.hasCompilerFlag(item.vref.clone());
          }
          );
          if  b_matched == false {
            continue;
          }
        }
        ctx.setInExpr();
        for i in 0..args.children.len() {
          let mut arg = args.children[i as usize].clone();
          if  i < arg_eval_start {
            continue;
          }
          arg_eval_start = i;
          if  ((callArgs.children.len() as i64)) <= (i + 1) {
            not_enough_args = true;
            break;
          }
          let mut callArg : CodeNode = callArgs.children[(i + 1) as usize].clone();
          if  arg.hasFlag("define".to_string()) {
            let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
            p.name = callArg.vref.clone();
            p.value_type = arg.value_type;
            p.node = Some(callArg.clone());
            p.nameNode = Some(callArg.clone());
            p.is_optional = false;
            p.init_cnt = 1;
            ctx.defineVariable(p.name.clone(), p.clone());
            callArg.hasParamDesc = true;
            callArg.ownParamDesc = Some(p.clone());
            callArg.paramDesc = Some(p.clone());
            if  (callArg.type_name.len() as i64) == 0 {
              callArg.type_name = arg.type_name.clone();
              callArg.value_type = arg.value_type;
            }
            callArg.eval_type = arg.value_type;
            callArg.eval_type_name = arg.type_name.clone();
          }
          if  arg.hasFlag("ignore".to_string()) {
            continue;
          }
          if  arg.hasFlag("keyword".to_string()) {
            if  callArg.vref != arg.vref {
              not_enough_args = true;
            }
            continue;
          }
          if  arg.hasFlag("noeval".to_string()) {
            callArg.eval_type = callArg.value_type;
            callArg.eval_type_name = callArg.type_name.clone();
            callArg.eval_array_type = callArg.array_type.clone();
            callArg.eval_key_type = callArg.key_type.clone();
            continue;
          }
          last_walked = i + 1;
          if  arg.value_type == 17 {
            let mut opList : Vec<CodeNode> = ctx.getOpFns(callArg.vref.clone());
            if  ((opList.len() as i64)) > 0 {
              let mut signature : CodeNode = arg.expression_value.copy();
              /** unused:  let mut params : CodeNode = signature.children[1 as usize].clone();   **/ 
            }
            if  codeDef.is_block_node == false {
              let mut later : WalkLater = WalkLater::new();
              later.arg = Some(arg.clone());
              later.callArg = Some(callArg.clone());
              walk_later.push(later.clone());
            }
          } else {
            if  (arg.type_name == "block".to_string()) || arg.hasFlag("block".to_string()) {
              if  arg.hasFlag("try_block".to_string()) {
                let mut tmpCtx : RangerAppWriterContext = ctx.fork();
                tmpCtx.is_try_block = true;
                callArg.evalCtx = Some(tmpCtx.clone());
                tmpCtx.newBlock();
                self.WalkNode(callArg.clone(), tmpCtx.clone(), wr.clone());
              } else {
                let mut tmpCtx_1 : RangerAppWriterContext = ctx.fork();
                tmpCtx_1.newBlock();
                callArg.evalCtx = Some(tmpCtx_1.clone());
                self.WalkNode(callArg.clone(), tmpCtx_1.clone(), wr.clone());
              }
              last_was_block = true;
            } else {
              ctx.setInExpr();
              self.WalkNode(callArg.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
              if  (arg.type_name.len() as i64) > 0 {
                self.convertToUnion(arg.type_name.clone(), callArg.clone(), ctx.clone(), wr.clone());
              }
              last_was_block = false;
            }
            if  arg.hasFlag("mutates".to_string()) {
              if  callArg.hasParamDesc {
                if  callArg.paramDesc.is_some() && (callArg.paramDesc.propertyClass.is_some()) {
                  if  callArg.paramDesc.propertyClass.nameNode.hasFlag("immutable".to_string()) {
                    let mut propC : Option<RangerAppClassDesc> = callArg.paramDesc.propertyClass;
                    let mut currC : Option<RangerAppClassDesc> = ctx.getCurrentClass();
                    if  (currC.unwrap()) != (propC.unwrap()) {
                      not_enough_args = true;
                    }
                  }
                }
              }
            }
          }
        }
        ctx.unsetInExpr();
        if  not_enough_args {
          continue;
        }
        if  expanding_node {
          for i2 in 0..callArgs.children.len() {
            let mut caCh = callArgs.children[i2 as usize].clone();
            if  caCh.is_block_node {
              let mut tmpCtx_2 : RangerAppWriterContext = ctx;
              caCh.evalCtx = Some(tmpCtx_2.clone());
              blocksToWalkLater.push(caCh.clone());
              continue;
            }
            if  i2 > last_walked {
              if  last_was_block {
                let mut sCtx : RangerAppWriterContext = ctx.forkWithOps((ch.children[3 as usize].clone()));
                self.WalkNode(caCh.clone(), sCtx.clone(), wr.clone());
              } else {
                ctx.setInExpr();
                self.WalkNode(caCh.clone(), ctx.clone(), wr.clone());
                ctx.unsetInExpr();
              }
            }
          }
        }
        let all_matched : bool = r#match.matchArguments(args.clone(), callArgs.clone(), ctx.clone(), 1);
        if  all_matched {
          let expr_level : i64 = ctx.expressionLevel();
          let mut is_last : bool = false;
          if  callArgs.parent.is_some() {
            is_last = ((callArgs.parent.children.len() as i64)) == (1 + (callArgs.parent.children.iter().position( |&r| r == callArgs ).unwrap()));
          }
          if  ((fc.vref == "if".to_string()) && ctx.hasCompilerFlag("voidexpr".to_string())) && ((expr_level > 0) || is_last) {
            println!( "{}", ["IF expr leve == ".to_string() , (ctx.expressionLevel().to_string()) ].join("") );
            println!( "{}", callArgs.getCode() );
            let mut thenBlock : CodeNode = callArgs.children[2 as usize].clone();
            let mut lastRow : CodeNode = thenBlock.children[(((thenBlock.children.len() as i64)) - 1) as usize].clone();
            println!( "{}", format!("{}{}", "Last row == ".to_string(), lastRow.getCode()) );
            let mut BlockOP : Option<CodeNode> = ctx.getLastBlockOp();
            let regName : String = ctx.createNewRegName();
            let mut regExpr : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref2(regName.clone(), lastRow.eval_type_name.clone())]);
            callArgs.eval_type = lastRow.eval_type;
            callArgs.eval_type_name = lastRow.eval_type_name.clone();
            let mut fnC : RangerAppWriterContext = ctx.findFunctionCtx();
            self.WalkNode(regExpr.clone(), fnC.clone(), wr.clone());
            let realRegName : String = (((regExpr.children[1 as usize].clone())).paramDesc).compiledName;
            let mut then_regs : bool = false;
            if  (lastRow.register_name.len() as i64) > 0 {
              let mut newLastRow : CodeNode = CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1(lastRow.register_name.clone())]);
              self.WalkNode(newLastRow.clone(), ctx.clone(), wr.clone());
              thenBlock.children.push(newLastRow.clone());
              then_regs = true;
            } else {
              let mut vCopy : CodeNode = lastRow.cleanCopy();
              lastRow.expression = true;
              lastRow.vref = "".to_string();
              lastRow.value_type = 0;
              lastRow.flow_done = false;
              lastRow.getChildrenFrom(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName.clone()), vCopy]));
              self.WalkNode(lastRow.clone(), ctx.clone(), wr.clone());
            }
            if  ((callArgs.children.len() as i64)) == 4 {
              let mut elseBlock : CodeNode = callArgs.children[3 as usize].clone();
              let mut lastRow_1 : CodeNode = elseBlock.children[(((elseBlock.children.len() as i64)) - 1) as usize].clone();
              if  (lastRow_1.register_name.len() as i64) > 0 {
                let mut newLastRow_1 : CodeNode = CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName.clone()), CodeNode::vref1(lastRow_1.register_name.clone())]);
                self.WalkNode(newLastRow_1.clone(), ctx.clone(), wr.clone());
                elseBlock.children.push(newLastRow_1.clone());
                then_regs = true;
              } else {
                let mut vCopy_1 : CodeNode = lastRow_1.cleanCopy();
                lastRow_1.expression = true;
                lastRow_1.vref = "".to_string();
                lastRow_1.value_type = 0;
                lastRow_1.flow_done = false;
                lastRow_1.getChildrenFrom(CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName.clone()), vCopy_1]));
                println!( "{}", format!("{}{}", " lastRow value --> ".to_string(), vCopy_1.getCode()) );
                self.WalkNode(lastRow_1.clone(), ctx.clone(), wr.clone());
              }
            }
            let mut tmp : CodeNode = (callArgs).clone();
            BlockOP.register_expressions.push(regExpr.clone());
            BlockOP.register_expressions.push(tmp.clone());
            callArgs.register_name = regName.clone();
            callArgs.reg_compiled_name = realRegName.clone();
            tmp.has_operator = true;
            tmp.op_index = main_index;
            tmp.operator_node = Some(Box::new(ch.clone()));
            return true;
          }
          if  (fc.vref != "for".to_string()) && ctx.hasCompilerFlag("new".to_string()) {
            let mut opDef : CodeNode = langOper.getSecond();
            let mut opCnts : HashMap<i64,i64> = HashMap::new();
            let mut regNames : HashMap<i64,String> = HashMap::new();
            let mut firstRef : HashMap<i64,CodeNode> = HashMap::new();
            operatorsOf::forEach_15(args.children, (item, index) => { 
              let mut opArg : CodeNode = item;
              if  opArg.hasFlag("loopcondition".to_string()) {
                let mut loopBlock : Option<CodeNode> = None;
                operatorsOf::forEach_15(args.children, (item, index) => { 
                  if  item.hasFlag("loopblock".to_string()) {
                    let mut tmp_1 : CodeNode = callArgs.children[(index + 1) as usize].clone();
                    loopBlock = Some(tmp_1.clone());
                  }
                }
                );
                if  loopBlock.is_none() {
                  ctx.addError(args.clone(), "Invalid operator: Loop condition without block ".to_string());
                  return;
                }
                let opName : i64 = index + 1;
                /** unused:  let mut item : CodeNode = callArgs.children[(index + 1) as usize].clone();   **/ 
                let mut regName_1 : String = "".to_string();
                let mut realArg : CodeNode = callArgs.children[opName as usize].clone();
                if  (realArg.register_name.len() as i64) > 0 {
                  regName_1 = realArg.register_name.clone();
                } else {
                  regName_1 = ctx.createNewRegName();
                }
                let mut argCopy : CodeNode = realArg.copy();
                let mut regExpr_1 : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName_1.clone()), argCopy]);
                ctx.lastBlockOp = Some(callArgs.clone());
                self.WalkNode(regExpr_1.clone(), ctx.clone(), wr.clone());
                let realRegName_1 : String = (((regExpr_1.children[1 as usize].clone())).paramDesc).compiledName;
                let mut regArg : CodeNode = regExpr_1.children[1 as usize].clone();
                regArg.paramDesc.set_cnt = 1;
                regArg.paramDesc.ref_cnt = 1;
                let mut BlockOP_1 : Option<CodeNode> = ctx.getLastBlockOp();
                BlockOP_1.register_expressions.push(regExpr_1.clone());
                realArg.register_name = regName_1.clone();
                realArg.reg_compiled_name = realRegName_1.clone();
                operatorsOf::forEach_15(callArgs.children, (item, index) => { 
                  if  item.is_block_node {
                    let mut argCopy_1 : CodeNode = realArg.copy();
                    argCopy_1.register_name = "".to_string();
                    argCopy_1.forTree((item, i) => { 
                      item.register_name = "".to_string();
                    }
                    );
                    let mut eval_expr : CodeNode = CodeNode::fromList([CodeNode::vref1("=".to_string()), CodeNode::vref1(regName_1.clone()), argCopy_1]);
                    /** unused:  let mut lastOp : CodeNode = loopBlock.children[(((loopBlock.children.len() as i64)) - 1) as usize].clone();   **/ 
                    ctx.lastBlockOp = Some(eval_expr.clone());
                    self.WalkNode(eval_expr.clone(), ctx.clone(), wr.clone());
                    item.children.push(eval_expr.clone());
                  }
                }
                );
              }
            }
            );
            operatorsOf::forEach_15(opDef.children, (item, index) => { 
              if  item.isFirstVref("e".to_string()) {
                if  item.hasFlag("ignore".to_string()) || item.hasFlag("noeval".to_string()) {
                  return;
                }
                let opName_1 : i64 = (item.getSecond()).int_value;
                /** unused:  let mut opArg_1 : CodeNode = args.children[(opName_1 - 1) as usize].clone();   **/ 
                if  opCnts.contains_key(&opName_1) {
                  let mut regName_2 : String = "".to_string();
                  let mut realArg_1 : CodeNode = callArgs.children[opName_1 as usize].clone();
                  let mut just_vref :  = (a) => { 
                    return false;
                  }
                  ;
                  just_vref = (a) => { 
                    if  (a.vref.len() as i64) > 0 {
                      return true;
                    }
                    if  TTypes::isPrimitive(a.value_type) {
                      return true;
                    }
                    if  ((a.children.len() as i64)) == 1 {
                      return just_vref((a.children[0 as usize].clone()));
                    }
                    return false;
                  }
                  ;
                  if  just_vref(realArg_1) {
                    return;
                  }
                  if  regNames.contains_key(&opName_1) {
                    if  (realArg_1.register_name.len() as i64) > 0 {
                      regName_2 = realArg_1.register_name.clone();
                    } else {
                      regName_2 = (regNames.get(opName_1)).unwrap();
                    }
                    realArg_1.register_name = regName_2.clone();
                  } else {
                    if  (realArg_1.register_name.len() as i64) > 0 {
                      regName_2 = realArg_1.register_name.clone();
                    } else {
                      regName_2 = ctx.createNewRegName();
                      regNames.insert(opName_1, regName_2);
                      let mut argCopy_2 : CodeNode = realArg_1.copy();
                      let mut regExpr_2 : CodeNode = CodeNode::fromList([CodeNode::vref1("def".to_string()), CodeNode::vref1(regName_2.clone()), argCopy_2]);
                      self.WalkNode(regExpr_2.clone(), ctx.clone(), wr.clone());
                      let mut regArg_1 : CodeNode = regExpr_2.children[1 as usize].clone();
                      let realRegName_2 : String = (((regExpr_2.children[1 as usize].clone())).paramDesc).compiledName;
                      regArg_1.paramDesc.set_cnt = 1;
                      regArg_1.paramDesc.ref_cnt = 1;
                      let mut BlockOP_2 : Option<CodeNode> = ctx.getLastBlockOp();
                      BlockOP_2.register_expressions.push(regExpr_2.clone());
                      realArg_1.register_name = regName_2.clone();
                      realArg_1.reg_compiled_name = realRegName_2.clone();
                    }
                  }
                } else {
                  opCnts.insert(opName_1, 1);
                  firstRef.insert(opName_1, item);
                }
              }
            }
            );
          }
        }
        if  all_matched {
          if  is_async {
            let mut activeFn : RangerAppFunctionDesc = ctx.getCurrentMethod();
            if  activeFn.nameNode.is_some() {
              activeFn.nameNode.setFlag("async".to_string());
            }
            while activeFn.insideFn.is_some() {
              activeFn = (*activeFn.insideFn.clone().unwrap());
              if  activeFn.nameNode.is_some() {
                activeFn.nameNode.setFlag("async".to_string());
              }
            }
          }
          if  throws_exception {
            if  false == ctx.isTryBlock() {
              let mut activeFn_1 : RangerAppFunctionDesc = ctx.getCurrentMethod();
              if  (activeFn_1.nameNode.is_some()) && activeFn_1.nameNode.hasFlag("throws".to_string()) {
              } else {
                ctx.addError(callArgs.clone(), format!("{}{}", (format!("{}{}", "The operator ".to_string(), fc.vref)), " potentially throws an exception, try { } block is required".to_string()));
              }
            }
          }
          for i_1 in 0..blocksToWalkLater.len() {
            let mut b = blocksToWalkLater[i_1 as usize].clone();
            let mut localFork : RangerAppWriterContext = b.evalCtx.fork();
            self.WalkNode(b.clone(), localFork.clone(), wr.clone());
          }
          for i_2 in 0..walk_later.len() {
            let mut later_1 = walk_later[i_2 as usize].clone();
            let mut ca : CodeNode = later_1.callArg.clone().unwrap();
            let mut aa : CodeNode = later_1.arg.clone().unwrap();
            /** unused:  let mut newNode : CodeNode = CodeNode::new(ca.code.clone().unwrap(), ca.sp, ca.ep);   **/ 
            if  (ca.is_block_node && (ca.isFirstVref("fn".to_string()) == false)) && (ca.isFirstVref("fun".to_string()) == false) {
              let mut fnDef : CodeNode = (*aa.expression_value.clone().unwrap());
              let mut copyOf : CodeNode = fnDef.rebuildWithType(match.clone(), false);
              let mut ffc : CodeNode = copyOf.children[0 as usize].clone();
              ffc.vref = "fun".to_string();
              let mut itemCopy : CodeNode = ca.rebuildWithType(match.clone(), false);
              copyOf.children.push(itemCopy.clone());
              let mut cnt : i64 = (ca.children.len() as i64);
              while cnt > 0 {
                ca.children.pop();
                cnt = cnt - 1;
              }
              for i_3 in 0..copyOf.children.len() {
                let mut ch_1 = copyOf.children[i_3 as usize].clone();
                ca.children.push(ch_1.clone());
              }
            }
            let mut sCtx_1 : RangerAppWriterContext = ctx.fork();
            sCtx_1.newBlock();
            self.WalkNode(ca.clone(), sCtx_1.clone(), wr.clone());
          }
        }
        let mut staticMethod : Option<RangerAppFunctionDesc> = None;
        if  codeDef.is_block_node && all_matched {
          let pure_transform : bool = ctx.hasCompilerFlag("pure".to_string());
          if  is_pure && pure_transform {
            let mut argDefs : CodeNode = CodeNode::blockFromList(operatorsOf::map_45(args.children, (item, index) => { 
              let mut callArg_1 : CodeNode = callArgs.children[(index + 1) as usize].clone();
              let mut arg_1 : CodeNode = item;
              let mut vName : CodeNode = item.copy();
              /** unused:  let mut caCopy : CodeNode = callArg_1.copy();   **/ 
              let mut prms : Vec<CodeNode> = self.transformParams2([callArg_1], [arg_1], ctx);
              let mut firstp : CodeNode = prms[0 as usize].clone();
              let mut ad : CodeNode = CodeNode::op3("def".to_string(), [vName, firstp]);
              return ad.clone();
            }
            ));
            let mut bodyStart : CodeNode = CodeNode::blockFromList([argDefs, codeDef]);
            let mut newCtx : RangerAppWriterContext = ctx.fork();
            let mut bodyCopy : CodeNode = bodyStart.rebuildWithType(match.clone(), true);
            callArgs.flow_done = false;
            callArgs.getChildrenFrom(bodyCopy.clone());
            self.WalkNode(callArgs.clone(), newCtx.clone(), wr.clone());
            return true;
          }
          let mut nSig : String = "".to_string();
          if  ((args.children.len() as i64)) > 0 {
            let mut arg0 : CodeNode = args.getFirst();
            nSig = self.getNameSignature(arg0.clone());
          } else {
            nSig = self.getVoidNameSignature();
          }
          let mut new_cl : RangerAppClassDesc = ctx.createOpStaticClass(nSig.clone());
          self.WalkNode(new_cl.classNode.clone().unwrap(), ctx.clone(), wr.clone());
          let mut bodyCopy_1 : CodeNode = codeDef.rebuildWithType(match.clone(), true);
          let mut argsCopy : CodeNode = args.rebuildWithType(match.clone(), true);
          let mut nameCopy : CodeNode = nameNode.rebuildWithType(match.clone(), true);
          let sigN : String = ctx.transformOpNameWord(fc.vref.clone());
          let argsSig : String = format!("{}{}", sigN, self.getArgsSignature(argsCopy.clone()));
          if  false == new_cl.hasStaticMethod(argsSig.clone()) {
            let mut sMethod : RangerAppFunctionDesc = ctx.createStaticMethod(argsSig.clone(), new_cl.clone(), nameCopy.clone(), argsCopy.clone(), bodyCopy_1.clone(), self.clone(), wr.clone());
            staticMethod = Some(sMethod.clone());
            let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
            currM.addCallTo(sMethod.clone());
            static_nameNode = Some(nameCopy.clone());
            let mut fCtx : RangerAppWriterContext = sMethod.fnCtx.clone().unwrap();
            fCtx.currentMethod = Some(sMethod.clone());
            fCtx.is_function = true;
            let mut m : RangerAppFunctionDesc = sMethod;
            fCtx.in_static_method = true;
            if  nameCopy.hasFlag("weak".to_string()) {
              m.changeStrength(0, 1, nameNode.clone());
            } else {
              m.changeStrength(1, 1, nameNode.clone());
            }
            fCtx.setInMethod();
            for i_4 in 0..m.params.len() {
              let mut v = m.params[i_4 as usize].clone();
              fCtx.defineVariable(v.name.clone(), v.clone());
              v.nameNode.eval_type = v.nameNode.typeNameAsType(fCtx.clone());
              v.nameNode.eval_type_name = v.nameNode.type_name.clone();
            }
            self.WalkNodeChildren(bodyCopy_1.clone(), fCtx.clone(), wr.clone());
            fCtx.unsetInMethod();
            fCtx.in_static_method = false;
            fCtx.function_level_context = true;
            for i_5 in 0..fCtx.localVarNames.len() {
              let mut n = fCtx.localVarNames[i_5 as usize].clone();
              let mut p_1 : Option<RangerAppParamDesc> = fCtx.localVariables.get(n);
              if  p_1.set_cnt > 0 {
                if  p_1.is_immutable {
                  ctx.addError(callArgs.clone(), "Immutable variable was assigned".to_string());
                }
                let mut defNode : Option<CodeNode> = p_1.node;
                defNode.setFlag("mutable".to_string());
                let mut nNode : Option<CodeNode> = p_1.nameNode;
                nNode.setFlag("mutable".to_string());
              }
            }
          } else {
            let mut sMethod_1 : Option<RangerAppFunctionDesc> = new_cl.findStaticMethod(argsSig.clone());
            static_nameNode = sMethod_1.nameNode.clone();
            let mut currM_1 : RangerAppFunctionDesc = ctx.getCurrentMethod();
            currM_1.addCallTo(sMethod_1.unwrap());
            staticMethod = Some(sMethod_1.clone());
          }
          is_static_fn = true;
          static_fn_name = argsSig.clone();
          static_class_name = new_cl.name.clone();
        }
        if  all_matched {
          if  is_static_fn {
            let mut firstArg : CodeNode = callArgs.getFirst();
            firstArg.vref = format!("{}{}", (format!("{}{}", static_class_name, ".".to_string())), static_fn_name);
            firstArg.flow_done = false;
            firstArg.value_type = 11;
            firstArg.ns.length = 0;
            firstArg.ns.push(static_class_name);
            firstArg.ns.push(static_fn_name);
            let mut newArgs : CodeNode = CodeNode::new(callArgs.code.clone().unwrap(), callArgs.sp, callArgs.ep);
            for i_6 in 0..callArgs.children.len() {
              let mut ca_1 = callArgs.children[i_6 as usize].clone();
              if  ca_1.is_part_of_chain {
                continue;
              }
              if  i_6 > 0 {
                let mut arg_2 : CodeNode = args.children[(i_6 - 1) as usize].clone();
                if  arg_2.hasFlag("noeval".to_string()) {
                  continue;
                }
                newArgs.children.push(ca_1.clone());
              }
            }
            let mut arg_len : i64 = (callArgs.children.len() as i64);
            while arg_len > 1 {
              callArgs.children.pop();
              arg_len = arg_len - 1;
            }
            callArgs.children.push(newArgs.clone());
            callArgs.flow_done = false;
            self.WalkNode(callArgs.clone(), ctx.clone(), wr.clone());
            /** unused:  let mut currMM : RangerAppFunctionDesc = ctx.getCurrentMethod();   **/ 
            for i_7 in 0..newArgs.children.len() {
              let mut ca_2 = newArgs.children[i_7 as usize].clone();
              if  ca_2.eval_type == 17 {
                if  ca_2.lambdaFnDesc.is_some() {
                  if  staticMethod.is_some() {
                    staticMethod.addCallTo(ca_2.lambdaFnDesc.clone().unwrap());
                    if  ca_2.lambdaFnDesc.nameNode.hasFlag("async".to_string()) {
                      staticMethod.nameNode.setFlag("async".to_string());
                    }
                  }
                }
              }
              ca_2.forTree((item, i) => { 
                if  item.fnDesc.is_some() {
                  if  staticMethod.is_some() {
                    staticMethod.addCallTo(item.fnDesc.clone().unwrap());
                  }
                }
              }
              );
            }
            r#match.setRvBasedOn(static_nameNode.unwrap(), callArgs.clone());
            ctx.removeOpNs(added_ns.clone());
            return true;
          }
          if  is_plugin {
            try {
              let fileName : String = format!("{}{}", (format!("{}{}", ("."), "/".to_string())), plugin_name);
              println!( "{}", format!("{}{}", "trying to load plugin: ".to_string(), fileName) );
              let mut plugin : RangerCompilerPlugin = ;
              callArgs.flow_done = false;
              self.WalkNode(callArgs.clone(), ctx.clone(), wr.clone());
              r#match.setRvBasedOn(nameNode.clone(), callArgs.clone());
              ctx.removeOpNs(added_ns.clone());
              println!( "{}", "plugin ready...".to_string() );
            } catch(e) {
              ctx.addError(callArgs.clone(), +"Plugin operator failed ".to_string()error_msg);
            }
            return true;
          }
          if  is_macro {
            let mut macroNode : CodeNode = self.buildMacro(langOper.clone(), callArgs.clone(), ctx.clone());
            let mut arg_len_1 : i64 = (callArgs.children.len() as i64);
            while arg_len_1 > 0 {
              callArgs.children.pop();
              arg_len_1 = arg_len_1 - 1;
            }
            callArgs.children.push(macroNode.clone());
            macroNode.parent = Some(Box::new(callArgs.clone()));
            self.WalkNode(macroNode.clone(), ctx.clone(), wr.clone());
            r#match.setRvBasedOn(nameNode.clone(), callArgs.clone());
            ctx.removeOpNs(added_ns.clone());
            return true;
          }
          if  nameNode.hasFlag("moves".to_string()) {
            let mut moves_opt : Option<CodeNode> = nameNode.getFlag("moves".to_string());
            let mut moves : CodeNode = moves_opt.unwrap();
            let mut ann : Option<CodeNode> = moves.vref_annotation;
            let mut from : CodeNode = ann.getFirst();
            let mut toItem : CodeNode = ann.getSecond();
            let mut cA : CodeNode = callArgs.children[from.int_value as usize].clone();
            let mut cA2 : CodeNode = callArgs.children[toItem.int_value as usize].clone();
            if  cA.hasParamDesc {
              let mut pp : Option<RangerAppParamDesc> = cA.paramDesc;
              let mut pp2 : Option<RangerAppParamDesc> = cA2.paramDesc;
              pp.moveRefTo(callArgs.clone(), pp2.unwrap(), ctx.clone());
            }
          }
          if  nameNode.hasFlag("returns".to_string()) {
            let mut activeFn_2 : RangerAppFunctionDesc = ctx.getCurrentMethod();
            if  (activeFn_2.nameNode.type_name != "void".to_string()) || (activeFn_2.nameNode.value_type == 17) {
              if  ((callArgs.children.len() as i64)) < 2 {
                ctx.addError(callArgs.clone(), " missing return value !!!".to_string());
              } else {
                let mut returnedValue : CodeNode = callArgs.children[1 as usize].clone();
                let mut validated_returnvalue : bool = false;
                if  activeFn_2.nameNode.value_type == 17 {
                  validated_returnvalue = true;
                  let mut fnExpr : Option<CodeNode> = activeFn_2.nameNode.expression_value;
                  if  fnExpr.is_none() {
                    ctx.addError(activeFn_2.nameNode.clone().unwrap(), "returned anonymous function should have a method signature".to_string());
                  } else {
                    if  (returnedValue.value_type != 17) && (returnedValue.eval_type != 17) {
                      ctx.addError(returnedValue.clone(), "Function should return anonymous function!".to_string());
                    } else {
                      if  returnedValue.hasParamDesc && (returnedValue.paramDesc.nameNode.is_some()) {
                        let mut rExpr : Option<CodeNode> = returnedValue.paramDesc.nameNode.expression_value;
                        self.matchLambdaArgs(fnExpr.unwrap(), rExpr.unwrap(), ctx.clone(), wr.clone());
                      } else {
                        let mut rExpr_1 : Option<CodeNode> = returnedValue.expression_value;
                        self.matchLambdaArgs(fnExpr.unwrap(), rExpr_1.unwrap(), ctx.clone(), wr.clone());
                      }
                    }
                  }
                }
                if  validated_returnvalue == false {
                  if  r#match.doesMatch((activeFn_2.nameNode.clone().unwrap()), returnedValue.clone(), ctx.clone()) == false {
                    if  activeFn_2.nameNode.ifNoTypeSetToEvalTypeOf(returnedValue.clone()) {
                    } else {
                      ctx.addError(returnedValue.clone(), format!("{}{}", "invalid return value type!!! ".to_string(), returnedValue.getCode()));
                      ctx.addError(returnedValue.clone(), format!("{}{}", "^ code: ".to_string(), returnedValue.getCode()));
                      ctx.addError(activeFn_2.nameNode.clone().unwrap(), "^ regarding to".to_string());
                      if  returnedValue.eval_type == 28 {
                        ctx.addError(activeFn_2.nameNode.clone().unwrap(), "^ which was a method".to_string());
                      }
                      ctx.addError(activeFn_2.nameNode.clone().unwrap(), ["^ value type = ".to_string() , (returnedValue.eval_type.to_string()) ].join(""));
                    }
                  }
                }
                let mut argNode : CodeNode = activeFn_2.nameNode.clone().unwrap();
                if  returnedValue.hasFlag("optional".to_string()) {
                  if  false == argNode.hasFlag("optional".to_string()) {
                    ctx.addError(callArgs.clone(), format!("{}{}", "function return value optionality does not match, expected non-optional return value, optional given at ".to_string(), argNode.getCode()));
                  }
                }
                if  argNode.hasFlag("optional".to_string()) {
                  if  false == returnedValue.hasFlag("optional".to_string()) {
                    ctx.addError(callArgs.clone(), format!("{}{}", "function return value optionality does not match, expected optional return value ".to_string(), argNode.getCode()));
                  }
                }
                let mut pp_1 : Option<RangerAppParamDesc> = returnedValue.paramDesc;
                if  pp_1.is_some() {
                  pp_1.moveRefTo(callArgs.clone(), activeFn_2.clone(), ctx.clone());
                }
              }
            }
            if  callArgs.parent.is_none() {
              ctx.addError(callArgs.clone(), "did not have parent".to_string());
              println!( "{}", format!("{}{}", "no parent => ".to_string(), callArgs.getCode()) );
            }
            callArgs.parent.didReturnAtIndex = callArgs.parent.children.iter().position( |&r| r == callArgs ).unwrap();
          }
          if  nameNode.hasFlag("returns".to_string()) == false {
            r#match.setRvBasedOn(nameNode.clone(), callArgs.clone());
            callArgs.evalTypeClass = Some(TFactory::new_def_signature(nameNode.clone(), ctx.clone(), wr.clone()));
          }
          if  has_eval_ctx {
            let mut tmpCtx_3 : RangerAppWriterContext = ctx;
            callArgs.evalCtx = Some(tmpCtx_3.clone());
          }
          let mut nodeP : Option<CodeNode> = callArgs.parent;
          if  nodeP.is_some() {
          } else {
          }
          /** unused:  let sig : String = nameNode.buildTypeSignatureUsingMatch(match.clone());   **/ 
          some_matched = true;
          callArgs.has_operator = true;
          callArgs.op_index = main_index;
          callArgs.operator_node = Some(Box::new(ch.clone()));
          for arg_index in 0..args.children.len() {
            let mut arg_3 = args.children[arg_index as usize].clone();
            if  arg_3.has_vref_annotation {
              let mut anns : Option<CodeNode> = arg_3.vref_annotation;
              for i_8 in 0..anns.children.len() {
                let mut ann_1 = anns.children[i_8 as usize].clone();
                if  ann_1.vref == "mutates".to_string() {
                  let mut theArg : CodeNode = callArgs.children[(arg_index + 1) as usize].clone();
                  if  theArg.hasParamDesc {
                    theArg.paramDesc.set_cnt = theArg.paramDesc.set_cnt + 1;
                  }
                }
              }
            }
          }
          break;
        }
      }
    }
    if  (require_all_match == true) && (some_matched == false) {
      ctx.addError(callArgs.clone(), format!("{}{}", "Could not match argument types for ".to_string(), callFnName.vref));
    }
    if  expects_error {
      let cnt_now : i64 = ctx.getErrorCount();
      if  cnt_now == err_cnt {
        ctx.addParserError(callArgs.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: expected generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now.to_string()) ].join(""));
      }
    } else {
      let cnt_now_1 : i64 = ctx.getErrorCount();
      if  cnt_now_1 > err_cnt {
        ctx.addParserError(callArgs.clone(), [(format!("{}{}", (["LANGUAGE_PARSER_ERROR: did not expect generated error, err counts : ".to_string() , (err_cnt.to_string()) ].join("")), " : ".to_string())) , (cnt_now_1.to_string()) ].join(""));
      }
    }
    ctx.removeOpNs(added_ns.clone());
    return some_matched;
  }
}
#[derive(Clone)]
struct TFactory { 
}
impl TFactory { 
  
  pub fn new() ->  TFactory {
    let mut me = TFactory { 
    };
    return me;
  }
  pub fn new_class_signature(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    let sig : String = node.vref.clone();
    let mut tc : Option<RangerTypeClass> = ctx.getTypeClass(sig.clone());
    if  tc.is_none() {
      let mut newTC : RangerTypeClass = ctx.addTypeClass(sig.clone());
      newTC.value_type = node.value_type;
      newTC.is_class = true;
      newTC.name = sig.clone();
      return newTC.clone();
    }
    return tc.unwrap().clone();
  }
  pub fn new_lambda_signature(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    let sig : String = TFactory::lambdaSignature(node.clone());
    let mut tc : Option<RangerTypeClass> = ctx.getTypeClass(sig.clone());
    if  tc.is_none() {
      let mut newTC : RangerTypeClass = ctx.addTypeClass(sig.clone());
      newTC.value_type = node.value_type;
      newTC.is_lambda = true;
      newTC.name = sig.clone();
      return newTC.clone();
    }
    return tc.unwrap().clone();
  }
  pub fn new_def_signature_from_simple_string(sig : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    let mut tc : Option<RangerTypeClass> = ctx.getTypeClass(sig.clone());
    if  tc.is_none() {
      let mut newTC : RangerTypeClass = ctx.addTypeClass(sig.clone());
      newTC.is_primitive = TTypes::isPrimitive(TTypes::nameToValue(sig.clone()));
      newTC.value_type = TTypes::nameToValue(sig.clone());
      newTC.name = sig.clone();
      if  ((sig.len() as i64) > 0) == false {
        newTC.is_empty = true;
      }
      return newTC.clone();
    }
    return tc.unwrap().clone();
  }
  pub fn sig(sig : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    return TFactory::new_def_signature_from_simple_string(sig.clone(), ctx.clone(), wr.clone()).clone();
  }
  pub fn new_def_signature(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    let sig : String = TFactory::baseSignature(node.clone());
    let mut tc : Option<RangerTypeClass> = ctx.getTypeClass(sig.clone());
    if  tc.is_none() {
      let mut newTC : RangerTypeClass = ctx.addTypeClass(sig.clone());
      newTC.value_type = node.value_type;
      newTC.is_primitive = TTypes::isPrimitive(node.value_type);
      if  node.value_type == 17 {
        newTC.is_lambda = true;
      }
      if  node.value_type == 6 {
        newTC.arrayType = Some(Box::new(TFactory::new_def_signature_from_simple_string(node.array_type.clone(), ctx.clone(), wr.clone()).clone()));
      }
      if  node.value_type == 7 {
        newTC.keyType = Some(Box::new(TFactory::new_def_signature_from_simple_string(node.key_type.clone(), ctx.clone(), wr.clone()).clone()));
        newTC.arrayType = Some(Box::new(TFactory::new_def_signature_from_simple_string(node.array_type.clone(), ctx.clone(), wr.clone()).clone()));
      }
      newTC.name = sig.clone();
      if  ((sig.len() as i64) > 0) == false {
        newTC.is_empty = true;
      }
      return newTC.clone();
    }
    return tc.unwrap().clone();
  }
  pub fn new_scalar_signature(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerTypeClass {
    let sig : String = TFactory::baseSignature(node.clone());
    let mut tc : Option<RangerTypeClass> = ctx.getTypeClass(sig.clone());
    if  tc.is_none() {
      let mut newTC : RangerTypeClass = ctx.addTypeClass(sig.clone());
      newTC.is_primitive = true;
      newTC.value_type = node.value_type;
      newTC.name = sig.clone();
      return newTC.clone();
    }
    return tc.unwrap().clone();
  }
  pub fn type_annotation(mut node : CodeNode) -> String {
    if  node.has_type_annotation {
      return format!("{}{}", (format!("{}{}", "@(".to_string(), TFactory::baseSignature(((*node.type_annotation.clone().unwrap()))))), ")".to_string()).clone();
    }
    return "".to_string().clone();
  }
  pub fn lambdaSignature(mut node : CodeNode) -> String {
    let mut fnNode : CodeNode = node.getFirst();
    let mut argNode : CodeNode = node.getSecond();
    let mut s : String = "".to_string();
    s = format!("{}{}", (format!("{}{}", s, "(_:".to_string())), TFactory::baseSignature(fnNode.clone()));
    s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, " (".to_string())), (operatorsOf::map_47(argNode.children, (item, index) => { 
      return format!("{}{}", "_:".to_string(), TFactory::baseSignature(item.clone())).clone();
    }
    ).join(" ".to_string())))), "))".to_string());
    return s.clone();
  }
  pub fn baseSignature(mut node : CodeNode) -> String {
    if  TTypes::isPrimitive(node.value_type) {
      return TTypes::valueAsString(node.value_type).clone();
    }
    let mut s : String = "".to_string();
    if  node.value_type == 6 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, node.array_type);
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    if  node.value_type == 7 {
      s = format!("{}{}", s, "[".to_string());
      s = format!("{}{}", s, node.key_type);
      s = format!("{}{}", s, ":".to_string());
      s = format!("{}{}", s, node.array_type);
      s = format!("{}{}", s, "]".to_string());
      return s.clone();
    }
    if  node.value_type == 17 {
      let mut fnNode : CodeNode = node.expression_value.getFirst();
      let mut argNode : CodeNode = node.expression_value.getSecond();
      s = format!("{}{}", (format!("{}{}", s, "(_:".to_string())), TFactory::baseSignature(fnNode.clone()));
      s = format!("{}{}", (format!("{}{}", (format!("{}{}", s, " (".to_string())), (operatorsOf::map_47(argNode.children, (item, index) => { 
        return format!("{}{}", "_:".to_string(), TFactory::baseSignature(item.clone())).clone();
      }
      ).join(" ".to_string())))), "))".to_string());
      return s.clone();
    }
    s = format!("{}{}", node.type_name, TFactory::type_annotation(node.clone()));
    return s.clone();
  }
}
#[derive(Clone)]
struct CallChain { 
  methodName : String, 
  method : Option<CodeNode>, 
  args : Option<CodeNode>, 
}
impl CallChain { 
  
  pub fn new() ->  CallChain {
    let mut me = CallChain { 
      methodName:"".to_string(), 
      method: None, 
      args: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct NodeEvalState { 
  ctx : Option<RangerAppWriterContext>, 
  is_running : bool, 
  child_index : i64, 
  cmd_index : i64, 
  is_ready : bool, 
  is_waiting : bool, 
  exit_after : bool, 
  expand_args : bool, 
  ask_expand : bool, 
  eval_rest : bool, 
  exec_cnt : i64, 
  b_debugger : bool, 
  b_top_node : bool, 
  ask_eval : bool, 
  param_eval_on : bool, 
  eval_index : i64, 
  eval_end_index : i64, 
  ask_eval_start : i64, 
  ask_eval_end : i64, 
  evaluating_cmd : Option<CodeNode>, 
}
impl NodeEvalState { 
  
  pub fn new() ->  NodeEvalState {
    let mut me = NodeEvalState { 
      ctx: None, 
      is_running:false, 
      child_index:-1, 
      cmd_index:-1, 
      is_ready:false, 
      is_waiting:false, 
      exit_after:false, 
      expand_args:false, 
      ask_expand:false, 
      eval_rest:false, 
      exec_cnt:0, 
      b_debugger:false, 
      b_top_node:false, 
      ask_eval:false, 
      param_eval_on:false, 
      eval_index:-1, 
      eval_end_index:-1, 
      ask_eval_start:0, 
      ask_eval_end:0, 
      evaluating_cmd: None, 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerGenericClassWriter { 
  compiler : Option<LiveCompiler>, 
  compFlags : HashMap<String,bool>, 
}
impl RangerGenericClassWriter { 
  
  pub fn new() ->  RangerGenericClassWriter {
    let mut me = RangerGenericClassWriter { 
      compiler: None, 
      compFlags: None, 
    };
    return me;
  }
  fn lineEnding(&mut self, ) -> String {
    return "".to_string().clone();
  }
  fn addSystemImport(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  cl.is_system {
      let langName : String = operatorsOf_21::getTargetLang_22(ctx.clone());
      if  cl.systemNodes.contains_key(&langName) {
        let mut sNode : CodeNode = (cl.systemNodes.get(langName)).unwrap();
        if  ((sNode.children.len() as i64)) > 2 {
          let mut impDefs : CodeNode = sNode.children[2 as usize].clone();
          impDefs.forTree((item, i) => { 
            if  item.isFirstVref("imp".to_string()) {
              let mut name : CodeNode = item.getSecond();
              wr.addImport(name.string_value.clone());
            }
          }
          );
        }
      }
    }
  }
  fn EncodeString(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> String {
    /** unused:  let encoded_str : String = "".to_string();   **/ 
    let str_length : i64 = node.string_value.len() as i64;
    let mut encoded_str_2 : String = "".to_string();
    let mut ii : i64 = 0;
    while ii < str_length {
      let cc : i64 = node.string_value.chars().nth(ii as usize).unwrap_or('\0') as i64;
      switch (cc ) { 
        case 8 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(98)));
          break;
        case 9 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(116)));
          break;
        case 10 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(110)));
          break;
        case 12 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(102)));
          break;
        case 13 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(114)));
          break;
        case 34 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(34)));
          break;
        case 92 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(92)));
          break;
        default: 
          encoded_str_2 = format!("{}{}", encoded_str_2, (String.fromCharCode(cc)));
          break;
      }
      ii = ii + 1;
    }
    return encoded_str_2.clone();
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn WriteSetterVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn writeArrayTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn WriteEnum(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      let rootObjName : String = node.ns[0 as usize].clone();
      let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
      if  e.is_some() {
        let enumName : String = node.ns[1 as usize].clone();
        wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
      } else {
        if  node.hasParamDesc {
          let mut pp : Option<RangerAppParamDesc> = node.paramDesc;
          let mut nn : Option<CodeNode> = pp.nameNode;
          self.WriteVRef(nn.unwrap(), ctx.clone(), wr.clone());
        }
      }
    }
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        let dd_str : String = ["".to_string() , (node.double_value.to_string()) ].join("");
        let ii_str : String = ["".to_string() , ((node.double_value as i64 ).to_string()) ].join("");
        if  dd_str == ii_str {
          wr.out(format!("{}{}", (["".to_string() , (node.double_value.to_string()) ].join("")), ".0".to_string()), false);
        } else {
          wr.out(["".to_string() , (node.double_value.to_string()) ].join(""), false);
        }
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    return type_string.clone();
  }
  fn import_lib(&mut self, lib_name : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.addImport(lib_name.clone());
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Integer".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "byte[]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn release_local_vars(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..ctx.localVarNames.len() {
      let mut n = ctx.localVarNames[i as usize].clone();
      let mut p : Option<RangerAppParamDesc> = ctx.localVariables.get(n);
      if  p.ref_cnt == 0 {
        continue;
      }
      if  p.isAllocatedType() {
        if  1 == p.getStrength() {
          if  p.nameNode.eval_type == 7 {
          }
          if  p.nameNode.eval_type == 6 {
          }
          if  (p.nameNode.eval_type != 6) && (p.nameNode.eval_type != 7) {
          }
        }
        if  0 == p.getStrength() {
          if  p.nameNode.eval_type == 7 {
          }
          if  p.nameNode.eval_type == 6 {
          }
          if  (p.nameNode.eval_type != 6) && (p.nameNode.eval_type != 7) {
          }
        }
      }
    }
    if  ctx.is_function {
      return;
    }
    if  ctx.parent.is_some() {
      self.release_local_vars(node.clone(), (*ctx.parent.clone().unwrap()), wr.clone());
    }
  }
  fn WalkNode(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  item.evalCtx.is_some() {
        if  operatorsOf_21::getTargetLang_22((item.evalCtx.clone().unwrap())) != operatorsOf_21::getTargetLang_22(ctx.clone()) {
          item.evalCtx.targetLangName = operatorsOf_21::getTargetLang_22(ctx.clone());
        }
      }
    }
    );
    if  node.evalCtx.is_some() {
      self.compiler.WalkNode(node.clone(), node.evalCtx.clone().unwrap(), wr.clone());
    } else {
      self.compiler.WalkNode(node.clone(), ctx.clone(), wr.clone());
    }
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out(node.type_name.clone(), false);
  }
  fn writeRawTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.writeTypeDef(node.clone(), ctx.clone(), wr.clone());
  }
  fn adjustType(&mut self, tn : String) -> String {
    return tn.clone();
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
      }
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      wr.out(self.adjustType(part.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut p : Option<RangerAppParamDesc> = node.paramDesc;
      if  p.set_cnt > 0 {
        wr.out(format!("{}{}", "var ".to_string(), p.name), false);
      } else {
        wr.out(format!("{}{}", "const ".to_string(), p.name), false);
      }
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        wr.out(";".to_string(), true);
      } else {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(").".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      let mut pms : Vec<CodeNode> = operatorsOf::filter_36(args.children, (item, index) => { 
        if  item.hasFlag("keyword".to_string()) {
          return false;
        }
        return true;
      }
      );
      for i in 0..pms.len() {
        let mut arg = pms[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn CreateMethodCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getFirst();
    let mut args : CodeNode = node.getSecond();
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    let mut pms : Vec<CodeNode> = operatorsOf::filter_36(args.children, (item, index) => { 
      if  item.hasFlag("keyword".to_string()) {
        return false;
      }
      return true;
    }
    );
    for i in 0..pms.len() {
      let mut arg = pms[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
  }
  fn CreatePropertyGet(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getSecond();
    let mut prop : CodeNode = node.getThird();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out(").".to_string(), false);
    self.WalkNode(prop.clone(), ctx.clone(), wr.clone());
  }
  fn isPackaged(&mut self, mut ctx : RangerAppWriterContext) -> bool {
    let package_name : String = ctx.getCompilerSetting("package".to_string());
    if  (package_name.len() as i64) > 0 {
      return true;
    }
    return false;
  }
  fn CreateUnions(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
  }
  fn CreateServices(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
  }
  fn CreatePages(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
  }
  fn CreatePage(&mut self, mut parser : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    ctx.addError(node.clone(), "CreatePage not implemented for the build target".to_string());
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    ctx.unsetInExpr();
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.flow_done == false {
        self.compiler.parser.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    wr.out(" => { ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      ctx.setInExpr();
      let mut cnt : i64 = 0;
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  arg.nameNode.hasFlag("keyword".to_string()) {
          continue;
        }
        if  cnt > 0 {
          wr.out(", ".to_string(), false);
        }
        cnt = cnt + 1;
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ((node.methodChain.len() as i64)) > 0 {
        for i_1 in 0..node.methodChain.len() {
          let mut cc = node.methodChain[i_1 as usize].clone();
          wr.out(format!("{}{}", ".".to_string(), cc.methodName), false);
          wr.out("(".to_string(), false);
          ctx.setInExpr();
          for i_2 in 0..cc.args.children.len() {
            let mut arg_1 = cc.args.children[i_2 as usize].clone();
            if  i_2 > 0 {
              wr.out(", ".to_string(), false);
            }
            self.WalkNode(arg_1.clone(), ctx.clone(), wr.clone());
          }
          ctx.unsetInExpr();
          wr.out(")".to_string(), false);
        }
      }
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(format!("{}{}", "new ".to_string(), node.clDesc.name), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn writeInterface(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn disabledVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("[".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("]".to_string(), false);
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    wr.out(format!("{}{}", (format!("{}{}", "class ".to_string(), cl.name)), " { ".to_string()), true);
    wr.indent(1);
    for i in 0..cl.variables.len() {
      let mut pvar = cl.variables[i as usize].clone();
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "/* var ".to_string(), pvar.name)), " => ".to_string())), pvar.nameNode.parent.getCode())), " */ ".to_string()), true);
    }
    for i_1 in 0..cl.static_methods.len() {
      let mut pvar_1 = cl.static_methods[i_1 as usize].clone();
      wr.out(format!("{}{}", (format!("{}{}", "/* static ".to_string(), pvar_1.name)), " */ ".to_string()), true);
    }
    for i_2 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_2 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_3 in 0..mVs.variants.len() {
        let mut variant = mVs.variants[i_3 as usize].clone();
        wr.out(format!("{}{}", (format!("{}{}", "function ".to_string(), variant.name)), "() {".to_string()), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx : RangerAppWriterContext = ctx.fork();
        self.WalkNode(variant.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct AndroidPageWriter { 
  classWriter : Option<RangerGenericClassWriter>, 
}
impl AndroidPageWriter { 
  
  pub fn new() ->  AndroidPageWriter {
    let mut me = AndroidPageWriter { 
      classWriter: None, 
    };
    return me;
  }
  fn BuildAST(&mut self, code_string : String) -> CodeNode {
    let mut lang_code : SourceCode = SourceCode::new(code_string.clone());
    lang_code.filename = "<AST>".to_string();
    let mut lang_parser : RangerLispParser = RangerLispParser::new(lang_code.clone());
    lang_parser.parse(false);
    let mut node : CodeNode = lang_parser.rootNode.clone().unwrap();
    return node.clone();
  }
  fn CreatePage(&mut self, mut parser : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut sc : CodeNode = node.getSecond();
    let pageName : String = sc.vref.clone();
    let mut wr : CodeWriter = orig_wr.getFileWriter(".".to_string(), (format!("{}{}", pageName, ".java".to_string())));
    wr.out("// created by AndroidPageWriter ".to_string(), true);
    let package_name : String = ctx.getCompilerSetting("package".to_string());
    if  (package_name.len() as i64) > 0 {
      wr.out(format!("{}{}", (format!("{}{}", "package ".to_string(), package_name)), ";".to_string()), true);
    }
    let mut importFork : CodeWriter = wr.fork();
    self.self.classWriter.import_lib("android.content.Context".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.support.v7.app.AppCompatActivity".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.widget.LinearLayout".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.view.LayoutInflater".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.os.Bundle".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.support.v4.app.Fragment".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.view.ViewGroup".to_string(), ctx.clone(), wr.clone());
    self.self.classWriter.import_lib("android.view.View".to_string(), ctx.clone(), wr.clone());
    let package_name_2 : String = ctx.getCompilerSetting("package".to_string());
    if  self.self.classWriter.isPackaged(ctx.clone()) {
      self.self.classWriter.import_lib(format!("{}{}", package_name_2, ".interfaces.*".to_string()), ctx.clone(), wr.clone());
      self.self.classWriter.import_lib(format!("{}{}", package_name_2, ".operators.*".to_string()), ctx.clone(), wr.clone());
      self.self.classWriter.import_lib(format!("{}{}", package_name_2, ".immutables.*".to_string()), ctx.clone(), wr.clone());
    }
    wr.out(format!("{}{}", (format!("{}{}", "public class ".to_string(), pageName)), " extends Fragment  {".to_string()), true);
    wr.indent(1);
    wr.out("public JinxProcess mainProcess; ".to_string(), true);
    wr.out("@Override ".to_string(), true);
    wr.out("public void onDestroyView() { ".to_string(), true);
    wr.indent(1);
    wr.out("super.onDestroyView(); ".to_string(), true);
    wr.out("if( mainProcess != null) mainProcess.abort();".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out("@Override".to_string(), true);
    wr.out("public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {".to_string(), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", "final View view = inflater.inflate(R.layout.activity_".to_string(), pageName)), ", container, false);".to_string()), true);
    let mut fnBody : CodeNode = node.children[2 as usize].clone();
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    subCtx.is_function = true;
    subCtx.in_static_method = true;
    subCtx.setInMethod();
    let mut rootCtx : RangerAppWriterContext = subCtx.getRoot();
    let errCnt : i64 = (rootCtx.compilerErrors.len() as i64);
    let mut copyOf : CodeNode = fnBody.copy();
    parser.WalkNodeChildren(fnBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInMethod();
    subCtx.in_static_method = false;
    subCtx.function_level_context = true;
    let errCnt2 : i64 = (rootCtx.compilerErrors.len() as i64);
    let mut cnt : i64 = errCnt2 - errCnt;
    while cnt > 0 {
      rootCtx.compilerErrors.pop();
      cnt = cnt - 1;
    }
    let mut preBody : CodeNode = fnBody.newExpressionNode();
    let mut mainBody : CodeNode = fnBody.newExpressionNode();
    let mut newBody : CodeNode = fnBody.newExpressionNode();
    let mut stdCode : CodeNode = fnBody.newExpressionNode();
    let mut stdBody : CodeNode = fnBody.newExpressionNode();
    let mut in_stdCode : bool = false;
    let mut pushed_std : bool = false;
    let mut first_lines : bool = true;
    let mut pRef : CodeNode = fnBody.newVRefNode("process".to_string());
    let mut pName : CodeNode = fnBody.newStringNode(pageName.clone());
    newBody.children.push(pRef.clone());
    newBody.children.push(pName.clone());
    if  pageName != "notme".to_string() {
      operatorsOf::forEach_15(fnBody.children, (item, index) => { 
        if  item.isFirstVref("ui".to_string()) || (item.eval_type_name == "JinxProcess".to_string()) {
          if  in_stdCode {
            newBody.children.push(stdCode.clone());
            in_stdCode = false;
          }
          first_lines = false;
        }
        if  item.isFirstVref("ui".to_string()) {
          first_lines = false;
          let mut taskNode : CodeNode = copyOf.children[index as usize].clone();
          let mut codeToRun : CodeNode = taskNode.getSecond();
          let mut uiNode : CodeNode = CodeNode::op2("task.call".to_string(), CodeNode::blockFromList([CodeNode::op3("def".to_string(), [CodeNode::vref1("uictx".to_string()), CodeNode::op2("unwrap".to_string(), CodeNode::op3("get".to_string(), [CodeNode::vref1("ctx.anyValues".to_string()), CodeNode::newStr("uicontext".to_string())]))]), CodeNode::op2("print".to_string(), CodeNode::newStr("after this should be ui_thread".to_string())), CodeNode::op3("case".to_string(), [CodeNode::vref1("uictx".to_string()), CodeNode::vref2("c".to_string(), "UIContextHandle".to_string()), CodeNode::blockFromList([CodeNode::op3("ui_thread".to_string(), [CodeNode::vref1("c".to_string()), codeToRun])])])]));
          newBody.children.push(uiNode.clone());
          return;
        }
        if  item.eval_type_name == "JinxProcess".to_string() {
          let mut taskNode_1 : CodeNode = copyOf.children[index as usize].clone();
          newBody.children.push(taskNode_1.clone());
        } else {
          if  first_lines {
            let mut tt : CodeNode = copyOf.children[index as usize].clone();
            preBody.children.push(tt.clone());
          } else {
            if  in_stdCode == false {
              stdCode = fnBody.newExpressionNode();
              stdCode.children.push(fnBody.newVRefNode("task.call".to_string()));
              let mut callBody : CodeNode = fnBody.newExpressionNode();
              callBody.is_block_node = true;
              let mut tryC : CodeNode = fnBody.newExpressionNode();
              let mut catchC : CodeNode = fnBody.newExpressionNode();
              catchC.is_block_node = true;
              tryC.children.push(fnBody.newVRefNode("try".to_string()));
              stdBody = fnBody.newExpressionNode();
              stdBody.is_block_node = true;
              tryC.children.push(stdBody.clone());
              tryC.children.push(catchC.clone());
              callBody.children.push(tryC.clone());
              stdCode.children.push(callBody.clone());
              in_stdCode = true;
              pushed_std = false;
            }
            let mut taskNode_2 : CodeNode = copyOf.children[index as usize].clone();
            stdBody.children.push(taskNode_2.clone());
          }
        }
      }
      );
    }
    if  in_stdCode {
      newBody.children.push(stdCode.clone());
    }
    let mut ast : CodeNode = self.BuildAST("\r\n def ctx (new JinxProcessCtx)\r\n ctx.anyValues = (set ctx.anyValues \"view\" view)\r\n ctx.anyValues = (set ctx.anyValues \"uicontext\" (getUIContext))\r\n ctx.anyValues = (set ctx.anyValues \"process\" mainProcess)\r\n mainProcess.start(ctx)\r\n      ".to_string());
    operatorsOf::forEach_15(ast.children, (item, index) => { 
      let mut n : CodeNode = item;
      mainBody.children.push(n.clone());
    }
    );
    let mut mainPN : CodeNode = fnBody.newVRefNode("mainProcess".to_string());
    mainPN.type_name = "JinxProcess".to_string();
    let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
    p.name = "mainProcess".to_string();
    p.compiledName = "mainProcess".to_string();
    p.value_type = 11;
    p.node = Some(mainPN.clone());
    p.nameNode = Some(mainPN.clone());
    p.is_optional = false;
    p.init_cnt = 1;
    subCtx.defineVariable(p.name.clone(), p.clone());
    let mut mainPN_2 : CodeNode = fnBody.newVRefNode("view".to_string());
    mainPN_2.type_name = "View".to_string();
    let mut p_2 : RangerAppParamDesc = RangerAppParamDesc::new();
    p_2.name = "view".to_string();
    p_2.compiledName = "view".to_string();
    p_2.value_type = 11;
    p_2.node = Some(mainPN_2.clone());
    p_2.nameNode = Some(mainPN_2.clone());
    p_2.is_optional = false;
    p_2.init_cnt = 1;
    subCtx.defineVariable(p_2.name.clone(), p_2.clone());
    let mut mainPN_3 : CodeNode = fnBody.newVRefNode("ctx".to_string());
    mainPN_3.type_name = "JinxProcessCtx".to_string();
    let mut p_3 : RangerAppParamDesc = RangerAppParamDesc::new();
    p_3.name = "ctx".to_string();
    p_3.compiledName = "ctx".to_string();
    p_3.value_type = 11;
    p_3.node = Some(mainPN_3.clone());
    p_3.nameNode = Some(mainPN_3.clone());
    p_3.is_optional = false;
    p_3.init_cnt = 1;
    subCtx.defineVariable(p_3.name.clone(), p_3.clone());
    subCtx.is_function = true;
    subCtx.in_static_method = true;
    subCtx.setInMethod();
    parser.WalkNode(preBody.clone(), subCtx.clone(), wr.clone());
    parser.WalkNode(newBody.clone(), subCtx.clone(), wr.clone());
    parser.WalkNode(mainBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInMethod();
    subCtx.in_static_method = false;
    subCtx.function_level_context = true;
    self.self.classWriter.WalkNode(preBody.clone(), subCtx.clone(), wr.clone());
    wr.out("mainProcess = (".to_string(), false);
    subCtx.setInExpr();
    self.self.classWriter.WalkNode(newBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInExpr();
    wr.out(");".to_string(), true);
    self.self.classWriter.WalkNode(mainBody.clone(), subCtx.clone(), wr.clone());
    wr.out("return view;".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    let mut import_list : Vec<String> = wr.getImports();
    for i in 0..import_list.len() {
      let mut codeStr = import_list[i as usize].clone();
      importFork.out(format!("{}{}", (format!("{}{}", "import ".to_string(), codeStr)), ";".to_string()), true);
    }
  }
}
#[derive(Clone)]
struct RangerJava7ClassWriter { 
  compiler : Option<LiveCompiler>, 
  signatures : HashMap<String,i64>, 
  signature_cnt : i64, 
  iface_created : HashMap<String,bool>, 
}
impl RangerJava7ClassWriter { 
  
  pub fn new() ->  RangerJava7ClassWriter {
    let mut me = RangerJava7ClassWriter { 
      compiler: None, 
      signatures: None, 
      signature_cnt:0, 
      iface_created: None, 
    };
    return me;
  }
  fn getSignatureInterface(&mut self, s : String) -> String {
    let idx : Option<i64> = self.signatures.get(s);
    if  idx.is_some() {
      return ["LambdaSignature".to_string() , ((idx.unwrap()).to_string()) ].join("").clone();
    }
    self.signature_cnt = self.signature_cnt + 1;
    self.signatures.insert(s, self.signature_cnt);
    return ["LambdaSignature".to_string() , (self.signature_cnt.to_string()) ].join("").clone();
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString2(&mut self, type_string : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Integer".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "byte[]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_system {
        /** unused:  let mut current_sys : RangerAppWriterContext = ctx;   **/ 
        let sName : String = (cc.systemNames.get("java7".to_string())).unwrap();
        self.addSystemImport(cc.clone(), ctx.clone(), wr.clone());
        return sName.clone();
      }
      if  cc.is_union {
        return "Object".to_string().clone();
      }
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Integer".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "byte[]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    if  node.hasFlag("optional".to_string()) {
      switch (v_type ) { 
        case 17 : 
          let sig : String = self.buildLambdaSignature(((*node.expression_value.clone().unwrap())));
          let iface_name : String = self.getSignatureInterface(sig.clone());
          wr.out(iface_name.clone(), false);
          if  self.isPackaged(ctx.clone()) {
            let package_name : String = ctx.getCompilerSetting("package".to_string());
            wr.addImport(format!("{}{}", package_name, ".interfaces.*".to_string()));
          }
          if  (self.iface_created.contains_key(&iface_name)) == false {
            let mut fnNode : CodeNode = node.expression_value.children[0 as usize].clone();
            let mut args : CodeNode = node.expression_value.children[1 as usize].clone();
            self.iface_created.insert(iface_name, true);
            let mut iface_dir : String = ".".to_string();
            if  self.isPackaged(ctx.clone()) {
              iface_dir = "./interfaces/".to_string();
            }
            let mut utilWr : CodeWriter = wr.getFileWriter(iface_dir.clone(), (format!("{}{}", iface_name, ".java".to_string())));
            if  self.isPackaged(ctx.clone()) {
              let package_name_1 : String = ctx.getCompilerSetting("package".to_string());
              if  (package_name_1.len() as i64) > 0 {
                utilWr.out(format!("{}{}", (format!("{}{}", "package ".to_string(), package_name_1)), ".interfaces;".to_string()), true);
                utilWr.out(format!("{}{}", (format!("{}{}", "import ".to_string(), package_name_1)), ".*;".to_string()), true);
              }
            }
            let mut importFork : CodeWriter = utilWr.fork();
            utilWr.out(format!("{}{}", (format!("{}{}", "public interface ".to_string(), iface_name)), " { ".to_string()), true);
            utilWr.indent(1);
            utilWr.out("public ".to_string(), false);
            self.writeTypeDef(fnNode.clone(), ctx.clone(), utilWr.clone());
            utilWr.out(" run(".to_string(), false);
            for i in 0..args.children.len() {
              let mut arg = args.children[i as usize].clone();
              if  i > 0 {
                utilWr.out(", ".to_string(), false);
              }
              utilWr.out(" final ".to_string(), false);
              self.writeTypeDef(arg.clone(), ctx.clone(), utilWr.clone());
              utilWr.out(" ".to_string(), false);
              utilWr.out(arg.vref.clone(), false);
            }
            utilWr.out(");".to_string(), true);
            utilWr.indent(-1);
            utilWr.out("}".to_string(), true);
            operatorsOf::forEach_12(utilWr.getImports(), (item, index) => { 
              importFork.out(format!("{}{}", (format!("{}{}", "import ".to_string(), item)), ";".to_string()), true);
            }
            );
          }
          break;
        case 13 : 
          wr.out("Integer".to_string(), false);
          break;
        case 3 : 
          wr.out("Integer".to_string(), false);
          break;
        case 2 : 
          wr.out("Double".to_string(), false);
          break;
        case 4 : 
          wr.out("String".to_string(), false);
          break;
        case 5 : 
          wr.out("Boolean".to_string(), false);
          break;
        case 14 : 
          wr.out("byte".to_string(), false);
          break;
        case 15 : 
          wr.out("byte[]".to_string(), false);
          break;
        case 7 : 
          wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "HashMap<".to_string(), self.getObjectTypeString2(k_name.clone(), ctx.clone(), wr.clone()))), ",".to_string())), self.getObjectTypeString2(a_name.clone(), ctx.clone(), wr.clone()))), ">".to_string()), false);
          wr.addImport("java.util.*".to_string());
          break;
        case 6 : 
          wr.out(format!("{}{}", (format!("{}{}", "ArrayList<".to_string(), self.getObjectTypeString2(a_name.clone(), ctx.clone(), wr.clone()))), ">".to_string()), false);
          wr.addImport("java.util.*".to_string());
          break;
        default: 
          if  t_name == "void".to_string() {
            wr.out("void".to_string(), false);
          } else {
            wr.out(self.getObjectTypeString2(t_name.clone(), ctx.clone(), wr.clone()), false);
          }
          if  ctx.isDefinedClass(t_name.clone()) {
            let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
            if  cc.is_system {
              self.addSystemImport(cc.clone(), ctx.clone(), wr.clone());
            }
          }
          break;
      }
    } else {
      switch (v_type ) { 
        case 17 : 
          let sig_1 : String = self.buildLambdaSignature(((*node.expression_value.clone().unwrap())));
          let iface_name_1 : String = self.getSignatureInterface(sig_1.clone());
          wr.out(iface_name_1.clone(), false);
          /** unused:  let package_name_2 : String = ctx.getCompilerSetting("package".to_string());   **/ 
          if  (self.iface_created.contains_key(&iface_name_1)) == false {
            let mut fnNode_1 : CodeNode = node.expression_value.children[0 as usize].clone();
            let mut args_1 : CodeNode = node.expression_value.children[1 as usize].clone();
            self.iface_created.insert(iface_name_1, true);
            let mut iface_dir_1 : String = ".".to_string();
            if  self.isPackaged(ctx.clone()) {
              iface_dir_1 = "./interfaces/".to_string();
            }
            let mut utilWr_1 : CodeWriter = wr.getFileWriter(iface_dir_1.clone(), (format!("{}{}", iface_name_1, ".java".to_string())));
            if  self.isPackaged(ctx.clone()) {
              let package_name_3 : String = ctx.getCompilerSetting("package".to_string());
              if  (package_name_3.len() as i64) > 0 {
                utilWr_1.out(format!("{}{}", (format!("{}{}", "package ".to_string(), package_name_3)), ".interfaces;".to_string()), true);
                utilWr_1.out(format!("{}{}", (format!("{}{}", "import ".to_string(), package_name_3)), ".*;".to_string()), true);
              }
            }
            let mut importFork_1 : CodeWriter = utilWr_1.fork();
            utilWr_1.out(format!("{}{}", (format!("{}{}", "public interface ".to_string(), iface_name_1)), " { ".to_string()), true);
            utilWr_1.indent(1);
            utilWr_1.out("public ".to_string(), false);
            self.writeTypeDef(fnNode_1.clone(), ctx.clone(), utilWr_1.clone());
            utilWr_1.out(" run(".to_string(), false);
            for i_1 in 0..args_1.children.len() {
              let mut arg_1 = args_1.children[i_1 as usize].clone();
              if  i_1 > 0 {
                utilWr_1.out(", ".to_string(), false);
              }
              utilWr_1.out(" final ".to_string(), false);
              self.writeTypeDef(arg_1.clone(), ctx.clone(), utilWr_1.clone());
              utilWr_1.out(" ".to_string(), false);
              utilWr_1.out(arg_1.vref.clone(), false);
            }
            utilWr_1.out(");".to_string(), true);
            utilWr_1.indent(-1);
            utilWr_1.out("}".to_string(), true);
            operatorsOf::forEach_12(utilWr_1.getImports(), (item, index) => { 
              importFork_1.out(format!("{}{}", (format!("{}{}", "import ".to_string(), item)), ";".to_string()), true);
            }
            );
          }
          break;
        case 13 : 
          wr.out("Integer".to_string(), false);
          break;
        case 3 : 
          wr.out("Integer".to_string(), false);
          break;
        case 2 : 
          wr.out("Double".to_string(), false);
          break;
        case 14 : 
          wr.out("byte".to_string(), false);
          break;
        case 15 : 
          wr.out("byte[]".to_string(), false);
          break;
        case 4 : 
          wr.out("String".to_string(), false);
          break;
        case 5 : 
          wr.out("Boolean".to_string(), false);
          break;
        case 7 : 
          wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "HashMap<".to_string(), self.getObjectTypeString2(k_name.clone(), ctx.clone(), wr.clone()))), ",".to_string())), self.getObjectTypeString2(a_name.clone(), ctx.clone(), wr.clone()))), ">".to_string()), false);
          wr.addImport("java.util.*".to_string());
          break;
        case 6 : 
          wr.out(format!("{}{}", (format!("{}{}", "ArrayList<".to_string(), self.getObjectTypeString2(a_name.clone(), ctx.clone(), wr.clone()))), ">".to_string()), false);
          wr.addImport("java.util.*".to_string());
          break;
        default: 
          let mut b_object_set : bool = false;
          if  ctx.isDefinedClass(t_name.clone()) {
            let mut cc_1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
            if  cc_1.is_union {
              wr.out("Object".to_string(), false);
              b_object_set = true;
            }
            if  cc_1.is_system {
              self.addSystemImport(cc_1.clone(), ctx.clone(), wr.clone());
              let sName : String = (cc_1.systemNames.get("java7".to_string())).unwrap();
              wr.out(sName.clone(), false);
              return;
            }
          }
          if  b_object_set == false {
            if  t_name == "void".to_string() {
              wr.out("void".to_string(), false);
            } else {
              wr.out(self.getTypeString(t_name.clone()), false);
            }
          }
          break;
      }
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      if  ctx.inLambda() {
        let mut currC : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        wr.out(format!("{}{}", currC.name, ".this".to_string()), false);
      } else {
        wr.out("this".to_string(), false);
      }
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    let max_len : i64 = (node.ns.len() as i64);
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let mut p_captured_mutable : bool = ((p.set_cnt > 0) && p.is_captured) && (p.is_class_variable == false);
          if  (p.nameNode.value_type == 7) || (p.nameNode.value_type == 6) {
            p_captured_mutable = false;
          }
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            if  ctx.inLambda() {
              let mut currC_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
              wr.out(format!("{}{}", currC_1.name, ".this".to_string()), false);
            } else {
              let mut currC_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
              wr.out(format!("{}{}", currC_2.name, ".this".to_string()), false);
            }
            continue;
          }
          if  p_captured_mutable {
            wr.out("[0]".to_string(), false);
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  i < (max_len - 1) {
          if  p.nameNode.hasFlag("optional".to_string()) {
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      let mut p_captured_mutable_1 : bool = ((p_1.set_cnt > 0) && p_1.is_captured) && (p_1.is_class_variable == false);
      if  (p_1.nameNode.value_type == 7) || (p_1.nameNode.value_type == 6) {
        p_captured_mutable_1 = false;
      }
      if  p_captured_mutable_1 {
        wr.out("[0]".to_string(), false);
      }
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_1 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      if  part_1 == "this".to_string() {
        if  ctx.inLambda() {
          let mut currC_3 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          wr.out(format!("{}{}", currC_3.name, ".this".to_string()), false);
          continue;
        }
      }
      wr.out(self.adjustType(part_1.clone()), false);
    }
  }
  fn disabledVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        let mut b_was_set : bool = false;
        if  nn.value_type == 6 {
          wr.out(" = new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
          b_was_set = true;
        }
        if  nn.value_type == 7 {
          wr.out(" = new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
          b_was_set = true;
        }
        if  (b_was_set == false) && nn.hasFlag("optional".to_string()) {
          wr.out(" = null".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      let mut p_captured_mutable : bool = ((p.set_cnt > 0) && p.is_captured) && (p.is_class_variable == false);
      if  (nn.value_type == 7) || (nn.value_type == 6) {
        p_captured_mutable = false;
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.is_captured && (p.is_class_variable == false)) && ((nn.value_type == 7) || (nn.value_type == 6)) {
        wr.out("final ".to_string(), false);
      } else {
        if  (p_captured_mutable == false) && ((p.set_cnt > 0) || p.is_class_variable) {
          wr.out("".to_string(), false);
        } else {
          wr.out("final ".to_string(), false);
        }
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      if  p_captured_mutable {
        wr.out("[]".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        if  p_captured_mutable {
          wr.out(" new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("[]{".to_string(), false);
        }
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        if  p_captured_mutable {
          wr.out("}".to_string(), false);
        }
        ctx.unsetInExpr();
      } else {
        if  p_captured_mutable {
          wr.out(" = new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("[]{ null }".to_string(), false);
        } else {
          let mut b_was_set : bool = false;
          if  nn.value_type == 6 {
            wr.out(" = new ".to_string(), false);
            self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            wr.out("()".to_string(), false);
            b_was_set = true;
          }
          if  nn.value_type == 7 {
            wr.out(" = new ".to_string(), false);
            self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            wr.out("()".to_string(), false);
            b_was_set = true;
          }
          if  (b_was_set == false) && nn.hasFlag("optional".to_string()) {
            wr.out(" = null".to_string(), false);
          }
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" final ".to_string(), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), arg.compiledName)), " ".to_string()), false);
    }
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "return".to_string() {
      wr.newline();
      if  ((node.children.len() as i64)) > 1 {
        let mut value : CodeNode = node.getSecond();
        wr.out("return ".to_string(), false);
        ctx.setInExpr();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        wr.out(";".to_string(), true);
      } else {
        wr.out("return;".to_string(), true);
      }
    }
  }
  fn buildLambdaSignature(&mut self, mut node : CodeNode) -> String {
    let mut exp : CodeNode = node;
    let mut exp_s : String = "".to_string();
    let mut fc : CodeNode = exp.getFirst();
    let mut args : CodeNode = exp.getSecond();
    exp_s = format!("{}{}", exp_s, fc.buildTypeSignature());
    exp_s = format!("{}{}", exp_s, "(".to_string());
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      exp_s = format!("{}{}", exp_s, arg.buildTypeSignature());
      exp_s = format!("{}{}", exp_s, ",".to_string());
    }
    exp_s = format!("{}{}", exp_s, ")".to_string());
    return exp_s.clone();
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut rv : Option<CodeNode> = None;
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      rv = Some(fName.expression_value.children[0 as usize].clone());
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      rv = Some(param.nameNode.expression_value.children[0 as usize].clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out(".run(".to_string(), false);
    ctx.setInExpr();
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    if  ctx.expressionLevel() == 0 {
      wr.out(");".to_string(), true);
    } else {
      wr.out(")".to_string(), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.addImport("java.util.*".to_string());
    wr.out("new ArrayList<".to_string(), false);
    wr.out(self.getObjectTypeString2(node.eval_array_type.clone(), ctx.clone(), wr.clone()), false);
    wr.out(">(Arrays.asList( new ".to_string(), false);
    wr.out(self.getObjectTypeString2(node.eval_array_type.clone(), ctx.clone(), wr.clone()), false);
    wr.out("[] {".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("}))".to_string(), false);
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fnNode : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    let sig : String = self.buildLambdaSignature(node.clone());
    let iface_name : String = self.getSignatureInterface(sig.clone());
    /** unused:  let package_name : String = ctx.getCompilerSetting("package".to_string());   **/ 
    if  (self.iface_created.contains_key(&iface_name)) == false {
      self.iface_created.insert(iface_name, true);
      /** unused:  let mut utilWr : CodeWriter = wr.getFileWriter("./interfaces/".to_string(), (format!("{}{}", iface_name, ".java".to_string())));   **/ 
      let mut iface_dir : String = ".".to_string();
      if  self.isPackaged(ctx.clone()) {
        iface_dir = "./interfaces/".to_string();
      }
      let mut utilWr_1 : CodeWriter = wr.getFileWriter(iface_dir.clone(), (format!("{}{}", iface_name, ".java".to_string())));
      if  self.isPackaged(ctx.clone()) {
        let package_name_2 : String = ctx.getCompilerSetting("package".to_string());
        if  (package_name_2.len() as i64) > 0 {
          utilWr_1.out(format!("{}{}", (format!("{}{}", "package ".to_string(), package_name_2)), ".interfaces;".to_string()), true);
          utilWr_1.out(format!("{}{}", (format!("{}{}", "import ".to_string(), package_name_2)), ".*;".to_string()), true);
        }
      }
      let mut importFork : CodeWriter = utilWr_1.fork();
      utilWr_1.out(format!("{}{}", (format!("{}{}", "public interface ".to_string(), iface_name)), " { ".to_string()), true);
      utilWr_1.indent(1);
      utilWr_1.out("public ".to_string(), false);
      self.writeTypeDef(fnNode.clone(), ctx.clone(), utilWr_1.clone());
      utilWr_1.out(" run(".to_string(), false);
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          utilWr_1.out(", ".to_string(), false);
        }
        utilWr_1.out(" final ".to_string(), false);
        self.writeTypeDef(arg.clone(), lambdaCtx.clone(), utilWr_1.clone());
        utilWr_1.out(" ".to_string(), false);
        utilWr_1.out(arg.vref.clone(), false);
      }
      utilWr_1.out(");".to_string(), true);
      utilWr_1.indent(-1);
      utilWr_1.out("}".to_string(), true);
      operatorsOf::forEach_12(utilWr_1.getImports(), (item, index) => { 
        importFork.out(format!("{}{}", (format!("{}{}", "import ".to_string(), item)), ";".to_string()), true);
      }
      );
    }
    wr.out(format!("{}{}", (format!("{}{}", "new ".to_string(), iface_name)), "() { ".to_string()), true);
    wr.indent(1);
    wr.out("public ".to_string(), false);
    self.writeTypeDef(fnNode.clone(), ctx.clone(), wr.clone());
    wr.out(" run(".to_string(), false);
    for i_1 in 0..args.children.len() {
      let mut arg_1 = args.children[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(" final ".to_string(), false);
      self.writeTypeDef(arg_1.clone(), lambdaCtx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(arg_1.vref.clone(), false);
    }
    wr.out(") {".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    lambdaCtx.is_lambda = true;
    for i_2 in 0..body.children.len() {
      let mut item = body.children[i_2 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    for i_3 in 0..lambdaCtx.captured_variables.len() {
      let mut cname = lambdaCtx.captured_variables[i_3 as usize].clone();
      wr.out(format!("{}{}", "// captured var ".to_string(), cname), true);
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), false);
  }
  fn getCounters(&mut self, mut ctx : RangerAppWriterContext) -> TypeCounts {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    let mut counters : TypeCounts = root.counters;
    if  counters.b_counted == false {
      let list :  = keysroot.definedClasses;
      forlistnameiif==indexOfname"operatorsOf".to_string()0
      counters.operator_cnt = counters.operator_cnt + 1;
      if==indexOfname"Map_".to_string()0
      counters.immutable_cnt = counters.immutable_cnt + 1;
      if==indexOfname"Vector_".to_string()0
      counters.immutable_cnt = counters.immutable_cnt + 1;
    }
    counters.b_counted = true;
    return counters.clone();
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..pC.variables.len() {
          let mut pvar = pC.variables[i_1 as usize].clone();
          declaredVariable.insert(pvar.name, true);
        }
      }
    }
    let mut class_dir : String = ".".to_string();
    let mut package_end : String = "".to_string();
    if  self.isPackaged(ctx.clone()) {
      if==indexOfcl.name"operatorsOf".to_string()0
      class_dir = "./operators/".to_string();
      package_end = ".operators".to_string();
      if==indexOfcl.name"Map_".to_string()0
      class_dir = "./immutables/".to_string();
      package_end = ".immutables".to_string();
      if==indexOfcl.name"Vector_".to_string()0
      class_dir = "./immutables/".to_string();
      package_end = ".immutables".to_string();
    }
    let mut wr : CodeWriter = orig_wr.getFileWriter(class_dir.clone(), (format!("{}{}", cl.name, ".java".to_string())));
    let package_name : String = ctx.getCompilerSetting("package".to_string());
    if  self.isPackaged(ctx.clone()) {
      if  (package_name.len() as i64) > 0 {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", "package ".to_string(), package_name)), package_end)), ";".to_string()), true);
      }
    }
    let mut importFork : CodeWriter = wr.fork();
    if  self.isPackaged(ctx.clone()) {
      let mut counters : TypeCounts = self.getCounters(ctx.clone());
      if  counters.interface_cnt > 0 {
        importFork.addImport(format!("{}{}", package_name, ".interfaces.*".to_string()));
      }
      if  counters.immutable_cnt > 0 {
        importFork.addImport(format!("{}{}", package_name, ".immutables.*".to_string()));
      }
      if  counters.operator_cnt > 0 {
        importFork.addImport(format!("{}{}", package_name, ".operators.*".to_string()));
      }
      if  (package_end.len() as i64) > 0 {
        importFork.addImport(format!("{}{}", package_name, ".*".to_string()));
      }
    }
    for i_2 in 0..cl.capturedLocals.len() {
      let mut dd = cl.capturedLocals[i_2 as usize].clone();
      if  dd.is_class_variable == false {
        if  dd.set_cnt > 0 {
          if  ctx.hasCompilerFlag("allow-mutate".to_string()) {
          } else {
          }
        }
      }
    }
    wr.out("".to_string(), true);
    wr.out(format!("{}{}", "public class ".to_string(), cl.name), false);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" extends ".to_string(), false);
      for i_3 in 0..cl.extends_classes.len() {
        let mut pName_1 = cl.extends_classes[i_3 as usize].clone();
        wr.out(pName_1.clone(), false);
      }
    }
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    wr.createTag("utilities".to_string());
    for i_4 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_4 as usize].clone();
      if  declaredVariable.contains_key(&pvar_1.name) {
        continue;
      }
      wr.out("public ".to_string(), false);
      self.writeVarDef(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      wr.out("".to_string(), true);
      wr.out(format!("{}{}", cl.name, "(".to_string()), false);
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
      wr.out(" ) {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_5 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_5 as usize].clone();
      wr.out("".to_string(), true);
      if  variant.nameNode.hasFlag("main".to_string()) && (variant.nameNode.code.filename != ctx.getRootFile()) {
        continue;
      }
      if  variant.nameNode.hasFlag("main".to_string()) {
        ctx.setCompilerSetting("mainclass".to_string(), cl.name);
        wr.out("public static void main(String [] args ) {".to_string(), true);
      } else {
        wr.out("public static ".to_string(), false);
        self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant.compiledName, "(".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
      }
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_6 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_6 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_7 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_7 as usize].clone();
        wr.out("".to_string(), true);
        wr.out("public ".to_string(), false);
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant_1.compiledName, "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    let mut import_list : Vec<String> = wr.getImports();
    for i_8 in 0..import_list.len() {
      let mut codeStr = import_list[i_8 as usize].clone();
      importFork.out(format!("{}{}", (format!("{}{}", "import ".to_string(), codeStr)), ";".to_string()), true);
    }
  }
  fn CreateServices(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    return;
  }
  fn CreatePages(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    operatorsOf_13::forEach_25(ctx.appPages, (item, index) => { 
      self.CreatePage(parser.clone(), item.clone(), ctx.clone(), orig_wr.clone());
    }
    );
  }
  fn CreatePage(&mut self, mut parser : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut writer : AndroidPageWriter = AndroidPageWriter::new();
    writer.classWriter = Some(self);
    writer.CreatePage(parser.clone(), node.clone(), ctx.clone(), orig_wr.clone());
  }
}
#[derive(Clone)]
struct RangerSwift3ClassWriter { 
  compiler : Option<LiveCompiler>, 
  header_created : bool, 
}
impl RangerSwift3ClassWriter { 
  
  pub fn new() ->  RangerSwift3ClassWriter {
    let mut me = RangerSwift3ClassWriter { 
      compiler: None, 
      header_created:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "self".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "Any".to_string().clone();
      }
      if  cc.is_system {
        let sysName : Option<String> = cc.systemNames.get("swift3".to_string());
        if  sysName.is_some() {
          return sysName.unwrap().clone();
        } else {
          let mut node : CodeNode = CodeNode::new(SourceCode::new("".to_string()), 0, 0);
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), type_string)), "defined for Swift ".to_string()));
        }
      }
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[UInt8]".to_string().clone();
        break;
      case "char".to_string() : 
        return "UInt8".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[UInt8]".to_string().clone();
        break;
      case "char".to_string() : 
        return "UInt8".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        wr.out("(".to_string(), false);
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(" _ : ".to_string(), false);
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") -> ".to_string(), false);
        self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), false);
        break;
      case 13 : 
        wr.out("Int".to_string(), false);
        break;
      case 3 : 
        wr.out("Int".to_string(), false);
        break;
      case 2 : 
        wr.out("Double".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 14 : 
        wr.out("UInt8".to_string(), false);
        break;
      case 15 : 
        wr.out("[UInt8]".to_string(), false);
        break;
      case 5 : 
        wr.out("Bool".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), ":".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "[".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      default: 
        if  t_name == "void".to_string() {
          wr.out("Void".to_string(), false);
          return;
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_union {
            wr.out("Any".to_string(), false);
            if  node.hasFlag("optional".to_string()) {
              wr.out("?".to_string(), false);
            }
            return;
          }
          if  cc.is_system {
            let sysName : Option<String> = cc.systemNames.get("swift3".to_string());
            if  sysName.is_some() {
              wr.out(sysName.unwrap(), false);
            } else {
              ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), t_name)), "defined for Swift ".to_string()));
            }
            if  node.hasFlag("optional".to_string()) {
              wr.out("?".to_string(), false);
            }
            return;
          }
        }
        wr.out(self.getTypeString(t_name.clone()), false);
        break;
    }
    if  node.hasFlag("optional".to_string()) {
      wr.out("?".to_string(), false);
    }
  }
  fn WriteEnum(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      let rootObjName : String = node.ns[0 as usize].clone();
      let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
      if  e.is_some() {
        let enumName : String = node.ns[1 as usize].clone();
        wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
      } else {
        if  node.hasParamDesc {
          let mut pp : Option<RangerAppParamDesc> = node.paramDesc;
          let mut nn : Option<CodeNode> = pp.nameNode;
          wr.out(nn.vref.clone(), false);
        }
      }
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("self".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    let max_len : i64 = (node.ns.len() as i64);
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("self".to_string(), false);
            continue;
          }
          if  (part != "this".to_string()) && ctx.isMemberVariable(part.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out("self.".to_string(), false);
              }
            }
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  i < (max_len - 1) {
          if  p.nameNode.hasFlag("optional".to_string()) {
            wr.out("!".to_string(), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      let part_1 : String = node.ns[0 as usize].clone();
      if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_1.clone());
        if  up_1.is_some() {
          if  false == ctx.isInStatic() {
            wr.out("self.".to_string(), false);
          }
        }
      }
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_2 = node.ns[i_1 as usize].clone();
      if  i_1 == 0 {
        if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_2.clone());
          if  up_2.is_some() {
            if  false == ctx.isInStatic() {
              wr.out("self.".to_string(), false);
            }
          }
        }
        if  ctx.hasClass(part_2.clone()) {
          let mut classDesc : RangerAppClassDesc = ctx.findClass(part_2.clone());
          wr.out(classDesc.compiledName.clone(), false);
          continue;
        }
      }
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      wr.out(self.adjustType(part_2.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  nn.hasFlag("optional".to_string()) {
        if  ((p.set_cnt == 1) && (p.ref_cnt == 2)) && (p.is_class_variable == false) {
          ctx.addError(node.clone(), "Optional variable is only set but never read.".to_string());
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " : ".to_string()), false);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "let ".to_string(), p.compiledName)), " : ".to_string()), false);
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ".to_string(), true);
      } else {
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(format!("{}{}", arg.compiledName, " : ".to_string()), false);
      let mut nn : CodeNode = arg.nameNode.clone().unwrap();
      if  nn.value_type == 17 {
        wr.out("  @escaping  ".to_string(), false);
      }
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn writeArgsDefWithLocals(&mut self, mut fnDesc : RangerAppFunctionDesc, mut localFnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((fnDesc.params.len() as i64)) != ((localFnDesc.params.len() as i64)) {
      ctx.addError(localFnDesc.node.clone().unwrap(), "Parameter count does not match with the function prototype".to_string());
      return;
    }
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      let mut local : RangerAppParamDesc = localFnDesc.params[i as usize].clone();
      if  local.name != arg.name {
        wr.out(format!("{}{}", arg.compiledName, " ".to_string()), false);
      }
      wr.out(format!("{}{}", local.compiledName, " : ".to_string()), false);
      let mut nn : CodeNode = arg.nameNode.clone().unwrap();
      if  nn.hasFlag("strong".to_string()) {
        if  nn.value_type == 17 {
          wr.out("  @escaping  ".to_string(), false);
        }
      }
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(").".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ctx.isDefinedClass(obj.eval_type_name.clone()) {
          let mut clDef : RangerAppClassDesc = ctx.findClass(obj.eval_type_name.clone());
          let mut clMethod : Option<RangerAppFunctionDesc> = clDef.findMethod(method.vref.clone());
          if  clMethod.is_some() {
            let mut mm : RangerAppFunctionDesc = clMethod.unwrap();
            let mut pDesc : RangerAppParamDesc = mm.params[i as usize].clone();
            wr.out(format!("{}{}", pDesc.compiledName, " : ".to_string()), false);
            self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
            continue;
          }
        } else {
          ctx.addError(arg.clone(), "Could not find evaluated class for the call".to_string());
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      let mut fnName : Option<CodeNode> = node.fnDesc.nameNode;
      if  ctx.expressionLevel() == 0 {
        if  fnName.type_name != "void".to_string() {
          wr.out("_ = ".to_string(), false);
        }
      }
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      let mut givenArgs : CodeNode = node.getSecond();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        wr.out(format!("{}{}", arg.compiledName, " : ".to_string()), false);
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.newline();
      }
    }
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut rv : Option<CodeNode> = None;
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      rv = Some(fName.expression_value.children[0 as usize].clone());
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      rv = Some(param.nameNode.expression_value.children[0 as usize].clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    if  ctx.expressionLevel() == 0 {
      if  rv.type_name != "void".to_string() {
        wr.out("_ = ".to_string(), false);
      }
    }
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fnNode : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("({ (".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(arg.vref.clone(), false);
    }
    wr.out(") ->  ".to_string(), false);
    self.writeTypeDef(fnNode.clone(), lambdaCtx.clone(), wr.clone());
    wr.out(" in ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    for i_2 in 0..lambdaCtx.captured_variables.len() {
      let mut cname = lambdaCtx.captured_variables[i_2 as usize].clone();
      wr.out(format!("{}{}", "// captured var ".to_string(), cname), true);
    }
    wr.indent(-1);
    wr.out("})".to_string(), false);
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(node.clDesc.name.clone(), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
          self.WalkNode(n.clone(), ctx.clone(), wr.clone());
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn haveSameSig(&mut self, mut fn1 : RangerAppFunctionDesc, mut fn2 : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext) -> bool {
    if  fn1.name != fn2.name {
      return false;
    }
    let mut match : RangerArgMatch = RangerArgMatch::new();
    let mut n1 : CodeNode = fn1.nameNode.clone().unwrap();
    let mut n2 : CodeNode = fn1.nameNode.clone().unwrap();
    if  r#match.doesDefsMatch(n1.clone(), n2.clone(), ctx.clone()) == false {
      return false;
    }
    if  ((fn1.params.len() as i64)) != ((fn2.params.len() as i64)) {
      return false;
    }
    for i in 0..fn1.params.len() {
      let mut p = fn1.params[i as usize].clone();
      let mut p2 : RangerAppParamDesc = fn2.params[i as usize].clone();
      if  r#match.doesDefsMatch((p.nameNode.clone().unwrap()), (p2.nameNode.clone().unwrap()), ctx.clone()) == false {
        return false;
      }
    }
    return true;
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "switch".to_string() {
      let mut condition : CodeNode = node.getSecond();
      let mut case_nodes : CodeNode = node.getThird();
      wr.newline();
      wr.out("switch (".to_string(), false);
      self.WalkNode(condition.clone(), ctx.clone(), wr.clone());
      wr.out(") {".to_string(), true);
      wr.indent(1);
      let mut found_default : bool = false;
      for i in 0..case_nodes.children.len() {
        let mut ch = case_nodes.children[i as usize].clone();
        let mut blockName : CodeNode = ch.getFirst();
        if  blockName.vref == "default".to_string() {
          found_default = true;
          self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
        } else {
          self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
        }
      }
      if  false == found_default {
        wr.newline();
        wr.out("default :".to_string(), true);
        wr.indent(1);
        wr.out("break".to_string(), true);
        wr.indent(-1);
      }
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    let mut dblDeclaredFunction : HashMap<String,bool> = HashMap::new();
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut declaredStaticFunction : HashMap<String,bool> = HashMap::new();
    let mut parentFunction : HashMap<String,RangerAppFunctionDesc> = HashMap::new();
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..pC.variables.len() {
          let mut pvar = pC.variables[i_1 as usize].clone();
          declaredVariable.insert(pvar.name, true);
        }
        for i_2 in 0..pC.defined_variants.len() {
          let mut fnVar = pC.defined_variants[i_2 as usize].clone();
          let mut mVs : Option<RangerAppMethodVariants> = pC.method_variants.get(fnVar);
          for i_3 in 0..mVs.variants.len() {
            let mut variant = mVs.variants[i_3 as usize].clone();
            declaredFunction.insert(variant.name, true);
            parentFunction.insert(variant.name, variant);
          }
        }
        for i_4 in 0..pC.static_methods.len() {
          let mut variant_1 = pC.static_methods[i_4 as usize].clone();
          declaredStaticFunction.insert(variant_1.name, true);
        }
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "func ==(l: ".to_string(), cl.compiledName)), ", r: ".to_string())), cl.compiledName)), ") -> Bool {".to_string()), true);
    wr.indent(1);
    wr.out("return l === r".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out(format!("{}{}", "class ".to_string(), cl.compiledName), false);
    let mut parentClass : Option<RangerAppClassDesc> = None;
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" : ".to_string(), false);
      for i_5 in 0..cl.extends_classes.len() {
        let mut pName_1 = cl.extends_classes[i_5 as usize].clone();
        parentClass = Some(ctx.findClass(pName_1.clone()));
        wr.out(parentClass.compiledName.clone(), false);
      }
    } else {
      wr.out(" : Equatable ".to_string(), false);
    }
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    for i_6 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_6 as usize].clone();
      if  declaredVariable.contains_key(&pvar_1.name) {
        wr.out(format!("{}{}", "// WAS DECLARED : ".to_string(), pvar_1.name), true);
        continue;
      }
      self.writeVarDef(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut b_must_override : bool = false;
      if parentClass.is_some() {
        if  ((constr.params.len() as i64)) == 0 {
          b_must_override = true;
        } else {
          if  parentClass.has_constructor {
            let mut p_constr : RangerAppFunctionDesc = parentClass.constructor_fn.clone().unwrap();
            if  self.haveSameSig((constr.unwrap()), p_constr.clone(), ctx.clone()) {
              b_must_override = true;
            }
          }
        }
      }
      if  b_must_override {
        wr.out("override ".to_string(), false);
      }
      wr.out("init(".to_string(), false);
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
      wr.out(" ) {".to_string(), true);
      wr.indent(1);
      if parentClass.is_some() {
        wr.out("super.init()".to_string(), true);
      }
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_7 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_7 as usize].clone();
      if  variant_2.nameNode.hasFlag("main".to_string()) {
        continue;
      }
      if  declaredStaticFunction.contains_key(&variant_2.name) {
        wr.out("override ".to_string(), false);
      }
      wr.out(format!("{}{}", (format!("{}{}", "class func ".to_string(), variant_2.compiledName)), "(".to_string()), false);
      self.writeArgsDef(variant_2.clone(), ctx.clone(), wr.clone());
      wr.out(") -> ".to_string(), false);
      self.writeTypeDef(variant_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_8 in 0..cl.defined_variants.len() {
      let mut fnVar_1 = cl.defined_variants[i_8 as usize].clone();
      let mut mVs_1 : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar_1);
      for i_9 in 0..mVs_1.variants.len() {
        let mut variant_3 = mVs_1.variants[i_9 as usize].clone();
        if  dblDeclaredFunction.contains_key(&variant_3.name) {
          continue;
        }
        if  declaredFunction.contains_key(&variant_3.name) {
          wr.out("override ".to_string(), false);
        }
        dblDeclaredFunction.insert(variant_3.name, true);
        wr.out(format!("{}{}", (format!("{}{}", "func ".to_string(), variant_3.compiledName)), "(".to_string()), false);
        if  parentFunction.contains_key(&variant_3.name) {
          self.writeArgsDefWithLocals((parentFunction.get(variant_3.name)).unwrap(), variant_3.clone(), ctx.clone(), wr.clone());
        } else {
          self.writeArgsDef(variant_3.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") -> ".to_string(), false);
        self.writeTypeDef(variant_3.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_3.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_3.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_10 in 0..cl.static_methods.len() {
      let mut variant_4 = cl.static_methods[i_10 as usize].clone();
      if  variant_4.nameNode.hasFlag("main".to_string()) && (variant_4.nameNode.code.filename == ctx.getRootFile()) {
        let mut theEnd : CodeWriter = wr.getTag("file_end".to_string());
        theEnd.newline();
        theEnd.out("func __main__swift() {".to_string(), true);
        theEnd.indent(1);
        let mut subCtx_3 : RangerAppWriterContext = variant_4.fnCtx.clone().unwrap();
        subCtx_3.is_function = true;
        self.WalkNode(variant_4.fnBody.clone().unwrap(), subCtx_3.clone(), theEnd.clone());
        theEnd.newline();
        theEnd.indent(-1);
        theEnd.out("}".to_string(), true);
        theEnd.out("// call the main function".to_string(), true);
        theEnd.out("__main__swift()".to_string(), true);
        if  ctx.hasCompilerFlag("forever".to_string()) {
          theEnd.out("CFRunLoopRun()".to_string(), true);
        }
      }
    }
  }
}
#[derive(Clone)]
struct RangerSwift6ClassWriter { 
  compiler : Option<LiveCompiler>, 
  header_created : bool, 
}
impl RangerSwift6ClassWriter { 
  
  pub fn new() ->  RangerSwift6ClassWriter {
    let mut me = RangerSwift6ClassWriter { 
      compiler: None, 
      header_created:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "self".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "Any".to_string().clone();
      }
      if  cc.is_system {
        let mut sysName : Option<String> = cc.systemNames.get("swift6".to_string());
        if  sysName.is_none() {
          sysName = cc.systemNames.get("swift3".to_string());
        }
        if  sysName.is_some() {
          return sysName.unwrap().clone();
        } else {
          let mut node : CodeNode = CodeNode::new(SourceCode::new("".to_string()), 0, 0);
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), type_string)), " defined for Swift6 ".to_string()));
        }
      }
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[UInt8]".to_string().clone();
        break;
      case "char".to_string() : 
        return "UInt8".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[UInt8]".to_string().clone();
        break;
      case "char".to_string() : 
        return "UInt8".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        wr.out("(".to_string(), false);
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(" _ : ".to_string(), false);
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") -> ".to_string(), false);
        self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), false);
        break;
      case 13 : 
        wr.out("Int".to_string(), false);
        break;
      case 3 : 
        wr.out("Int".to_string(), false);
        break;
      case 2 : 
        wr.out("Double".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 14 : 
        wr.out("UInt8".to_string(), false);
        break;
      case 15 : 
        wr.out("[UInt8]".to_string(), false);
        break;
      case 5 : 
        wr.out("Bool".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), ":".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "[".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      default: 
        if  t_name == "void".to_string() {
          wr.out("Void".to_string(), false);
          return;
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_union {
            wr.out("Any".to_string(), false);
            if  node.hasFlag("optional".to_string()) {
              wr.out("?".to_string(), false);
            }
            return;
          }
          if  cc.is_system {
            let mut sysName : Option<String> = cc.systemNames.get("swift6".to_string());
            if  sysName.is_none() {
              sysName = cc.systemNames.get("swift3".to_string());
            }
            if  sysName.is_some() {
              wr.out(sysName.unwrap(), false);
            } else {
              ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), t_name)), " defined for Swift6 ".to_string()));
            }
            if  node.hasFlag("optional".to_string()) {
              wr.out("?".to_string(), false);
            }
            return;
          }
        }
        wr.out(self.getTypeString(t_name.clone()), false);
        break;
    }
    if  node.hasFlag("optional".to_string()) {
      wr.out("?".to_string(), false);
    }
  }
  fn WriteEnum(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      let rootObjName : String = node.ns[0 as usize].clone();
      let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
      if  e.is_some() {
        let enumName : String = node.ns[1 as usize].clone();
        wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
      } else {
        if  node.hasParamDesc {
          let mut pp : Option<RangerAppParamDesc> = node.paramDesc;
          let mut nn : Option<CodeNode> = pp.nameNode;
          wr.out(nn.vref.clone(), false);
        }
      }
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("self".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    let max_len : i64 = (node.ns.len() as i64);
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("self".to_string(), false);
            continue;
          }
          if  (part != "this".to_string()) && ctx.isMemberVariable(part.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out("self.".to_string(), false);
              }
            }
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  i < (max_len - 1) {
          if  p.nameNode.hasFlag("optional".to_string()) {
            wr.out("!".to_string(), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      let part_1 : String = node.ns[0 as usize].clone();
      if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_1.clone());
        if  up_1.is_some() {
          if  false == ctx.isInStatic() {
            wr.out("self.".to_string(), false);
          }
        }
      }
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_2 = node.ns[i_1 as usize].clone();
      if  i_1 == 0 {
        if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_2.clone());
          if  up_2.is_some() {
            if  false == ctx.isInStatic() {
              wr.out("self.".to_string(), false);
            }
          }
        }
        if  ctx.hasClass(part_2.clone()) {
          let mut classDesc : RangerAppClassDesc = ctx.findClass(part_2.clone());
          wr.out(classDesc.compiledName.clone(), false);
          continue;
        }
      }
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      wr.out(self.adjustType(part_2.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  nn.hasFlag("optional".to_string()) {
        if  ((p.set_cnt == 1) && (p.ref_cnt == 2)) && (p.is_class_variable == false) {
          ctx.addError(node.clone(), "Optional variable is only set but never read.".to_string());
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " : ".to_string()), false);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "let ".to_string(), p.compiledName)), " : ".to_string()), false);
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ".to_string(), true);
      } else {
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(format!("{}{}", arg.compiledName, " : ".to_string()), false);
      let mut nn : CodeNode = arg.nameNode.clone().unwrap();
      if  nn.value_type == 17 {
        wr.out("  @escaping  ".to_string(), false);
      }
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn writeArgsDefWithLocals(&mut self, mut fnDesc : RangerAppFunctionDesc, mut localFnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ((fnDesc.params.len() as i64)) != ((localFnDesc.params.len() as i64)) {
      ctx.addError(localFnDesc.node.clone().unwrap(), "Parameter count does not match with the function prototype".to_string());
      return;
    }
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      let mut local : RangerAppParamDesc = localFnDesc.params[i as usize].clone();
      if  local.name != arg.name {
        wr.out(format!("{}{}", arg.compiledName, " ".to_string()), false);
      }
      wr.out(format!("{}{}", local.compiledName, " : ".to_string()), false);
      let mut nn : CodeNode = arg.nameNode.clone().unwrap();
      if  nn.hasFlag("strong".to_string()) {
        if  nn.value_type == 17 {
          wr.out("  @escaping  ".to_string(), false);
        }
      }
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(").".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ctx.isDefinedClass(obj.eval_type_name.clone()) {
          let mut clDef : RangerAppClassDesc = ctx.findClass(obj.eval_type_name.clone());
          let mut clMethod : Option<RangerAppFunctionDesc> = clDef.findMethod(method.vref.clone());
          if  clMethod.is_some() {
            let mut mm : RangerAppFunctionDesc = clMethod.unwrap();
            let mut pDesc : RangerAppParamDesc = mm.params[i as usize].clone();
            wr.out(format!("{}{}", pDesc.compiledName, " : ".to_string()), false);
            self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
            continue;
          }
        } else {
          ctx.addError(arg.clone(), "Could not find evaluated class for the call".to_string());
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      let mut fnName : Option<CodeNode> = node.fnDesc.nameNode;
      if  ctx.expressionLevel() == 0 {
        if  fnName.type_name != "void".to_string() {
          wr.out("_ = ".to_string(), false);
        }
      }
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      let mut givenArgs : CodeNode = node.getSecond();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        wr.out(format!("{}{}", arg.compiledName, " : ".to_string()), false);
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.newline();
      }
    }
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut rv : Option<CodeNode> = None;
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      rv = Some(fName.expression_value.children[0 as usize].clone());
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      rv = Some(param.nameNode.expression_value.children[0 as usize].clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    if  ctx.expressionLevel() == 0 {
      if  rv.type_name != "void".to_string() {
        wr.out("_ = ".to_string(), false);
      }
    }
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fnNode : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("({ (".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(arg.vref.clone(), false);
    }
    wr.out(") ->  ".to_string(), false);
    self.writeTypeDef(fnNode.clone(), lambdaCtx.clone(), wr.clone());
    wr.out(" in ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    for i_2 in 0..lambdaCtx.captured_variables.len() {
      let mut cname = lambdaCtx.captured_variables[i_2 as usize].clone();
      wr.out(format!("{}{}", "// captured var ".to_string(), cname), true);
    }
    wr.indent(-1);
    wr.out("})".to_string(), false);
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(node.clDesc.name.clone(), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
          self.WalkNode(n.clone(), ctx.clone(), wr.clone());
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn haveSameSig(&mut self, mut fn1 : RangerAppFunctionDesc, mut fn2 : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext) -> bool {
    if  fn1.name != fn2.name {
      return false;
    }
    let mut match : RangerArgMatch = RangerArgMatch::new();
    let mut n1 : CodeNode = fn1.nameNode.clone().unwrap();
    let mut n2 : CodeNode = fn1.nameNode.clone().unwrap();
    if  r#match.doesDefsMatch(n1.clone(), n2.clone(), ctx.clone()) == false {
      return false;
    }
    if  ((fn1.params.len() as i64)) != ((fn2.params.len() as i64)) {
      return false;
    }
    for i in 0..fn1.params.len() {
      let mut p = fn1.params[i as usize].clone();
      let mut p2 : RangerAppParamDesc = fn2.params[i as usize].clone();
      if  r#match.doesDefsMatch((p.nameNode.clone().unwrap()), (p2.nameNode.clone().unwrap()), ctx.clone()) == false {
        return false;
      }
    }
    return true;
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "switch".to_string() {
      let mut condition : CodeNode = node.getSecond();
      let mut case_nodes : CodeNode = node.getThird();
      wr.newline();
      wr.out("switch (".to_string(), false);
      self.WalkNode(condition.clone(), ctx.clone(), wr.clone());
      wr.out(") {".to_string(), true);
      wr.indent(1);
      let mut found_default : bool = false;
      for i in 0..case_nodes.children.len() {
        let mut ch = case_nodes.children[i as usize].clone();
        let mut blockName : CodeNode = ch.getFirst();
        if  blockName.vref == "default".to_string() {
          found_default = true;
          self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
        } else {
          self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
        }
      }
      if  false == found_default {
        wr.newline();
        wr.out("default :".to_string(), true);
        wr.indent(1);
        wr.out("break".to_string(), true);
        wr.indent(-1);
      }
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    let mut dblDeclaredFunction : HashMap<String,bool> = HashMap::new();
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut declaredStaticFunction : HashMap<String,bool> = HashMap::new();
    let mut parentFunction : HashMap<String,RangerAppFunctionDesc> = HashMap::new();
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..pC.variables.len() {
          let mut pvar = pC.variables[i_1 as usize].clone();
          declaredVariable.insert(pvar.name, true);
        }
        for i_2 in 0..pC.defined_variants.len() {
          let mut fnVar = pC.defined_variants[i_2 as usize].clone();
          let mut mVs : Option<RangerAppMethodVariants> = pC.method_variants.get(fnVar);
          for i_3 in 0..mVs.variants.len() {
            let mut variant = mVs.variants[i_3 as usize].clone();
            declaredFunction.insert(variant.name, true);
            parentFunction.insert(variant.name, variant);
          }
        }
        for i_4 in 0..pC.static_methods.len() {
          let mut variant_1 = pC.static_methods[i_4 as usize].clone();
          declaredStaticFunction.insert(variant_1.name, true);
        }
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "func ==(l: ".to_string(), cl.compiledName)), ", r: ".to_string())), cl.compiledName)), ") -> Bool {".to_string()), true);
    wr.indent(1);
    wr.out("return l === r".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out(format!("{}{}", "class ".to_string(), cl.compiledName), false);
    let mut parentClass : Option<RangerAppClassDesc> = None;
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" : ".to_string(), false);
      for i_5 in 0..cl.extends_classes.len() {
        let mut pName_1 = cl.extends_classes[i_5 as usize].clone();
        parentClass = Some(ctx.findClass(pName_1.clone()));
        wr.out(parentClass.compiledName.clone(), false);
      }
    } else {
      wr.out(" : Equatable ".to_string(), false);
    }
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    for i_6 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_6 as usize].clone();
      if  declaredVariable.contains_key(&pvar_1.name) {
        wr.out(format!("{}{}", "// WAS DECLARED : ".to_string(), pvar_1.name), true);
        continue;
      }
      self.writeVarDef(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut b_must_override : bool = false;
      if parentClass.is_some() {
        if  ((constr.params.len() as i64)) == 0 {
          b_must_override = true;
        } else {
          if  parentClass.has_constructor {
            let mut p_constr : RangerAppFunctionDesc = parentClass.constructor_fn.clone().unwrap();
            if  self.haveSameSig((constr.unwrap()), p_constr.clone(), ctx.clone()) {
              b_must_override = true;
            }
          }
        }
      }
      if  b_must_override {
        wr.out("override ".to_string(), false);
      }
      wr.out("init(".to_string(), false);
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
      wr.out(" ) {".to_string(), true);
      wr.indent(1);
      if parentClass.is_some() {
        wr.out("super.init()".to_string(), true);
      }
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_7 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_7 as usize].clone();
      if  variant_2.nameNode.hasFlag("main".to_string()) {
        continue;
      }
      if  declaredStaticFunction.contains_key(&variant_2.name) {
        wr.out("override ".to_string(), false);
      }
      wr.out(format!("{}{}", (format!("{}{}", "class func ".to_string(), variant_2.compiledName)), "(".to_string()), false);
      self.writeArgsDef(variant_2.clone(), ctx.clone(), wr.clone());
      wr.out(") -> ".to_string(), false);
      self.writeTypeDef(variant_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_8 in 0..cl.defined_variants.len() {
      let mut fnVar_1 = cl.defined_variants[i_8 as usize].clone();
      let mut mVs_1 : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar_1);
      for i_9 in 0..mVs_1.variants.len() {
        let mut variant_3 = mVs_1.variants[i_9 as usize].clone();
        if  dblDeclaredFunction.contains_key(&variant_3.name) {
          continue;
        }
        if  declaredFunction.contains_key(&variant_3.name) {
          wr.out("override ".to_string(), false);
        }
        dblDeclaredFunction.insert(variant_3.name, true);
        wr.out(format!("{}{}", (format!("{}{}", "func ".to_string(), variant_3.compiledName)), "(".to_string()), false);
        if  parentFunction.contains_key(&variant_3.name) {
          self.writeArgsDefWithLocals((parentFunction.get(variant_3.name)).unwrap(), variant_3.clone(), ctx.clone(), wr.clone());
        } else {
          self.writeArgsDef(variant_3.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") -> ".to_string(), false);
        self.writeTypeDef(variant_3.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_3.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_3.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_10 in 0..cl.static_methods.len() {
      let mut variant_4 = cl.static_methods[i_10 as usize].clone();
      if  variant_4.nameNode.hasFlag("main".to_string()) && (variant_4.nameNode.code.filename == ctx.getRootFile()) {
        let mut theEnd : CodeWriter = wr.getTag("file_end".to_string());
        theEnd.newline();
        theEnd.out("// Main entry point".to_string(), true);
        theEnd.out("func main() {".to_string(), true);
        theEnd.indent(1);
        let mut subCtx_3 : RangerAppWriterContext = variant_4.fnCtx.clone().unwrap();
        subCtx_3.is_function = true;
        self.WalkNode(variant_4.fnBody.clone().unwrap(), subCtx_3.clone(), theEnd.clone());
        theEnd.newline();
        theEnd.indent(-1);
        theEnd.out("}".to_string(), true);
        theEnd.out("main()".to_string(), true);
      }
    }
  }
}
#[derive(Clone)]
struct RangerCppClassWriter { 
  compiler : Option<LiveCompiler>, 
  header_created : bool, 
}
impl RangerCppClassWriter { 
  
  pub fn new() ->  RangerCppClassWriter {
    let mut me = RangerCppClassWriter { 
      compiler: None, 
      header_created:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(["".to_string() , (node.double_value.to_string()) ].join(""), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "std::string(".to_string(), (format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string())))), ")".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "char".to_string() : 
        return "char".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "const char*".to_string().clone();
        break;
      case "int".to_string() : 
        return "int".to_string().clone();
        break;
      case "string".to_string() : 
        return "std::string".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "double".to_string().clone();
        break;
    }
    if  ctx.isEnumDefined(type_string.clone()) {
      return "int".to_string().clone();
    }
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return format!("{}{}", "r_union_".to_string(), type_string).clone();
      }
      return format!("{}{}", (format!("{}{}", "std::shared_ptr<".to_string(), type_string)), ">".to_string()).clone();
    }
    return type_string.clone();
  }
  fn getTypeString2(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "char".to_string() : 
        return "char".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "const char*".to_string().clone();
        break;
      case "int".to_string() : 
        return "int".to_string().clone();
        break;
      case "string".to_string() : 
        return "std::string".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "double".to_string().clone();
        break;
    }
    if  ctx.isEnumDefined(type_string.clone()) {
      return "int".to_string().clone();
    }
    return type_string.clone();
  }
  fn writePtr(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.type_name == "void".to_string() {
      return;
    }
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        self.import_lib("<functional>".to_string(), ctx.clone(), wr.clone());
        wr.out("std::function<".to_string(), false);
        self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(")>".to_string(), false);
        break;
      case 13 : 
        wr.out("int".to_string(), false);
        break;
      case 3 : 
        if  node.hasFlag("optional".to_string()) {
          wr.out(" r_optional_primitive<int> ".to_string(), false);
        } else {
          wr.out("int".to_string(), false);
        }
        break;
      case 14 : 
        wr.out("char".to_string(), false);
        break;
      case 15 : 
        wr.out("const char*".to_string(), false);
        break;
      case 2 : 
        if  node.hasFlag("optional".to_string()) {
          wr.out(" r_optional_primitive<double> ".to_string(), false);
        } else {
          wr.out("double".to_string(), false);
        }
        break;
      case 4 : 
        wr.addImport("<string>".to_string());
        wr.out("std::string".to_string(), false);
        break;
      case 5 : 
        wr.out("bool".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "std::map<".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), ",".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), ">".to_string()), false);
        wr.addImport("<map>".to_string());
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "std::vector<".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), ">".to_string()), false);
        wr.addImport("<vector>".to_string());
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("void".to_string(), false);
          return;
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_union {
            wr.out("r_union_".to_string(), false);
            wr.out(t_name.clone(), false);
            return;
          }
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
          wr.out("std::shared_ptr<".to_string(), false);
          wr.out(cc_1.name.clone(), false);
          wr.out(">".to_string(), false);
          return;
        }
        if  node.hasFlag("optional".to_string()) {
          wr.out("std::shared_ptr<std::vector<".to_string(), false);
          wr.out(self.getTypeString2(t_name.clone(), ctx.clone()), false);
          wr.out(">".to_string(), false);
          return;
        }
        wr.out(self.getTypeString2(t_name.clone(), ctx.clone()), false);
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      let mut currC : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      if  currC.is_some() {
        let mut cc : RangerAppClassDesc = currC.unwrap();
        if  ((cc.extends_classes.len() as i64)) > 0 {
          wr.out(format!("{}{}", (format!("{}{}", "std::dynamic_pointer_cast<".to_string(), cc.name)), ">(shared_from_this())".to_string()), false);
          return;
        }
      }
      wr.out("shared_from_this()".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      let rootObjName : String = node.ns[0 as usize].clone();
      if  ((node.ns.len() as i64)) > 1 {
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    let mut had_static : bool = false;
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i > 0 {
          if  had_static {
            wr.out("::".to_string(), false);
          } else {
            wr.out("->".to_string(), false);
          }
        }
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("this".to_string(), false);
            continue;
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  p.isClass() {
          had_static = true;
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_1 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  had_static {
          wr.out("::".to_string(), false);
        } else {
          wr.out("->".to_string(), false);
        }
      }
      if  ctx.hasClass(part_1.clone()) {
        had_static = true;
      } else {
        had_static = false;
      }
      wr.out(self.adjustType(part_1.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out("".to_string(), false);
      } else {
        wr.out("".to_string(), false);
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn disabledVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out("".to_string(), false);
      } else {
        wr.out("".to_string(), false);
      }
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
      }
      wr.out(";".to_string(), false);
      wr.newline();
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(")->".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "return".to_string() {
      if  ctx.isInMain() {
        wr.out("return 0;".to_string(), true);
      } else {
        wr.out("return;".to_string(), true);
      }
      return;
    }
    if  cmd == "switch".to_string() {
      let mut condition : CodeNode = node.getSecond();
      let mut case_nodes : CodeNode = node.getThird();
      wr.newline();
      let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
      p.name = "caseMatched".to_string();
      p.value_type = 5;
      ctx.defineVariable(p.name.clone(), p.clone());
      let mut b_has_default : bool = false;
      for i in 0..case_nodes.children.len() {
        let mut ch = case_nodes.children[i as usize].clone();
        let mut blockName : CodeNode = ch.getFirst();
        if  blockName.vref == "default".to_string() {
          b_has_default = true;
        }
      }
      if  b_has_default {
        wr.out(format!("{}{}", (format!("{}{}", "bool ".to_string(), p.compiledName)), " = false;".to_string()), true);
      }
      for i_1 in 0..case_nodes.children.len() {
        let mut ch_1 = case_nodes.children[i_1 as usize].clone();
        let mut blockName_1 : CodeNode = ch_1.getFirst();
        if  blockName_1.vref == "default".to_string() {
          let mut defBlock : CodeNode = ch_1.getSecond();
          wr.out("if( ! ".to_string(), false);
          wr.out(p.compiledName.clone(), false);
          wr.out(") {".to_string(), true);
          wr.indent(1);
          self.WalkNode(defBlock.clone(), ctx.clone(), wr.clone());
          wr.indent(-1);
          wr.out("}".to_string(), true);
        } else {
          let mut caseValue : CodeNode = ch_1.getSecond();
          let mut caseBlock : CodeNode = ch_1.getThird();
          wr.out("if( ".to_string(), false);
          self.WalkNode(condition.clone(), ctx.clone(), wr.clone());
          wr.out(" == ".to_string(), false);
          self.WalkNode(caseValue.clone(), ctx.clone(), wr.clone());
          wr.out(") {".to_string(), true);
          wr.indent(1);
          if  b_has_default {
            wr.out(format!("{}{}", p.compiledName, " = true;".to_string()), true);
          }
          self.WalkNode(caseBlock.clone(), ctx.clone(), wr.clone());
          wr.indent(-1);
          wr.out("}".to_string(), true);
        }
      }
    }
  }
  fn CreateMethodCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getFirst();
    let mut args : CodeNode = node.getSecond();
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
  }
  fn CreatePropertyGet(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getSecond();
    let mut prop : CodeNode = node.getThird();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out(")->".to_string(), false);
    self.WalkNode(prop.clone(), ctx.clone(), wr.clone());
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    wr.out(")".to_string(), false);
    ctx.unsetInExpr();
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.import_lib("<functional>".to_string(), ctx.clone(), wr.clone());
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    /** unused:  let mut fnNode : CodeNode = node.children[0 as usize].clone();   **/ 
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("[&".to_string(), false);
    for i in 0..lambdaCtx.captured_variables.len() {
      let mut cname = lambdaCtx.captured_variables[i as usize].clone();
      let mut vD : RangerAppParamDesc = lambdaCtx.getVariableDef(cname.clone());
      if  vD.varType == 4 {
        wr.out(", ".to_string(), false);
        wr.out(vD.compiledName, false);
      }
    }
    wr.out("](".to_string(), false);
    for i_1 in 0..args.children.len() {
      let mut arg = args.children[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(", ".to_string(), false);
      }
      self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(arg.vref.clone(), false);
    }
    wr.out(") mutable { ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_2 in 0..body.children.len() {
      let mut item = body.children[i_2 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), false);
  }
  fn writeCppHeaderVar(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter, do_initialize : bool) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out("".to_string(), false);
      } else {
        wr.out("".to_string(), false);
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(p.compiledName.clone(), false);
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), arg.compiledName)), " ".to_string()), false);
    }
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      let mut givenArgs : CodeNode = node.getSecond();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  i >= ((givenArgs.children.len() as i64)) {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(" std::make_shared<".to_string(), false);
      wr.out(node.clDesc.name.clone(), false);
      wr.out(">(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.compiler.createPolyfillLegacy("\r\ntemplate< typename T, size_t N >\r\nstd::vector<T> r_make_vector_from_array( const T (&data)[N] )\r\n{\r\n    return std::vector<T>(data, data+N);\r\n}\r\n".to_string(), ctx.clone(), wr.clone());
    wr.out("r_make_vector_from_array( (".to_string(), false);
    wr.out(self.getObjectTypeString(node.eval_array_type.clone(), ctx.clone()), false);
    wr.out("[] ) {".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("} )".to_string(), false);
  }
  fn writeClassHeader(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut inheritedVars : HashMap<String,bool> = HashMap::new();
    wr.out(format!("{}{}", "class ".to_string(), cl.name), false);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" : ".to_string(), false);
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        wr.out("public ".to_string(), false);
        wr.out(pName.clone(), false);
        let mut extC : RangerAppClassDesc = ctx.findClass(pName.clone());
        for i_1 in 0..extC.variables.len() {
          let mut pvar = extC.variables[i_1 as usize].clone();
          inheritedVars.insert(pvar.name, true);
        }
      }
    } else {
      wr.out(format!("{}{}", (format!("{}{}", " : public std::enable_shared_from_this<".to_string(), cl.name)), "> ".to_string()), false);
    }
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    wr.out("public :".to_string(), true);
    wr.indent(1);
    for i_2 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_2 as usize].clone();
      if  (inheritedVars.contains_key(&pvar_1.name)) == false {
        self.writeCppHeaderVar(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone(), false);
      }
    }
    wr.out("/* class constructor */ ".to_string(), true);
    wr.out(format!("{}{}", cl.name, "(".to_string()), false);
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
    }
    wr.out(" );".to_string(), true);
    for i_3 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_3 as usize].clone();
      if  i_3 == 0 {
        wr.out("/* static methods */ ".to_string(), true);
      }
      wr.out("static ".to_string(), false);
      self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), variant.compiledName)), "(".to_string()), false);
      self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
      wr.out(");".to_string(), true);
    }
    for i_4 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_4 as usize].clone();
      if  i_4 == 0 {
        wr.out("/* instance methods */ ".to_string(), true);
      }
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_5 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_5 as usize].clone();
        if  cl.is_inherited {
          wr.out("virtual ".to_string(), false);
        }
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), variant_1.compiledName)), "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(");".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.indent(-1);
    wr.out("};".to_string(), true);
  }
  fn CreateUnions(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  item.is_union {
        self.compiler.installFile("variant.hpp".to_string(), ctx.clone(), wr.clone());
        ctx.addPluginNode("makefile".to_string(), CodeNode::fromList([CodeNode::fromList([CodeNode::vref1("dep".to_string()), CodeNode::newStr("variant.hpp".to_string()), CodeNode::newStr("https://github.com/mpark/variant/releases/download/v1.2.2/variant.hpp".to_string())])]));
        wr.out("typedef mpark::variant<".to_string(), false);
        wr.indent(1);
        let mut cnt : i64 = 0;
        operatorsOf::forEach_12(item.is_union_of, (item, index) => { 
          if  ctx.isDefinedClass(item.clone()) {
            let mut cl : RangerAppClassDesc = ctx.findClass(item.clone());
            if  false == cl.isNormalClass() {
              return;
            }
            if  cnt > 0 {
              wr.out(", ".to_string(), false);
            }
            wr.out(self.getObjectTypeString(item.clone(), ctx.clone()), false);
            cnt = cnt + 1;
          } else {
            if  cnt > 0 {
              wr.out(", ".to_string(), false);
            }
            wr.out(self.getObjectTypeString(item.clone(), ctx.clone()), false);
            cnt = cnt + 1;
          }
        }
        );
        wr.indent(-1);
        wr.out(format!("{}{}", (format!("{}{}", ">  r_union_".to_string(), index)), ";".to_string()), true);
        wr.addImport("\"variant.hpp\"".to_string());
      }
    }
    );
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    let mut wr : CodeWriter = orig_wr;
    if  cl.is_none() {
      return;
    }
    self.import_lib("<memory>".to_string(), ctx.clone(), wr.clone());
    for i in 0..cl.capturedLocals.len() {
      let mut dd = cl.capturedLocals[i as usize].clone();
      if  dd.is_class_variable == false {
        if  dd.set_cnt > 0 {
          if  ctx.hasCompilerFlag("dont-allow-mutate".to_string()) {
            ctx.addError(dd.nameNode.clone().unwrap(), "Mutating captured variable is not allowed".to_string());
            return;
          }
        }
      }
    }
    if  self.header_created == false {
      wr.createTag("c++Imports".to_string());
      wr.out("".to_string(), true);
      wr.out("// define classes here to avoid compiler errors".to_string(), true);
      wr.createTag("c++ClassDefs".to_string());
      wr.out("".to_string(), true);
      wr.createTag("c++unions".to_string());
      wr.createTag("utilities".to_string());
      wr.out("".to_string(), true);
      wr.out("// header definitions".to_string(), true);
      wr.createTag("c++Header".to_string());
      wr.out("".to_string(), true);
      wr.out("int __g_argc;".to_string(), true);
      wr.out("char **__g_argv;".to_string(), true);
      self.CreateUnions(self.compiler.parser.clone().unwrap(), ctx.clone(), wr.getTag("c++unions".to_string()));
      self.header_created = true;
    }
    let mut classWriter : CodeWriter = orig_wr.getTag("c++ClassDefs".to_string());
    let mut headerWriter : CodeWriter = orig_wr.getTag("c++Header".to_string());
    /** unused:  let projectName : String = "project".to_string();   **/ 
    classWriter.out(format!("{}{}", (format!("{}{}", "class ".to_string(), cl.name)), ";".to_string()), true);
    self.writeClassHeader(node.clone(), ctx.clone(), headerWriter.clone());
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", cl.name, "::".to_string())), cl.name)), "(".to_string()), false);
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
    }
    wr.out(" ) ".to_string(), false);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i_1 in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i_1 as usize].clone();
        let mut pcc : RangerAppClassDesc = ctx.findClass(pName.clone());
        if  pcc.has_constructor {
          wr.out(format!("{}{}", (format!("{}{}", " : ".to_string(), pcc.name)), "(".to_string()), false);
          let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
          for i_2 in 0..constr_1.params.len() {
            let mut arg = constr_1.params[i_2 as usize].clone();
            if  i_2 > 0 {
              wr.out(",".to_string(), false);
            }
            wr.out(" ".to_string(), false);
            wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), arg.name)), " ".to_string()), false);
          }
          wr.out(")".to_string(), false);
        }
      }
    }
    wr.out("{".to_string(), true);
    wr.indent(1);
    for i_3 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_3 as usize].clone();
      let mut nn : CodeNode = pvar.node.clone().unwrap();
      if  ((nn.children.len() as i64)) > 2 {
        let mut valueNode : CodeNode = nn.children[2 as usize].clone();
        wr.out(format!("{}{}", (format!("{}{}", "this->".to_string(), pvar.compiledName)), " = ".to_string()), false);
        self.WalkNode(valueNode.clone(), ctx.clone(), wr.clone());
        wr.out(";".to_string(), true);
      }
    }
    if  cl.has_constructor {
      let mut constr_2 : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr_2.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr_2.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_4 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_4 as usize].clone();
      if  variant.nameNode.hasFlag("main".to_string()) {
        continue;
      }
      self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), cl.name)), "::".to_string()), false);
      wr.out(format!("{}{}", variant.compiledName, "(".to_string()), false);
      self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
      wr.out(") {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_5 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_5 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_6 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_6 as usize].clone();
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), cl.name)), "::".to_string()), false);
        wr.out(format!("{}{}", variant_1.compiledName, "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    for i_7 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_7 as usize].clone();
      if  variant_2.nameNode.hasFlag("main".to_string()) && (variant_2.nameNode.code.filename == ctx.getRootFile()) {
        ctx.setCompilerSetting("mainclass".to_string(), cl.name);
        wr.out("int main(int argc, char* argv[]) {".to_string(), true);
        wr.indent(1);
        wr.out("__g_argc = argc;".to_string(), true);
        wr.out("__g_argv = argv;".to_string(), true);
        let mut subCtx_3 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
        subCtx_3.in_main = true;
        subCtx_3.is_function = true;
        self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_3.clone(), wr.clone());
        wr.newline();
        wr.out("return 0;".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
  }
}
#[derive(Clone)]
struct RangerRustClassWriter { 
  compiler : Option<LiveCompiler>, 
  thisName : String, 
  fileHeaderWritten : bool, 
}
impl RangerRustClassWriter { 
  
  pub fn new() ->  RangerRustClassWriter {
    let mut me = RangerRustClassWriter { 
      compiler: None, 
      thisName:"self".to_string(), 
      fileHeaderWritten:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    switch (tn ) { 
      case "type".to_string() : 
        return "r#type".to_string().clone();
        break;
      case "static".to_string() : 
        return "r#static".to_string().clone();
        break;
      case "async".to_string() : 
        return "r#async".to_string().clone();
        break;
      case "await".to_string() : 
        return "r#await".to_string().clone();
        break;
      case "dyn".to_string() : 
        return "r#dyn".to_string().clone();
        break;
      case "impl".to_string() : 
        return "r#impl".to_string().clone();
        break;
      case "trait".to_string() : 
        return "r#trait".to_string().clone();
        break;
      case "mod".to_string() : 
        return "r#mod".to_string().clone();
        break;
      case "pub".to_string() : 
        return "r#pub".to_string().clone();
        break;
      case "use".to_string() : 
        return "r#use".to_string().clone();
        break;
      case "extern".to_string() : 
        return "r#extern".to_string().clone();
        break;
      case "crate".to_string() : 
        return "r#crate".to_string().clone();
        break;
      case "super".to_string() : 
        return "r#super".to_string().clone();
        break;
      case "where".to_string() : 
        return "r#where".to_string().clone();
        break;
      case "unsafe".to_string() : 
        return "r#unsafe".to_string().clone();
        break;
      case "move".to_string() : 
        return "r#move".to_string().clone();
        break;
      case "ref".to_string() : 
        return "r#ref".to_string().clone();
        break;
      case "mut".to_string() : 
        return "r#mut".to_string().clone();
        break;
      case "const".to_string() : 
        return "r#const".to_string().clone();
        break;
      case "match".to_string() : 
        return "r#match".to_string().clone();
        break;
      case "as".to_string() : 
        return "r#as".to_string().clone();
        break;
      case "abstract".to_string() : 
        return "r#abstract".to_string().clone();
        break;
      case "become".to_string() : 
        return "r#become".to_string().clone();
        break;
      case "box".to_string() : 
        return "r#box".to_string().clone();
        break;
      case "do".to_string() : 
        return "r#do".to_string().clone();
        break;
      case "final".to_string() : 
        return "r#final".to_string().clone();
        break;
      case "macro".to_string() : 
        return "r#macro".to_string().clone();
        break;
      case "override".to_string() : 
        return "r#override".to_string().clone();
        break;
      case "priv".to_string() : 
        return "r#priv".to_string().clone();
        break;
      case "typeof".to_string() : 
        return "r#typeof".to_string().clone();
        break;
      case "unsized".to_string() : 
        return "r#unsized".to_string().clone();
        break;
      case "virtual".to_string() : 
        return "r#virtual".to_string().clone();
        break;
      case "yield".to_string() : 
        return "r#yield".to_string().clone();
        break;
      case "try".to_string() : 
        return "r#try".to_string().clone();
        break;
    }
    return tn.clone();
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(format!("{}{}", (["".to_string() , (node.double_value.to_string()) ].join("")), "_f64".to_string()), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string())), ".to_string()".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "i64".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "f64".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "i64".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "f64".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let is_optional : bool = node.hasFlag("optional".to_string());
    let mut is_self_referential : bool = false;
    let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    if  uc.is_some() {
      let mut currClass : RangerAppClassDesc = uc.unwrap();
      if  node.type_name == currClass.name {
        is_self_referential = true;
      }
    }
    if  is_optional {
      if  is_self_referential {
        wr.out("Option<Box<".to_string(), false);
      } else {
        wr.out("Option<".to_string(), false);
      }
    }
    let mut v_type : i64 = node.value_type;
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
    }
    switch (v_type ) { 
      case 13 : 
        wr.out("i64".to_string(), false);
        break;
      case 3 : 
        wr.out("i64".to_string(), false);
        break;
      case 2 : 
        wr.out("f64".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 5 : 
        wr.out("bool".to_string(), false);
        break;
      case 14 : 
        wr.out("u8".to_string(), false);
        break;
      case 15 : 
        wr.out("Vec<u8>".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "HashMap<".to_string(), self.getObjectTypeString(node.key_type.clone(), ctx.clone()))), ",".to_string())), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), ">".to_string()), false);
        wr.addImport("std::collections::HashMap".to_string());
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "Vec<".to_string(), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), ">".to_string()), false);
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("()".to_string(), false);
          return;
        }
        wr.out(self.getTypeString(node.type_name.clone()), false);
        break;
    }
    if  is_optional {
      if  is_self_referential {
        wr.out(">>".to_string(), false);
      } else {
        wr.out(">".to_string(), false);
      }
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out(self.thisName.clone(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      let mut had_static : bool = false;
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out(self.thisName.clone(), false);
            continue;
          }
        }
        if  i > 0 {
          if  had_static {
            wr.out("::".to_string(), false);
          } else {
            wr.out(".".to_string(), false);
          }
        }
        if  i == 0 {
          let part_1 : String = node.ns[0 as usize].clone();
          if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part_1.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
              }
            }
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  p.isClass() {
          had_static = true;
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let part_2 : String = node.ns[0 as usize].clone();
      if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_2.clone());
        if  up_1.is_some() {
          if  false == ctx.isInStatic() {
            wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
          }
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_3 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  (i_1 == 1) && b_was_static {
          wr.out("::".to_string(), false);
        } else {
          wr.out(".".to_string(), false);
        }
      }
      if  i_1 == 0 {
        if  ctx.hasClass(part_3.clone()) {
          b_was_static = true;
        }
        if  (part_3 != "this".to_string()) && ctx.hasCurrentClass() {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_3.clone());
          if  up_2.is_some() {
            if  false == ctx.isInStatic() {
              wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
            }
          }
        }
      }
      wr.out(self.adjustType(part_3.clone()), false);
    }
  }
  fn writeStructField(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      wr.out(format!("{}{}", self.adjustType(p.compiledName.clone()), " : ".to_string()), false);
      let mut nameN : CodeNode = p.nameNode.clone().unwrap();
      self.writeTypeDef(nameN.clone(), ctx.clone(), wr.clone());
      wr.out(", ".to_string(), true);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      let map_or_hash : bool = (nn.value_type == 6) || (nn.value_type == 7);
      let needs_mut : bool = ((p.set_cnt > 0) || p.is_class_variable) || map_or_hash;
      let is_object : bool = nn.value_type == 10;
      if  needs_mut || is_object {
        wr.out(format!("{}{}", (format!("{}{}", "let mut ".to_string(), p.compiledName)), " : ".to_string()), false);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "let ".to_string(), p.compiledName)), " : ".to_string()), false);
      }
      let mut nameN : CodeNode = p.nameNode.clone().unwrap();
      self.writeTypeDef(nameN.clone(), ctx.clone(), wr.clone());
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        if  nameN.type_name == "string".to_string() {
          if  value.value_type == 11 {
            if  ((value.ns.len() as i64)) > 1 {
              wr.out(".clone()".to_string(), false);
            }
          }
        }
      } else {
        if  nn.value_type == 6 {
          wr.out(" = Vec::new()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = HashMap::new()".to_string(), false);
        }
        if  nameN.hasFlag("optional".to_string()) {
          wr.out(" = None".to_string(), false);
        }
      }
      wr.out(";".to_string(), false);
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ".to_string(), true);
      } else {
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      let mut nameN : CodeNode = arg.nameNode.clone().unwrap();
      let mut v_type : i64 = nameN.value_type;
      if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
        v_type = nameN.typeNameAsType(ctx.clone());
      }
      let is_object : bool = ((v_type == 10) || (v_type == 6)) || (v_type == 7);
      if  is_object {
        wr.out(format!("{}{}", (format!("{}{}", "mut ".to_string(), arg.name)), " : ".to_string()), false);
      } else {
        wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
      }
      self.writeTypeDef(nameN.clone(), ctx.clone(), wr.clone());
    }
  }
  fn isSelfMethodCall(&mut self, mut node : CodeNode) -> bool {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      if  ((fc.ns.len() as i64)) > 0 {
        let part : String = fc.ns[0 as usize].clone();
        if  part == "this".to_string() {
          return true;
        }
      }
    }
    return false;
  }
  fn findSelfCallInArgs(&mut self, mut node : CodeNode) -> i64 {
    if  node.hasFnCall {
      let mut givenArgs : CodeNode = node.getSecond();
      let mut idx : i64 = 0;
      for i in 0..givenArgs.children.len() {
        let mut arg = givenArgs.children[i as usize].clone();
        if  self.isSelfMethodCall(arg.clone()) {
          return i;
        }
        idx = i + 1;
      }
    }
    return -1;
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      let part : String = fc.ns[0 as usize].clone();
      let is_self_call : bool = part == "this".to_string();
      let selfCallArgIdx : i64 = self.findSelfCallInArgs(node.clone());
      let mut givenArgs : CodeNode = node.getSecond();
      if  is_self_call && (selfCallArgIdx >= 0) {
        let mut tempVars : Vec<String> = Vec::new();
        for argIdx in 0..givenArgs.children.len() {
          let mut argNode = givenArgs.children[argIdx as usize].clone();
          if  self.isSelfMethodCall(argNode.clone()) {
            let tempName : String = ctx.rustGetTempVar();
            tempVars.push(tempName);
            wr.out(format!("{}{}", (format!("{}{}", "let ".to_string(), tempName)), " = ".to_string()), false);
            ctx.setInExpr();
            self.WalkNode(argNode.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            wr.out(";".to_string(), true);
          } else {
            tempVars.push("".to_string().to_string());
          }
        }
        if  (part != "this".to_string()) && ctx.isMemberVariable(part.clone()) {
          let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          if  uc.is_some() {
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
              }
            }
          }
        }
        self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
        wr.out("(".to_string(), false);
        for i in 0..node.fnDesc.params.len() {
          let mut arg = node.fnDesc.params[i as usize].clone();
          let mut n : Option<CodeNode> = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  n.is_none() {
            let mut nameN : CodeNode = arg.nameNode.clone().unwrap();
            let mut defVal : Option<CodeNode> = nameN.getFlag("default".to_string());
            if  defVal.is_some() {
              let mut defV : CodeNode = defVal.unwrap();
              let mut fc2 : CodeNode = defV.vref_annotation.getFirst();
              ctx.setInExpr();
              self.WalkNode(fc2.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
            } else {
              ctx.addError(node.clone(), "Default argument was missing".to_string());
            }
            continue;
          }
          let tempVar : String = tempVars[i as usize].clone();
          if  (tempVar.len() as i64) > 0 {
            wr.out(tempVar.clone(), false);
          } else {
            let mut nVal : CodeNode = n.unwrap();
            ctx.setInExpr();
            self.WalkNode(nVal.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            let mut argNameN : CodeNode = arg.nameNode.clone().unwrap();
            let mut arg_type : i64 = argNameN.value_type;
            if  ((arg_type == 10) || (arg_type == 11)) || (arg_type == 0) {
              arg_type = argNameN.typeNameAsType(ctx.clone());
            }
            let mut needs_clone : bool = false;
            if  argNameN.type_name == "string".to_string() {
              needs_clone = true;
            }
            if  arg_type == 10 {
              needs_clone = true;
            }
            if  needs_clone {
              if  nVal.value_type == 11 {
                wr.out(".clone()".to_string(), false);
              }
            }
          }
        }
        wr.out(")".to_string(), false);
        if  ctx.expressionLevel() == 0 {
          wr.out(";".to_string(), true);
        }
        return;
      }
      if  (part != "this".to_string()) && ctx.isMemberVariable(part.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        if  uc_1.is_some() {
          let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
          let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part.clone());
          if  up_1.is_some() {
            if  false == ctx.isInStatic() {
              wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
            }
          }
        }
      }
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      for i_1 in 0..node.fnDesc.params.len() {
        let mut arg_1 = node.fnDesc.params[i_1 as usize].clone();
        let mut n_1 : Option<CodeNode> = givenArgs.children[i_1 as usize].clone();
        if  i_1 > 0 {
          wr.out(", ".to_string(), false);
        }
        if  n_1.is_none() {
          let mut nameN_1 : CodeNode = arg_1.nameNode.clone().unwrap();
          let mut defVal_1 : Option<CodeNode> = nameN_1.getFlag("default".to_string());
          if  defVal_1.is_some() {
            let mut defV_1 : CodeNode = defVal_1.unwrap();
            let mut fc2_1 : CodeNode = defV_1.vref_annotation.getFirst();
            ctx.setInExpr();
            self.WalkNode(fc2_1.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut nVal_1 : CodeNode = n_1.unwrap();
        ctx.setInExpr();
        self.WalkNode(nVal_1.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        let mut argNameN_1 : CodeNode = arg_1.nameNode.clone().unwrap();
        let mut arg_type_1 : i64 = argNameN_1.value_type;
        if  ((arg_type_1 == 10) || (arg_type_1 == 11)) || (arg_type_1 == 0) {
          arg_type_1 = argNameN_1.typeNameAsType(ctx.clone());
        }
        let mut needs_clone_1 : bool = false;
        if  argNameN_1.type_name == "string".to_string() {
          needs_clone_1 = true;
        }
        if  arg_type_1 == 10 {
          needs_clone_1 = true;
        }
        if  needs_clone_1 {
          if  nVal_1.value_type == 11 {
            wr.out(".clone()".to_string(), false);
          }
        }
      }
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(node.clDesc.name.clone(), false);
      wr.out("::new(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        let mut c : RangerAppFunctionDesc = constr.unwrap();
        for i in 0..c.params.len() {
          let mut arg = c.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          let mut argNameN : CodeNode = arg.nameNode.clone().unwrap();
          let mut arg_type : i64 = argNameN.value_type;
          if  ((arg_type == 10) || (arg_type == 11)) || (arg_type == 0) {
            arg_type = argNameN.typeNameAsType(ctx.clone());
          }
          let mut needs_clone : bool = false;
          if  argNameN.type_name == "string".to_string() {
            needs_clone = true;
          }
          if  arg_type == 10 {
            needs_clone = true;
          }
          if  needs_clone {
            if  n.value_type == 11 {
              wr.out(".clone()".to_string(), false);
            }
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut ucl : Option<RangerAppClassDesc> = node.clDesc;
    if  ucl.is_none() {
      return;
    }
    let mut cl : RangerAppClassDesc = ucl.unwrap();
    let mut prevClass : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    ctx.setCurrentClass(cl.clone());
    let mut wr : CodeWriter = orig_wr;
    if  self.fileHeaderWritten == false {
      wr.out("#![allow(unused_parens)]".to_string(), true);
      wr.out("#![allow(unused_mut)]".to_string(), true);
      wr.out("#![allow(unused_variables)]".to_string(), true);
      wr.out("#![allow(non_snake_case)]".to_string(), true);
      wr.out("#![allow(dead_code)]".to_string(), true);
      wr.out("".to_string(), true);
      self.fileHeaderWritten = true;
    }
    wr.out("#[derive(Clone)]".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "struct ".to_string(), cl.name)), " { ".to_string()), true);
    wr.indent(1);
    for i in 0..cl.variables.len() {
      let mut pvar = cl.variables[i as usize].clone();
      let mut pnode : CodeNode = pvar.node.clone().unwrap();
      self.writeStructField(pnode.clone(), ctx.clone(), wr.clone());
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "impl ".to_string(), cl.name)), " { ".to_string()), true);
    wr.indent(1);
    self.thisName = "me".to_string();
    wr.out("".to_string(), true);
    wr.out("pub fn new(".to_string(), false);
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      if  constr.is_some() {
        let mut c : RangerAppFunctionDesc = constr.unwrap();
        for i_1 in 0..c.params.len() {
          let mut arg = c.params[i_1 as usize].clone();
          if  i_1 > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
          let mut nameN : CodeNode = arg.nameNode.clone().unwrap();
          self.writeTypeDef(nameN.clone(), ctx.clone(), wr.clone());
        }
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", ") ->  ".to_string(), cl.name)), " {".to_string()), true);
    wr.indent(1);
    wr.newline();
    wr.out(format!("{}{}", (format!("{}{}", "let mut me = ".to_string(), cl.name)), " { ".to_string()), true);
    wr.indent(1);
    for i_2 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_2 as usize].clone();
      let mut nn : Option<CodeNode> = pvar_1.node;
      if  nn.is_some() {
        let mut node_1 : CodeNode = nn.unwrap();
        if  ((node_1.children.len() as i64)) > 2 {
          let mut valueNode : CodeNode = node_1.children[2 as usize].clone();
          wr.out(format!("{}{}", self.adjustType(pvar_1.compiledName.clone()), ":".to_string()), false);
          self.WalkNode(valueNode.clone(), ctx.clone(), wr.clone());
          wr.out(", ".to_string(), true);
        } else {
          if  (pvar_1).isArray() {
            wr.out(format!("{}{}", self.adjustType(pvar_1.compiledName.clone()), ": Vec::new(), ".to_string()), true);
          } else {
            if  pvar_1.is_optional {
              wr.out(format!("{}{}", self.adjustType(pvar_1.compiledName.clone()), ": None, ".to_string()), true);
            }
          }
        }
      }
    }
    wr.indent(-1);
    wr.out("};".to_string(), true);
    wr.newline();
    if  cl.has_constructor {
      let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      if  constr_1.is_some() {
        let mut c_1 : RangerAppFunctionDesc = constr_1.unwrap();
        let mut subCtx : Option<RangerAppWriterContext> = c_1.fnCtx;
        if  subCtx.is_some() {
          let mut sCtx : RangerAppWriterContext = subCtx.unwrap();
          sCtx.is_function = true;
          let mut fnB : CodeNode = c_1.fnBody.clone().unwrap();
          self.WalkNode(fnB.clone(), sCtx.clone(), wr.clone());
        }
      }
    }
    wr.out("return me;".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    self.thisName = "self".to_string();
    for i_3 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_3 as usize].clone();
      let mut vnn : CodeNode = variant.nameNode.clone().unwrap();
      if  vnn.hasFlag("main".to_string()) {
        continue;
      }
      wr.out(format!("{}{}", (format!("{}{}", "pub fn ".to_string(), variant.name)), "(".to_string()), false);
      self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
      wr.out(") -> ".to_string(), false);
      self.writeTypeDef(vnn.clone(), ctx.clone(), wr.clone());
      wr.out(" {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : Option<RangerAppWriterContext> = variant.fnCtx;
      if  subCtx_1.is_some() {
        let mut sCtx_1 : RangerAppWriterContext = subCtx_1.unwrap();
        sCtx_1.is_function = true;
        let mut fnB_1 : CodeNode = variant.fnBody.clone().unwrap();
        self.WalkNode(fnB_1.clone(), sCtx_1.clone(), wr.clone());
      }
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_4 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_4 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_5 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_5 as usize].clone();
        wr.out(format!("{}{}", (format!("{}{}", "fn ".to_string(), variant_1.name)), "(".to_string()), false);
        wr.out("&mut self, ".to_string(), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") -> ".to_string(), false);
        let mut vnn_1 : CodeNode = variant_1.nameNode.clone().unwrap();
        self.writeTypeDef(vnn_1.clone(), ctx.clone(), wr.clone());
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : Option<RangerAppWriterContext> = variant_1.fnCtx;
        if  subCtx_2.is_some() {
          let mut sCtx_2 : RangerAppWriterContext = subCtx_2.unwrap();
          sCtx_2.is_function = true;
          let mut fnB_2 : CodeNode = variant_1.fnBody.clone().unwrap();
          self.WalkNode(fnB_2.clone(), sCtx_2.clone(), wr.clone());
        }
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_6 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_6 as usize].clone();
      let mut nn_1 : CodeNode = variant_2.nameNode.clone().unwrap();
      if  nn_1.hasFlag("main".to_string()) {
        wr.out("fn main() {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_3 : Option<RangerAppWriterContext> = variant_2.fnCtx;
        if  subCtx_3.is_some() {
          let mut sCtx_3 : RangerAppWriterContext = subCtx_3.unwrap();
          sCtx_3.is_function = true;
          let mut fnB_3 : CodeNode = variant_2.fnBody.clone().unwrap();
          self.WalkNode(fnB_3.clone(), sCtx_3.clone(), wr.clone());
        }
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    if  prevClass.is_some() {
      ctx.setCurrentClass(prevClass.unwrap());
    }
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "=".to_string() {
      let mut left : CodeNode = node.getSecond();
      let mut right : CodeNode = node.getThird();
      let mut is_optional : bool = false;
      let mut is_self_ref : bool = false;
      let mut field_type_name : String = "".to_string();
      let mut left_is_self_field : bool = false;
      let mut left_is_array : bool = false;
      if  left.hasParamDesc {
        let mut pp : Option<RangerAppParamDesc> = left.paramDesc;
        is_optional = pp.is_optional;
        left_is_self_field = pp.is_class_variable;
        let mut nameN : Option<CodeNode> = pp.nameNode;
        if  nameN.is_some() {
          let mut nn : CodeNode = nameN.unwrap();
          field_type_name = nn.type_name.clone();
          if  nn.value_type == 6 {
            left_is_array = true;
          }
          let mut oc : Option<RangerAppClassDesc> = pp.propertyClass;
          if  oc.is_some() {
            let mut ownerClass : RangerAppClassDesc = oc.unwrap();
            if  ownerClass.name == field_type_name {
              is_self_ref = true;
            }
          }
        }
      }
      if  left_is_array {
        is_optional = false;
      }
      let mut should_clone_rhs : bool = false;
      let mut rhs_is_string : bool = false;
      let mut rhs_is_object : bool = false;
      let mut rhs_is_optional : bool = false;
      if  right.hasParamDesc {
        let mut rp : Option<RangerAppParamDesc> = right.paramDesc;
        rhs_is_optional = rp.is_optional;
        let mut rNameN : Option<CodeNode> = rp.nameNode;
        if  rNameN.is_some() {
          let mut rnn : CodeNode = rNameN.unwrap();
          if  rnn.type_name == "string".to_string() {
            rhs_is_string = true;
          }
          let mut rv_type : i64 = rnn.value_type;
          if  (rv_type == 10) || (rv_type == 11) {
            rv_type = rnn.typeNameAsType(ctx.clone());
          }
          if  rv_type == 10 {
            rhs_is_object = true;
          }
          if  rv_type == 6 {
            rhs_is_object = true;
          }
        }
        if  left_is_self_field {
          if  rhs_is_string || rhs_is_object {
            should_clone_rhs = true;
          }
        }
        if  rhs_is_string {
          should_clone_rhs = true;
        }
        if  rhs_is_object {
          should_clone_rhs = true;
        }
        if  rhs_is_optional {
          should_clone_rhs = true;
        }
      }
      if  right.value_type == 11 {
        if  right.hasParamDesc {
          let mut rp_1 : Option<RangerAppParamDesc> = right.paramDesc;
          rhs_is_optional = rp_1.is_optional;
          let mut rNameN_1 : Option<CodeNode> = rp_1.nameNode;
          if  rNameN_1.is_some() {
            let mut rnn_1 : CodeNode = rNameN_1.unwrap();
            if  rnn_1.type_name == "string".to_string() {
              rhs_is_string = true;
            }
            let mut rv_type_1 : i64 = rnn_1.value_type;
            if  (rv_type_1 == 10) || (rv_type_1 == 11) {
              rv_type_1 = rnn_1.typeNameAsType(ctx.clone());
            }
            if  rv_type_1 == 10 {
              rhs_is_object = true;
            }
            if  rv_type_1 == 6 {
              rhs_is_object = true;
            }
          }
          if  left_is_self_field {
            if  rhs_is_string || rhs_is_object {
              should_clone_rhs = true;
            }
          }
          if  rhs_is_string {
            should_clone_rhs = true;
          }
          if  rhs_is_object {
            should_clone_rhs = true;
          }
          if  rhs_is_optional {
            should_clone_rhs = true;
          }
        }
      }
      ctx.setInExpr();
      self.WalkNode(left.clone(), ctx.clone(), wr.clone());
      if  is_optional {
        if  rhs_is_optional {
          wr.out(" = ".to_string(), false);
          self.WalkNode(right.clone(), ctx.clone(), wr.clone());
          wr.out(".clone();".to_string(), true);
        } else {
          if  is_self_ref {
            wr.out(" = Some(Box::new(".to_string(), false);
            self.WalkNode(right.clone(), ctx.clone(), wr.clone());
            wr.out(".clone()));".to_string(), true);
          } else {
            wr.out(" = Some(".to_string(), false);
            self.WalkNode(right.clone(), ctx.clone(), wr.clone());
            if  should_clone_rhs {
              wr.out(".clone()".to_string(), false);
            }
            wr.out(");".to_string(), true);
          }
        }
      } else {
        wr.out(" = ".to_string(), false);
        self.WalkNode(right.clone(), ctx.clone(), wr.clone());
        if  should_clone_rhs {
          wr.out(".clone()".to_string(), false);
        }
        wr.out(";".to_string(), true);
      }
      ctx.unsetInExpr();
      return;
    }
    if  cmd == "return".to_string() {
      let cnt : i64 = node.children.length;
      if  cnt > 1 {
        let mut retVal : CodeNode = node.getSecond();
        if  retVal.hasFnCall {
          let mut retFc : CodeNode = retVal.getFirst();
          let mut isSelfCall : bool = false;
          if  ((retFc.ns.len() as i64)) > 0 {
            let firstPart : String = retFc.ns[0 as usize].clone();
            if  firstPart == "this".to_string() {
              isSelfCall = true;
            }
          }
          if  isSelfCall {
            let mut givenArgs : CodeNode = retVal.getSecond();
            let mut tempVars : Vec<String> = Vec::new();
            let mut tempIdx : i64 = 0;
            for i in 0..givenArgs.children.len() {
              let mut arg = givenArgs.children[i as usize].clone();
              if  arg.hasFnCall {
                let mut argFc : CodeNode = arg.getFirst();
                if  ((argFc.ns.len() as i64)) > 0 {
                  let argFirstPart : String = argFc.ns[0 as usize].clone();
                  if  argFirstPart == "this".to_string() {
                    let tmpName : String = ctx.rustGetTempVar();
                    wr.out(format!("{}{}", (format!("{}{}", "let ".to_string(), tmpName)), " = ".to_string()), false);
                    ctx.setInExpr();
                    self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
                    ctx.unsetInExpr();
                    wr.out(";".to_string(), true);
                    tempVars.push(tmpName);
                    tempIdx = tempIdx + 1;
                  } else {
                    tempVars.push("".to_string().to_string());
                  }
                } else {
                  tempVars.push("".to_string().to_string());
                }
              } else {
                tempVars.push("".to_string().to_string());
              }
            }
            if  tempIdx > 0 {
              wr.out("return ".to_string(), false);
              self.WriteVRef(retFc.clone(), ctx.clone(), wr.clone());
              wr.out("(".to_string(), false);
              for i_1 in 0..retVal.fnDesc.params.len() {
                let mut arg_1 = retVal.fnDesc.params[i_1 as usize].clone();
                if  i_1 > 0 {
                  wr.out(", ".to_string(), false);
                }
                let tmpVar : String = tempVars[i_1 as usize].clone();
                if  (tmpVar.len() as i64) > 0 {
                  wr.out(tmpVar.clone(), false);
                } else {
                  let mut n : Option<CodeNode> = givenArgs.children[i_1 as usize].clone();
                  if  n.is_some() {
                    let mut nVal : CodeNode = n.unwrap();
                    ctx.setInExpr();
                    self.WalkNode(nVal.clone(), ctx.clone(), wr.clone());
                    ctx.unsetInExpr();
                    let mut argNameN : CodeNode = arg_1.nameNode.clone().unwrap();
                    if  (argNameN.type_name == "string".to_string()) && (nVal.value_type == 11) {
                      wr.out(".clone()".to_string(), false);
                    }
                  }
                }
              }
              wr.out(")".to_string(), false);
              let tn : String = retVal.eval_type_name.clone();
              if  (tn == "string".to_string()) || (retVal.eval_type == 10) {
                wr.out(".clone()".to_string(), false);
              }
              wr.out(";".to_string(), true);
              return;
            }
          }
        }
        wr.out("return ".to_string(), false);
        ctx.setInExpr();
        self.WalkNode(retVal.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        let tn_1 : String = retVal.eval_type_name.clone();
        if  (tn_1 == "string".to_string()) || (retVal.eval_type == 10) {
          wr.out(".clone()".to_string(), false);
        }
        wr.out(";".to_string(), true);
      } else {
        wr.out("return;".to_string(), true);
      }
      return;
    }
    if  cmd == "push".to_string() {
      let mut left_1 : CodeNode = node.getSecond();
      let mut right_1 : CodeNode = node.getThird();
      let mut arr_type : String = "".to_string();
      if  left_1.hasParamDesc {
        let mut pp_1 : Option<RangerAppParamDesc> = left_1.paramDesc;
        arr_type = pp_1.nameNode.array_type.clone();
      }
      ctx.setInExpr();
      self.WalkNode(left_1.clone(), ctx.clone(), wr.clone());
      wr.out(".push(".to_string(), false);
      self.WalkNode(right_1.clone(), ctx.clone(), wr.clone());
      if  arr_type == "string".to_string() {
        if  right_1.value_type == 4 {
          wr.out(".to_string()".to_string(), false);
        }
      }
      if  right_1.value_type == 11 {
        if  arr_type != "string".to_string() {
          if  arr_type != "int".to_string() {
            if  arr_type != "double".to_string() {
              if  arr_type != "boolean".to_string() {
                wr.out(".clone()".to_string(), false);
              }
            }
          }
        }
      }
      ctx.unsetInExpr();
      wr.out(");".to_string(), true);
      return;
    }
    if  cmd == "unwrap".to_string() {
      let mut arg_2 : CodeNode = node.getSecond();
      let mut needs_deref : bool = false;
      let mut is_self_field : bool = false;
      let mut inner_type : String = "".to_string();
      if  arg_2.hasParamDesc {
        let mut pp_2 : Option<RangerAppParamDesc> = arg_2.paramDesc;
        is_self_field = pp_2.is_class_variable;
        let mut nameN_1 : Option<CodeNode> = pp_2.nameNode;
        if  nameN_1.is_some() {
          let mut nn_1 : CodeNode = nameN_1.unwrap();
          inner_type = nn_1.type_name.clone();
          let mut oc_1 : Option<RangerAppClassDesc> = pp_2.propertyClass;
          if  oc_1.is_some() {
            let mut ownerClass_1 : RangerAppClassDesc = oc_1.unwrap();
            if  ownerClass_1.name == inner_type {
              needs_deref = true;
            }
          }
        }
      }
      ctx.setInExpr();
      if  needs_deref {
        wr.out("(*".to_string(), false);
        self.WalkNode(arg_2.clone(), ctx.clone(), wr.clone());
        if  is_self_field {
          wr.out(".clone().unwrap())".to_string(), false);
        } else {
          wr.out(".unwrap())".to_string(), false);
        }
      } else {
        self.WalkNode(arg_2.clone(), ctx.clone(), wr.clone());
        if  is_self_field {
          wr.out(".clone().unwrap()".to_string(), false);
        } else {
          wr.out(".unwrap()".to_string(), false);
        }
      }
      ctx.unsetInExpr();
      return;
    }
  }
}
#[derive(Clone)]
struct RangerKotlinClassWriter { 
  compiler : Option<LiveCompiler>, 
}
impl RangerKotlinClassWriter { 
  
  pub fn new() ->  RangerKotlinClassWriter {
    let mut me = RangerKotlinClassWriter { 
      compiler: None, 
    };
    return me;
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(node.getParsedString(), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "CharArray".to_string().clone();
        break;
      case "char".to_string() : 
        return "Char".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "CharArray".to_string().clone();
        break;
      case "char".to_string() : 
        return "Char".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    if  node.eval_type != 0 {
      v_type = node.eval_type;
    }
    switch (v_type ) { 
      case 13 : 
        wr.out("Int".to_string(), false);
        break;
      case 3 : 
        wr.out("Int".to_string(), false);
        break;
      case 2 : 
        wr.out("Double".to_string(), false);
        break;
      case 14 : 
        wr.out("Char".to_string(), false);
        break;
      case 15 : 
        wr.out("CharArray".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 5 : 
        wr.out("Boolean".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "MutableMap<".to_string(), self.getObjectTypeString(node.key_type.clone(), ctx.clone()))), ",".to_string())), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), ">".to_string()), false);
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "MutableList<".to_string(), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), ">".to_string()), false);
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("Unit".to_string(), false);
        } else {
          wr.out(self.getTypeString(node.type_name.clone()), false);
        }
        break;
    }
    if  node.hasFlag("optional".to_string()) {
      wr.out("?".to_string(), false);
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("this".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    /** unused:  let max_len : i64 = (node.ns.len() as i64);   **/ 
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("this".to_string(), false);
            continue;
          }
          let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          if  uc.is_some() {
            let mut currC : RangerAppClassDesc = uc.unwrap();
            if  part == currC.name {
              if  false == ctx.isInStatic() {
                wr.out("this".to_string(), false);
                continue;
              }
            }
          }
          if  ctx.isMemberVariable(part.clone()) {
            if  false == ctx.isInStatic() {
              wr.out("this.".to_string(), false);
            }
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  i == 0 {
          if  p.nameNode.hasFlag("optional".to_string()) {
            wr.out("!!".to_string(), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_1 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      if  i_1 == 0 {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        if  uc_1.is_some() {
          let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
          if  part_1 == currC_1.name {
            if  false == ctx.isInStatic() {
              wr.out("this".to_string(), false);
              continue;
            }
          }
        }
      }
      wr.out(self.adjustType(part_1.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out("var ".to_string(), false);
      } else {
        wr.out("val ".to_string(), false);
      }
      wr.out(p.compiledName.clone(), false);
      wr.out(" : ".to_string(), false);
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = arrayListOf()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = hashMapOf()".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(" ".to_string(), false);
      wr.out(node.clDesc.name.clone(), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut wr : CodeWriter = orig_wr;
    /** unused:  let mut importFork : CodeWriter = wr.fork();   **/ 
    wr.out("".to_string(), true);
    wr.out(format!("{}{}", "class ".to_string(), cl.name), false);
    if  cl.has_constructor {
      let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
      wr.out("(".to_string(), false);
      self.writeArgsDef(constr.clone(), ctx.clone(), wr.clone());
      wr.out(" ) ".to_string(), true);
    }
    wr.out(" {".to_string(), true);
    wr.indent(1);
    for i in 0..cl.variables.len() {
      let mut pvar = cl.variables[i as usize].clone();
      self.writeVarDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      wr.out("".to_string(), true);
      wr.out("init {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    if  ((cl.static_methods.len() as i64)) > 0 {
      wr.out("companion object {".to_string(), true);
      wr.indent(1);
    }
    for i_1 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_1 as usize].clone();
      wr.out("".to_string(), true);
      if  variant.nameNode.hasFlag("main".to_string()) {
        continue;
      }
      wr.out("fun ".to_string(), false);
      wr.out(" ".to_string(), false);
      wr.out(format!("{}{}", variant.name, "(".to_string()), false);
      self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
      wr.out(") : ".to_string(), false);
      self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    if  ((cl.static_methods.len() as i64)) > 0 {
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_2 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_2 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_3 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_3 as usize].clone();
        wr.out("".to_string(), true);
        wr.out("fun ".to_string(), false);
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant_1.name, "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") : ".to_string(), false);
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_4 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_4 as usize].clone();
      wr.out("".to_string(), true);
      if  variant_2.nameNode.hasFlag("main".to_string()) && (variant_2.nameNode.code.filename == ctx.getRootFile()) {
        wr.out("fun main(args : Array<String>) {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_3 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
        subCtx_3.is_function = true;
        self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_3.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
  }
}
#[derive(Clone)]
struct RangerCSharpClassWriter { 
  compiler : Option<LiveCompiler>, 
}
impl RangerCSharpClassWriter { 
  
  pub fn new() ->  RangerCSharpClassWriter {
    let mut me = RangerCSharpClassWriter { 
      compiler: None, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "dynamic".to_string().clone();
      }
      if  cc.is_system {
        let sysName : Option<String> = cc.systemNames.get("csharp".to_string());
        if  sysName.is_some() {
          return sysName.unwrap().clone();
        } else {
          let mut node : CodeNode = CodeNode::new(SourceCode::new("".to_string()), 0, 0);
          ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), type_string)), "defined for C# ".to_string()));
        }
      }
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "byte[]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "byte[]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "double".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeLambdaType(&mut self, mut expression_value : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut rv : CodeNode = expression_value.children[0 as usize].clone();
    let mut sec : CodeNode = expression_value.children[1 as usize].clone();
    /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
    let mut is_void : bool = false;
    if  (rv.type_name == "void".to_string()) || (rv.eval_type_name == "void".to_string()) {
      is_void = true;
    }
    if  is_void {
      wr.out("Action".to_string(), false);
      if  ((sec.children.len() as i64)) > 0 {
        wr.out("<".to_string(), false);
      }
    } else {
      wr.out("Func<".to_string(), false);
    }
    for i in 0..sec.children.len() {
      let mut arg = sec.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
    }
    if  is_void == false {
      if  ((sec.children.len() as i64)) > 0 {
        wr.out(", ".to_string(), false);
      }
      self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
    }
    if  is_void {
      if  ((sec.children.len() as i64)) > 0 {
        wr.out(">".to_string(), false);
      }
    } else {
      wr.out(">".to_string(), false);
    }
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        self.writeLambdaType((*node.expression_value.clone().unwrap()), ctx.clone(), wr.clone());
        break;
      case 13 : 
        wr.out("int".to_string(), false);
        break;
      case 3 : 
        wr.out("int".to_string(), false);
        break;
      case 2 : 
        wr.out("double".to_string(), false);
        break;
      case 14 : 
        wr.out("byte".to_string(), false);
        break;
      case 15 : 
        wr.out("byte[]".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 5 : 
        wr.out("bool".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "Dictionary<".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), ",".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), ">".to_string()), false);
        wr.addImport("System.Collections".to_string());
        wr.addImport("System.Collections.Generic".to_string());
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "List<".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), ">".to_string()), false);
        wr.addImport("System.Collections".to_string());
        wr.addImport("System.Collections.Generic".to_string());
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("void".to_string(), false);
          return;
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_union {
            wr.out("dynamic".to_string(), false);
            return;
          }
          if  cc.is_system {
            let sysName : Option<String> = cc.systemNames.get("csharp".to_string());
            if  sysName.is_some() {
              wr.out(sysName.unwrap(), false);
            } else {
              ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), t_name)), "defined for C# ".to_string()));
            }
            return;
          }
        }
        wr.out(self.getTypeString(node.type_name.clone()), false);
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            if  ctx.inLambda() {
              wr.out("this".to_string(), false);
            } else {
              wr.out("this".to_string(), false);
            }
            continue;
          }
        }
        if  i == 0 {
          if  p.nameNode.hasFlag("optional".to_string()) {
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_1 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      wr.out(self.adjustType(part_1.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out("".to_string(), false);
      } else {
        wr.out("".to_string(), false);
      }
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = new ".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("()".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    /** unused:  let mut fName : CodeNode = node.children[1 as usize].clone();   **/ 
    let mut body : CodeNode = node.children[2 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    wr.out("(".to_string(), false);
    wr.out("(".to_string(), false);
    self.writeLambdaType(node.clone(), ctx.clone(), wr.clone());
    wr.out(")".to_string(), false);
    wr.out("(".to_string(), false);
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.flow_done == false {
        self.compiler.parser.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    wr.out(" => { ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), false);
    wr.out("))".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(format!("{}{}", (format!("{}{}", " ".to_string(), arg.compiledName)), " ".to_string()), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("new List<".to_string(), false);
    wr.out(self.getObjectTypeString(node.eval_array_type.clone(), ctx.clone()), false);
    wr.out("> {".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("}".to_string(), false);
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut wr : CodeWriter = orig_wr;
    self.import_lib("System".to_string(), ctx.clone(), wr.clone());
    wr.out(format!("{}{}", (format!("{}{}", "class ".to_string(), cl.name)), " ".to_string()), false);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" : ".to_string(), false);
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        wr.out(pName.clone(), false);
      }
    }
    wr.out(" {".to_string(), true);
    wr.indent(1);
    wr.createTag("utilities".to_string());
    for i_1 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_1 as usize].clone();
      wr.out("public ".to_string(), false);
      self.writeVarDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
      wr.out(format!("{}{}", cl.name, "(".to_string()), false);
      self.writeArgsDef(constr.clone(), ctx.clone(), wr.clone());
      wr.out(" ) {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_2 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_2 as usize].clone();
      if  variant.nameNode.hasFlag("main".to_string()) && (variant.nameNode.code.filename != ctx.getRootFile()) {
        continue;
      }
      if  variant.nameNode.hasFlag("main".to_string()) {
        wr.out("static void Main( string [] args ) {".to_string(), true);
      } else {
        wr.out("public static ".to_string(), false);
        self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant.name, "(".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
      }
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_3 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_3 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_4 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_4 as usize].clone();
        wr.out("public ".to_string(), false);
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant_1.name, "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
        wr.indent(1);
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct RangerScalaClassWriter { 
  compiler : Option<LiveCompiler>, 
  init_done : bool, 
}
impl RangerScalaClassWriter { 
  
  pub fn new() ->  RangerScalaClassWriter {
    let mut me = RangerScalaClassWriter { 
      compiler: None, 
      init_done:false, 
    };
    return me;
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "Any".to_string().clone();
      }
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "Array[Byte]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "Int".to_string().clone();
        break;
      case "string".to_string() : 
        return "String".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "Boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "Double".to_string().clone();
        break;
      case "chararray".to_string() : 
        return "Array[Byte]".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFlag("optional".to_string()) {
      wr.out("Option[".to_string(), false);
    }
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        let mut is_void : bool = false;
        if  (rv.type_name == "void".to_string()) || (rv.eval_type_name == "void".to_string()) {
          is_void = true;
        }
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(")".to_string(), false);
        if  is_void {
          wr.out("=> Unit".to_string(), false);
        } else {
          wr.out("=> ".to_string(), false);
          self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        }
        break;
      case 13 : 
        wr.out("Int".to_string(), false);
        break;
      case 3 : 
        wr.out("Int".to_string(), false);
        break;
      case 2 : 
        wr.out("Double".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 5 : 
        wr.out("Boolean".to_string(), false);
        break;
      case 14 : 
        wr.out("Byte".to_string(), false);
        break;
      case 15 : 
        wr.out("Array[Byte]".to_string(), false);
        break;
      case 7 : 
        wr.addImport("scala.collection.mutable".to_string());
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "collection.mutable.HashMap[".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), ", ".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      case 6 : 
        wr.addImport("scala.collection.mutable".to_string());
        wr.out(format!("{}{}", (format!("{}{}", "collection.mutable.ArrayBuffer[".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      default: 
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_union {
            wr.out("Any".to_string(), false);
            if  node.hasFlag("optional".to_string()) {
              wr.out("]".to_string(), false);
            }
            return;
          }
        }
        if  node.type_name == "void".to_string() {
          wr.out("Unit".to_string(), false);
          return;
        }
        wr.out(self.getTypeString(t_name.clone()), false);
        break;
    }
    if  node.hasFlag("optional".to_string()) {
      wr.out("]".to_string(), false);
    }
  }
  fn writeTypeDefNoOption(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    if  node.eval_type != 0 {
      v_type = node.eval_type;
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        let mut is_void : bool = false;
        if  (rv.type_name == "void".to_string()) || (rv.eval_type_name == "void".to_string()) {
          is_void = true;
        }
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(")".to_string(), false);
        if  is_void {
          wr.out("=> Unit".to_string(), false);
        } else {
          wr.out("=> ".to_string(), false);
          self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        }
        break;
      case 13 : 
        wr.out("Int".to_string(), false);
        break;
      case 3 : 
        wr.out("Int".to_string(), false);
        break;
      case 2 : 
        wr.out("Double".to_string(), false);
        break;
      case 4 : 
        wr.out("String".to_string(), false);
        break;
      case 5 : 
        wr.out("Boolean".to_string(), false);
        break;
      case 14 : 
        wr.out("Byte".to_string(), false);
        break;
      case 15 : 
        wr.out("Array[Byte]".to_string(), false);
        break;
      case 7 : 
        wr.addImport("scala.collection.mutable".to_string());
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "collection.mutable.HashMap[".to_string(), self.getObjectTypeString(node.key_type.clone(), ctx.clone()))), ", ".to_string())), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      case 6 : 
        wr.addImport("scala.collection.mutable".to_string());
        wr.out(format!("{}{}", (format!("{}{}", "collection.mutable.ArrayBuffer[".to_string(), self.getObjectTypeString(node.array_type.clone(), ctx.clone()))), "]".to_string()), false);
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("Unit".to_string(), false);
          return;
        }
        wr.out(self.getTypeString(node.type_name.clone()), false);
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("this".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("this".to_string(), false);
            continue;
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  i == 0 {
          if  p.nameNode.hasFlag("optional".to_string()) {
            wr.out(".get".to_string(), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    for i_1 in 0..node.ns.len() {
      let mut part_1 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      wr.out(self.adjustType(part_1.clone()), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut p : Option<RangerAppParamDesc> = node.paramDesc;
      /** unused:  let mut nn : CodeNode = node.children[1 as usize].clone();   **/ 
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused ".to_string(), false);
      }
      if  (p.set_cnt > 0) || p.is_class_variable {
        wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " ".to_string()), false);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "val ".to_string(), p.compiledName)), " ".to_string()), false);
      }
      let ti_ok : bool = ctx.canUseTypeInference((p.nameNode.clone().unwrap()));
      if  (false == ti_ok) || ((false == p.nameNode.hasFlag("optional".to_string())) && (((node.children.len() as i64)) == 2)) {
        wr.out(": ".to_string(), false);
        self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
      }
      if  ((node.children.len() as i64)) > 2 {
        wr.out("= ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        let mut b_inited : bool = false;
        if  p.nameNode.value_type == 6 {
          b_inited = true;
          wr.out("= new collection.mutable.ArrayBuffer()".to_string(), false);
        }
        if  p.nameNode.value_type == 7 {
          b_inited = true;
          wr.out("= new collection.mutable.HashMap()".to_string(), false);
        }
        if  p.nameNode.hasFlag("optional".to_string()) {
          wr.out(" = Option.empty[".to_string(), false);
          self.writeTypeDefNoOption(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out("]".to_string(), false);
        } else {
          if  b_inited == false {
            wr.out("= _".to_string(), false);
          }
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("**/ ".to_string(), true);
      } else {
        wr.newline();
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      wr.out(format!("{}{}", arg.compiledName, " : ".to_string()), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn writeFnEnd(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.indent(-1);
    wr.out("} catch {".to_string(), true);
    wr.indent(1);
    wr.out("case rv:ScalaReturnValue => {".to_string(), true);
    wr.indent(1);
    wr.out("__returns__ = rv.value".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out("__returns__.asInstanceOf[".to_string(), false);
    self.writeTypeDef(node.clone(), ctx.clone(), wr.clone());
    wr.out("]".to_string(), true);
  }
  fn writeFnStart(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("var __returns__ : Any = null".to_string(), true);
    wr.out("try {".to_string(), true);
    wr.indent(1);
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "for".to_string() {
      let mut listNode : CodeNode = node.children[1 as usize].clone();
      let mut itemNode : CodeNode = node.children[2 as usize].clone();
      let mut indexNode : CodeNode = node.children[3 as usize].clone();
      let mut bodyNode : CodeNode = node.children[4 as usize].clone();
      let mut break_cnt : i64 = 0;
      let mut continue_cnt : i64 = 0;
      bodyNode.forTree((item, i) => { 
        if  item.isFirstVref("break".to_string()) {
          break_cnt = break_cnt + 1;
        }
        if  item.isFirstVref("continue".to_string()) {
          continue_cnt = continue_cnt + 1;
        }
      }
      );
      if  continue_cnt > 0 {
        ctx.addError(node.clone(), "oops, sorry. Currently Scala output can not handle for-loops with continue :/".to_string());
        return;
      }
      if  break_cnt > 0 {
        wr.addImport("scala.util.control._".to_string());
        wr.out("try {".to_string(), true);
        wr.indent(1);
        wr.out("val __break__ = new Breaks".to_string(), true);
        wr.out("__break__.breakable {".to_string(), true);
        wr.indent(1);
      }
      wr.out("for( ".to_string(), false);
      self.WalkNode(indexNode.clone(), ctx.clone(), wr.clone());
      wr.out(" <- 0 until ".to_string(), false);
      self.WalkNode(listNode.clone(), ctx.clone(), wr.clone());
      wr.out(".length ) {".to_string(), true);
      wr.indent(1);
      wr.out("val ".to_string(), false);
      self.WalkNode(itemNode.clone(), ctx.clone(), wr.clone());
      wr.out(" = ".to_string(), false);
      self.WalkNode(listNode.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      self.WalkNode(indexNode.clone(), ctx.clone(), wr.clone());
      wr.out(")".to_string(), true);
      self.WalkNode(bodyNode.clone(), ctx.clone(), wr.clone());
      wr.indent(-1);
      wr.out("}".to_string(), true);
      if  break_cnt > 0 {
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      return;
    }
    if  cmd == "try".to_string() {
      let mut tryBlock : CodeNode = node.getSecond();
      let mut catchBlock : CodeNode = node.getThird();
      wr.out("try {".to_string(), true);
      wr.indent(1);
      self.WalkNode(tryBlock.clone(), ctx.clone(), wr.clone());
      wr.indent(-1);
      wr.out("} catch {".to_string(), true);
      wr.indent(1);
      if  ctx.inLambda() {
        wr.out("case rv:ScalaReturnValue => {".to_string(), true);
        wr.indent(1);
        wr.out("throw new ScalaReturnValue(rv.value)".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      wr.out("case e: Exception => {".to_string(), true);
      wr.indent(1);
      self.WalkNode(catchBlock.clone(), ctx.clone(), wr.clone());
      wr.indent(-1);
      wr.out("}".to_string(), true);
      wr.indent(-1);
      wr.out("}".to_string(), true);
      return;
    }
    if  cmd == "return".to_string() {
      if  ((node.children.len() as i64)) > 1 {
        let mut rValue : CodeNode = node.getSecond();
        if  ctx.getFlag("last_returns".to_string()) {
          self.WalkNode(rValue.clone(), ctx.clone(), wr.clone());
          return;
        }
        if  ctx.inLambda() {
          wr.out("throw new ScalaReturnValue(".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(rValue.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.out(")".to_string(), true);
        } else {
          wr.out("return ".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(rValue.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.out("  ".to_string(), true);
        }
      } else {
        if  ctx.inLambda() {
          wr.out("throw new ScalaReturnValue(null)".to_string(), true);
        } else {
          wr.out("return".to_string(), true);
        }
      }
      return;
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fnDef : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    lambdaCtx.is_lambda = true;
    wr.out("((".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.flow_done == false {
        self.compiler.parser.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      wr.out(" : ".to_string(), false);
      self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    let mut return_cnt : i64 = 0;
    let line_cnt : i64 = (body.children.len() as i64);
    body.forTree((item, i) => { 
      if  item.isFirstVref("return".to_string()) {
        return_cnt = return_cnt + 1;
      }
    }
    );
    if  line_cnt == 1 {
      return_cnt = 1;
    }
    if  fnDef.type_name != "void".to_string() {
      if  return_cnt == 1 {
        if  line_cnt > 1 {
          wr.out(" => { ".to_string(), true);
          wr.indent(1);
          lambdaCtx.restartExpressionLevel();
        } else {
          wr.out(" => ".to_string(), false);
          lambdaCtx.setInExpr();
        }
        lambdaCtx.setFlag("last_returns".to_string(), true);
        for i_1 in 0..body.children.len() {
          let mut item = body.children[i_1 as usize].clone();
          self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
        }
        if  line_cnt > 1 {
          wr.newline();
          wr.indent(-1);
          wr.out("}".to_string(), false);
        } else {
          lambdaCtx.unsetInExpr();
        }
        wr.out(")".to_string(), false);
        return;
      }
    }
    if  (line_cnt > 1) || (return_cnt > 1) {
      wr.out(" => { ".to_string(), true);
      wr.indent(1);
      lambdaCtx.restartExpressionLevel();
    } else {
      wr.out(" => ".to_string(), false);
      lambdaCtx.setInExpr();
    }
    if  fnDef.type_name != "void".to_string() {
      self.writeFnStart(fnDef.clone(), ctx.clone(), wr.clone());
    }
    for i_2 in 0..body.children.len() {
      let mut item_1 = body.children[i_2 as usize].clone();
      self.WalkNode(item_1.clone(), lambdaCtx.clone(), wr.clone());
    }
    if  fnDef.type_name != "void".to_string() {
      self.writeFnEnd(fnDef.clone(), ctx.clone(), wr.clone());
    }
    if  (line_cnt > 1) || (return_cnt > 1) {
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), false);
    } else {
      lambdaCtx.unsetInExpr();
    }
    wr.out(")".to_string(), false);
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("collection.mutable.ArrayBuffer(".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out(")".to_string(), false);
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut wr : CodeWriter = orig_wr;
    if  self.init_done == false {
      wr.out("case class ScalaReturnValue(value:Any) extends Exception".to_string(), true);
      wr.createTag("imports".to_string());
      self.init_done = true;
      wr.createTag("beginning".to_string());
    }
    /** unused:  let mut importFork : CodeWriter = wr.getTag("imports".to_string());   **/ 
    let b_class_has_content : bool = ((cl.has_constructor || (((cl.variables.len() as i64)) > 0)) || (((cl.defined_variants.len() as i64)) > 0)) || (((cl.extends_classes.len() as i64)) > 0);
    if  b_class_has_content {
      if  ((cl.extends_classes.len() as i64)) > 0 {
        for i in 0..cl.extends_classes.len() {
          let mut pName = cl.extends_classes[i as usize].clone();
          let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
          for i_1 in 0..pC.defined_variants.len() {
            let mut fnVar = pC.defined_variants[i_1 as usize].clone();
            let mut mVs : Option<RangerAppMethodVariants> = pC.method_variants.get(fnVar);
            for i_2 in 0..mVs.variants.len() {
              let mut variant = mVs.variants[i_2 as usize].clone();
              declaredFunction.insert(variant.name, true);
            }
          }
        }
      }
      wr.out(format!("{}{}", (format!("{}{}", "class ".to_string(), cl.name)), " ".to_string()), false);
      if  cl.has_constructor {
        wr.out("(".to_string(), false);
        let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
        for i_3 in 0..constr.params.len() {
          let mut arg = constr.params[i_3 as usize].clone();
          if  i_3 > 0 {
            wr.out(", ".to_string(), false);
          }
          wr.out(format!("{}{}", arg.name, " : ".to_string()), false);
          self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out(")".to_string(), false);
      }
      if  ((cl.extends_classes.len() as i64)) > 0 {
        wr.out(" extends ".to_string(), false);
        for i_4 in 0..cl.extends_classes.len() {
          let mut pName_1 = cl.extends_classes[i_4 as usize].clone();
          wr.out(pName_1.clone(), false);
        }
      }
      wr.out(" {".to_string(), true);
      wr.indent(1);
      for i_5 in 0..cl.variables.len() {
        let mut pvar = cl.variables[i_5 as usize].clone();
        self.writeVarDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
      }
      if  cl.has_constructor {
        let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
        wr.newline();
        let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
        subCtx.is_function = true;
        self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
        wr.newline();
      }
      for i_6 in 0..cl.defined_variants.len() {
        let mut fnVar_1 = cl.defined_variants[i_6 as usize].clone();
        let mut mVs_1 : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar_1);
        for i_7 in 0..mVs_1.variants.len() {
          let mut variant_1 = mVs_1.variants[i_7 as usize].clone();
          if  declaredFunction.contains_key(&variant_1.name) {
            wr.out("override ".to_string(), false);
          }
          wr.out("def ".to_string(), false);
          wr.out(" ".to_string(), false);
          wr.out(format!("{}{}", variant_1.name, "(".to_string()), false);
          self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
          wr.out(") : ".to_string(), false);
          self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(" = ".to_string(), false);
          let mut return_cnt : i64 = 0;
          let line_cnt : i64 = (variant_1.fnBody.children.len() as i64);
          variant_1.fnBody.forTree((item, i) => { 
            if  item.isFirstVref("return".to_string()) {
              return_cnt = return_cnt + 1;
            }
          }
          );
          let mut subCtx_1 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
          subCtx_1.is_function = true;
          if  return_cnt <= 1 {
            subCtx_1.setFlag("last_returns".to_string(), true);
            if  line_cnt > 1 {
              wr.out(" { ".to_string(), true);
              wr.indent(1);
            } else {
              subCtx_1.setInExpr();
            }
            self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
            if  line_cnt > 1 {
              wr.newline();
              wr.indent(-1);
              wr.out("}".to_string(), true);
            } else {
              subCtx_1.unsetInExpr();
              wr.newline();
            }
          } else {
            wr.out(" {".to_string(), true);
            wr.indent(1);
            wr.newline();
            self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
            wr.newline();
            wr.indent(-1);
            wr.out("}".to_string(), true);
          }
        }
      }
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    let mut b_has_non_main_static : bool = false;
    let mut b_had_app : bool = false;
    let mut app_obj : Option<RangerAppFunctionDesc> = None;
    operatorsOf::forEach_29(cl.static_methods, (item, index) => { 
      if  item.name != "main".to_string() {
        b_has_non_main_static = true;
      } else {
        b_had_app = true;
        let mut it : RangerAppFunctionDesc = item;
        app_obj = Some(it.clone());
      }
    }
    );
    if  b_has_non_main_static {
      wr.out("".to_string(), true);
      wr.out([(format!("{}{}", (format!("{}{}", "// companion object for static methods of ".to_string(), cl.name)), " static cnt == ".to_string())) , (((cl.static_methods.len() as i64)).to_string()) ].join(""), true);
      wr.out(format!("{}{}", (format!("{}{}", "object ".to_string(), cl.name)), " {".to_string()), true);
      wr.indent(1);
      for i_8 in 0..cl.static_methods.len() {
        let mut variant_2 = cl.static_methods[i_8 as usize].clone();
        if  variant_2.nameNode.hasFlag("main".to_string()) {
          continue;
        }
        wr.out("def ".to_string(), false);
        wr.out(" ".to_string(), false);
        wr.out(format!("{}{}", variant_2.name, "(".to_string()), false);
        self.writeArgsDef(variant_2.clone(), ctx.clone(), wr.clone());
        wr.out(") : ".to_string(), false);
        self.writeTypeDef(variant_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" = {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    if  b_had_app {
      let mut variant_3 : Option<RangerAppFunctionDesc> = app_obj;
      let b_scalafiddle : bool = ctx.hasCompilerFlag("scalafiddle".to_string());
      let mut theEnd : CodeWriter = wr.getTag("file_end".to_string());
      if  b_scalafiddle {
        theEnd = wr.getTag("beginning".to_string());
        theEnd.out("".to_string(), true);
        theEnd.out("// -----------  the scalafiddle main function begins ---------".to_string(), true);
      }
      if  b_scalafiddle == false {
        theEnd.out("".to_string(), true);
        theEnd.out(format!("{}{}", "// application main function for ".to_string(), cl.name), true);
        theEnd.out(format!("{}{}", (format!("{}{}", "object App".to_string(), cl.name)), " extends App {".to_string()), true);
        theEnd.indent(1);
        theEnd.newline();
      }
      let mut subCtx_3 : RangerAppWriterContext = variant_3.fnCtx.clone().unwrap();
      subCtx_3.is_function = true;
      self.WalkNode(variant_3.fnBody.clone().unwrap(), subCtx_3.clone(), theEnd.clone());
      if  b_scalafiddle {
        theEnd.out("// -----------  the scalafiddle main function ends ---------".to_string(), true);
        theEnd.out("".to_string(), true);
      }
      if  b_scalafiddle == false {
        theEnd.newline();
        theEnd.indent(-1);
        theEnd.out("}".to_string(), true);
      }
    }
  }
}
#[derive(Clone)]
struct RangerGolangClassWriter { 
  compiler : Option<LiveCompiler>, 
  thisName : String, 
  write_raw_type : bool, 
  did_write_nullable : bool, 
}
impl RangerGolangClassWriter { 
  
  pub fn new() ->  RangerGolangClassWriter {
    let mut me = RangerGolangClassWriter { 
      compiler: None, 
      thisName:"this".to_string(), 
      write_raw_type:false, 
      did_write_nullable:false, 
    };
    return me;
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(node.getParsedString(), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string()), false);
        break;
      case 3 : 
        wr.out(format!("{}{}", (["int64(".to_string() , (node.int_value.to_string()) ].join("")), ")".to_string()), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  type_string == "this".to_string() {
      return self.thisName.clone();
    }
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "interface{}".to_string().clone();
      }
      if  cc.doesInherit() {
        return format!("{}{}", "IFACE_".to_string(), ctx.transformTypeName(type_string.clone())).clone();
      }
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "int64".to_string().clone();
        break;
      case "string".to_string() : 
        return "string".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "float64".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[]byte".to_string().clone();
        break;
    }
    return ctx.transformTypeName(type_string.clone()).clone();
  }
  fn getTypeString2(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    if  type_string == "this".to_string() {
      return self.thisName.clone();
    }
    switch (type_string ) { 
      case "int".to_string() : 
        return "int64".to_string().clone();
        break;
      case "string".to_string() : 
        return "string".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "bool".to_string().clone();
        break;
      case "double".to_string() : 
        return "float64".to_string().clone();
        break;
      case "char".to_string() : 
        return "byte".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "[]byte".to_string().clone();
        break;
    }
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_union {
        return "interface{}".to_string().clone();
      }
    }
    return ctx.transformTypeName(type_string.clone()).clone();
  }
  fn writeRawTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.write_raw_type = true;
    self.writeTypeDef(node.clone(), ctx.clone(), wr.clone());
    self.write_raw_type = false;
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.writeTypeDef2(node.clone(), ctx.clone(), wr.clone());
  }
  fn writeArrayTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut a_name : String = node.array_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
    }
    switch (v_type ) { 
      case 7 : 
        if  ctx.isDefinedClass(a_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(a_name.clone());
          if  cc.is_union {
            wr.out("interface{}".to_string(), false);
            return;
          }
          if  cc.doesInherit() {
            wr.out(format!("{}{}", "IFACE_".to_string(), self.getTypeString2(a_name.clone(), ctx.clone())), false);
            return;
          }
        }
        if  ctx.isPrimitiveType(a_name.clone()) == false {
          wr.out("*".to_string(), false);
        }
        wr.out(format!("{}{}", self.getObjectTypeString(a_name.clone(), ctx.clone()), "".to_string()), false);
        break;
      case 6 : 
        if  ctx.isDefinedClass(a_name.clone()) {
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(a_name.clone());
          if  cc_1.is_union {
            wr.out("interface{}".to_string(), false);
            return;
          }
          if  cc_1.doesInherit() {
            wr.out(format!("{}{}", "IFACE_".to_string(), self.getTypeString2(a_name.clone(), ctx.clone())), false);
            return;
          }
        }
        if  (self.write_raw_type == false) && (ctx.isPrimitiveType(a_name.clone()) == false) {
          wr.out("*".to_string(), false);
        }
        wr.out(format!("{}{}", self.getObjectTypeString(a_name.clone(), ctx.clone()), "".to_string()), false);
        break;
      default: 
        break;
    }
  }
  fn writeTypeDef2(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        wr.out("func(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.writeTypeDef2(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") ".to_string(), false);
        self.writeTypeDef2(rv.clone(), ctx.clone(), wr.clone());
        break;
      case 13 : 
        wr.out("int64".to_string(), false);
        break;
      case 3 : 
        wr.out("int64".to_string(), false);
        break;
      case 2 : 
        wr.out("float64".to_string(), false);
        break;
      case 4 : 
        wr.out("string".to_string(), false);
        break;
      case 5 : 
        wr.out("bool".to_string(), false);
        break;
      case 14 : 
        wr.out("byte".to_string(), false);
        break;
      case 15 : 
        wr.out("[]byte".to_string(), false);
        break;
      case 7 : 
        if  self.write_raw_type {
          wr.out(format!("{}{}", self.getObjectTypeString(a_name.clone(), ctx.clone()), "".to_string()), false);
        } else {
          wr.out(format!("{}{}", (format!("{}{}", "map[".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), "]".to_string()), false);
          if  ctx.isDefinedClass(a_name.clone()) {
            let mut cc : RangerAppClassDesc = ctx.findClass(a_name.clone());
            if  cc.is_union {
              wr.out("interface{}".to_string(), false);
              return;
            }
            if  cc.doesInherit() {
              wr.out(format!("{}{}", "IFACE_".to_string(), self.getTypeString2(a_name.clone(), ctx.clone())), false);
              return;
            }
          }
          if  (self.write_raw_type == false) && (ctx.isPrimitiveType(a_name.clone()) == false) {
            wr.out("*".to_string(), false);
          }
          wr.out(format!("{}{}", self.getObjectTypeString(a_name.clone(), ctx.clone()), "".to_string()), false);
        }
        break;
      case 6 : 
        if  false == self.write_raw_type {
          wr.out("[]".to_string(), false);
        }
        if  ctx.isDefinedClass(a_name.clone()) {
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(a_name.clone());
          if  cc_1.is_union {
            wr.out("interface{}".to_string(), false);
            return;
          }
          if  cc_1.doesInherit() {
            wr.out(format!("{}{}", "IFACE_".to_string(), self.getTypeString2(a_name.clone(), ctx.clone())), false);
            return;
          }
        }
        if  (self.write_raw_type == false) && (ctx.isPrimitiveType(a_name.clone()) == false) {
          wr.out("*".to_string(), false);
        }
        wr.out(format!("{}{}", self.getObjectTypeString(a_name.clone(), ctx.clone()), "".to_string()), false);
        break;
      default: 
        if  (node.type_name == "void".to_string()) || (false == ((node.type_name.len() as i64) > 0)) {
          wr.out("()".to_string(), false);
          return;
        }
        let mut b_iface : bool = false;
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc_2 : RangerAppClassDesc = ctx.findClass(t_name.clone());
          b_iface = cc_2.is_interface;
          if  cc_2.is_system {
            let sysName : Option<String> = cc_2.systemNames.get("go".to_string());
            if  sysName.is_some() {
              wr.out(sysName.unwrap(), false);
            } else {
              ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "No system class ".to_string(), t_name)), "defined for Go ".to_string()));
            }
            return;
          }
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc_3 : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc_3.is_union {
            wr.out("interface{}".to_string(), false);
            return;
          }
          if  cc_3.doesInherit() {
            wr.out(format!("{}{}", "IFACE_".to_string(), self.getTypeString2(t_name.clone(), ctx.clone())), false);
            return;
          }
        }
        if  ((self.write_raw_type == false) && (node.isPrimitiveType() == false)) && (b_iface == false) {
          wr.out("*".to_string(), false);
        }
        wr.out(self.getTypeString2(t_name.clone(), ctx.clone()), false);
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out(self.thisName.clone(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    let mut next_is_gs : bool = false;
    /** unused:  let last_was_setter : bool = false;   **/ 
    let mut needs_par : bool = false;
    let ns_last : i64 = ((node.ns.len() as i64)) - 1;
    if  ((node.nsp.len() as i64)) > 0 {
      let mut had_static : bool = false;
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  next_is_gs {
          if  p.isProperty() {
            wr.out(".Get_".to_string(), false);
            needs_par = true;
          } else {
            needs_par = false;
          }
          next_is_gs = false;
        }
        if  needs_par == false {
          if  i > 0 {
            if  had_static {
              wr.out("_static_".to_string(), false);
            } else {
              wr.out(".".to_string(), false);
            }
          }
        }
        if  (p.nameNode.is_some()) && ctx.isDefinedClass(p.nameNode.type_name.clone()) {
          let mut c : RangerAppClassDesc = ctx.findClass(p.nameNode.type_name.clone());
          if  c.doesInherit() {
            next_is_gs = true;
          }
        }
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out(self.thisName.clone(), false);
            continue;
          }
          let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          if  ((part != self.thisName) && (cc.is_some())) && (false == ctx.isInStatic()) {
            let mut currC : RangerAppClassDesc = cc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            let mut lvDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
            if  (up.is_some()) && lvDef.is_class_variable {
              /** unused:  let mut p3 : RangerAppParamDesc = up.unwrap();   **/ 
              wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
            }
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  needs_par {
          wr.out("()".to_string(), false);
          needs_par = false;
        }
        if  ((p.nameNode.is_some()) && p.nameNode.hasFlag("optional".to_string())) && (i != ns_last) {
          wr.out(".value.(".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(")".to_string(), false);
        }
        if  p.isClass() {
          had_static = true;
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let part_1 : String = node.ns[0 as usize].clone();
      let mut cc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      if  ((part_1 != self.thisName) && (cc_1.is_some())) && (false == ctx.isInStatic()) {
        let mut currC_1 : RangerAppClassDesc = cc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_1.clone());
        let mut lvDef_1 : RangerAppParamDesc = ctx.getVariableDef(part_1.clone());
        if  (up_1.is_some()) && lvDef_1.is_class_variable {
          /** unused:  let mut p3_1 : RangerAppParamDesc = up_1.unwrap();   **/ 
          wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_2 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  (i_1 == 1) && b_was_static {
          wr.out("_static_".to_string(), false);
        } else {
          wr.out(".".to_string(), false);
        }
      }
      if  i_1 == 0 {
        if  part_2 == "this".to_string() {
          wr.out(self.thisName.clone(), false);
          continue;
        }
        if  ctx.hasClass(part_2.clone()) {
          b_was_static = true;
        }
        let mut cc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        if  ((part_2 != "this".to_string()) && (cc_2.is_some())) && (false == ctx.isInStatic()) {
          let mut currC_2 : RangerAppClassDesc = cc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_2.clone());
          let mut lvDef_2 : RangerAppParamDesc = ctx.getVariableDef(part_2.clone());
          if  (up_2.is_some()) && lvDef_2.is_class_variable {
            /** unused:  let mut p3_2 : RangerAppParamDesc = up_2.unwrap();   **/ 
            wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
          }
        }
      }
      wr.out(self.adjustType(part_2.clone()), false);
    }
  }
  fn WriteSetterVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out(self.thisName.clone(), false);
      return;
    }
    if  node.eval_type == 13 {
      let rootObjName : String = node.ns[0 as usize].clone();
      let enumName : String = node.ns[1 as usize].clone();
      let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
      if  e.is_some() {
        wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
        return;
      }
    }
    let mut next_is_gs : bool = false;
    /** unused:  let last_was_setter : bool = false;   **/ 
    let mut needs_par : bool = false;
    let ns_len : i64 = ((node.ns.len() as i64)) - 1;
    if  ((node.nsp.len() as i64)) > 0 {
      let mut had_static : bool = false;
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  next_is_gs {
          if  p.isProperty() {
            wr.out(".Get_".to_string(), false);
            needs_par = true;
          } else {
            needs_par = false;
          }
          next_is_gs = false;
        }
        if  needs_par == false {
          if  i > 0 {
            if  had_static {
              wr.out("_static_".to_string(), false);
            } else {
              wr.out(".".to_string(), false);
            }
          }
        }
        if  ctx.isDefinedClass(p.nameNode.type_name.clone()) {
          let mut c : RangerAppClassDesc = ctx.findClass(p.nameNode.type_name.clone());
          if  c.doesInherit() {
            next_is_gs = true;
          }
        }
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out(self.thisName.clone(), false);
            continue;
          }
          let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          if  ((part != self.thisName) && (cc.is_some())) && (false == ctx.isInStatic()) {
            let mut currC : RangerAppClassDesc = cc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            let mut lvDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
            if  (up.is_some()) && lvDef.is_class_variable {
              /** unused:  let mut p3 : RangerAppParamDesc = up.unwrap();   **/ 
              wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
            }
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
        if  needs_par {
          wr.out("()".to_string(), false);
          needs_par = false;
        }
        if  i < ns_len {
          if  p.nameNode.hasFlag("optional".to_string()) {
            wr.out(".value.(".to_string(), false);
            self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            wr.out(")".to_string(), false);
          }
        }
        if  p.isClass() {
          had_static = true;
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let part_1 : String = node.ns[0 as usize].clone();
      let mut cc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
      if  ((part_1 != self.thisName) && (cc_1.is_some())) && (false == ctx.isInStatic()) {
        let mut currC_1 : RangerAppClassDesc = cc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_1.clone());
        let mut lvDef_1 : RangerAppParamDesc = ctx.getVariableDef(part_1.clone());
        if  (up_1.is_some()) && lvDef_1.is_class_variable {
          /** unused:  let mut p3_1 : RangerAppParamDesc = up_1.unwrap();   **/ 
          wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_2 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  (i_1 == 1) && b_was_static {
          wr.out("_static_".to_string(), false);
        } else {
          wr.out(".".to_string(), false);
        }
      }
      if  i_1 == 0 {
        if  part_2 == "this".to_string() {
          wr.out(self.thisName.clone(), false);
          continue;
        }
        if  ctx.hasClass(part_2.clone()) {
          b_was_static = true;
        }
        let mut cc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        if  ((part_2 != "this".to_string()) && (cc_2.is_some())) && (false == ctx.isInStatic()) {
          let mut currC_2 : RangerAppClassDesc = cc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_2.clone());
          let mut lvDef_2 : RangerAppParamDesc = ctx.getVariableDef(part_2.clone());
          if  (up_2.is_some()) && lvDef_2.is_class_variable {
            /** unused:  let mut p3_2 : RangerAppParamDesc = up_2.unwrap();   **/ 
            wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
          }
        }
      }
      wr.out(self.adjustType(part_2.clone()), false);
    }
  }
  fn goExtractAssign(&mut self, mut value : CodeNode, mut p : RangerAppParamDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut arr_node : CodeNode = value.children[1 as usize].clone();
    wr.newline();
    wr.out("".to_string(), true);
    wr.out("// array_extract operator ".to_string(), true);
    wr.out("var ".to_string(), false);
    let mut pArr : RangerAppParamDesc = RangerAppParamDesc::new();
    pArr.name = "_arrTemp".to_string();
    pArr.node = Some(arr_node.clone());
    pArr.nameNode = Some(arr_node.clone());
    pArr.is_optional = false;
    ctx.defineVariable(p.name.clone(), pArr.clone());
    wr.out(pArr.compiledName.clone(), false);
    wr.out(" ".to_string(), false);
    self.writeTypeDef(arr_node.clone(), ctx.clone(), wr.clone());
    wr.newline();
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", p.compiledName, " , ".to_string())), pArr.compiledName)), " = ".to_string()), false);
    ctx.setInExpr();
    self.WalkNode(value.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out(";".to_string(), true);
    let mut left : CodeNode = arr_node;
    let a_len : i64 = ((left.ns.len() as i64)) - 1;
    /** unused:  let last_part : String = left.ns[a_len as usize].clone();   **/ 
    let mut next_is_gs : bool = false;
    let mut last_was_setter : bool = false;
    let mut needs_par : bool = false;
    let mut b_was_static : bool = false;
    for i in 0..left.ns.len() {
      let mut part = left.ns[i as usize].clone();
      if  next_is_gs {
        if  i == a_len {
          wr.out(".Set_".to_string(), false);
          last_was_setter = true;
        } else {
          wr.out(".Get_".to_string(), false);
          needs_par = true;
          next_is_gs = false;
          last_was_setter = false;
        }
      }
      if  (last_was_setter == false) && (needs_par == false) {
        if  i > 0 {
          if  (i == 1) && b_was_static {
            wr.out("_static_".to_string(), false);
          } else {
            wr.out(".".to_string(), false);
          }
        }
      }
      if  i == 0 {
        if  part == "this".to_string() {
          wr.out(self.thisName.clone(), false);
          continue;
        }
        if  ctx.hasClass(part.clone()) {
          b_was_static = true;
        }
        let mut partDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
        if  partDef.nameNode.is_some() {
          if  ctx.isDefinedClass(partDef.nameNode.type_name.clone()) {
            let mut c : RangerAppClassDesc = ctx.findClass(partDef.nameNode.type_name.clone());
            if  c.doesInherit() {
              next_is_gs = true;
            }
          }
        }
        let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        if  ((part != "this".to_string()) && (cc.is_some())) && (false == ctx.isInStatic()) {
          let mut currC : RangerAppClassDesc = cc.unwrap();
          let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
          let mut lvDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
          if  (up.is_some()) && lvDef.is_class_variable {
            /** unused:  let mut p3 : RangerAppParamDesc = up.unwrap();   **/ 
            wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
          }
        }
      }
      if  ((left.nsp.len() as i64)) > 0 {
        let mut p_1 : RangerAppParamDesc = left.nsp[i as usize].clone();
        wr.out(self.adjustType(p_1.compiledName.clone()), false);
      } else {
        if  left.hasParamDesc {
          wr.out(left.paramDesc.compiledName.clone(), false);
        } else {
          wr.out(self.adjustType(part.clone()), false);
        }
      }
      if  needs_par {
        wr.out("()".to_string(), false);
        needs_par = false;
      }
      if  ((left.nsp.len() as i64)) >= (i + 1) {
        let mut pp : RangerAppParamDesc = left.nsp[i as usize].clone();
        if  pp.nameNode.hasFlag("optional".to_string()) {
          wr.out(".value.(".to_string(), false);
          self.writeTypeDef(pp.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(")".to_string(), false);
        }
      }
    }
    if  last_was_setter {
      wr.out("(".to_string(), false);
      wr.out(pArr.compiledName.clone(), false);
      wr.out("); ".to_string(), true);
    } else {
      wr.out(" = ".to_string(), false);
      wr.out(pArr.compiledName.clone(), false);
      wr.out("; ".to_string(), true);
    }
    wr.out("".to_string(), true);
  }
  fn writeStructField(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      wr.out(format!("{}{}", p.compiledName, " ".to_string()), false);
      if  p.nameNode.hasFlag("optional".to_string()) {
        wr.out("*GoNullable".to_string(), false);
      } else {
        self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      }
      if  p.ref_cnt == 0 {
        wr.out(" /**  unused  **/ ".to_string(), false);
      }
      wr.out(format!("{}{}", (format!("{}{}", " `json:\"".to_string(), p.name)), "\"` ".to_string()), false);
      wr.out("".to_string(), true);
      if  p.nameNode.hasFlag("optional".to_string()) {
      }
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      let mut b_not_used : bool = false;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        let mut b_can_skip : bool = true;
        if  ((node.children.len() as i64)) > 2 {
          let mut value : CodeNode = node.getThird();
          if  value.has_call || value.has_lambda_call {
            b_can_skip = false;
          }
          value.forTree((item, i) => { 
            if  item.has_call || item.has_lambda_call {
              b_can_skip = false;
            }
          }
          );
          if  b_can_skip == false {
            wr.out(" _ = ".to_string(), false);
            ctx.setInExpr();
            self.WalkNode(value.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            wr.out("".to_string(), true);
            return;
          }
        }
        if  b_can_skip {
          wr.out(format!("{}{}", (format!("{}{}", "/** unused:  ".to_string(), p.compiledName)), "*/".to_string()), true);
          b_not_used = true;
          return;
        }
      }
      let map_or_hash : bool = (nn.value_type == 6) || (nn.value_type == 7);
      if  nn.hasFlag("optional".to_string()) {
        wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " *GoNullable = new(GoNullable); ".to_string()), true);
        if  ((node.children.len() as i64)) > 2 {
          let mut value_1 : CodeNode = node.children[2 as usize].clone();
          if  value_1.hasParamDesc {
            let mut pnn : Option<CodeNode> = value_1.paramDesc.nameNode;
            if  pnn.hasFlag("optional".to_string()) {
              wr.out(format!("{}{}", p.compiledName, ".value = ".to_string()), false);
              ctx.setInExpr();
              let mut value_2 : CodeNode = node.getThird();
              self.WalkNode(value_2.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
              wr.out(".value;".to_string(), true);
              wr.out(format!("{}{}", p.compiledName, ".has_value = ".to_string()), false);
              ctx.setInExpr();
              let mut value_3 : CodeNode = node.getThird();
              self.WalkNode(value_3.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
              wr.out(".has_value;".to_string(), true);
              return;
            } else {
              wr.out(format!("{}{}", p.compiledName, ".value = ".to_string()), false);
              ctx.setInExpr();
              let mut value_4 : CodeNode = node.getThird();
              self.WalkNode(value_4.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
              wr.out(";".to_string(), true);
              wr.out(format!("{}{}", p.compiledName, ".has_value = true;".to_string()), true);
              return;
            }
          } else {
            wr.out(format!("{}{}", p.compiledName, " = ".to_string()), false);
            ctx.setInExpr();
            let mut value_5 : CodeNode = node.getThird();
            self.WalkNode(value_5.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            wr.out(";".to_string(), true);
            return;
          }
        }
        return;
      } else {
        if  ((p.set_cnt > 0) || p.is_class_variable) || map_or_hash {
          wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " ".to_string()), false);
        } else {
          wr.out(format!("{}{}", (format!("{}{}", "var ".to_string(), p.compiledName)), " ".to_string()), false);
        }
      }
      let ti_ok : bool = ctx.canUseTypeInference((p.nameNode.clone().unwrap()));
      if  (false == ti_ok) || ((false == p.nameNode.hasFlag("optional".to_string())) && (((node.children.len() as i64)) == 2)) {
        self.writeTypeDef2(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      }
      if  ((node.children.len() as i64)) > 2 {
        let mut value_6 : CodeNode = node.getThird();
        if  value_6.expression && (((value_6.children.len() as i64)) > 1) {
          let mut fc : CodeNode = value_6.children[0 as usize].clone();
          if  fc.vref == "array_extract".to_string() {
            self.goExtractAssign(value_6.clone(), p.unwrap(), ctx.clone(), wr.clone());
            return;
          }
        }
        wr.out("= ".to_string(), false);
        ctx.setInExpr();
        if  p.nameNode.eval_type_name == "char".to_string() {
          wr.out("byte(".to_string(), false);
        }
        self.WalkNode(value_6.clone(), ctx.clone(), wr.clone());
        if  p.nameNode.eval_type_name == "char".to_string() {
          wr.out(")".to_string(), false);
        }
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = make(".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(", 0)".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = make(".to_string(), false);
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(")".to_string(), false);
        }
      }
      wr.out(";".to_string(), false);
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
      } else {
        wr.newline();
      }
      if  b_not_used == false {
        if  nn.hasFlag("optional".to_string()) {
          wr.addImport("errors".to_string());
        }
      }
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(format!("{}{}", arg.compiledName, " ".to_string()), false);
      if  arg.nameNode.hasFlag("optional".to_string()) {
        wr.out("*GoNullable".to_string(), false);
      } else {
        self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(format!("{}{}", (format!("{}{}", "CreateNew_".to_string(), node.clDesc.name)), "(".to_string()), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.writeTypeDef(node.clone(), ctx.clone(), wr.clone());
    wr.out(" {".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("}".to_string(), false);
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), subCtx.clone(), wr.clone());
      } else {
        self.WalkNode(n.clone(), subCtx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fnNode : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("func (".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(arg.vref.clone(), false);
      wr.out(" ".to_string(), false);
      if  arg.hasFlag("optional".to_string()) {
        wr.out("*GoNullable".to_string(), false);
      } else {
        self.writeTypeDef(arg.clone(), lambdaCtx.clone(), wr.clone());
      }
    }
    wr.out(") ".to_string(), false);
    if  fnNode.hasFlag("optional".to_string()) {
      wr.out("*GoNullable".to_string(), false);
    } else {
      self.writeTypeDef(fnNode.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.out(" {".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), false);
  }
  fn CustomOperator(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = node.getFirst();
    let cmd : String = fc.vref.clone();
    if  cmd == "return".to_string() {
      if  ((node.children.len() as i64)) > 1 {
        let mut rValue : CodeNode = node.getSecond();
        if  ctx.isCatchBlock() || ctx.isTryBlock() {
          wr.out("__ex_returned = true".to_string(), true);
          wr.out("__exReturn = ".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(rValue.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.newline();
          if  ctx.isTryBlock() {
            wr.out("return __ex_returned, __exReturn".to_string(), true);
          }
        } else {
          wr.out("return ".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(rValue.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.newline();
        }
      } else {
        if  ctx.isCatchBlock() {
          wr.out("__ex_returned = true".to_string(), true);
        }
        if  ctx.isTryBlock() {
          wr.out("return false, nil".to_string(), true);
        }
        wr.out("return".to_string(), true);
      }
      return;
    }
    if  cmd == "try".to_string() {
      let mut tryBlock : CodeNode = node.getSecond();
      let mut catchBlock : CodeNode = node.getThird();
      let mut currFn : RangerAppFunctionDesc = ctx.getCurrentMethod();
      let mut ex2 : RangerAppParamDesc = operatorsOf_21::createc95var_48(ctx.clone(), "did_return".to_string(), "boolean".to_string());
      let mut ex3 : RangerAppParamDesc = operatorsOf_21::createc95var_49(ctx.clone(), "ex_result".to_string(), (currFn.nameNode.clone().unwrap()));
      if  currFn.nameNode.type_name == "void".to_string() {
        wr.out(format!("{}{}", ex2.compiledName, ", _ := (func () ( __ex_returned bool,  __exReturn interface{}) {".to_string()), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", ex2.compiledName, ", ".to_string())), ex3.compiledName)), " := (func () ( __ex_returned bool,  __exReturn interface{}) {".to_string()), true);
      }
      wr.indent(1);
      wr.out("defer func() {".to_string(), true);
      wr.indent(1);
      wr.out("if r:= recover(); r != nil {".to_string(), true);
      wr.indent(1);
      let mut subCtx : RangerAppWriterContext = ctx.fork();
      subCtx.is_catch_block = true;
      self.WalkNode(catchBlock.clone(), subCtx.clone(), wr.clone());
      wr.indent(-1);
      wr.out("}".to_string(), true);
      wr.indent(-1);
      wr.out("}()".to_string(), true);
      let mut subCtx_1 : RangerAppWriterContext = ctx.fork();
      subCtx_1.is_try_block = true;
      self.WalkNode(tryBlock.clone(), subCtx_1.clone(), wr.clone());
      wr.out("return __ex_returned, __exReturn".to_string(), true);
      wr.indent(-1);
      wr.out("})()".to_string(), true);
      if  currFn.nameNode.type_name != "void".to_string() {
        wr.out(format!("{}{}", (format!("{}{}", "if ".to_string(), ex2.compiledName)), " {".to_string()), true);
        wr.indent(1);
        wr.out(format!("{}{}", "return ".to_string(), ex3.compiledName), false);
        wr.out(".(".to_string(), false);
        self.writeTypeDef(currFn.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      } else {
        wr.out(format!("{}{}", (format!("{}{}", "if ".to_string(), ex2.compiledName)), " {".to_string()), true);
        wr.indent(1);
        wr.out("return ".to_string(), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      return;
    }
    if  ((cmd == "=".to_string()) || (cmd == "push".to_string())) || (cmd == "removeLast".to_string()) {
      let mut left : CodeNode = node.getSecond();
      let mut right : CodeNode = left;
      if  (cmd == "=".to_string()) || (cmd == "push".to_string()) {
        right = node.getThird();
      }
      wr.newline();
      let mut b_was_static : bool = false;
      if  left.hasParamDesc {
        let a_len : i64 = ((left.ns.len() as i64)) - 1;
        /** unused:  let last_part : String = left.ns[a_len as usize].clone();   **/ 
        let mut next_is_gs : bool = false;
        let mut last_was_setter : bool = false;
        let mut needs_par : bool = false;
        for i in 0..left.ns.len() {
          let mut part = left.ns[i as usize].clone();
          if  next_is_gs {
            if  i == a_len {
              wr.out(".Set_".to_string(), false);
              last_was_setter = true;
            } else {
              wr.out(".Get_".to_string(), false);
              needs_par = true;
              next_is_gs = false;
              last_was_setter = false;
            }
          }
          if  (last_was_setter == false) && (needs_par == false) {
            if  i > 0 {
              if  (i == 1) && b_was_static {
                wr.out("_static_".to_string(), false);
              } else {
                wr.out(".".to_string(), false);
              }
            }
          }
          if  i == 0 {
            if  part == "this".to_string() {
              wr.out(self.thisName.clone(), false);
              continue;
            }
            if  ctx.hasClass(part.clone()) {
              b_was_static = true;
            }
            let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            if  ((part != "this".to_string()) && (cc.is_some())) && (false == ctx.isInStatic()) {
              let mut currC : RangerAppClassDesc = cc.unwrap();
              let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
              let mut lvDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
              if  (up.is_some()) && lvDef.is_class_variable {
                /** unused:  let mut p3 : RangerAppParamDesc = up.unwrap();   **/ 
                wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
              }
            }
          }
          let mut partDef : RangerAppParamDesc = ctx.getVariableDef(part.clone());
          if  ((left.nsp.len() as i64)) > i {
            partDef = left.nsp[i as usize].clone();
          }
          if  partDef.nameNode.is_some() {
            if  ctx.isDefinedClass(partDef.nameNode.type_name.clone()) {
              let mut c : RangerAppClassDesc = ctx.findClass(partDef.nameNode.type_name.clone());
              if  c.doesInherit() {
                next_is_gs = true;
              }
            }
          }
          if  ((left.nsp.len() as i64)) > 0 {
            let mut p : RangerAppParamDesc = left.nsp[i as usize].clone();
            wr.out(self.adjustType(p.compiledName.clone()), false);
          } else {
            if  left.hasParamDesc {
              wr.out(left.paramDesc.compiledName.clone(), false);
            } else {
              wr.out(self.adjustType(part.clone()), false);
            }
          }
          if  needs_par {
            wr.out("()".to_string(), false);
            needs_par = false;
          }
          if  ((left.nsp.len() as i64)) >= (i + 1) {
            let mut pp : RangerAppParamDesc = left.nsp[i as usize].clone();
            if  pp.nameNode.hasFlag("optional".to_string()) {
              if  ((left.nsp.len() as i64)) > (i + 1) {
                wr.out(".value.(".to_string(), false);
                self.writeTypeDef(pp.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
                wr.out(")".to_string(), false);
              } else {
                wr.out(".value".to_string(), false);
                if  right.hasFlag("optional".to_string()) == false {
                  wr.out(" /* right is not optional, should set the has_value -> true */".to_string(), false);
                }
              }
            }
          }
        }
        if  cmd == "removeLast".to_string() {
          if  last_was_setter {
            wr.out("(".to_string(), false);
            ctx.setInExpr();
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out("[:len(".to_string(), false);
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out(")-1]".to_string(), false);
            ctx.unsetInExpr();
            wr.out("); ".to_string(), true);
          } else {
            wr.out(" = ".to_string(), false);
            ctx.setInExpr();
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out("[:len(".to_string(), false);
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out(")-1]".to_string(), false);
            ctx.unsetInExpr();
            wr.out("; ".to_string(), true);
          }
          return;
        }
        if  cmd == "push".to_string() {
          if  last_was_setter {
            wr.out("(".to_string(), false);
            ctx.setInExpr();
            wr.out("append(".to_string(), false);
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out(",".to_string(), false);
            self.WalkNode(right.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            wr.out(")); ".to_string(), true);
          } else {
            wr.out(" = ".to_string(), false);
            wr.out("append(".to_string(), false);
            ctx.setInExpr();
            self.WalkNode(left.clone(), ctx.clone(), wr.clone());
            wr.out(",".to_string(), false);
            self.WalkNode(right.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
            wr.out("); ".to_string(), true);
          }
          return;
        }
        if  last_was_setter {
          wr.out("(".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(right.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.out("); ".to_string(), true);
        } else {
          wr.out(" = ".to_string(), false);
          ctx.setInExpr();
          self.WalkNode(right.clone(), ctx.clone(), wr.clone());
          ctx.unsetInExpr();
          wr.out("; ".to_string(), true);
        }
        return;
      }
      self.WriteSetterVRef(left.clone(), ctx.clone(), wr.clone());
      wr.out(" = ".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(right.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out("; /* custom */".to_string(), true);
    }
  }
  fn writeInterface(&mut self, mut cl : RangerAppClassDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out(format!("{}{}", (format!("{}{}", "type ".to_string(), cl.name)), " interface { ".to_string()), true);
    wr.indent(1);
    for i in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_1 in 0..mVs.variants.len() {
        let mut variant = mVs.variants[i_1 as usize].clone();
        wr.out(format!("{}{}", variant.compiledName, "(".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(") ".to_string(), false);
        if  variant.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out("".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut wr : CodeWriter = orig_wr;
    if  self.did_write_nullable == false {
      wr.raw("\r\ntype GoNullable struct { \r\n  value interface{}\r\n  has_value bool\r\n}\r\n".to_string(), true);
      wr.createTag("utilities".to_string());
      self.did_write_nullable = true;
    }
    let mut declaredVariable : HashMap<String,bool> = HashMap::new();
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut declaredIfFunction : HashMap<String,bool> = HashMap::new();
    wr.out(format!("{}{}", (format!("{}{}", "type ".to_string(), cl.name)), " struct { ".to_string()), true);
    wr.indent(1);
    for i in 0..cl.variables.len() {
      let mut pvar = cl.variables[i as usize].clone();
      self.writeStructField(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
      declaredVariable.insert(pvar.name, true);
    }
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i_1 in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i_1 as usize].clone();
        let mut pC : RangerAppClassDesc = ctx.findClass(pName.clone());
        wr.out(format!("{}{}", "// inherited from parent class ".to_string(), pName), true);
        for i_2 in 0..pC.variables.len() {
          let mut pvar_1 = pC.variables[i_2 as usize].clone();
          if  declaredVariable.contains_key(&pvar_1.name) {
            continue;
          }
          self.writeStructField(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
        }
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    if  cl.doesInherit() || (((cl.extends_classes.len() as i64)) > 0) {
      wr.out(format!("{}{}", (format!("{}{}", "type IFACE_".to_string(), cl.name)), " interface { ".to_string()), true);
      wr.indent(1);
      for i_3 in 0..cl.variables.len() {
        let mut p = cl.variables[i_3 as usize].clone();
        wr.out("Get_".to_string(), false);
        wr.out(format!("{}{}", p.compiledName, "() ".to_string()), false);
        if  p.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out("".to_string(), true);
        wr.out("Set_".to_string(), false);
        wr.out(format!("{}{}", p.compiledName, "(value ".to_string()), false);
        if  p.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out(") ".to_string(), true);
      }
      for i_4 in 0..cl.defined_variants.len() {
        let mut fnVar = cl.defined_variants[i_4 as usize].clone();
        let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
        for i_5 in 0..mVs.variants.len() {
          let mut variant = mVs.variants[i_5 as usize].clone();
          if  declaredIfFunction.contains_key(&variant.name) {
            continue;
          }
          declaredIfFunction.insert(variant.name, true);
          wr.out(format!("{}{}", variant.compiledName, "(".to_string()), false);
          self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
          wr.out(") ".to_string(), false);
          if  variant.nameNode.hasFlag("optional".to_string()) {
            wr.out("*GoNullable".to_string(), false);
          } else {
            self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          }
          wr.out("".to_string(), true);
        }
      }
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    self.thisName = "me".to_string();
    wr.out("".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "func CreateNew_".to_string(), cl.name)), "(".to_string()), false);
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      for i_6 in 0..constr.params.len() {
        let mut arg = constr.params[i_6 as usize].clone();
        if  i_6 > 0 {
          wr.out(", ".to_string(), false);
        }
        wr.out(format!("{}{}", arg.name, " ".to_string()), false);
        self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", ") *".to_string(), cl.name)), " {".to_string()), true);
    wr.indent(1);
    wr.newline();
    wr.out(format!("{}{}", (format!("{}{}", "me := new(".to_string(), cl.name)), ")".to_string()), true);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i_7 in 0..cl.extends_classes.len() {
        let mut pName_1 = cl.extends_classes[i_7 as usize].clone();
        let mut pC_1 : RangerAppClassDesc = ctx.findClass(pName_1.clone());
        for i_8 in 0..pC_1.variables.len() {
          let mut pvar_2 = pC_1.variables[i_8 as usize].clone();
          let mut nn : CodeNode = pvar_2.node.clone().unwrap();
          if  ((nn.children.len() as i64)) > 2 {
            let mut valueNode : CodeNode = nn.children[2 as usize].clone();
            wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_2.compiledName)), " = ".to_string()), false);
            self.WalkNode(valueNode.clone(), ctx.clone(), wr.clone());
            wr.out("".to_string(), true);
          } else {
            let mut pNameN : CodeNode = pvar_2.nameNode.clone().unwrap();
            if  pNameN.value_type == 6 {
              wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_2.compiledName)), " = ".to_string()), false);
              wr.out("make(".to_string(), false);
              self.writeTypeDef(pvar_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
              wr.out(",0)".to_string(), true);
            }
            if  pNameN.value_type == 7 {
              wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_2.compiledName)), " = ".to_string()), false);
              wr.out("make(".to_string(), false);
              self.writeTypeDef(pvar_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
              wr.out(")".to_string(), true);
            }
          }
        }
        for i_9 in 0..pC_1.variables.len() {
          let mut pvar_3 = pC_1.variables[i_9 as usize].clone();
          if  pvar_3.nameNode.hasFlag("optional".to_string()) {
            wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_3.compiledName)), " = new(GoNullable);".to_string()), true);
          }
        }
        if  pC_1.has_constructor {
          let mut constr_1 : Option<RangerAppFunctionDesc> = pC_1.constructor_fn;
          let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
          subCtx.is_function = true;
          self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
        }
      }
    }
    for i_10 in 0..cl.variables.len() {
      let mut pvar_4 = cl.variables[i_10 as usize].clone();
      let mut nn_1 : CodeNode = pvar_4.node.clone().unwrap();
      if  ((nn_1.children.len() as i64)) > 2 {
        let mut valueNode_1 : CodeNode = nn_1.children[2 as usize].clone();
        wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_4.compiledName)), " = ".to_string()), false);
        self.WalkNode(valueNode_1.clone(), ctx.clone(), wr.clone());
        wr.out("".to_string(), true);
      } else {
        let mut pNameN_1 : Option<CodeNode> = pvar_4.nameNode;
        if  pNameN_1.value_type == 6 {
          wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_4.compiledName)), " = ".to_string()), false);
          wr.out("make(".to_string(), false);
          self.writeTypeDef(pvar_4.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(",0)".to_string(), true);
        }
        if  pNameN_1.value_type == 7 {
          wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_4.compiledName)), " = ".to_string()), false);
          wr.out("make(".to_string(), false);
          self.writeTypeDef(pvar_4.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          wr.out(")".to_string(), true);
        }
      }
    }
    for i_11 in 0..cl.variables.len() {
      let mut pvar_5 = cl.variables[i_11 as usize].clone();
      if  pvar_5.nameNode.hasFlag("optional".to_string()) {
        wr.out(format!("{}{}", (format!("{}{}", "me.".to_string(), pvar_5.compiledName)), " = new(GoNullable);".to_string()), true);
      }
    }
    if  cl.has_constructor {
      let mut constr_2 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut subCtx_1 : RangerAppWriterContext = constr_2.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(constr_2.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
    }
    wr.out("return me;".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    self.thisName = "this".to_string();
    for i_12 in 0..cl.static_methods.len() {
      let mut variant_1 = cl.static_methods[i_12 as usize].clone();
      if  variant_1.nameNode.hasFlag("main".to_string()) {
        continue;
      }
      wr.newline();
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "func ".to_string(), cl.name)), "_static_".to_string())), variant_1.compiledName)), "(".to_string()), false);
      self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
      wr.out(") ".to_string(), false);
      let mut vnn : CodeNode = variant_1.nameNode.clone().unwrap();
      if  vnn.hasFlag("optional".to_string()) {
        wr.out("*GoNullable".to_string(), false);
      } else {
        self.writeTypeDef(vnn.clone(), ctx.clone(), wr.clone());
      }
      wr.out(" {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
      subCtx_2.is_function = true;
      subCtx_2.in_static_method = true;
      self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
      subCtx_2.in_static_method = false;
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    let mut declaredFn : HashMap<String,bool> = HashMap::new();
    for i_13 in 0..cl.defined_variants.len() {
      let mut fnVar_1 = cl.defined_variants[i_13 as usize].clone();
      let mut mVs_1 : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar_1);
      for i_14 in 0..mVs_1.variants.len() {
        let mut variant_2 = mVs_1.variants[i_14 as usize].clone();
        if  declaredFunction.contains_key(&variant_2.name) {
          continue;
        }
        declaredFunction.insert(variant_2.name, true);
        declaredFn.insert(variant_2.name, true);
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string())), variant_2.compiledName)), " (".to_string()), false);
        self.writeArgsDef(variant_2.clone(), ctx.clone(), wr.clone());
        wr.out(") ".to_string(), false);
        if  variant_2.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(variant_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_3 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
        subCtx_3.is_function = true;
        self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_3.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    if  ((cl.extends_classes.len() as i64)) > 0 {
      for i_15 in 0..cl.extends_classes.len() {
        let mut pName_2 = cl.extends_classes[i_15 as usize].clone();
        let mut pC_2 : RangerAppClassDesc = ctx.findClass(pName_2.clone());
        wr.out(format!("{}{}", "// inherited methods from parent class ".to_string(), pName_2), true);
        for i_16 in 0..pC_2.defined_variants.len() {
          let mut fnVar_2 = pC_2.defined_variants[i_16 as usize].clone();
          let mut mVs_2 : Option<RangerAppMethodVariants> = pC_2.method_variants.get(fnVar_2);
          for i_17 in 0..mVs_2.variants.len() {
            let mut variant_3 = mVs_2.variants[i_17 as usize].clone();
            if  declaredFn.contains_key(&variant_3.name) {
              continue;
            }
            wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string())), variant_3.compiledName)), " (".to_string()), false);
            self.writeArgsDef(variant_3.clone(), ctx.clone(), wr.clone());
            wr.out(") ".to_string(), false);
            if  variant_3.nameNode.hasFlag("optional".to_string()) {
              wr.out("*GoNullable".to_string(), false);
            } else {
              self.writeTypeDef(variant_3.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            }
            wr.out(" {".to_string(), true);
            wr.indent(1);
            wr.newline();
            let mut subCtx_4 : RangerAppWriterContext = variant_3.fnCtx.clone().unwrap();
            subCtx_4.is_function = true;
            self.WalkNode(variant_3.fnBody.clone().unwrap(), subCtx_4.clone(), wr.clone());
            wr.newline();
            wr.indent(-1);
            wr.out("}".to_string(), true);
          }
        }
      }
    }
    let mut declaredGetter : HashMap<String,bool> = HashMap::new();
    if  cl.doesInherit() || (((cl.extends_classes.len() as i64)) > 0) {
      for i_18 in 0..cl.variables.len() {
        let mut p_1 = cl.variables[i_18 as usize].clone();
        declaredGetter.insert(p_1.name, true);
        wr.newline();
        wr.out(format!("{}{}", "// getter for variable ".to_string(), p_1.name), true);
        wr.out(format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string()), false);
        wr.out("Get_".to_string(), false);
        wr.out(format!("{}{}", p_1.compiledName, "() ".to_string()), false);
        if  p_1.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(p_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", "return this.".to_string(), p_1.compiledName), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
        wr.newline();
        wr.out(format!("{}{}", "// setter for variable ".to_string(), p_1.name), true);
        wr.out(format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string()), false);
        wr.out("Set_".to_string(), false);
        wr.out(format!("{}{}", p_1.compiledName, "( value ".to_string()), false);
        if  p_1.nameNode.hasFlag("optional".to_string()) {
          wr.out("*GoNullable".to_string(), false);
        } else {
          self.writeTypeDef(p_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        }
        wr.out(") ".to_string(), false);
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "this.".to_string(), p_1.compiledName)), " = value ".to_string()), true);
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
      if  ((cl.extends_classes.len() as i64)) > 0 {
        for i_19 in 0..cl.extends_classes.len() {
          let mut pName_3 = cl.extends_classes[i_19 as usize].clone();
          let mut pC_3 : RangerAppClassDesc = ctx.findClass(pName_3.clone());
          wr.out(format!("{}{}", "// inherited getters and setters from the parent class ".to_string(), pName_3), true);
          for i_20 in 0..pC_3.variables.len() {
            let mut p_2 = pC_3.variables[i_20 as usize].clone();
            if  declaredGetter.contains_key(&p_2.name) {
              continue;
            }
            wr.newline();
            wr.out(format!("{}{}", "// getter for variable ".to_string(), p_2.name), true);
            wr.out(format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string()), false);
            wr.out("Get_".to_string(), false);
            wr.out(format!("{}{}", p_2.compiledName, "() ".to_string()), false);
            if  p_2.nameNode.hasFlag("optional".to_string()) {
              wr.out("*GoNullable".to_string(), false);
            } else {
              self.writeTypeDef(p_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            }
            wr.out(" {".to_string(), true);
            wr.indent(1);
            wr.out(format!("{}{}", "return this.".to_string(), p_2.compiledName), true);
            wr.indent(-1);
            wr.out("}".to_string(), true);
            wr.newline();
            wr.out(format!("{}{}", "// getter for variable ".to_string(), p_2.name), true);
            wr.out(format!("{}{}", (format!("{}{}", "func (this *".to_string(), cl.name)), ") ".to_string()), false);
            wr.out("Set_".to_string(), false);
            wr.out(format!("{}{}", p_2.compiledName, "( value ".to_string()), false);
            if  p_2.nameNode.hasFlag("optional".to_string()) {
              wr.out("*GoNullable".to_string(), false);
            } else {
              self.writeTypeDef(p_2.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            }
            wr.out(") ".to_string(), false);
            wr.out(" {".to_string(), true);
            wr.indent(1);
            wr.out(format!("{}{}", (format!("{}{}", "this.".to_string(), p_2.compiledName)), " = value ".to_string()), true);
            wr.indent(-1);
            wr.out("}".to_string(), true);
          }
        }
      }
    }
    for i_21 in 0..cl.static_methods.len() {
      let mut variant_4 = cl.static_methods[i_21 as usize].clone();
      if  variant_4.nameNode.hasFlag("main".to_string()) && (variant_4.nameNode.code.filename == ctx.getRootFile()) {
        wr.out("func main() {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_5 : RangerAppWriterContext = variant_4.fnCtx.clone().unwrap();
        subCtx_5.is_function = true;
        subCtx_5.in_static_method = true;
        self.WalkNode(variant_4.fnBody.clone().unwrap(), subCtx_5.clone(), wr.clone());
        subCtx_5.in_static_method = false;
        if  ctx.hasCompilerFlag("forever".to_string()) {
          wr.out("for {}".to_string(), true);
        }
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
  }
}
#[derive(Clone)]
struct RangerPHPClassWriter { 
  compiler : Option<LiveCompiler>, 
  thisName : String, 
  wrote_header : bool, 
}
impl RangerPHPClassWriter { 
  
  pub fn new() ->  RangerPHPClassWriter {
    let mut me = RangerPHPClassWriter { 
      compiler: None, 
      thisName:"this".to_string(), 
      wrote_header:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn EncodeString(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> String {
    /** unused:  let encoded_str : String = "".to_string();   **/ 
    let str_length : i64 = node.string_value.len() as i64;
    let mut encoded_str_2 : String = "".to_string();
    let mut ii : i64 = 0;
    while ii < str_length {
      let cc : i64 = node.string_value.chars().nth(ii as usize).unwrap_or('\0') as i64;
      switch (cc ) { 
        case 8 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(98)));
          break;
        case 9 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(116)));
          break;
        case 10 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(110)));
          break;
        case 12 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(102)));
          break;
        case 13 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(114)));
          break;
        case 34 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(34)));
          break;
        case 36 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(34)));
          break;
        case 92 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(92)));
          break;
        default: 
          encoded_str_2 = format!("{}{}", encoded_str_2, (String.fromCharCode(cc)));
          break;
      }
      ii = ii + 1;
    }
    return encoded_str_2.clone();
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(["".to_string() , (node.double_value.to_string()) ].join(""), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("true".to_string(), false);
        } else {
          wr.out("false".to_string(), false);
        }
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("$this".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("$this".to_string(), false);
            continue;
          }
        }
        if  i > 0 {
          wr.out("->".to_string(), false);
        }
        if  i == 0 {
          wr.out("$".to_string(), false);
          if  p.nameNode.hasFlag("optional".to_string()) {
          }
          let part_1 : String = node.ns[0 as usize].clone();
          if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part_1.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out(format!("{}{}", self.thisName, "->".to_string()), false);
              }
            }
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      wr.out("$".to_string(), false);
      let part_2 : String = node.ns[0 as usize].clone();
      if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_2.clone());
        if  up_1.is_some() {
          if  false == ctx.isInStatic() {
            wr.out(format!("{}{}", self.thisName, "->".to_string()), false);
          }
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_3 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  (i_1 == 1) && b_was_static {
          wr.out("::".to_string(), false);
        } else {
          wr.out("->".to_string(), false);
        }
      }
      if  i_1 == 0 {
        if  ctx.hasClass(part_3.clone()) {
          b_was_static = true;
        } else {
          wr.out("$".to_string(), false);
        }
        if  (part_3 != "this".to_string()) && ctx.hasCurrentClass() {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_3.clone());
          if  up_2.is_some() {
            if  false == ctx.isInStatic() {
              wr.out(format!("{}{}", self.thisName, "->".to_string()), false);
            }
          }
        }
      }
      wr.out(self.adjustType(part_3.clone()), false);
    }
  }
  fn writeVarInitDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      wr.out(format!("{}{}", "$this->".to_string(), p.compiledName), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = array()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = array()".to_string(), false);
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/".to_string(), true);
        return;
      }
      wr.out(";".to_string(), false);
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      wr.newline();
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      wr.out(format!("{}{}", "$".to_string(), p.compiledName), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = array()".to_string(), false);
        } else {
          if  nn.value_type == 7 {
            wr.out(" = array()".to_string(), false);
          } else {
            wr.out(" = null".to_string(), false);
          }
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ;".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn disabledVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      wr.out(format!("{}{}", "$this->".to_string(), p.compiledName), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = array()".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = array()".to_string(), false);
        }
      }
      wr.out(";".to_string(), false);
      wr.newline();
    }
  }
  fn CreateMethodCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getFirst();
    let mut args : CodeNode = node.getSecond();
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
  }
  fn CreatePropertyGet(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getSecond();
    let mut prop : CodeNode = node.getThird();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
    wr.out("->".to_string(), false);
    wr.out(prop.vref.clone(), false);
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    ctx.setInExpr();
    wr.out("call_user_func(".to_string(), false);
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i >= 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    if  ctx.expressionLevel() == 0 {
      wr.out(");".to_string(), true);
    } else {
      wr.out(")".to_string(), false);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    /** unused:  let mut fnNode : CodeNode = node.children[0 as usize].clone();   **/ 
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("(function (".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.out(") ".to_string(), false);
    let mut captCnt : i64 = 0;
    for i_1 in 0..lambdaCtx.captured_variables.len() {
      let mut cname = lambdaCtx.captured_variables[i_1 as usize].clone();
      let mut pp : RangerAppParamDesc = lambdaCtx.getVariableDef(cname.clone());
      if  pp.set_cnt >= 0 {
        if  captCnt == 0 {
          wr.out("use (".to_string(), false);
        } else {
          wr.out(", ".to_string(), false);
        }
        wr.out(format!("{}{}", " &$".to_string(), cname), false);
        captCnt = captCnt + 1;
      } else {
        if  pp.varType == 4 {
          ctx.addError(node.clone(), "Mutating captured function parameter is not allowed".to_string());
        }
      }
    }
    if  captCnt > 0 {
      wr.out(")".to_string(), false);
    }
    wr.out(" {".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_2 in 0..body.children.len() {
      let mut item = body.children[i_2 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    for i_3 in 0..lambdaCtx.captured_variables.len() {
      let mut cname_1 = lambdaCtx.captured_variables[i_3 as usize].clone();
      wr.out(format!("{}{}", "// captured var ".to_string(), cname_1), true);
    }
    wr.indent(-1);
    if  ctx.expressionLevel() == 0 {
      wr.out("});".to_string(), true);
    } else {
      wr.out("})".to_string(), false);
    }
  }
  fn writeClassVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      wr.out(format!("{}{}", (format!("{}{}", "var $".to_string(), p.compiledName)), ";".to_string()), true);
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(format!("{}{}", (format!("{}{}", " $".to_string(), arg.compiledName)), " ".to_string()), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("array(".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out(")".to_string(), false);
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      ctx.setInExpr();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(" new ".to_string(), false);
      wr.out(node.clDesc.name.clone(), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("".to_string(), false);
      ctx.setInExpr();
      if  ctx.hasCompilerFlag("php54".to_string()) {
        wr.out(format!("{}{}", (format!("{}{}", "call_user_method(\"".to_string(), method.vref)), "\",".to_string()), false);
        self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      } else {
        wr.out("(".to_string(), false);
        self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), false);
        ctx.unsetInExpr();
        wr.out("->".to_string(), false);
        wr.out(method.vref.clone(), false);
        wr.out("(".to_string(), false);
        ctx.setInExpr();
      }
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut wr : CodeWriter = orig_wr;
    /** unused:  let mut importFork : CodeWriter = wr.fork();   **/ 
    for i in 0..cl.capturedLocals.len() {
      let mut dd = cl.capturedLocals[i as usize].clone();
      if  dd.is_class_variable == false {
        if  dd.set_cnt > 0 {
        }
      }
    }
    if  self.wrote_header == false {
      wr.out("<?php ".to_string(), true);
      wr.out("".to_string(), true);
      self.wrote_header = true;
    }
    wr.out(format!("{}{}", "class ".to_string(), cl.name), false);
    let mut parentClass : Option<RangerAppClassDesc> = None;
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out(" extends ".to_string(), false);
      for i_1 in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i_1 as usize].clone();
        wr.out(pName.clone(), false);
        parentClass = Some(ctx.findClass(pName.clone()));
      }
    }
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    for i_2 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_2 as usize].clone();
      self.writeClassVarDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    wr.out("function __construct(".to_string(), false);
    if  cl.has_constructor {
      let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
      self.writeArgsDef(constr.clone(), ctx.clone(), wr.clone());
    }
    wr.out(" ) {".to_string(), true);
    wr.indent(1);
    if parentClass.is_some() {
      wr.out("parent::__construct();".to_string(), true);
    }
    for i_3 in 0..cl.variables.len() {
      let mut pvar_1 = cl.variables[i_3 as usize].clone();
      self.writeVarInitDef(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_4 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_4 as usize].clone();
      if  variant.nameNode.hasFlag("main".to_string()) {
        continue;
      } else {
        wr.out("public static function ".to_string(), false);
        wr.out(format!("{}{}", variant.compiledName, "(".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
      }
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      subCtx_1.in_static_method = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      subCtx_1.in_static_method = false;
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_5 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_5 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_6 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_6 as usize].clone();
        if  declaredFunction.contains_key(&variant_1.name) {
          continue;
        }
        declaredFunction.insert(variant_1.name, true);
        wr.out(format!("{}{}", (format!("{}{}", "function ".to_string(), variant_1.compiledName)), "(".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        subCtx_2.in_static_method = false;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    for i_7 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_7 as usize].clone();
      ctx.disableCurrentClass();
      ctx.in_static_method = true;
      if  variant_2.nameNode.hasFlag("main".to_string()) && (variant_2.nameNode.code.filename == ctx.getRootFile()) {
        wr.out("/* static PHP main routine */".to_string(), false);
        wr.newline();
        self.WalkNode(variant_2.fnBody.clone().unwrap(), ctx.clone(), wr.clone());
        wr.newline();
      }
      ctx.in_static_method = false;
    }
  }
}
#[derive(Clone)]
struct RangerPythonClassWriter { 
  compiler : Option<LiveCompiler>, 
  thisName : String, 
  wrote_header : bool, 
}
impl RangerPythonClassWriter { 
  
  pub fn new() ->  RangerPythonClassWriter {
    let mut me = RangerPythonClassWriter { 
      compiler: None, 
      thisName:"self".to_string(), 
      wrote_header:false, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "self".to_string().clone();
    }
    return tn.clone();
  }
  fn EncodeString(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> String {
    let mut encoded_str : String = "".to_string();
    let str_length : i64 = node.string_value.len() as i64;
    let mut ii : i64 = 0;
    while ii < str_length {
      let cc : i64 = node.string_value.chars().nth(ii as usize).unwrap_or('\0') as i64;
      switch (cc ) { 
        case 8 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(98)));
          break;
        case 9 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(116)));
          break;
        case 10 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(110)));
          break;
        case 12 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(102)));
          break;
        case 13 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(114)));
          break;
        case 34 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(34)));
          break;
        case 92 : 
          encoded_str = format!("{}{}", (format!("{}{}", encoded_str, (String.fromCharCode(92)))), (String.fromCharCode(92)));
          break;
        default: 
          encoded_str = format!("{}{}", encoded_str, (String.fromCharCode(cc)));
          break;
      }
      ii = ii + 1;
    }
    return encoded_str.clone();
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.value_type ) { 
      case 2 : 
        wr.out(["".to_string() , (node.double_value.to_string()) ].join(""), false);
        break;
      case 4 : 
        let s : String = self.EncodeString(node.clone(), ctx.clone(), wr.clone());
        wr.out(format!("{}{}", (format!("{}{}", "\"".to_string(), s)), "\"".to_string()), false);
        break;
      case 3 : 
        wr.out(["".to_string() , (node.int_value.to_string()) ].join(""), false);
        break;
      case 5 : 
        if  node.boolean_value {
          wr.out("True".to_string(), false);
        } else {
          wr.out("False".to_string(), false);
        }
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.vref == "this".to_string() {
      wr.out("self".to_string(), false);
      return;
    }
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  part == "this".to_string() {
            wr.out("self".to_string(), false);
            continue;
          }
        }
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  i == 0 {
          if  p.nameNode.hasFlag("optional".to_string()) {
          }
          let part_1 : String = node.ns[0 as usize].clone();
          if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part_1.clone());
            if  up.is_some() {
              if  false == ctx.isInStatic() {
                wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
              }
            }
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let part_2 : String = node.ns[0 as usize].clone();
      if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_2.clone());
        if  up_1.is_some() {
          if  false == ctx.isInStatic() {
            wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
          }
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_3 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        wr.out(".".to_string(), false);
      }
      if  i_1 == 0 {
        if  ctx.hasClass(part_3.clone()) {
          b_was_static = true;
        }
        if  (part_3 != "this".to_string()) && ctx.hasCurrentClass() {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_3.clone());
          if  up_2.is_some() {
            if  false == ctx.isInStatic() {
              wr.out(format!("{}{}", self.thisName, ".".to_string()), false);
            }
          }
        }
      }
      wr.out(self.adjustType(part_3.clone()), false);
    }
  }
  fn writeVarInitDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("# unused:  ".to_string(), false);
      }
      wr.out(format!("{}{}", "self.".to_string(), p.compiledName), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = []".to_string(), false);
        }
        if  nn.value_type == 7 {
          wr.out(" = {}".to_string(), false);
        }
      }
      wr.newline();
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("# unused:  ".to_string(), false);
      }
      wr.out(p.compiledName.clone(), false);
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          wr.out(" = []".to_string(), false);
        } else {
          if  nn.value_type == 7 {
            wr.out(" = {}".to_string(), false);
          } else {
            wr.out(" = None".to_string(), false);
          }
        }
      }
      wr.newline();
    }
  }
  fn CreateMethodCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getFirst();
    let mut args : CodeNode = node.getSecond();
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out("(".to_string(), false);
    ctx.setInExpr();
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
  }
  fn CreatePropertyGet(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut obj : CodeNode = node.getSecond();
    let mut prop : CodeNode = node.getThird();
    ctx.setInExpr();
    self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
    ctx.unsetInExpr();
    wr.out(".".to_string(), false);
    wr.out(prop.vref.clone(), false);
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut givenArgs : CodeNode = node.children[1 as usize].clone();
    let mut args : Option<CodeNode> = None;
    if  fName.expression_value.is_some() {
      args = Some(fName.expression_value.children[1 as usize].clone());
    } else {
      let mut param : RangerAppParamDesc = ctx.getVariableDef(fName.vref.clone());
      args = Some(param.nameNode.expression_value.children[1 as usize].clone());
    }
    ctx.setInExpr();
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      let mut n : CodeNode = givenArgs.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.value_type != 0 {
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
    }
    ctx.unsetInExpr();
    wr.out(")".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.newline();
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    /** unused:  let mut fnNode : CodeNode = node.children[0 as usize].clone();   **/ 
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("lambda ".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.out(": ".to_string(), false);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
  }
  fn writeClassVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      wr.out(arg.compiledName.clone(), false);
    }
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("[".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("]".to_string(), false);
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      ctx.setInExpr();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.newline();
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(node.clDesc.name.clone(), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out(")".to_string(), false);
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(".".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.newline();
      }
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut declaredFunction : HashMap<String,bool> = HashMap::new();
    let mut wr : CodeWriter = orig_wr;
    /** unused:  let mut importFork : CodeWriter = wr.fork();   **/ 
    if  self.wrote_header == false {
      wr.out("# -*- coding: utf-8 -*-".to_string(), true);
      wr.out("".to_string(), true);
      self.wrote_header = true;
    }
    wr.out(format!("{}{}", "class ".to_string(), cl.name), false);
    let mut parentClass : Option<RangerAppClassDesc> = None;
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out("(".to_string(), false);
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        wr.out(pName.clone(), false);
        parentClass = Some(ctx.findClass(pName.clone()));
      }
      wr.out(")".to_string(), false);
    }
    wr.out(":".to_string(), true);
    wr.indent(1);
    wr.out("def __init__(self".to_string(), false);
    if  cl.has_constructor {
      let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
      if  ((constr.params.len() as i64)) > 0 {
        wr.out(", ".to_string(), false);
        self.writeArgsDef(constr.clone(), ctx.clone(), wr.clone());
      }
    }
    wr.out("):".to_string(), true);
    wr.indent(1);
    if parentClass.is_some() {
      wr.out("super().__init__()".to_string(), true);
    }
    let mut hasContent : bool = false;
    for i_1 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_1 as usize].clone();
      self.writeVarInitDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
      hasContent = true;
    }
    if  cl.has_constructor {
      let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      hasContent = true;
    }
    if  hasContent == false {
      wr.out("pass".to_string(), true);
    }
    wr.newline();
    wr.indent(-1);
    for i_2 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_2 as usize].clone();
      if  variant.nameNode.hasFlag("main".to_string()) {
        continue;
      } else {
        wr.out("@staticmethod".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "def ".to_string(), variant.compiledName)), "(".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out("):".to_string(), true);
      }
      wr.indent(1);
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      subCtx_1.in_static_method = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      subCtx_1.in_static_method = false;
      wr.newline();
      wr.indent(-1);
    }
    for i_3 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_3 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_4 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_4 as usize].clone();
        if  declaredFunction.contains_key(&variant_1.name) {
          continue;
        }
        declaredFunction.insert(variant_1.name, true);
        wr.out(format!("{}{}", (format!("{}{}", "def ".to_string(), variant_1.compiledName)), "(self".to_string()), false);
        if  ((variant_1.params.len() as i64)) > 0 {
          wr.out(", ".to_string(), false);
          self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        }
        wr.out("):".to_string(), true);
        wr.indent(1);
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        subCtx_2.in_static_method = false;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
      }
    }
    wr.indent(-1);
    wr.newline();
    for i_5 in 0..cl.static_methods.len() {
      let mut variant_2 = cl.static_methods[i_5 as usize].clone();
      ctx.disableCurrentClass();
      ctx.in_static_method = true;
      if  variant_2.nameNode.hasFlag("main".to_string()) && (variant_2.nameNode.code.filename == ctx.getRootFile()) {
        wr.out("# Main entry point".to_string(), true);
        wr.out("def main():".to_string(), true);
        wr.indent(1);
        self.WalkNode(variant_2.fnBody.clone().unwrap(), ctx.clone(), wr.clone());
        wr.indent(-1);
        wr.newline();
        wr.out("if __name__ == \"__main__\":".to_string(), true);
        wr.indent(1);
        wr.out("main()".to_string(), true);
        wr.indent(-1);
      }
      ctx.in_static_method = false;
    }
  }
}
#[derive(Clone)]
struct WebPageWriter { 
  classWriter : Option<RangerGenericClassWriter>, 
}
impl WebPageWriter { 
  
  pub fn new() ->  WebPageWriter {
    let mut me = WebPageWriter { 
      classWriter: None, 
    };
    return me;
  }
  fn CreatePage(&mut self, mut parser : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut sc : CodeNode = node.getSecond();
    let mut wr : CodeWriter = orig_wr;
    wr.out("// created by WebPageWriter ".to_string(), true);
    wr.out(format!("{}{}", sc.vref, " () {".to_string()), true);
    wr.indent(1);
    wr.out(format!("{}{}", (format!("{}{}", "var view = document.getElementById('".to_string(), sc.vref)), "');".to_string()), true);
    let mut fnBody : CodeNode = node.children[2 as usize].clone();
    let mut subCtx : RangerAppWriterContext = ctx.fork();
    subCtx.is_function = true;
    subCtx.in_static_method = true;
    subCtx.setInMethod();
    parser.WalkNodeChildren(fnBody.clone(), subCtx.clone(), wr.clone());
    subCtx.unsetInMethod();
    subCtx.in_static_method = false;
    subCtx.function_level_context = true;
    self.self.classWriter.WalkNode(fnBody.clone(), subCtx.clone(), wr.clone());
    wr.out("return view;".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct RangerJavaScriptClassWriter { 
  compiler : Option<LiveCompiler>, 
  thisName : String, 
  wrote_header : bool, 
  target_flow : bool, 
  target_typescript : bool, 
}
impl RangerJavaScriptClassWriter { 
  
  pub fn new() ->  RangerJavaScriptClassWriter {
    let mut me = RangerJavaScriptClassWriter { 
      compiler: None, 
      thisName:"this".to_string(), 
      wrote_header:false, 
      target_flow:false, 
      target_typescript:false, 
    };
    return me;
  }
  fn lineEnding(&mut self, ) -> String {
    return ";".to_string().clone();
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn CreateTsUnions(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut root : RangerAppWriterContext = ctx.getRoot();
    operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
      if  item.is_union {
        wr.out(format!("{}{}", (format!("{}{}", "type union_".to_string(), index)), " = ".to_string()), false);
        wr.indent(1);
        let mut cnt : i64 = 0;
        operatorsOf::forEach_12(item.is_union_of, (item, index) => { 
          if  ctx.isDefinedClass(item.clone()) {
            let mut cl : RangerAppClassDesc = ctx.findClass(item.clone());
            if  false == cl.isNormalClass() {
              return;
            }
            if  cnt > 0 {
              wr.out("|".to_string(), false);
            }
            wr.out(self.getObjectTypeString(item.clone(), ctx.clone()), false);
            cnt = cnt + 1;
          } else {
            if  cnt > 0 {
              wr.out("|".to_string(), false);
            }
            wr.out(self.getObjectTypeString(item.clone(), ctx.clone()), false);
            cnt = cnt + 1;
          }
        }
        );
        wr.indent(-1);
        wr.out(";".to_string(), true);
      }
    }
    );
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      let mut fc : CodeNode = node.getFirst();
      if  (node.fnDesc.is_some()) && (node.fnDesc.nameNode.is_some()) {
        let mut fnName : Option<CodeNode> = node.fnDesc.nameNode;
        if  fnName.hasFlag("async".to_string()) {
          wr.out("await ".to_string(), false);
        }
      }
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      ctx.setInExpr();
      let mut cnt : i64 = 0;
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  arg.nameNode.hasFlag("keyword".to_string()) {
          continue;
        }
        if  cnt > 0 {
          wr.out(", ".to_string(), false);
        }
        cnt = cnt + 1;
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ((node.methodChain.len() as i64)) > 0 {
        for i_1 in 0..node.methodChain.len() {
          let mut cc = node.methodChain[i_1 as usize].clone();
          wr.out(format!("{}{}", ".".to_string(), cc.methodName), false);
          wr.out("(".to_string(), false);
          ctx.setInExpr();
          for i_2 in 0..cc.args.children.len() {
            let mut arg_1 = cc.args.children[i_2 as usize].clone();
            if  i_2 > 0 {
              wr.out(", ".to_string(), false);
            }
            self.WalkNode(arg_1.clone(), ctx.clone(), wr.clone());
          }
          ctx.unsetInExpr();
          wr.out(")".to_string(), false);
        }
      }
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      if  (node.fnDesc.is_some()) && (node.fnDesc.nameNode.is_some()) {
        let mut fnName : Option<CodeNode> = node.fnDesc.nameNode;
        if  fnName.hasFlag("async".to_string()) {
          wr.out("await ".to_string(), false);
        }
      }
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(").".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(", ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() == 0 {
        wr.out(";".to_string(), true);
      }
    }
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "number".to_string().clone();
        break;
      case "string".to_string() : 
        return "string".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "string".to_string().clone();
        break;
      case "char".to_string() : 
        return "number".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "number".to_string().clone();
        break;
    }
    if  ctx.isDefinedClass(type_string.clone()) {
      let mut cc : RangerAppClassDesc = ctx.findClass(type_string.clone());
      if  cc.is_system {
        /** unused:  let mut current_sys : RangerAppWriterContext = ctx;   **/ 
        let sName : String = (cc.systemNames.get("es6".to_string())).unwrap();
        return sName.clone();
      }
      if  cc.is_union {
        return format!("{}{}", "union_".to_string(), cc.name).clone();
      }
    }
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    switch (type_string ) { 
      case "int".to_string() : 
        return "number".to_string().clone();
        break;
      case "string".to_string() : 
        return "string".to_string().clone();
        break;
      case "charbuffer".to_string() : 
        return "string".to_string().clone();
        break;
      case "char".to_string() : 
        return "number".to_string().clone();
        break;
      case "boolean".to_string() : 
        return "boolean".to_string().clone();
        break;
      case "double".to_string() : 
        return "number".to_string().clone();
        break;
    }
    return type_string.clone();
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    switch (v_type ) { 
      case 17 : 
        let mut rv : CodeNode = node.expression_value.children[0 as usize].clone();
        let mut sec : CodeNode = node.expression_value.children[1 as usize].clone();
        /** unused:  let mut fc : CodeNode = sec.getFirst();   **/ 
        wr.out("(".to_string(), false);
        for i in 0..sec.children.len() {
          let mut arg = sec.children[i as usize].clone();
          if  i > 0 {
            wr.out(", ".to_string(), false);
          }
          self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
          wr.out(":".to_string(), false);
          self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
        }
        wr.out(") => ".to_string(), false);
        if  self.target_typescript {
          if  node.hasFlag("async".to_string()) {
            wr.out("Promise<".to_string(), false);
          }
        }
        self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
        if  self.target_typescript {
          if  node.hasFlag("async".to_string()) {
            wr.out(">".to_string(), false);
          }
        }
        break;
      case 13 : 
        wr.out("number".to_string(), false);
        break;
      case 3 : 
        wr.out("number".to_string(), false);
        break;
      case 14 : 
        wr.out("number".to_string(), false);
        break;
      case 15 : 
        wr.out("string".to_string(), false);
        break;
      case 2 : 
        wr.out("number".to_string(), false);
        break;
      case 4 : 
        wr.out("string".to_string(), false);
        break;
      case 5 : 
        wr.out("boolean".to_string(), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "{[key:".to_string(), self.getObjectTypeString(k_name.clone(), ctx.clone()))), "]:".to_string())), self.getObjectTypeString(a_name.clone(), ctx.clone()))), "}".to_string()), false);
        break;
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "Array<".to_string(), self.getObjectTypeString(a_name.clone(), ctx.clone()))), ">".to_string()), false);
        break;
      default: 
        if  node.type_name == "void".to_string() {
          wr.out("void".to_string(), false);
          return;
        }
        if  ctx.isDefinedClass(t_name.clone()) {
          let mut cc : RangerAppClassDesc = ctx.findClass(t_name.clone());
          if  cc.is_system {
            /** unused:  let mut current_sys : RangerAppWriterContext = ctx;   **/ 
            let sName : String = (cc.systemNames.get("es6".to_string())).unwrap();
            wr.out(sName.clone(), false);
            return;
          }
          if  cc.is_union {
            wr.out("union_".to_string(), false);
            wr.out(t_name.clone(), false);
            return;
          }
          let mut cc_1 : RangerAppClassDesc = ctx.findClass(t_name.clone());
          wr.out(cc_1.name.clone(), false);
          return;
        }
        wr.out(self.getTypeString(t_name.clone()), false);
        break;
    }
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.eval_type == 13 {
      if  ((node.ns.len() as i64)) > 1 {
        let rootObjName : String = node.ns[0 as usize].clone();
        let enumName : String = node.ns[1 as usize].clone();
        let mut e : Option<RangerAppEnum> = ctx.getEnum(rootObjName.clone());
        if  e.is_some() {
          wr.out(["".to_string() , (((e.values.get(enumName)).unwrap()).to_string()) ].join(""), false);
          return;
        }
      }
    }
    if  ((node.nsp.len() as i64)) > 0 {
      for i in 0..node.nsp.len() {
        let mut p = node.nsp[i as usize].clone();
        if  i > 0 {
          wr.out(".".to_string(), false);
        }
        if  i == 0 {
          let part : String = node.ns[0 as usize].clone();
          if  (part != "this".to_string()) && ctx.isMemberVariable(part.clone()) {
            let mut uc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
            let mut currC : RangerAppClassDesc = uc.unwrap();
            let mut up : Option<RangerAppParamDesc> = currC.findVariable(part.clone());
            if  up.is_some() {
              wr.out("this.".to_string(), false);
            }
          }
          if  part == "this".to_string() {
            wr.out("this".to_string(), false);
            continue;
          }
        }
        if  (p.compiledName.len() as i64) > 0 {
          wr.out(self.adjustType(p.compiledName.clone()), false);
        } else {
          if  (p.name.len() as i64) > 0 {
            wr.out(self.adjustType(p.name.clone()), false);
          } else {
            wr.out(self.adjustType((node.ns[i as usize].clone())), false);
          }
        }
      }
      return;
    }
    if  node.hasParamDesc {
      let part_1 : String = node.ns[0 as usize].clone();
      if  (part_1 != "this".to_string()) && ctx.isMemberVariable(part_1.clone()) {
        let mut uc_1 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
        let mut currC_1 : RangerAppClassDesc = uc_1.unwrap();
        let mut up_1 : Option<RangerAppParamDesc> = currC_1.findVariable(part_1.clone());
        if  up_1.is_some() {
          wr.out("this.".to_string(), false);
        }
      }
      let mut p_1 : Option<RangerAppParamDesc> = node.paramDesc;
      wr.out(p_1.compiledName.clone(), false);
      return;
    }
    let mut b_was_static : bool = false;
    for i_1 in 0..node.ns.len() {
      let mut part_2 = node.ns[i_1 as usize].clone();
      if  i_1 > 0 {
        if  (i_1 == 1) && b_was_static {
          wr.out(".".to_string(), false);
        } else {
          wr.out(".".to_string(), false);
        }
      }
      if  i_1 == 0 {
        if  ctx.hasClass(part_2.clone()) {
          b_was_static = true;
        } else {
          wr.out("".to_string(), false);
        }
        if  (part_2 != "this".to_string()) && ctx.isMemberVariable(part_2.clone()) {
          let mut uc_2 : Option<RangerAppClassDesc> = ctx.getCurrentClass();
          let mut currC_2 : RangerAppClassDesc = uc_2.unwrap();
          let mut up_2 : Option<RangerAppParamDesc> = currC_2.findVariable(part_2.clone());
          if  up_2.is_some() {
            wr.out("this.".to_string(), false);
          }
        }
      }
      wr.out(self.adjustType(part_2.clone()), false);
    }
  }
  fn writeVarInitDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      let remove_unused : bool = ctx.hasCompilerFlag("remove-unused-class-vars".to_string());
      if  (p.ref_cnt == 0) && (remove_unused || (p.is_class_variable == false)) {
        return;
      }
      let mut was_set : bool = false;
      if  ((node.children.len() as i64)) > 2 {
        wr.out(format!("{}{}", (format!("{}{}", "this.".to_string(), p.compiledName)), " = ".to_string()), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        was_set = true;
      } else {
        if  nn.value_type == 6 {
          wr.out(format!("{}{}", "this.".to_string(), p.compiledName), false);
          if  nn.hasFlag("immutable".to_string()) {
            wr.out(" = require('immutable').List()".to_string(), false);
          } else {
            wr.out(" = []".to_string(), false);
          }
          was_set = true;
        }
        if  nn.value_type == 7 {
          wr.out(format!("{}{}", "this.".to_string(), p.compiledName), false);
          if  nn.hasFlag("immutable".to_string()) {
            wr.out(" = require('immutable').Map()".to_string(), false);
          } else {
            wr.out(" = {}".to_string(), false);
          }
          was_set = true;
        }
      }
      if  was_set {
        wr.out(";".to_string(), false);
        if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
          wr.out("     /** note: unused */".to_string(), false);
        }
        wr.newline();
      }
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      /** unused:  let opt_js : bool = ctx.hasCompilerFlag("optimize-js".to_string());   **/ 
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("/** unused:  ".to_string(), false);
      }
      let mut has_value : bool = false;
      if  ((node.children.len() as i64)) > 2 {
        has_value = true;
      }
      if  ((p.set_cnt > 0) || p.is_class_variable) || (has_value == false) {
        wr.out(format!("{}{}", "let ".to_string(), p.compiledName), false);
      } else {
        wr.out(format!("{}{}", "const ".to_string(), p.compiledName), false);
      }
      if  self.target_typescript {
        wr.out(" : ".to_string(), false);
        self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
      }
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" = ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      } else {
        if  nn.value_type == 6 {
          if  nn.hasFlag("immutable".to_string()) {
            wr.out(" = require('immutable').List()".to_string(), false);
          } else {
            wr.out(" = []".to_string(), false);
          }
        }
        if  nn.value_type == 7 {
          if  nn.hasFlag("immutable".to_string()) {
            wr.out(" = require('immutable').Map()".to_string(), false);
          } else {
            wr.out(" = {}".to_string(), false);
          }
        }
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == true) {
        wr.out("     /** note: unused */".to_string(), false);
      }
      if  (p.ref_cnt == 0) && (p.is_class_variable == false) {
        wr.out("   **/ ".to_string(), true);
      } else {
        wr.out(";".to_string(), false);
        wr.newline();
      }
    }
  }
  fn writeClassVarDef(&mut self, mut p : RangerAppParamDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  self.target_typescript {
      wr.out(p.compiledName.clone(), false);
      wr.out(": ".to_string(), false);
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    ctx.setInExpr();
    let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
    if  (currM.nameNode.is_some()) && currM.nameNode.hasFlag("async".to_string()) {
      wr.out("await ".to_string(), false);
    }
    self.WalkNode(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    ctx.unsetInExpr();
    if  ctx.expressionLevel() == 0 {
      wr.out(";".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    if  ctx.expressionLevel() > 0 {
      wr.out("(".to_string(), false);
    }
    if  fName.hasFlag("async".to_string()) {
      wr.out("async ".to_string(), false);
    }
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(", ".to_string(), false);
      }
      if  arg.flow_done == false {
        self.compiler.parser.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      }
      self.WalkNode(arg.clone(), lambdaCtx.clone(), wr.clone());
      if  self.target_typescript {
        wr.out(" : ".to_string(), false);
        self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
      }
    }
    wr.out(")".to_string(), false);
    if  self.target_typescript {
      wr.out(":".to_string(), false);
      if  fName.hasFlag("async".to_string()) {
        wr.out(" Promise<".to_string(), false);
      }
      self.writeTypeDef(fName.clone(), ctx.clone(), wr.clone());
      if  fName.hasFlag("async".to_string()) {
        wr.out(">".to_string(), false);
      }
    }
    wr.out(" => { ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), lambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("}".to_string(), false);
    if  ctx.expressionLevel() > 0 {
      wr.out(")".to_string(), false);
    } else {
      wr.out("".to_string(), true);
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut cnt : i64 = 0;
    let mut pms : Vec<RangerAppParamDesc> = operatorsOf::filter_50(fnDesc.params, (item, index) => { 
      if  item.nameNode.hasFlag("keyword".to_string()) {
        return false;
      }
      return true;
    }
    );
    for i in 0..pms.len() {
      let mut arg = pms[i as usize].clone();
      if  cnt > 0 {
        wr.out(", ".to_string(), false);
      }
      cnt = cnt + 1;
      wr.out(arg.compiledName.clone(), false);
      if  self.target_typescript {
        wr.out(" : ".to_string(), false);
        self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      }
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    let mut is_react_native : bool = false;
    let mut is_rn_default : bool = false;
    self.target_typescript = ctx.hasCompilerFlag("typescript".to_string());
    if  ctx.hasCompilerFlag("dead4main".to_string()) || ctx.hasCompilerSetting("dceclass".to_string()) {
      if  cl.is_used_by_main == false {
        return;
      }
    }
    if  cl.is_interface {
      orig_wr.out(format!("{}{}", "// interface : ".to_string(), cl.name), true);
      return;
    }
    if  cl.is_none() {
      return;
    }
    if  cl.nameNode.hasFlag("ReactNative".to_string()) {
      is_react_native = true;
      self.compFlags.insert("ReactNative".to_string(), true);
    }
    if  cl.nameNode.hasFlag("default".to_string()) {
      is_rn_default = true;
    }
    let mut wr : CodeWriter = orig_wr;
    /** unused:  let mut importFork : CodeWriter = wr.fork();   **/ 
    if  self.wrote_header == false {
      self.wrote_header = true;
      if  ctx.hasCompilerFlag("nodecli".to_string()) {
        wr.out("#!/usr/bin/env node".to_string(), true);
      }
      if  ctx.hasCompilerFlag("nodemodule".to_string()) && (self.target_typescript == false) {
        let mut root : RangerAppWriterContext = ctx.getRoot();
        operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
          if  ctx.hasCompilerFlag("dead4main".to_string()) || ctx.hasCompilerSetting("dceclass".to_string()) {
            if  item.is_used_by_main == false {
              return;
            }
          }
          if  item.isNormalClass() {
            let mut theEnd : CodeWriter = wr.getTag("file_end".to_string());
            theEnd.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "module.exports.".to_string(), item.name)), " = ".to_string())), item.name)), ";".to_string()), true);
          }
        }
        );
      }
      self.target_flow = ctx.hasCompilerFlag("flow".to_string());
      if  self.target_typescript {
        self.CreateTsUnions(self.compiler.parser.clone().unwrap(), ctx.clone(), wr.clone());
      }
      if  ctx.hasCompilerFlag("npm".to_string()) {
        self.writeNpmPackage(node.clone(), ctx.clone(), wr.clone());
      }
    }
    let mut b_extd : bool = false;
    let mut do_export : bool = false;
    if  is_react_native || self.target_typescript {
      do_export = true;
      if  cl.is_system || cl.is_operator_class {
        do_export = false;
      }
    }
    if  do_export {
      wr.out("export ".to_string(), false);
      if  is_rn_default {
        wr.out(" default ".to_string(), false);
      }
    }
    wr.out(format!("{}{}", (format!("{}{}", "class ".to_string(), cl.name)), " ".to_string()), false);
    if  is_react_native {
      wr.out(" extends Component ".to_string(), false);
    } else {
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        if  i == 0 {
          wr.out(" extends ".to_string(), false);
        }
        wr.out(pName.clone(), false);
        b_extd = true;
      }
    }
    wr.out(" {".to_string(), true);
    wr.indent(1);
    for i_1 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_1 as usize].clone();
      self.writeClassVarDef(pvar.clone(), ctx.clone(), wr.clone());
    }
    if  is_react_native == false {
      wr.out("constructor(".to_string(), false);
      if  cl.has_constructor {
        let mut constr : RangerAppFunctionDesc = cl.constructor_fn.clone().unwrap();
        self.writeArgsDef(constr.clone(), ctx.clone(), wr.clone());
      }
      wr.out(") {".to_string(), true);
      wr.indent(1);
      if  b_extd {
        wr.out("super()".to_string(), true);
      }
      for i_2 in 0..cl.variables.len() {
        let mut pvar_1 = cl.variables[i_2 as usize].clone();
        self.writeVarInitDef(pvar_1.node.clone().unwrap(), ctx.clone(), wr.clone());
      }
      if  cl.has_constructor {
        let mut constr_1 : Option<RangerAppFunctionDesc> = cl.constructor_fn;
        wr.newline();
        let mut subCtx : RangerAppWriterContext = constr_1.fnCtx.clone().unwrap();
        subCtx.is_function = true;
        self.WalkNode(constr_1.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      }
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_3 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_3 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_4 in 0..mVs.variants.len() {
        let mut variant = mVs.variants[i_4 as usize].clone();
        if  variant.nameNode.hasFlag("async".to_string()) {
          wr.out("async ".to_string(), false);
        }
        wr.out(format!("{}{}", (format!("{}{}", "".to_string(), variant.compiledName)), " (".to_string()), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), false);
        if  self.target_typescript {
          wr.out(" : ".to_string(), false);
          if  variant.nameNode.hasFlag("async".to_string()) {
            wr.out(" Promise<".to_string(), false);
          }
          self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
          if  variant.nameNode.hasFlag("async".to_string()) {
            wr.out(">".to_string(), false);
          }
          wr.out(" ".to_string(), false);
        }
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
        subCtx_1.is_function = true;
        operatorsOf_13::forEach_20(subCtx_1.localVariables, (item, index) => { 
          if  item.is_register {
            wr.out(format!("{}{}", "// register ".to_string(), item.name), true);
          }
        }
        );
        self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("};".to_string(), true);
      }
    }
    if  self.target_typescript {
      for i_5 in 0..cl.static_methods.len() {
        let mut variant_1 = cl.static_methods[i_5 as usize].clone();
        if  variant_1.nameNode.hasFlag("main".to_string()) {
          continue;
        }
        if  variant_1.nameNode.hasFlag("test".to_string()) {
          println!( "{}", format!("{}{}", "Found a test function, but not writing it: ".to_string(), variant_1.nameNode.vref) );
          continue;
        }
        wr.out("static ".to_string(), false);
        if  variant_1.nameNode.hasFlag("async".to_string()) {
          wr.out("async ".to_string(), false);
        }
        wr.out(format!("{}{}", (format!("{}{}", "".to_string(), variant_1.compiledName)), " (".to_string()), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(")".to_string(), false);
        wr.out(" : ".to_string(), false);
        if  variant_1.nameNode.hasFlag("async".to_string()) {
          wr.out(" Promise<".to_string(), false);
        }
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        if  variant_1.nameNode.hasFlag("async".to_string()) {
          wr.out("> ".to_string(), false);
        }
        wr.out(" ".to_string(), false);
        wr.out(" {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("};".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    if  self.target_typescript == false {
      for i_6 in 0..cl.static_methods.len() {
        let mut variant_2 = cl.static_methods[i_6 as usize].clone();
        if  variant_2.nameNode.hasFlag("main".to_string()) {
          continue;
        } else {
          if  variant_2.nameNode.hasFlag("test".to_string()) {
            let mut testFile : CodeWriter = wr.getFileWriter("test/".to_string(), "testfile.js".to_string());
            testFile.out("// test file for JS".to_string(), true);
            testFile.out("describe(\"testcase\", function() {".to_string(), true);
            testFile.indent(1);
            testFile.indent(-1);
            testFile.out("}".to_string(), true);
            println!( "{}", format!("{}{}", "Found a test function, but not writing it: ".to_string(), variant_2.nameNode.vref) );
            continue;
          }
          let mut asyncKeyword : String = "".to_string();
          if  variant_2.nameNode.hasFlag("async".to_string()) {
            asyncKeyword = "async ".to_string();
          }
          wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", cl.name, ".".to_string())), variant_2.compiledName)), " = ".to_string())), asyncKeyword)), "function(".to_string()), false);
          self.writeArgsDef(variant_2.clone(), ctx.clone(), wr.clone());
          wr.out(") {".to_string(), true);
        }
        wr.indent(1);
        wr.newline();
        let mut subCtx_3 : RangerAppWriterContext = variant_2.fnCtx.clone().unwrap();
        subCtx_3.is_function = true;
        self.WalkNode(variant_2.fnBody.clone().unwrap(), subCtx_3.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("};".to_string(), true);
      }
    }
    if  ctx.hasCompilerFlag("nodemodule".to_string()) == false {
      for i_7 in 0..cl.static_methods.len() {
        let mut variant_3 = cl.static_methods[i_7 as usize].clone();
        ctx.disableCurrentClass();
        if  variant_3.nameNode.hasFlag("main".to_string()) && (variant_3.nameNode.code.filename == ctx.getRootFile()) {
          let mut asyncKeyword_1 : String = "".to_string();
          if  variant_3.nameNode.hasFlag("async".to_string()) {
            asyncKeyword_1 = "async ".to_string();
          }
          let mut theEnd_1 : CodeWriter = wr.getTag("file_end".to_string());
          theEnd_1.out("/* static JavaSript main routine at the end of the JS file */".to_string(), false);
          theEnd_1.newline();
          theEnd_1.out(format!("{}{}", asyncKeyword_1, "function __js_main() {".to_string()), true);
          theEnd_1.indent(1);
          self.WalkNode(variant_3.fnBody.clone().unwrap(), ctx.clone(), theEnd_1.clone());
          theEnd_1.newline();
          theEnd_1.indent(-1);
          theEnd_1.out("}".to_string(), true);
          theEnd_1.out("__js_main();".to_string(), true);
        }
      }
    }
  }
  fn BuildAST(&mut self, code_string : String) -> CodeNode {
    let mut lang_code : SourceCode = SourceCode::new(code_string.clone());
    lang_code.filename = "services".to_string();
    let mut lang_parser : RangerLispParser = RangerLispParser::new(lang_code.clone());
    lang_parser.parse(false);
    let mut node : CodeNode = lang_parser.rootNode.clone().unwrap();
    return node.clone();
  }
  fn CreateServices(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    if  ctx.hasCompilerFlag("client".to_string()) {
      ctx.addError(CodeNode::blockNode(), "client service writing for target JavaScript is not implemented".to_string());
      return;
    }
    let mut root : RangerAppWriterContext = ctx.getRoot();
    let mut serviceBlock : CodeNode = CodeNode::blockNode();
    let mut wr : CodeWriter = CodeWriter::new();
    wr.out("class test_webservice {".to_string(), true);
    wr.indent(1);
    wr.out("fn run () {".to_string(), true);
    wr.indent(1);
    wr.out("def www (create_web_server)".to_string(), true);
    wr.out("prepare_server www".to_string(), true);
    operatorsOf_13::forEach_25(root.appServices, (item, index) => { 
      try {
        let mut paramList : CodeNode = item.getThird();
        let mut param : CodeNode = paramList.getFirst();
        wr.out(format!("{}{}", (format!("{}{}", "www.post_route(\"/".to_string(), item.appGUID)), "\" {".to_string()), true);
        wr.indent(1);
        wr.out(format!("{}{}", (format!("{}{}", "def obj (".to_string(), param.type_name)), ".fromDictionary( (from_string (get_post_data req ))) )".to_string()), true);
        wr.out("def service (new appServices)".to_string(), true);
        wr.out(format!("{}{}", (format!("{}{}", "def data (service.".to_string(), item.appGUID)), "(obj))".to_string()), true);
        wr.out("res.send((to_string (data.toDictionary())))".to_string(), true);
        wr.indent(-1);
        wr.out("})".to_string(), true);
        let mut nn : CodeNode = item.getSecond();
        nn.vref = item.appGUID.clone();
        let mut params : CodeNode = item.getThird();
        let mut block_index : i64 = 3;
        let ch_len : i64 = ((item.children.len() as i64)) - 1;
        for i in 0..item.children.len() {
          let mut cb = item.children[i as usize].clone();
          if  i > 3 {
            if  (cb.vref.len() as i64) > 0 {
              if  ctx.hasCompilerFlag(cb.vref.clone()) && (i < ch_len) {
                block_index = i + 1;
              }
            }
          }
        }
        let mut codeBlock : CodeNode = item.getChild(block_index).unwrap();
        serviceBlock.children.push(CodeNode::op3("fn".to_string(), [nn, params, codeBlock]));
      } catch(e) {
        ctx.addError(item.clone(), "Invalid service function".to_string());
      }
    }
    );
    wr.indent(-1);
    wr.out("www.startServer( 1777, {".to_string(), true);
    wr.indent(1);
    wr.out("print \"Server started\"".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    wr.out("}".to_string(), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
    let mut codeNode : CodeNode = self.BuildAST(wr.getCode());
    let mut serviceClassDef : CodeNode = CodeNode::op3("class".to_string(), [CodeNode::vref1("appServices".to_string()), serviceBlock]);
    /** unused:  let mut subCtx : RangerAppWriterContext = root.fork();   **/ 
    let mut theEnd : CodeWriter = orig_wr.getTag("file_end".to_string());
    parser.WalkCollectMethods(serviceClassDef.clone(), root.clone(), theEnd.clone());
    parser.WalkCollectMethods(codeNode.clone(), root.clone(), theEnd.clone());
    parser.WalkNode(serviceClassDef.clone(), root.clone(), theEnd.clone());
    parser.WalkNode(codeNode.clone(), root.clone(), theEnd.clone());
    theEnd.out("(new test_webservice).run();".to_string(), true);
  }
  fn CreatePages(&mut self, mut parser : RangerFlowParser, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut wr : CodeWriter = orig_wr.getFileWriter(".".to_string(), "pages.js".to_string());
    wr.out("class theApplicationClass {".to_string(), true);
    wr.indent(1);
    operatorsOf_13::forEach_25(ctx.appPages, (item, index) => { 
      self.CreatePage(parser.clone(), item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
  fn CreatePage(&mut self, mut parser : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut writer : WebPageWriter = WebPageWriter::new();
    writer.classWriter = Some(self);
    writer.CreatePage(parser.clone(), node.clone(), ctx.clone(), orig_wr.clone());
  }
  fn writeNpmPackage(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut wr : CodeWriter = orig_wr.getFileWriter(".".to_string(), "package.json".to_string());
    let mut opts : Vec<String> = ["name".to_string(), "version".to_string(), "description".to_string(), "author".to_string(), "license".to_string()];
    wr.out("{".to_string(), true);
    wr.indent(1);
    operatorsOf::forEach_12(opts, (item, index) => { 
      if  ctx.hasCompilerSetting(item.clone()) == false {
        ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "NPM package requires option -".to_string(), item)), "=<value>".to_string()));
      } else {
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"".to_string(), item)), "\" : \"".to_string())), ctx.getCompilerSetting(item.clone()))), "\",".to_string()), true);
      }
    }
    );
    let target_file : String = ctx.getCompilerSetting("o".to_string());
    if  ctx.hasCompilerFlag("nodecli".to_string()) {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "\"bin\": {\"".to_string(), ctx.getCompilerSetting("name".to_string()))), "\":\"".to_string())), target_file)), "\"},".to_string()), true);
    }
    wr.out("\"scripts\":{},".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "\"main\":\"".to_string(), target_file)), "\"".to_string()), true);
    wr.indent(-1);
    wr.out("}".to_string(), true);
  }
}
#[derive(Clone)]
struct RangerRangerClassWriter { 
  compiler : Option<LiveCompiler>, 
}
impl RangerRangerClassWriter { 
  
  pub fn new() ->  RangerRangerClassWriter {
    let mut me = RangerRangerClassWriter { 
      compiler: None, 
    };
    return me;
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "this".to_string().clone();
    }
    return tn.clone();
  }
  fn getObjectTypeString(&mut self, type_string : String, mut ctx : RangerAppWriterContext) -> String {
    return type_string.clone();
  }
  fn getTypeString(&mut self, type_string : String) -> String {
    return type_string.clone();
  }
  fn writeArrayLiteral(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("([] ".to_string(), false);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(" ".to_string(), false);
      }
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out(")".to_string(), false);
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut v_type : i64 = node.value_type;
    let mut t_name : String = node.type_name.clone();
    let mut a_name : String = node.array_type.clone();
    let mut k_name : String = node.key_type.clone();
    if  ((v_type == 10) || (v_type == 11)) || (v_type == 0) {
      v_type = node.typeNameAsType(ctx.clone());
    }
    if  node.eval_type != 0 {
      v_type = node.eval_type;
      if  (node.eval_type_name.len() as i64) > 0 {
        t_name = node.eval_type_name.clone();
      }
      if  (node.eval_array_type.len() as i64) > 0 {
        a_name = node.eval_array_type.clone();
      }
      if  (node.eval_key_type.len() as i64) > 0 {
        k_name = node.eval_key_type.clone();
      }
    }
    if  v_type == 7 {
      wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), k_name)), ":".to_string())), a_name)), "]".to_string()), false);
      return;
    }
    if  v_type == 6 {
      wr.out(format!("{}{}", (format!("{}{}", "[".to_string(), a_name)), "]".to_string()), false);
      return;
    }
    wr.out(t_name.clone(), false);
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out(node.vref.clone(), false);
  }
  fn WriteVRefWithOpt(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out(node.vref.clone(), false);
    let mut flags : Vec<String> = ["optional".to_string(), "weak".to_string(), "strong".to_string(), "temp".to_string(), "lives".to_string(), "returns".to_string(), "returnvalue".to_string()];
    let mut some_set : bool = false;
    for i in 0..flags.len() {
      let mut flag = flags[i as usize].clone();
      if  node.hasFlag(flag.clone()) {
        if  false == some_set {
          wr.out("@(".to_string(), false);
          some_set = true;
        } else {
          wr.out(" ".to_string(), false);
        }
        wr.out(flag.clone(), false);
      }
    }
    if  some_set {
      wr.out(")".to_string(), false);
    }
  }
  fn writeVarDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasParamDesc {
      let mut nn : CodeNode = node.children[1 as usize].clone();
      let mut p : Option<RangerAppParamDesc> = nn.paramDesc;
      wr.out("def ".to_string(), false);
      self.WriteVRefWithOpt(nn.clone(), ctx.clone(), wr.clone());
      wr.out(":".to_string(), false);
      self.writeTypeDef(p.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      if  ((node.children.len() as i64)) > 2 {
        wr.out(" ".to_string(), false);
        ctx.setInExpr();
        let mut value : CodeNode = node.getThird();
        self.WalkNode(value.clone(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
      }
      wr.newline();
    }
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fName : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    self.WriteVRef(fName.clone(), ctx.clone(), wr.clone());
    wr.out("(".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(" ".to_string(), false);
      }
      self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    if  ctx.expressionLevel() == 0 {
      wr.out(" ".to_string(), true);
    }
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut lambdaCtx : RangerAppWriterContext = node.lambda_ctx.clone().unwrap();
    let mut nn : CodeNode = node.children[0 as usize].clone();
    let mut args : CodeNode = node.children[1 as usize].clone();
    let mut body : CodeNode = node.children[2 as usize].clone();
    wr.out("(fn:".to_string(), false);
    self.writeTypeDef(nn.clone(), ctx.clone(), wr.clone());
    wr.out(" (".to_string(), false);
    for i in 0..args.children.len() {
      let mut arg = args.children[i as usize].clone();
      if  i > 0 {
        wr.out(" ".to_string(), false);
      }
      self.WriteVRefWithOpt(arg.clone(), ctx.clone(), wr.clone());
      wr.out(":".to_string(), false);
      self.writeTypeDef(arg.clone(), ctx.clone(), wr.clone());
    }
    wr.out(")".to_string(), false);
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    lambdaCtx.restartExpressionLevel();
    let mut newLambdaCtx : RangerAppWriterContext = lambdaCtx.fork();
    newLambdaCtx.targetLangName = "ranger".to_string();
    for i_1 in 0..body.children.len() {
      let mut item = body.children[i_1 as usize].clone();
      self.WalkNode(item.clone(), newLambdaCtx.clone(), wr.clone());
    }
    wr.newline();
    wr.indent(-1);
    wr.out("})".to_string(), true);
  }
  fn writeFnCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasFnCall {
      if  ctx.expressionLevel() > 0 {
        wr.out("(".to_string(), false);
      }
      let mut fc : CodeNode = node.getFirst();
      self.WriteVRef(fc.clone(), ctx.clone(), wr.clone());
      wr.out("(".to_string(), false);
      let mut givenArgs : CodeNode = node.getSecond();
      ctx.setInExpr();
      for i in 0..node.fnDesc.params.len() {
        let mut arg = node.fnDesc.params[i as usize].clone();
        if  i > 0 {
          wr.out(" ".to_string(), false);
        }
        if  ((givenArgs.children.len() as i64)) <= i {
          let mut defVal : Option<CodeNode> = arg.nameNode.getFlag("default".to_string());
          if  defVal.is_some() {
            let mut fc_1 : CodeNode = defVal.vref_annotation.getFirst();
            self.WalkNode(fc_1.clone(), ctx.clone(), wr.clone());
          } else {
            ctx.addError(node.clone(), "Default argument was missing".to_string());
          }
          continue;
        }
        let mut n : CodeNode = givenArgs.children[i as usize].clone();
        self.WalkNode(n.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out(")".to_string(), false);
      if  ctx.expressionLevel() > 0 {
        wr.out(")".to_string(), false);
      }
      if  ctx.expressionLevel() == 0 {
        wr.newline();
      }
    }
  }
  fn writeNewCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.hasNewOper {
      let mut cl : Option<RangerAppClassDesc> = node.clDesc;
      /** unused:  let mut fc : CodeNode = node.getSecond();   **/ 
      wr.out(format!("{}{}", "(new ".to_string(), node.clDesc.name), false);
      wr.out("(".to_string(), false);
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      let mut givenArgs : CodeNode = node.getThird();
      if  constr.is_some() {
        for i in 0..constr.params.len() {
          let mut arg = constr.params[i as usize].clone();
          let mut n : CodeNode = givenArgs.children[i as usize].clone();
          if  i > 0 {
            wr.out(" ".to_string(), false);
          }
          if  true || (arg.nameNode.is_some()) {
            self.WalkNode(n.clone(), ctx.clone(), wr.clone());
          }
        }
      }
      wr.out("))".to_string(), false);
    }
  }
  fn writeArgsDef(&mut self, mut fnDesc : RangerAppFunctionDesc, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    for i in 0..fnDesc.params.len() {
      let mut arg = fnDesc.params[i as usize].clone();
      if  i > 0 {
        wr.out(",".to_string(), false);
      }
      wr.out(" ".to_string(), false);
      self.WriteVRefWithOpt(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
      wr.out(":".to_string(), false);
      self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
    }
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  node.has_call {
      let mut obj : CodeNode = node.getSecond();
      let mut method : CodeNode = node.getThird();
      let mut args : CodeNode = node.children[3 as usize].clone();
      wr.out("(call ".to_string(), false);
      ctx.setInExpr();
      self.WalkNode(obj.clone(), ctx.clone(), wr.clone());
      ctx.unsetInExpr();
      wr.out(" ".to_string(), false);
      wr.out(method.vref.clone(), false);
      wr.out("(".to_string(), false);
      ctx.setInExpr();
      for i in 0..args.children.len() {
        let mut arg = args.children[i as usize].clone();
        if  i > 0 {
          wr.out(" ".to_string(), false);
        }
        self.WalkNode(arg.clone(), ctx.clone(), wr.clone());
      }
      ctx.unsetInExpr();
      wr.out("))".to_string(), false);
      if  ctx.expressionLevel() == 0 {
      }
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut cl : Option<RangerAppClassDesc> = node.clDesc;
    if  cl.is_none() {
      return;
    }
    let mut wr : CodeWriter = orig_wr;
    let mut importFork : CodeWriter = wr.fork();
    wr.out("".to_string(), true);
    wr.out(format!("{}{}", "class ".to_string(), cl.name), false);
    wr.out(" { ".to_string(), true);
    wr.indent(1);
    if  ((cl.extends_classes.len() as i64)) > 0 {
      wr.out("Extends(".to_string(), false);
      for i in 0..cl.extends_classes.len() {
        let mut pName = cl.extends_classes[i as usize].clone();
        wr.out(pName.clone(), false);
      }
      wr.out(")".to_string(), true);
    }
    wr.createTag("utilities".to_string());
    for i_1 in 0..cl.variables.len() {
      let mut pvar = cl.variables[i_1 as usize].clone();
      self.writeVarDef(pvar.node.clone().unwrap(), ctx.clone(), wr.clone());
    }
    if  cl.has_constructor {
      let mut constr : Option<RangerAppFunctionDesc> = cl.constructor_fn;
      wr.out("".to_string(), true);
      wr.out("Constructor (".to_string(), false);
      self.writeArgsDef(constr.unwrap(), ctx.clone(), wr.clone());
      wr.out(" ) {".to_string(), true);
      wr.indent(1);
      wr.newline();
      let mut subCtx : RangerAppWriterContext = constr.fnCtx.clone().unwrap();
      subCtx.is_function = true;
      self.WalkNode(constr.fnBody.clone().unwrap(), subCtx.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_2 in 0..cl.static_methods.len() {
      let mut variant = cl.static_methods[i_2 as usize].clone();
      wr.out("".to_string(), true);
      if  variant.nameNode.hasFlag("main".to_string()) {
        wr.out("sfn m@(main):void () {".to_string(), true);
      } else {
        wr.out("sfn ".to_string(), false);
        self.WriteVRefWithOpt(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(":".to_string(), false);
        self.writeTypeDef(variant.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" (".to_string(), false);
        self.writeArgsDef(variant.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
      }
      wr.indent(1);
      wr.newline();
      let mut subCtx_1 : RangerAppWriterContext = variant.fnCtx.clone().unwrap();
      subCtx_1.is_function = true;
      self.WalkNode(variant.fnBody.clone().unwrap(), subCtx_1.clone(), wr.clone());
      wr.newline();
      wr.indent(-1);
      wr.out("}".to_string(), true);
    }
    for i_3 in 0..cl.defined_variants.len() {
      let mut fnVar = cl.defined_variants[i_3 as usize].clone();
      let mut mVs : Option<RangerAppMethodVariants> = cl.method_variants.get(fnVar);
      for i_4 in 0..mVs.variants.len() {
        let mut variant_1 = mVs.variants[i_4 as usize].clone();
        wr.out("".to_string(), true);
        wr.out("fn ".to_string(), false);
        self.WriteVRefWithOpt(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(":".to_string(), false);
        self.writeTypeDef(variant_1.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
        wr.out(" ".to_string(), false);
        wr.out("(".to_string(), false);
        self.writeArgsDef(variant_1.clone(), ctx.clone(), wr.clone());
        wr.out(") {".to_string(), true);
        wr.indent(1);
        wr.newline();
        let mut subCtx_2 : RangerAppWriterContext = variant_1.fnCtx.clone().unwrap();
        subCtx_2.is_function = true;
        self.WalkNode(variant_1.fnBody.clone().unwrap(), subCtx_2.clone(), wr.clone());
        wr.newline();
        wr.indent(-1);
        wr.out("}".to_string(), true);
      }
    }
    wr.indent(-1);
    wr.out("}".to_string(), true);
    let mut import_list : Vec<String> = wr.getImports();
    for i_5 in 0..import_list.len() {
      let mut codeStr = import_list[i_5 as usize].clone();
      importFork.out(format!("{}{}", (format!("{}{}", "Import \"".to_string(), codeStr)), "\"".to_string()), true);
    }
  }
}
#[derive(Clone)]
struct OpList { 
  list : Vec<CodeNode>, 
}
impl OpList { 
  
  pub fn new() ->  OpList {
    let mut me = OpList { 
      list: Vec::new(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct RangerActiveOperators { 
  stdCommands : Option<CodeNode>, 
  parent : Option<Box<RangerActiveOperators>>, 
  opHash : HashMap<String,OpList>, 
  initialized : bool, 
}
impl RangerActiveOperators { 
  
  pub fn new() ->  RangerActiveOperators {
    let mut me = RangerActiveOperators { 
      stdCommands: None, 
      parent: None, 
      opHash: None, 
      initialized:false, 
    };
    return me;
  }
  fn fork(&mut self, mut fromOperator : CodeNode) -> RangerActiveOperators {
    let mut newOps : RangerActiveOperators = RangerActiveOperators::new();
    newOps.parent = Some(Box::new(self.clone()));
    for i in 0..fromOperator.children.len() {
      let mut lch = fromOperator.children[i as usize].clone();
      let mut fc : CodeNode = lch.getFirst();
      if  fc.vref == "operators".to_string() {
        let mut n : CodeNode = lch.getSecond();
        newOps.stdCommands = Some(n.clone());
      }
    }
    return newOps.clone();
  }
  fn initializeOpCache(&mut self, ) -> () {
    operatorsOf_13::forEach_19(self.opHash, (item, index) => { 
      item.list.length = 0;
    }
    );
    for i in 0..self.stdCommands.children.len() {
      let mut lch = self.stdCommands.children[i as usize].clone();
      let mut fc : CodeNode = lch.getFirst();
      if  self.opHash.contains_key(&fc.vref) {
        let mut opList : OpList = (self.opHash.get(fc.vref)).unwrap();
        opList.list.push(lch.clone());
      } else {
        let mut newOpList : OpList = OpList::new();
        self.opHash.insert(fc.vref, newOpList);
        newOpList.list.push(lch.clone());
      }
    }
    self.initialized = true;
  }
  fn getOperators(&mut self, name : String) -> Vec<CodeNode> {
    let mut results : Vec<CodeNode> = Vec::new();
    if  false == self.initialized {
      self.initializeOpCache();
    }
    let mut items : Option<OpList> = self.opHash.get(name);
    if  items.is_some() {
      return items.list;
    }
    return results;
  }
  fn initFrom(&mut self, mut main : CodeNode) -> () {
    let mut lang : Option<CodeNode> = None;
    for i in 0..main.children.len() {
      let mut m = main.children[i as usize].clone();
      let mut fc : CodeNode = m.getFirst();
      if  fc.vref == "language".to_string() {
        lang = Some(m.clone());
      }
    }
    if  lang.is_none() {
      return;
    }
    /** unused:  let mut cmds : Option<CodeNode> = None;   **/ 
    let mut langNodes : CodeNode = lang.children[1 as usize].clone();
    for i_1 in 0..langNodes.children.len() {
      let mut lch = langNodes.children[i_1 as usize].clone();
      let mut fc_1 : CodeNode = lch.getFirst();
      if  fc_1.vref == "commands".to_string() {
        /** unused:  let mut n : CodeNode = lch.getSecond();   **/ 
        self.stdCommands = Some(lch.getSecond());
      }
    }
    return;
  }
}
#[derive(Clone)]
struct LiveCompiler { 
  parser : Option<RangerFlowParser>, 
  langWriter : Option<RangerGenericClassWriter>, 
  hasCreatedPolyfill : HashMap<String,bool>, 
  lastProcessedNode : Option<CodeNode>, 
  repeat_index : i64, 
  installedFile : HashMap<String,bool>, 
}
impl LiveCompiler { 
  
  pub fn new() ->  LiveCompiler {
    let mut me = LiveCompiler { 
      parser: None, 
      langWriter: None, 
      hasCreatedPolyfill: None, 
      lastProcessedNode: None, 
      repeat_index:0, 
      installedFile: None, 
    };
    return me;
  }
  fn initWriter(&mut self, mut ctx : RangerAppWriterContext) -> () {
    if  self.langWriter.is_some() {
      return;
    }
    let langName : String = operatorsOf_21::getTargetLang_22(ctx.clone());
    println!( "{}", format!("{}{}", "Livecompiler starting with language => ".to_string(), langName) );
    switch (langName ) { 
      case "go".to_string() : 
        self.langWriter = Some(RangerGolangClassWriter::new());
        break;
      case "scala".to_string() : 
        self.langWriter = Some(RangerScalaClassWriter::new());
        break;
      case "java7".to_string() : 
        self.langWriter = Some(RangerJava7ClassWriter::new());
        break;
      case "swift3".to_string() : 
        self.langWriter = Some(RangerSwift3ClassWriter::new());
        break;
      case "swift6".to_string() : 
        self.langWriter = Some(RangerSwift6ClassWriter::new());
        break;
      case "kotlin".to_string() : 
        self.langWriter = Some(RangerKotlinClassWriter::new());
        break;
      case "php".to_string() : 
        self.langWriter = Some(RangerPHPClassWriter::new());
        break;
      case "python".to_string() : 
        self.langWriter = Some(RangerPythonClassWriter::new());
        break;
      case "rust".to_string() : 
        self.langWriter = Some(RangerRustClassWriter::new());
        break;
      case "cpp".to_string() : 
        self.langWriter = Some(RangerCppClassWriter::new());
        break;
      case "csharp".to_string() : 
        self.langWriter = Some(RangerCSharpClassWriter::new());
        break;
      case "es6".to_string() : 
        self.langWriter = Some(RangerJavaScriptClassWriter::new());
        break;
      case "ranger".to_string() : 
        self.langWriter = Some(RangerRangerClassWriter::new());
        break;
    }
    if  self.langWriter.is_some() {
      self.langWriter.compiler = Some(self);
    } else {
      self.langWriter = Some(RangerGenericClassWriter::new());
      self.langWriter.compiler = Some(self);
    }
  }
  fn EncodeString(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> String {
    /** unused:  let encoded_str : String = "".to_string();   **/ 
    let str_length : i64 = node.string_value.len() as i64;
    let mut encoded_str_2 : String = "".to_string();
    let mut ii : i64 = 0;
    while ii < str_length {
      let ch : i64 = node.string_value.chars().nth(ii as usize).unwrap_or('\0') as i64;
      let cc : i64 = ch;
      switch (cc ) { 
        case 8 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(98)));
          break;
        case 9 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(116)));
          break;
        case 10 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(110)));
          break;
        case 12 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(102)));
          break;
        case 13 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(114)));
          break;
        case 34 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(34)));
          break;
        case 92 : 
          encoded_str_2 = format!("{}{}", (format!("{}{}", encoded_str_2, (String.fromCharCode(92)))), (String.fromCharCode(92)));
          break;
        default: 
          encoded_str_2 = format!("{}{}", encoded_str_2, (String.fromCharCode(ch)));
          break;
      }
      ii = ii + 1;
    }
    return encoded_str_2.clone();
  }
  fn WriteScalarValue(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.WriteScalarValue(node.clone(), ctx.clone(), wr.clone());
  }
  fn adjustType(&mut self, tn : String) -> String {
    if  tn == "this".to_string() {
      return "self".to_string().clone();
    }
    return tn.clone();
  }
  fn WriteVRef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.WriteVRef(node.clone(), ctx.clone(), wr.clone());
  }
  fn writeTypeDef(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.writeTypeDef(node.clone(), ctx.clone(), wr.clone());
  }
  fn CreateLambdaCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.CreateLambdaCall(node.clone(), ctx.clone(), wr.clone());
  }
  fn CreateCallExpression(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.CreateCallExpression(node.clone(), ctx.clone(), wr.clone());
  }
  fn CreateLambda(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.self.langWriter.CreateLambda(node.clone(), ctx.clone(), wr.clone());
  }
  fn getTypeString(&mut self, str : String, mut ctx : RangerAppWriterContext) -> String {
    return "".to_string().clone();
  }
  fn createPolyfill(&mut self, location : String, code : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut p_write : CodeWriter = wr.getTag(location.clone());
    if  (p_write.compiledTags.contains_key(&code)) == false {
      p_write.raw(code.clone(), true);
      p_write.compiledTags.insert(code, true);
    }
  }
  fn createPolyfillLegacy(&mut self, code : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.createPolyfill("utilities".to_string(), code.clone(), ctx.clone(), wr.clone());
  }
  fn installFile(&mut self, filename : String, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  self.installedFile.contains_key(&filename) {
      return;
    }
    let mut env : InputEnv = ctx.getEnv().unwrap();
    self.installedFile.insert(filename, true);
    /** unused:  let fName : String = format!("{}{}", (format!("{}{}", operatorsOf_8::installc95directory_51(env.clone()), "/".to_string())), filename);   **/ 
    if  operatorsOf_8::filec95exists_9(env.clone(), (format!("{}{}", operatorsOf_8::installc95directory_51(env.clone()), "/".to_string())), filename.clone()) {
      let fileData : Option<String> = r_read_file(&(format!("{}{}", operatorsOf_8::installc95directory_51(env.clone()), "/".to_string())), &filename);
      if  fileData.is_some() {
        let mut file_wr : CodeWriter = wr.getFileWriter(".".to_string(), filename);
        file_wr.raw(fileData.unwrap(), false);
      } else {
        println!( "{}", format!("{}{}", "did not get contents of ".to_string(), filename) );
      }
    } else {
      println!( "{}", format!("{}{}", (format!("{}{}", "did not find installed file ".to_string(), operatorsOf_8::installc95directory_51(env.clone()))), filename) );
    }
  }
  fn findOpCode(&mut self, mut op : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fnName : CodeNode = op.children[1 as usize].clone();
    let mut args : CodeNode = op.children[2 as usize].clone();
    if  ((op.children.len() as i64)) > 3 {
      let mut details : CodeNode = op.children[3 as usize].clone();
      for i in 0..details.children.len() {
        let mut det = details.children[i as usize].clone();
        if  ((det.children.len() as i64)) > 0 {
          let mut fc : CodeNode = det.children[0 as usize].clone();
          if  fc.vref == "code".to_string() {
            let mut match : RangerArgMatch = RangerArgMatch::new();
            let all_matched : bool = r#match.matchArguments(args.clone(), node.clone(), ctx.clone(), 1);
            if  all_matched == false {
              return;
            }
            let mut origCode : CodeNode = det.children[1 as usize].clone();
            let mut theCode : CodeNode = origCode.rebuildWithType(match.clone(), true);
            let mut appCtx : RangerAppWriterContext = ctx.getRoot();
            let stdFnName : String = appCtx.createSignature(fnName.vref.clone(), (format!("{}{}", fnName.vref, theCode.getCode())));
            let mut stdClass : RangerAppClassDesc = ctx.findClass("RangerStaticMethods".to_string());
            let mut runCtx : RangerAppWriterContext = appCtx.fork();
            let mut b_failed : bool = false;
            if  false == (stdClass.defined_static_methods.contains_key(&stdFnName)) {
              runCtx.setInMethod();
              let mut m : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
              m.name = stdFnName.clone();
              m.node = Some(op.clone());
              m.is_static = true;
              m.nameNode = Some(fnName.clone());
              m.fnBody = Some(theCode.clone());
              for ii in 0..args.children.len() {
                let mut arg = args.children[ii as usize].clone();
                let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
                p.name = arg.vref.clone();
                p.value_type = arg.value_type;
                p.node = Some(arg.clone());
                p.nameNode = Some(arg.clone());
                p.refType = 1;
                p.varType = 4;
                m.params.push(p.clone());
                arg.hasParamDesc = true;
                arg.paramDesc = Some(p.clone());
                arg.eval_type = arg.value_type;
                arg.eval_type_name = arg.type_name.clone();
                runCtx.defineVariable(p.name.clone(), p.clone());
              }
              stdClass.addStaticMethod(m.clone());
              let err_cnt : i64 = (ctx.compilerErrors.len() as i64);
              let mut flowParser : RangerFlowParser = RangerFlowParser::new();
              let mut TmpWr : CodeWriter = CodeWriter::new();
              flowParser.WalkNode(theCode.clone(), runCtx.clone(), TmpWr.clone());
              runCtx.unsetInMethod();
              let err_delta : i64 = ((ctx.compilerErrors.len() as i64)) - err_cnt;
              if  err_delta > 0 {
                b_failed = true;
                println!( "{}", "Had following compiler errors:".to_string() );
                for i_1 in 0..ctx.compilerErrors.len() {
                  let mut e = ctx.compilerErrors[i_1 as usize].clone();
                  if  i_1 < err_cnt {
                    continue;
                  }
                  let line_index : i64 = e.node.getLine();
                  println!( "{}", [(format!("{}{}", e.node.getFilename(), " Line: ".to_string())) , (line_index.to_string()) ].join("") );
                  println!( "{}", e.description );
                  println!( "{}", e.node.getLineString(line_index) );
                }
              } else {
                println!( "{}", "no errors found".to_string() );
              }
            }
            if  b_failed {
              wr.out("/* custom operator compilation failed */ ".to_string(), false);
            } else {
              wr.out(format!("{}{}", (format!("{}{}", "RangerStaticMethods.".to_string(), stdFnName)), "(".to_string()), false);
              for i_2 in 0..node.children.len() {
                let mut cc = node.children[i_2 as usize].clone();
                if  i_2 == 0 {
                  continue;
                }
                if  i_2 > 1 {
                  wr.out(", ".to_string(), false);
                }
                self.WalkNode(cc.clone(), ctx.clone(), wr.clone());
              }
              wr.out(")".to_string(), false);
            }
            return;
          }
        }
      }
    }
  }
  fn findOpTemplate(&mut self, mut op : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> Option<CodeNode> {
    /** unused:  let mut fnName : CodeNode = op.children[1 as usize].clone();   **/ 
    /** unused:  let mut root : RangerAppWriterContext = ctx.getRoot();   **/ 
    let langName : String = operatorsOf_21::getTargetLang_22(ctx.clone());
    let mut rv : Option<CodeNode> = None;
    let mut opDef : CodeNode = op;
    if  ((op.children.len() as i64)) > 3 {
      let mut details : CodeNode = op.children[3 as usize].clone();
      for i in 0..details.children.len() {
        let mut det = details.children[i as usize].clone();
        if  ((det.children.len() as i64)) > 0 {
          let mut fc : CodeNode = det.children[0 as usize].clone();
          if  fc.vref == "templates".to_string() {
            let mut tplList : CodeNode = det.children[1 as usize].clone();
            for i_1 in 0..tplList.children.len() {
              let mut tpl = tplList.children[i_1 as usize].clone();
              let mut tplName : CodeNode = tpl.getFirst();
              let mut tplImpl : Option<CodeNode> = None;
              tplImpl = Some(tpl.getSecond());
              let is_ts : bool = ctx.hasCompilerFlag("typescript".to_string());
              if  is_ts && ((tplName.vref == "typescript".to_string()) || (tplName.vref == "ts".to_string())) {
                rv = tplImpl.clone();
                return rv.clone();
              }
              if  (tplName.vref != "*".to_string()) && (tplName.vref != langName) {
                continue;
              }
              if  tplName.hasFlag("mutable".to_string()) {
                if  false == node.hasFlag("mutable".to_string()) {
                  continue;
                }
              }
              rv = tplImpl.clone();
              return rv.clone();
            }
            if  langName == "ranger".to_string() {
              let mut opNameNode : CodeNode = opDef.getFirst();
              let mut opArgs : CodeNode = opDef.getThird();
              let mut rangerTpl : CodeNode = CodeNode::fromList([CodeNode::newStr((format!("{}{}", (format!("{}{}", "(".to_string(), opNameNode.vref)), " ".to_string())))]);
              let mut cnt : i64 = 1;
              operatorsOf::forEach_15(opArgs.children, (item, index) => { 
                if  item.type_name == "block".to_string() {
                  rangerTpl.children.push(CodeNode::fromList([CodeNode::vref1("block".to_string()), CodeNode::newInt(cnt)]));
                } else {
                  rangerTpl.children.push(CodeNode::fromList([CodeNode::vref1("e".to_string()), CodeNode::newInt(cnt)]));
                }
                cnt = cnt + 1;
              }
              );
              rangerTpl.children.push(CodeNode::newStr(")".to_string()));
              rv = Some(rangerTpl.clone());
            }
          }
        }
      }
    }
    return rv.clone();
  }
  fn localCall(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> bool {
    if  node.hasFnCall {
      if  self.langWriter.is_some() {
        self.self.langWriter.writeFnCall(node.clone(), ctx.clone(), wr.clone());
        return true;
      }
    }
    if  node.hasNewOper {
      self.self.langWriter.writeNewCall(node.clone(), ctx.clone(), wr.clone());
      return true;
    }
    if  node.hasVarDef {
      if  node.disabled_node {
        self.self.langWriter.disabledVarDef(node.clone(), ctx.clone(), wr.clone());
      } else {
        self.self.langWriter.writeVarDef(node.clone(), ctx.clone(), wr.clone());
      }
      return true;
    }
    if  node.hasClassDescription {
      self.self.langWriter.writeClass(node.clone(), ctx.clone(), wr.clone());
      return true;
    }
    return false;
  }
  fn WalkNode(&mut self, mut node : CodeNode, mut in_ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    self.initWriter(in_ctx.clone());
    if  node.disabled_node {
      return;
    }
    let mut ctx : RangerAppWriterContext = in_ctx;
    if  node.evalCtx.is_some() {
      ctx = node.evalCtx.clone().unwrap();
    }
    if  (node.register_name.len() as i64) > 0 {
      if  ctx.expressionLevel() > 0 {
        if  (node.reg_compiled_name.len() as i64) > 0 {
          wr.out(node.reg_compiled_name.clone(), false);
        } else {
          println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", "Could not find compiled name for ".to_string(), node.register_name)), " at ".to_string())), node.getCode()) );
        }
      }
      return;
    }
    let mut liveNodes : Vec<CodeNode> = Vec::new();
    /** unused:  let mut rootItem : CodeNode = node;   **/ 
    if  ((node.register_expressions.len() as i64)) > 0 {
      operatorsOf::forEach_15(node.register_expressions, (item, index) => { 
        liveNodes.push(item.clone());
      }
      );
    }
    operatorsOf::forEach_15(liveNodes, (item, index) => { 
      if  item.register_set == false {
        item.register_set = true;
        self.WalkNode(item.clone(), ctx.clone(), wr.clone());
      }
    }
    );
    liveNodes.length = 0;
    if  node.value_type == 12 {
      return;
    }
    if  node.isPrimitive() {
      self.WriteScalarValue(node.clone(), ctx.clone(), wr.clone());
      return;
    }
    self.lastProcessedNode = Some(node.clone());
    if  node.isFirstVref("property".to_string()) {
      self.self.langWriter.CreatePropertyGet(node.clone(), ctx.clone(), wr.clone());
      return;
    }
    if  node.is_plugin {
      return;
    }
    if  node.is_array_literal {
      self.self.langWriter.writeArrayLiteral(node.clone(), ctx.clone(), wr.clone());
      return;
    }
    if  ((node.value_type == 11) || (node.value_type == 7)) || (node.value_type == 6) {
      self.WriteVRef(node.clone(), ctx.clone(), wr.clone());
      return;
    }
    if  node.value_type == 18 {
      self.WriteVRef(node.clone(), ctx.clone(), wr.clone());
      return;
    }
    if  ((node.children.len() as i64)) > 0 {
      if  node.has_operator {
        let mut op : CodeNode = ctx.findOperator(node.clone());
        /** unused:  let mut fc : CodeNode = op.getFirst();   **/ 
        let mut tplImpl : Option<CodeNode> = self.findOpTemplate(op.clone(), node.clone(), ctx.clone(), wr.clone());
        let mut evalCtx : RangerAppWriterContext = ctx;
        if  node.evalCtx.is_some() {
          evalCtx = node.evalCtx.clone().unwrap();
        }
        if  tplImpl.is_some() {
          let mut opName : CodeNode = op.getSecond();
          if  opName.hasFlag("returns".to_string()) {
            self.self.langWriter.release_local_vars(node.clone(), evalCtx.clone(), wr.clone());
          }
          self.walkCommandList(tplImpl.unwrap(), node.clone(), evalCtx.clone(), wr.clone());
        } else {
          self.findOpCode(op.clone(), node.clone(), evalCtx.clone(), wr.clone());
        }
        return;
      }
      if  node.is_direct_method_call {
        self.self.langWriter.CreateMethodCall(node.clone(), ctx.clone(), wr.clone());
        return;
      }
      if  node.has_lambda {
        self.CreateLambda(node.clone(), ctx.clone(), wr.clone());
        return;
      }
      if  node.has_lambda_call {
        self.CreateLambdaCall(node.clone(), ctx.clone(), wr.clone());
        return;
      }
      if  node.is_part_of_chain {
        return;
      }
      if  node.has_call {
        self.CreateCallExpression(node.clone(), ctx.clone(), wr.clone());
        return;
      }
      if  ((node.children.len() as i64)) > 1 {
        if  self.localCall(node.clone(), ctx.clone(), wr.clone()) {
          return;
        }
      }
      /** unused:  let mut fc_1 : CodeNode = node.getFirst();   **/ 
    }
    if  node.expression {
      for i in 0..node.children.len() {
        let mut item = node.children[i as usize].clone();
        if  (node.didReturnAtIndex >= 0) && (node.didReturnAtIndex < i) {
          break;
        }
        if  node.is_block_node {
          let mut liveNodes_2 : Vec<CodeNode> = Vec::new();
          /** unused:  let mut rootItem_2 : CodeNode = item;   **/ 
          if  ((item.register_expressions.len() as i64)) > 0 {
            operatorsOf::forEach_15(item.register_expressions, (item, index) => { 
              liveNodes_2.push(item.clone());
            }
            );
          }
          item.walkTreeUntil((item, i) => { 
            if  item.is_block_node {
              return false;
            }
            return true;
          }
          );
          operatorsOf::forEach_15(liveNodes_2, (item, index) => { 
            if  item.register_set == false {
              item.register_set = true;
              self.WalkNode(item.clone(), ctx.clone(), wr.clone());
            }
          }
          );
        }
        self.WalkNode(item.clone(), ctx.clone(), wr.clone());
      }
    } else {
      if  node.value_type == 17 {
        self.WriteVRef(node.clone(), ctx.clone(), wr.clone());
      }
    }
  }
  fn walkCommandList(&mut self, mut cmd : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ctx.expressionLevel() == 0 {
      wr.newline();
      if  operatorsOf_21::getTargetLang_22(ctx.clone()) == "swift3".to_string() {
        let mut opn : CodeNode = (*node.operator_node.clone().unwrap());
        let mut nn : CodeNode = opn.getSecond();
        if  nn.type_name != "void".to_string() {
          wr.out("_ = ".to_string(), false);
        }
      }
    }
    if  ctx.expressionLevel() > 1 {
      wr.out("(".to_string(), false);
    }
    for i in 0..cmd.children.len() {
      let mut c = cmd.children[i as usize].clone();
      self.walkCommand(c.clone(), node.clone(), ctx.clone(), wr.clone());
    }
    if  ctx.expressionLevel() > 1 {
      wr.out(")".to_string(), false);
    }
    if  ctx.expressionLevel() == 0 {
      wr.line_end(self.self.langWriter.lineEnding());
      wr.newline();
    }
  }
  fn walkCommand(&mut self, mut cmd : CodeNode, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  cmd.expression {
      if  ((cmd.children.len() as i64)) < 2 {
        ctx.addError(node.clone(), "Invalid command".to_string());
        ctx.addError(cmd.clone(), "Invalid command".to_string());
        return;
      }
      let mut cmdE : CodeNode = cmd.getFirst();
      let mut cmdArg : CodeNode = cmd.getSecond();
      switch (cmdE.vref ) { 
        case "service_id".to_string() : 
          let idx : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) >= idx {
            let mut arg : CodeNode = node.children[idx as usize].clone();
            let mut root : RangerAppWriterContext = ctx.getRoot();
            let mut sNode : Option<CodeNode> = root.appServices.get(arg.vref);
            if  sNode.is_some() {
              wr.out(sNode.appGUID.clone(), false);
            } else {
              ctx.addError(arg.clone(), "Service not found".to_string());
            }
          } else {
            ctx.addError(node.clone(), "Service not found".to_string());
          }
          break;
        case "log".to_string() : 
          println!( "{}", cmdArg.string_value );
          break;
        case "str".to_string() : 
          let idx_1 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_1 {
            let mut arg_1 : CodeNode = node.children[idx_1 as usize].clone();
            wr.out(arg_1.string_value.clone(), false);
          }
          break;
        case "block".to_string() : 
          let idx_2 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_2 {
            let mut arg_2 : CodeNode = node.children[idx_2 as usize].clone();
            let mut sCtx : RangerAppWriterContext = ctx.fork();
            sCtx.restartExpressionLevel();
            self.WalkNode(arg_2.clone(), sCtx.clone(), wr.clone());
          }
          break;
        case "varname".to_string() : 
          if  ctx.isVarDefined(cmdArg.vref.clone()) {
            let mut p : RangerAppParamDesc = ctx.getVariableDef(cmdArg.vref.clone());
            wr.out(p.compiledName.clone(), false);
          }
          break;
        case "defvar".to_string() : 
          let mut p_1 : RangerAppParamDesc = RangerAppParamDesc::new();
          p_1.name = cmdArg.vref.clone();
          p_1.value_type = cmdArg.value_type;
          p_1.node = Some(cmdArg.clone());
          p_1.nameNode = Some(cmdArg.clone());
          p_1.is_optional = false;
          ctx.defineVariable(p_1.name.clone(), p_1.clone());
          break;
        case "cc".to_string() : 
          let idx_3 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_3 {
            let mut arg_3 : CodeNode = node.children[idx_3 as usize].clone();
            let cc : u8 = arg_3.string_value.charCodeAt(0);
            wr.out(["".to_string() , ((cc as i64 ).to_string()) ].join(""), false);
          }
          break;
        case "optional_option".to_string() : 
          let idx_4 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_4 {
            let mut arg_4 : CodeNode = node.children[idx_4 as usize].clone();
            if  ctx.hasCompilerSetting(arg_4.string_value.clone()) {
              let setting : String = ctx.getCompilerSetting(arg_4.string_value.clone());
              wr.out(setting.clone(), false);
            }
          }
          break;
        case "required_option".to_string() : 
          let idx_5 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_5 {
            let mut arg_5 : CodeNode = node.children[idx_5 as usize].clone();
            if  ctx.hasCompilerSetting(arg_5.string_value.clone()) {
              let setting_1 : String = ctx.getCompilerSetting(arg_5.string_value.clone());
              wr.out(setting_1.clone(), false);
            } else {
              ctx.addError(node.clone(), format!("{}{}", (format!("{}{}", "This source code requires compiler option -".to_string(), arg_5.string_value)), "=<> to be set ".to_string()));
            }
          }
          break;
        case "java_case".to_string() : 
          let idx_6 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_6 {
            let mut arg_6 : CodeNode = node.children[idx_6 as usize].clone();
            self.WalkNode(arg_6.clone(), ctx.clone(), wr.clone());
            if  arg_6.didReturnAtIndex < 0 {
              wr.newline();
              wr.out("break;".to_string(), true);
            }
          }
          break;
        case "plugin".to_string() : 
          if  ((cmd.children.len() as i64)) > 2 {
            let mut cmdData : CodeNode = cmd.getThird();
            let name : String = cmdArg.string_value.clone();
            ctx.addPluginNode(name.clone(), cmdData.clone());
          }
          break;
        case "lambda".to_string() : 
          let idx_7 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_7 {
            let mut arg_7 : CodeNode = node.children[idx_7 as usize].clone();
            ctx.setInExpr();
            self.WalkNode(arg_7.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
          }
          break;
        case "e".to_string() : 
          let idx_8 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_8 {
            let mut arg_8 : CodeNode = node.children[idx_8 as usize].clone();
            ctx.setInExpr();
            self.WalkNode(arg_8.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
          }
          break;
        case "goset".to_string() : 
          let idx_9 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_9 {
            let mut arg_9 : CodeNode = node.children[idx_9 as usize].clone();
            ctx.setInExpr();
            self.self.langWriter.WriteSetterVRef(arg_9.clone(), ctx.clone(), wr.clone());
            ctx.unsetInExpr();
          }
          break;
        case "pe".to_string() : 
          let idx_10 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_10 {
            let mut arg_10 : CodeNode = node.children[idx_10 as usize].clone();
            self.WalkNode(arg_10.clone(), ctx.clone(), wr.clone());
          }
          break;
        case "ptr".to_string() : 
          let idx_11 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_11 {
            let mut arg_11 : CodeNode = node.children[idx_11 as usize].clone();
            if  arg_11.hasParamDesc {
              if  arg_11.paramDesc.nameNode.isAPrimitiveType() == false {
                wr.out("*".to_string(), false);
              }
            } else {
              if  arg_11.isAPrimitiveType() == false {
                wr.out("*".to_string(), false);
              }
            }
          }
          break;
        case "ptrsrc".to_string() : 
          let idx_12 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_12 {
            let mut arg_12 : CodeNode = node.children[idx_12 as usize].clone();
            if  (arg_12.isPrimitiveType() == false) && (arg_12.isPrimitive() == false) {
              wr.out("&".to_string(), false);
            }
          }
          break;
        case "nameof".to_string() : 
          let idx_13 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_13 {
            let mut arg_13 : CodeNode = node.children[idx_13 as usize].clone();
            wr.out(arg_13.vref.clone(), false);
          }
          break;
        case "list".to_string() : 
          let idx_14 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_14 {
            let mut arg_14 : CodeNode = node.children[idx_14 as usize].clone();
            for i in 0..arg_14.children.len() {
              let mut ch = arg_14.children[i as usize].clone();
              if  i > 0 {
                wr.out(" ".to_string(), false);
              }
              ctx.setInExpr();
              self.WalkNode(ch.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
            }
          }
          break;
        case "repeat".to_string() : 
          let idx_15 : i64 = cmdArg.int_value;
          self.repeat_index = idx_15;
          if  ((node.children.len() as i64)) >= idx_15 {
            let mut cmdToRepeat : CodeNode = cmd.getThird();
            let mut i_1 : i64 = idx_15;
            while i_1 < ((node.children.len() as i64)) {
              if  i_1 >= idx_15 {
                for ii in 0..cmdToRepeat.children.len() {
                  let mut cc_1 = cmdToRepeat.children[ii as usize].clone();
                  if  ((cc_1.children.len() as i64)) > 0 {
                    let mut fc : CodeNode = cc_1.getFirst();
                    if  fc.vref == "e".to_string() {
                      let mut dc : CodeNode = cc_1.getSecond();
                      dc.int_value = i_1;
                    }
                    if  fc.vref == "block".to_string() {
                      let mut dc_1 : CodeNode = cc_1.getSecond();
                      dc_1.int_value = i_1;
                    }
                  }
                }
                self.walkCommandList(cmdToRepeat.clone(), node.clone(), ctx.clone(), wr.clone());
              }
              i_1 = i_1 + 1;
            }
          }
          break;
        case "repeat_from".to_string() : 
          let idx_16 : i64 = cmdArg.int_value;
          self.repeat_index = idx_16;
          if  ((node.children.len() as i64)) >= idx_16 {
            let mut cmdToRepeat_1 : CodeNode = cmd.getThird();
            let mut i_2 : i64 = idx_16;
            while i_2 < ((node.children.len() as i64)) {
              if  i_2 >= idx_16 {
                for ii_1 in 0..cmdToRepeat_1.children.len() {
                  let mut cc_2 = cmdToRepeat_1.children[ii_1 as usize].clone();
                  if  ((cc_2.children.len() as i64)) > 0 {
                    let mut fc_1 : CodeNode = cc_2.getFirst();
                    if  fc_1.vref == "e".to_string() {
                      let mut dc_2 : CodeNode = cc_2.getSecond();
                      dc_2.int_value = i_2;
                    }
                    if  fc_1.vref == "block".to_string() {
                      let mut dc_3 : CodeNode = cc_2.getSecond();
                      dc_3.int_value = i_2;
                    }
                  }
                }
                self.walkCommandList(cmdToRepeat_1.clone(), node.clone(), ctx.clone(), wr.clone());
                if  (i_2 + 1) < ((node.children.len() as i64)) {
                  wr.out(",".to_string(), false);
                }
              }
              i_2 = i_2 + 1;
            }
          }
          break;
        case "comma".to_string() : 
          let idx_17 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_17 {
            let mut arg_15 : CodeNode = node.children[idx_17 as usize].clone();
            for i_3 in 0..arg_15.children.len() {
              let mut ch_1 = arg_15.children[i_3 as usize].clone();
              if  i_3 > 0 {
                wr.out(",".to_string(), false);
              }
              ctx.setInExpr();
              self.WalkNode(ch_1.clone(), ctx.clone(), wr.clone());
              ctx.unsetInExpr();
            }
          }
          break;
        case "swift_rc".to_string() : 
          let idx_18 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_18 {
            let mut arg_16 : CodeNode = node.children[idx_18 as usize].clone();
            if  arg_16.hasParamDesc {
              if  arg_16.paramDesc.ref_cnt == 0 {
                wr.out("_".to_string(), false);
              } else {
                let mut p_2 : RangerAppParamDesc = ctx.getVariableDef(arg_16.vref.clone());
                wr.out(p_2.compiledName.clone(), false);
              }
            } else {
              wr.out(arg_16.vref.clone(), false);
            }
          }
          break;
        case "r_ktype".to_string() : 
          let idx_19 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_19 {
            let mut arg_17 : CodeNode = node.children[idx_19 as usize].clone();
            if  arg_17.hasParamDesc {
              let ss : String = self.self.langWriter.getObjectTypeString(arg_17.paramDesc.nameNode.key_type.clone(), ctx.clone());
              wr.out(ss.clone(), false);
            } else {
              let ss_1 : String = self.self.langWriter.getObjectTypeString(arg_17.key_type.clone(), ctx.clone());
              wr.out(ss_1.clone(), false);
            }
          }
          break;
        case "r_atype".to_string() : 
          let idx_20 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_20 {
            let mut arg_18 : CodeNode = node.children[idx_20 as usize].clone();
            if  arg_18.hasParamDesc {
              let ss_2 : String = self.self.langWriter.getObjectTypeString(arg_18.paramDesc.nameNode.array_type.clone(), ctx.clone());
              wr.out(ss_2.clone(), false);
            } else {
              let ss_3 : String = self.self.langWriter.getObjectTypeString(arg_18.array_type.clone(), ctx.clone());
              wr.out(ss_3.clone(), false);
            }
          }
          break;
        case "r_atype_fname".to_string() : 
          let idx_21 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_21 {
            let mut arg_19 : CodeNode = node.children[idx_21 as usize].clone();
            if  arg_19.hasParamDesc {
              let mut ss_4 : String = self.self.langWriter.getObjectTypeString(arg_19.paramDesc.nameNode.array_type.clone(), ctx.clone());
              if  ss_4 == "interface{}".to_string() {
                ss_4 = "interface".to_string();
              }
              wr.out(ss_4.clone(), false);
            } else {
              let mut ss_5 : String = self.self.langWriter.getObjectTypeString(arg_19.array_type.clone(), ctx.clone());
              if  ss_5 == "interface{}".to_string() {
                ss_5 = "interface".to_string();
              }
              wr.out(ss_5.clone(), false);
            }
          }
          break;
        case "custom".to_string() : 
          self.self.langWriter.CustomOperator(node.clone(), ctx.clone(), wr.clone());
          break;
        case "arraytype".to_string() : 
          let idx_22 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_22 {
            let mut arg_20 : CodeNode = node.children[idx_22 as usize].clone();
            if  arg_20.hasParamDesc {
              self.self.langWriter.writeArrayTypeDef(arg_20.paramDesc.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            } else {
              self.self.langWriter.writeArrayTypeDef(arg_20.clone(), ctx.clone(), wr.clone());
            }
          }
          break;
        case "java_class".to_string() : 
          try {
            let fName : String = format!("{}{}", cmdArg.string_value, ".java".to_string());
            let mut p_write : CodeWriter = wr.getTag("utilities".to_string());
            if  (p_write.compiledTags.contains_key(&fName)) == false {
              let mut code : CodeNode = cmd.getThird();
              let mut classWr : CodeWriter = wr.getFileWriter(".".to_string(), fName.clone());
              if  (classWr.getCode().len() as i64) > 0 {
              } else {
                let package_name : String = ctx.getCompilerSetting("package".to_string());
                classWr.out(format!("{}{}", (format!("{}{}", "package ".to_string(), package_name)), ";".to_string()), true);
                classWr.raw(code.string_value.clone(), false);
                p_write.compiledTags.insert(fName, true);
              }
            }
          } catch(e) {
          }
          break;
        case "rawtype".to_string() : 
          let idx_23 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) > idx_23 {
            let mut arg_21 : CodeNode = node.children[idx_23 as usize].clone();
            if  arg_21.hasParamDesc {
              self.self.langWriter.writeRawTypeDef(arg_21.paramDesc.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            } else {
              self.self.langWriter.writeRawTypeDef(arg_21.clone(), ctx.clone(), wr.clone());
            }
          }
          break;
        case "macro".to_string() : 
          let mut p_write_1 : CodeWriter = wr.getTag("utilities".to_string());
          let mut newWriter : CodeWriter = CodeWriter::new();
          let mut testCtx : RangerAppWriterContext = ctx.fork();
          testCtx.restartExpressionLevel();
          testCtx.targetLangName = "ranger".to_string();
          self.walkCommandList(cmdArg.clone(), node.clone(), testCtx.clone(), newWriter.clone());
          let p_str : String = newWriter.getCode();
          /** unused:  let mut root_1 : RangerAppWriterContext = ctx.getRoot();   **/ 
          if  (p_write_1.compiledTags.contains_key(&p_str)) == false {
            p_write_1.compiledTags.insert(p_str, true);
            let mut mCtx : RangerAppWriterContext = ctx.fork();
            mCtx.restartExpressionLevel();
            mCtx.targetLangName = "ranger".to_string();
            self.walkCommandList(cmdArg.clone(), node.clone(), mCtx.clone(), p_write_1.clone());
          }
          break;
        case "install_file".to_string() : 
          self.installFile(cmdArg.string_value.clone(), ctx.clone(), wr.clone());
          break;
        case "create_polyfill".to_string() : 
          self.createPolyfillLegacy(cmdArg.string_value.clone(), ctx.clone(), wr.clone());
          break;
        case "typeof".to_string() : 
          let idx_24 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) >= idx_24 {
            let mut arg_22 : CodeNode = node.children[idx_24 as usize].clone();
            if  arg_22.hasParamDesc {
              self.writeTypeDef(arg_22.paramDesc.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            } else {
              self.writeTypeDef(arg_22.clone(), ctx.clone(), wr.clone());
            }
          }
          break;
        case "imp".to_string() : 
          self.self.langWriter.import_lib(cmdArg.string_value.clone(), ctx.clone(), wr.clone());
          break;
        case "polyfill".to_string() : 
          let location : String = cmdArg.string_value.clone();
          if  ((cmd.children.len() as i64)) > 2 {
            let mut codeCmd : CodeNode = cmd.getThird();
            let code_1 : String = codeCmd.string_value.clone();
            self.createPolyfill(location.clone(), code_1.clone(), ctx.clone(), wr.clone());
          }
          break;
        case "atype".to_string() : 
          let idx_25 : i64 = cmdArg.int_value;
          if  ((node.children.len() as i64)) >= idx_25 {
            let mut arg_23 : CodeNode = node.children[idx_25 as usize].clone();
            let mut p_3 : Option<RangerAppParamDesc> = self.findParamDesc(arg_23.clone(), ctx.clone(), wr.clone());
            let mut nameNode : CodeNode = p_3.nameNode.clone().unwrap();
            let tn : String = nameNode.array_type.clone();
            wr.out(self.getTypeString(tn.clone(), ctx.clone()), false);
          }
          break;
      }
    } else {
      if  cmd.value_type == 11 {
        switch (cmd.vref ) { 
          case "nl".to_string() : 
            wr.newline();
            break;
          case "space".to_string() : 
            wr.out(" ".to_string(), false);
            break;
          case "I".to_string() : 
            wr.indent(1);
            break;
          case "i".to_string() : 
            wr.indent(-1);
            break;
          case "op".to_string() : 
            let mut fc_2 : CodeNode = node.getFirst();
            wr.out(fc_2.vref.clone(), false);
            break;
        }
      } else {
        if  cmd.value_type == 4 {
          wr.out(cmd.string_value.clone(), false);
        }
      }
    }
  }
  fn compile(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
  }
  fn findParamDesc(&mut self, mut obj : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> Option<RangerAppParamDesc> {
    let mut varDesc : Option<RangerAppParamDesc> = None;
    let mut set_nsp : bool = false;
    let mut classDesc : Option<RangerAppClassDesc> = None;
    if  0 == ((obj.nsp.len() as i64)) {
      set_nsp = true;
    }
    if  obj.vref != "this".to_string() {
      if  ((obj.ns.len() as i64)) > 1 {
        let cnt : i64 = (obj.ns.len() as i64);
        let mut classRefDesc : Option<RangerAppParamDesc> = None;
        for i in 0..obj.ns.len() {
          let mut strname = obj.ns[i as usize].clone();
          if  i == 0 {
            if  strname == "this".to_string() {
              classDesc = Some(ctx.getCurrentClass());
              if  set_nsp {
                obj.nsp.push(classDesc.unwrap());
              }
            } else {
              if  ctx.isDefinedClass(strname.clone()) {
                classDesc = Some(ctx.findClass(strname.clone()));
                if  set_nsp {
                  obj.nsp.push(classDesc.unwrap());
                }
                continue;
              }
              classRefDesc = Some(ctx.getVariableDef(strname.clone()));
              if  classRefDesc.is_none() {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for called object: ".to_string(), strname));
                break;
              }
              if  set_nsp {
                obj.nsp.push(classRefDesc.unwrap());
              }
              classRefDesc.ref_cnt = 1 + classRefDesc.ref_cnt;
              classDesc = Some(ctx.findClass(classRefDesc.nameNode.type_name.clone()));
            }
          } else {
            if  i < (cnt - 1) {
              varDesc = Some(classDesc.findVariable(strname.clone()));
              if  varDesc.is_none() {
                ctx.addError(obj.clone(), format!("{}{}", "Error, no description for refenced obj: ".to_string(), strname));
              }
              let subClass : String = varDesc.getTypeName();
              classDesc = Some(ctx.findClass(subClass.clone()));
              if  set_nsp {
                obj.nsp.push(varDesc.unwrap());
              }
              continue;
            }
            if  classDesc.is_some() {
              varDesc = Some(classDesc.findVariable(strname.clone()));
              if  varDesc.is_none() {
                let mut classMethod : Option<RangerAppFunctionDesc> = classDesc.findMethod(strname.clone());
                if  classMethod.is_none() {
                  classMethod = classDesc.findStaticMethod(strname.clone());
                  if  classMethod.is_none() {
                    ctx.addError(obj.clone(), format!("{}{}", "variable not found ".to_string(), strname));
                  }
                }
                if  classMethod.is_some() {
                  if  set_nsp {
                    obj.nsp.push(classMethod.unwrap());
                  }
                  return classMethod.clone();
                }
              }
              if  set_nsp {
                obj.nsp.push(varDesc.unwrap());
              }
            }
          }
        }
        return varDesc.clone();
      }
      varDesc = Some(ctx.getVariableDef(obj.vref.clone()));
      if  varDesc.nameNode.is_some() {
      } else {
        println!( "{}", format!("{}{}", "findParamDesc : description not found for ".to_string(), obj.vref) );
        if  varDesc.is_some() {
          println!( "{}", format!("{}{}", "Vardesc was found though...".to_string(), varDesc.name) );
        }
        ctx.addError(obj.clone(), format!("{}{}", "Error, no description for called object: ".to_string(), obj.vref));
      }
      return varDesc.clone();
    }
    let mut cc : Option<RangerAppClassDesc> = ctx.getCurrentClass();
    return cc.clone();
  }
}
#[derive(Clone)]
struct ColorConsole { 
}
impl ColorConsole { 
  
  pub fn new() ->  ColorConsole {
    let mut me = ColorConsole { 
    };
    return me;
  }
  fn out(&mut self, color : String, str : String) -> () {
    println!( "{}", str );
  }
}
#[derive(Clone)]
struct RangerDocGenerator { 
}
impl RangerDocGenerator { 
  
  pub fn new() ->  RangerDocGenerator {
    let mut me = RangerDocGenerator { 
    };
    return me;
  }
  fn writeTypeDef(&mut self, mut item : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  item.hasFlag("optional".to_string()) {
      wr.out("<optional>".to_string(), false);
    }
    switch (item.value_type ) { 
      case 6 : 
        wr.out(format!("{}{}", (format!("{}{}", "[".to_string(), item.array_type)), "]".to_string()), false);
        break;
      case 7 : 
        wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "[".to_string(), item.key_type)), ":".to_string())), item.array_type)), "]".to_string()), false);
        break;
      case 17 : 
        wr.out("(fn:".to_string(), false);
        try {
          let mut rv : CodeNode = item.expression_value.children[0 as usize].clone();
          let mut args : CodeNode = item.expression_value.children[1 as usize].clone();
          self.writeTypeDef(rv.clone(), ctx.clone(), wr.clone());
          wr.out(" (".to_string(), false);
          operatorsOf::forEach_15(args.children, (item, index) => { 
            if  index > 0 {
              wr.out(", ".to_string(), false);
            }
            wr.out(item.vref.clone(), false);
            wr.out(": ".to_string(), false);
            self.writeTypeDef(item.clone(), ctx.clone(), wr.clone());
          }
          );
          wr.out(")".to_string(), false);
        } catch(e) {
        }
        wr.out(")".to_string(), false);
        break;
      default: 
        if  (item.type_name.len() as i64) > 0 {
          wr.out(format!("{}{}", "".to_string(), item.type_name), false);
        }
        break;
    }
  }
  fn writeArgDefs(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    operatorsOf::forEach_15(node.children, (item, index) => { 
      if  index > 0 {
        wr.out(" ".to_string(), false);
      }
      wr.out(format!("{}{}", (format!("{}{}", "`".to_string(), item.vref)), "`".to_string()), false);
      wr.out(":".to_string(), false);
      self.writeTypeDef(item.clone(), ctx.clone(), wr.clone());
      wr.out(" ".to_string(), false);
    }
    );
  }
  fn createClassDoc(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    if  ctx.hasCompilerSetting("classdoc".to_string()) {
      let b_only_documented : bool = false == ctx.hasCompilerFlag("allowempty".to_string());
      let mut wr : CodeWriter = orig_wr.getFileWriter(".".to_string(), ctx.getCompilerSetting("classdoc".to_string()));
      if  b_only_documented == false {
        wr.out("# Classes".to_string(), true);
      }
      let mut root : RangerAppWriterContext = ctx.getRoot();
      operatorsOf_13::forEach_14(root.definedClasses, (item, index) => { 
        if  false == item.isNormalClass() {
          return;
        }
        if  b_only_documented == false {
          wr.out(format!("{}{}", "## ".to_string(), index), true);
        }
        let mut theClass : RangerAppClassDesc = item;
        operatorsOf_13::forEach_30(item.method_variants, (item, index) => { 
          operatorsOf::forEach_29(item.variants, (item, index) => { 
            if  b_only_documented {
              if  (item.git_doc.len() as i64) == 0 {
                return;
              }
            }
            wr.out("#### ".to_string(), false);
            if item.nameNode.is_some() {
              if  item.nameNode.type_name != "void".to_string() {
                wr.out("`".to_string(), false);
                self.writeTypeDef(item.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
                wr.out("` ".to_string(), false);
              }
            }
            wr.out(format!("{}{}", (format!("{}{}", theClass.name, ":: ".to_string())), item.name), false);
            wr.out("(".to_string(), false);
            for i in 0..item.params.len() {
              let mut arg = item.params[i as usize].clone();
              if  i > 0 {
                wr.out(" ".to_string(), false);
              }
              wr.out(format!("{}{}", (format!("{}{}", "`".to_string(), arg.compiledName)), "`".to_string()), false);
              wr.out(":".to_string(), false);
              self.writeTypeDef(arg.nameNode.clone().unwrap(), ctx.clone(), wr.clone());
            }
            wr.out(")".to_string(), false);
            wr.out("".to_string(), true);
            wr.out(item.git_doc.clone(), false);
            wr.out("".to_string(), true);
          }
          );
        }
        );
      }
      );
    }
  }
  fn writeOpDesc(&mut self, mut item : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut fc : CodeNode = item.getFirst();
    let mut nameNode : CodeNode = item.getSecond();
    let mut args : CodeNode = item.getThird();
    wr.out("| ".to_string(), false);
    let mut name : String = fc.vref;
    if  fc.vref == "||".to_string() {
      name = "&#124;&#124;".to_string();
    }
    if  fc.vref == "|".to_string() {
      name = "&#124;".to_string();
    }
    wr.out(name.clone(), false);
    wr.out(" | ".to_string(), false);
    if  nameNode.type_name != "void".to_string() {
      wr.out("`".to_string(), false);
      self.writeTypeDef(nameNode.clone(), ctx.clone(), wr.clone());
      wr.out("` ".to_string(), false);
    }
    wr.out("| ".to_string(), false);
    wr.out("  (".to_string(), false);
    self.writeArgDefs(args.clone(), ctx.clone(), wr.clone());
    wr.out(" )".to_string(), false);
    wr.out("| ".to_string(), false);
    if  item.hasStringProperty("doc".to_string()) {
      wr.out(item.getStringProperty("doc".to_string()), false);
    }
    wr.out("| ".to_string(), false);
    wr.out("".to_string(), true);
  }
  fn writeTypeDoc(&mut self, mut list : Vec<RangerAppOperatorDesc>, tester : , mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut www : CodeWriter = wr.fork();
    wr.out("".to_string(), true);
    wr.out("".to_string(), true);
    wr.out("| operator | returns | arguments | description |".to_string(), true);
    wr.out("| -------- | ------- | --------- | ------------| ".to_string(), true);
    let mut cnt : i64 = 0;
    operatorsOf::forEach_17(list, (item, index) => { 
      if  tester(item) {
        if  cnt > 0 {
          www.out(", ".to_string(), false);
        }
        www.out(format!("{}{}", (format!("{}{}", "  `".to_string(), item.name)), "` ".to_string()), false);
        self.writeOpDesc(item.node.clone().unwrap(), ctx.clone(), wr.clone());
        cnt = cnt + 1;
      }
    }
    );
  }
  fn createOperatorDoc(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    if  ctx.hasCompilerSetting("operatordoc".to_string()) {
      let mut wr : CodeWriter = orig_wr.getFileWriter(".".to_string(), ctx.getCompilerSetting("operatordoc".to_string()));
      let mut allOps : Vec<RangerAppOperatorDesc> = ctx.getAllOperators();
      let mut statements : Vec<RangerAppOperatorDesc> = operatorsOf::filter_52(allOps, (item, index) => { 
        let mut is_map_array : bool = false;
        if item.firstArg.is_some() {
          is_map_array = (item.firstArg.value_type == 6) || (item.firstArg.value_type == 7);
        }
        if==indexOfitem.name"if_".to_string()0
        return false;
        return (item.nameNode.type_name == "void".to_string()) && (false == is_map_array);
      }
      );
      let mut lang_statements : Vec<RangerAppOperatorDesc> = operatorsOf::filter_52(allOps, (item, index) => { 
        if==indexOfitem.name"if_".to_string()0
        return true;
        return false;
      }
      );
      statements = operatorsOf::groupBy_53(statements, (item) => { 
        return item.name.clone();
      }
      );
      let mut operator_list : Vec<RangerAppOperatorDesc> = operatorsOf::filter_52(allOps, (item, index) => { 
        let mut is_map_array_1 : bool = false;
        if item.firstArg.is_some() {
          is_map_array_1 = (item.firstArg.value_type == 6) || (item.firstArg.value_type == 7);
        }
        return is_map_array_1 || (item.nameNode.type_name != "void".to_string());
      }
      );
      let mut nList : Vec<RangerAppOperatorDesc> = operatorsOf::groupBy_53(operator_list, (item) => { 
        let mut key : String = item.name.clone();
        let mut fc : Option<CodeNode> = item.firstArg;
        if fc.is_some() {
          key = format!("{}{}", key, (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", ":".to_string(), fc.type_name)), ":".to_string())), fc.key_type)), ":".to_string())), fc.array_type)));
        }
        return key.clone();
      }
      );
      wr.out("## Statements".to_string(), true);
      self.writeTypeDoc(statements, (item) => { 
        return true;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Language switches".to_string(), true);
      self.writeTypeDoc(lang_statements, (item) => { 
        return true;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Operators without arguments".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        return item.firstArg.is_none();
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Generic operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return item.firstArg.type_name == "T".to_string();
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Numeric operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return ((item.firstArg.type_name == "int".to_string()) || (item.firstArg.type_name == "double".to_string())) && ((item.nameNode.type_name == "int".to_string()) || (item.nameNode.type_name == "double".to_string()));
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Miscellaneous operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return ((item.firstArg.type_name == "int".to_string()) || (item.firstArg.type_name == "double".to_string())) && (((item.nameNode.type_name != "int".to_string()) && (item.nameNode.type_name != "double".to_string())) && (item.nameNode.type_name != "boolean".to_string()));
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## String operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return item.firstArg.type_name == "string".to_string();
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("".to_string(), true);
      wr.out("## Array operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return item.firstArg.value_type == 6;
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Map operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return item.firstArg.value_type == 7;
        }
        return false;
      }
      , ctx.clone(), wr.clone());
      wr.out("".to_string(), true);
      wr.out("## Boolean / test operators".to_string(), true);
      self.writeTypeDoc(nList, (item) => { 
        if item.firstArg.is_some() {
          return item.nameNode.type_name == "boolean".to_string();
        }
        return false;
      }
      , ctx.clone(), wr.clone());
    }
  }
}
#[derive(Clone)]
struct viewbuilder_Android { 
}
impl viewbuilder_Android { 
  
  pub fn new() ->  viewbuilder_Android {
    let mut me = viewbuilder_Android { 
    };
    return me;
  }
  fn _attr(&mut self, mut wr : CodeWriter, name : String, value : String) -> () {
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "android:".to_string(), name)), "=".to_string())), "\"".to_string())), value)), "\" ".to_string()), true);
  }
  fn elWithText(&mut self, name : String, mut node : CodeNode, mut wr : CodeWriter) -> () {
    wr.out(format!("{}{}", (format!("{}{}", "<".to_string(), name)), " ".to_string()), true);
    wr.indent(1);
    let mut width : String = "match_parent".to_string();
    let height : String = "wrap_content".to_string();
    let mut weight : String = "".to_string();
    operatorsOf::forEach_15(node.children, (item, index) => { 
      switch (item.value_type ) { 
        case 20 : 
          self._attr(wr.clone(), "text".to_string(), item.string_value.clone());
          break;
      }
    }
    );
    operatorsOf::forEach_15(node.attrs, (item, index) => { 
      if  item.vref == "font-size".to_string() {
        self._attr(wr.clone(), "textSize".to_string(), format!("{}{}", item.string_value, "dp".to_string()));
      }
      if  item.vref == "id".to_string() {
        self._attr(wr.clone(), "id".to_string(), format!("{}{}", "@+id/".to_string(), item.string_value));
      }
      if  item.vref == "width-pros".to_string() {
        weight = item.string_value.clone();
      }
      if  item.vref == "width".to_string() {
        width = format!("{}{}", item.string_value, "dp".to_string());
      }
    }
    );
    self._attr(wr.clone(), "layout_width".to_string(), width.clone());
    self._attr(wr.clone(), "layout_height".to_string(), height.clone());
    if  (weight.len() as i64) > 0 {
      self._attr(wr.clone(), "layout_weight".to_string(), weight.clone());
    }
    wr.out("/>".to_string(), true);
    wr.indent(-1);
  }
  fn WalkNode(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.vref ) { 
      case "ScrollView".to_string() : 
        wr.out("<ScrollView ".to_string(), true);
        wr.indent(1);
        self._attr(wr.clone(), "layout_width".to_string(), "match_parent".to_string());
        self._attr(wr.clone(), "layout_height".to_string(), "wrap_content".to_string());
        operatorsOf::forEach_15(node.attrs, (item, index) => { 
          if  item.vref == "id".to_string() {
            self._attr(wr.clone(), "id".to_string(), format!("{}{}", "@+id/".to_string(), item.string_value));
          }
        }
        );
        wr.out(">".to_string(), true);
        wr.indent(1);
        operatorsOf::forEach_15(node.children, (item, index) => { 
          self.WalkNode(item.clone(), ctx.clone(), wr.clone());
        }
        );
        wr.indent(-1);
        wr.out("</ScrollView>".to_string(), true);
        wr.indent(-1);
        break;
      case "LinearLayout".to_string() : 
        wr.out("<LinearLayout ".to_string(), true);
        wr.indent(1);
        self._attr(wr.clone(), "layout_width".to_string(), "match_parent".to_string());
        self._attr(wr.clone(), "layout_height".to_string(), "wrap_content".to_string());
        let mut orientation : String = "vertical".to_string();
        operatorsOf::forEach_15(node.attrs, (item, index) => { 
          if  item.vref == "id".to_string() {
            self._attr(wr.clone(), "id".to_string(), format!("{}{}", "@+id/".to_string(), item.string_value));
          }
          if  item.vref == "direction".to_string() {
            orientation = item.string_value.clone();
          }
        }
        );
        self._attr(wr.clone(), "orientation".to_string(), orientation.clone());
        self._attr(wr.clone(), "weightSum".to_string(), "100".to_string());
        wr.out(">".to_string(), true);
        wr.indent(1);
        operatorsOf::forEach_15(node.children, (item, index) => { 
          self.WalkNode(item.clone(), ctx.clone(), wr.clone());
        }
        );
        wr.indent(-1);
        wr.out("</LinearLayout>".to_string(), true);
        wr.indent(-1);
        break;
      case "Button".to_string() : 
        self.elWithText("Button".to_string(), node.clone(), wr.clone());
        break;
      case "Text".to_string() : 
        self.elWithText("TextView".to_string(), node.clone(), wr.clone());
        break;
      case "Input".to_string() : 
        wr.out("<EditText ".to_string(), true);
        wr.indent(1);
        self._attr(wr.clone(), "layout_width".to_string(), "match_parent".to_string());
        self._attr(wr.clone(), "layout_height".to_string(), "wrap_content".to_string());
        operatorsOf::forEach_15(node.attrs, (item, index) => { 
          if  item.vref == "hint".to_string() {
            self._attr(wr.clone(), "hint".to_string(), item.string_value.clone());
          }
          if  item.vref == "id".to_string() {
            self._attr(wr.clone(), "id".to_string(), format!("{}{}", "@+id/".to_string(), item.string_value));
          }
          if  (item.vref == "type".to_string()) && (item.string_value == "password".to_string()) {
            self._attr(wr.clone(), "inputType".to_string(), "textPassword".to_string());
          }
        }
        );
        operatorsOf::forEach_15(node.children, (item, index) => { 
          switch (item.value_type ) { 
            case 20 : 
              self._attr(wr.clone(), "text".to_string(), item.string_value.clone());
              break;
          }
        }
        );
        wr.out("/>".to_string(), true);
        wr.indent(-1);
        break;
    }
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut orig_wr : CodeWriter) -> () {
    let mut viewName : String = "".to_string();
    let mut b_scroll : bool = false;
    operatorsOf::forEach_15(node.attrs, (item, index) => { 
      if  item.vref == "name".to_string() {
        viewName = item.string_value.clone();
      }
      if  item.vref == "type".to_string() {
        if  item.string_value == "scroll".to_string() {
          b_scroll = true;
        }
      }
    }
    );
    let mut wr : CodeWriter = orig_wr.getFileWriter("layout".to_string(), (format!("{}{}", (format!("{}{}", "activity_".to_string(), viewName)), ".xml".to_string())));
    wr.out("<?xml version=\"1.0\" encoding=\"utf-8\"?>".to_string(), true);
    let mut viewTag : String = "LinearLayout".to_string();
    if  b_scroll {
      viewTag = "ScrollView".to_string();
    }
    wr.out(format!("{}{}", (format!("{}{}", "<".to_string(), viewTag)), " xmlns:android=\"http://schemas.android.com/apk/res/android\" ".to_string()), true);
    wr.indent(1);
    self._attr(wr.clone(), "layout_width".to_string(), "match_parent".to_string());
    self._attr(wr.clone(), "layout_height".to_string(), "match_parent".to_string());
    if  b_scroll == false {
      self._attr(wr.clone(), "paddingLeft".to_string(), "16dp".to_string());
      self._attr(wr.clone(), "paddingRight".to_string(), "16dp".to_string());
      self._attr(wr.clone(), "orientation".to_string(), "vertical".to_string());
    }
    self._attr(wr.clone(), "id".to_string(), format!("{}{}", "@+id/view_id_".to_string(), viewName));
    wr.out(">".to_string(), true);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.indent(-1);
    wr.out(format!("{}{}", (format!("{}{}", "</".to_string(), viewTag)), ">".to_string()), true);
  }
}
#[derive(Clone)]
struct viewbuilder_Web { 
}
impl viewbuilder_Web { 
  
  pub fn new() ->  viewbuilder_Web {
    let mut me = viewbuilder_Web { 
    };
    return me;
  }
  fn _attr(&mut self, mut wr : CodeWriter, name : String, value : String) -> () {
    wr.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", " ".to_string(), name)), "=".to_string())), "\"".to_string())), value)), "\" ".to_string()), false);
  }
  fn tagAttrs(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    operatorsOf::forEach_15(node.attrs, (item, index) => { 
      if  item.vref == "id".to_string() {
        self._attr(wr.clone(), "x-id".to_string(), item.string_value.clone());
      }
      if  item.vref == "hint".to_string() {
        self._attr(wr.clone(), "tooltip".to_string(), item.string_value.clone());
        self._attr(wr.clone(), "title".to_string(), item.string_value.clone());
        self._attr(wr.clone(), "placeholder".to_string(), item.string_value.clone());
      }
    }
    );
  }
  fn tagText(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    operatorsOf::forEach_15(node.children, (item, index) => { 
      switch (item.value_type ) { 
        case 20 : 
          wr.out(item.string_value.clone(), false);
          break;
      }
    }
    );
  }
  fn tag(&mut self, name : String, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out(format!("{}{}", "<".to_string(), name), false);
    self.tagAttrs(node.clone(), ctx.clone(), wr.clone());
    wr.out(">".to_string(), false);
    self.tagText(node.clone(), ctx.clone(), wr.clone());
    wr.out(format!("{}{}", (format!("{}{}", "</".to_string(), name)), ">".to_string()), true);
  }
  fn WalkNode(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    switch (node.vref ) { 
      case "LinearLayout".to_string() : 
        self.tag("div".to_string(), node.clone(), ctx.clone(), wr.clone());
        break;
      case "Button".to_string() : 
        wr.out("<div><a class='waves-effect waves-light btn' ".to_string(), false);
        self.tagAttrs(node.clone(), ctx.clone(), wr.clone());
        wr.out(">".to_string(), false);
        self.tagText(node.clone(), ctx.clone(), wr.clone());
        wr.out("</a></div>".to_string(), false);
        break;
      case "Text".to_string() : 
        self.tag("div".to_string(), node.clone(), ctx.clone(), wr.clone());
        break;
      case "Input".to_string() : 
        wr.out("<div>".to_string(), true);
        self.tag("input".to_string(), node.clone(), ctx.clone(), wr.clone());
        wr.out("</div>".to_string(), true);
        break;
    }
  }
  fn CreateViews(&mut self, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    wr.out("<!DOCTYPE html>".to_string(), true);
    wr.out("<html>".to_string(), true);
    wr.indent(1);
    wr.out("<head>".to_string(), true);
    wr.indent(1);
    wr.out("\r\n  <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.min.css\">\r\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js\"></script>    \r\n    ".to_string(), true);
    wr.indent(-1);
    wr.out("</head>".to_string(), true);
    wr.out("<body>".to_string(), true);
    operatorsOf_13::forEach_25(ctx.viewClassBody, (item, index) => { 
      self.writeClass(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.out("</body>".to_string(), true);
    wr.out("</html>".to_string(), true);
  }
  fn writeClass(&mut self, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    let mut viewName : String = "".to_string();
    operatorsOf::forEach_15(node.attrs, (item, index) => { 
      if  item.vref == "name".to_string() {
        viewName = item.string_value.clone();
      }
    }
    );
    wr.out("".to_string(), true);
    wr.out(format!("{}{}", (format!("{}{}", "<div id=\"".to_string(), viewName)), "\">".to_string()), true);
    wr.indent(1);
    operatorsOf::forEach_15(node.children, (item, index) => { 
      self.WalkNode(item.clone(), ctx.clone(), wr.clone());
    }
    );
    wr.indent(-1);
    wr.out("</div>".to_string(), true);
  }
}
#[derive(Clone)]
struct CompilerResults { 
  ctx : Option<RangerAppWriterContext>, 
  fileSystem : Option<CodeFileSystem>, 
  target_dir : String, 
  hasErrors : bool, 
  errorMessage : String, 
}
impl CompilerResults { 
  
  pub fn new() ->  CompilerResults {
    let mut me = CompilerResults { 
      ctx: None, 
      fileSystem: None, 
      target_dir:"".to_string(), 
      hasErrors:false, 
      errorMessage:"".to_string(), 
    };
    return me;
  }
}
#[derive(Clone)]
struct VirtualCompiler { 
  envObj : Option<InputEnv>, 
}
impl VirtualCompiler { 
  
  pub fn new() ->  VirtualCompiler {
    let mut me = VirtualCompiler { 
      envObj: None, 
    };
    return me;
  }
  pub fn create_env() -> () {
    let mut env : InputEnv = InputEnv::new();
    env.filesystem = Some(InputFSFolder::new());
    env.commandLine = Some(CmdParams::new());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Lang.rgr".to_string(), (r_read_file(&".".to_string(), &"Lang.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "stdlib.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"stdlib.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "stdops.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"stdops.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Timers.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"Timers.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "DOMLib.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"DOMLib.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Ajax.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"Ajax.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Crypto.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"Crypto.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Engine3D.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"Engine3D.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "Storage.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"Storage.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "JSON.rgr".to_string(), (r_read_file(&"../lib/".to_string(), &"JSON.rgr".to_string())).unwrap());
    operatorsOf_3::createc95file_4(env.filesystem.clone().unwrap(), "hello_world.rgr".to_string(), "\r\n\r\nclass tester {\r\n  static fn main () {\r\n    print \"Hello World!\"\r\n  }\r\n}\r\n\r\n    ".to_string());
    r_write_file(&".".to_string(), &"compileEnv.js".to_string(), &format!("{}{}", "window._Ranger_compiler_environment_ = ".to_string(), (serde_json::to_string(&env.toDictionary()).unwrap())));
  }
  pub fn displayCompilerErrors(mut appCtx : RangerAppWriterContext) -> () {
    let mut cons : ColorConsole = ColorConsole::new();
    for i in 0..appCtx.compilerErrors.len() {
      let mut e = appCtx.compilerErrors[i as usize].clone();
      let line_index : i64 = e.node.getLine();
      cons.out("gray".to_string(), [(format!("{}{}", e.node.getFilename(), " Line: ".to_string())) , ((1 + line_index).to_string()) ].join(""));
      cons.out("gray".to_string(), e.description.clone());
      cons.out("gray".to_string(), e.node.getLineString(line_index));
      cons.out("".to_string(), format!("{}{}", e.node.getColStartString(), "^-------".to_string()));
    }
  }
  pub fn displayParserErrors(mut appCtx : RangerAppWriterContext) -> () {
    if  ((appCtx.parserErrors.len() as i64)) == 0 {
      println!( "{}", "no language test errors".to_string() );
      return;
    }
    println!( "{}", "LANGUAGE TEST ERRORS:".to_string() );
    for i in 0..appCtx.parserErrors.len() {
      let mut e = appCtx.parserErrors[i as usize].clone();
      let line_index : i64 = e.node.getLine();
      println!( "{}", [(format!("{}{}", e.node.getFilename(), " Line: ".to_string())) , ((1 + line_index).to_string()) ].join("") );
      println!( "{}", e.description );
      println!( "{}", e.node.getLineString(line_index) );
    }
  }
  fn getEnvVar(&mut self, name : String) -> String {
    return operatorsOf_8::envc95var_54((self.envObj.clone().unwrap()), name.clone()).clone();
  }
  fn possiblePaths(&mut self, envVarName : String) -> Vec<String> {
    let mut res : Vec<String> = Vec::new();
    let mut parts : Vec<String> = envVarName.split(";".to_string());
    res.push("./".to_string().to_string());
    for i in 0..parts.len() {
      let mut str = parts[i as usize].clone();
      let s : String = str.trim();
      if  (s.len() as i64) > 0 {
        let mut dirNames : Vec<String> = s.split("/".to_string());
        dirNames.pop();
        let theDir : String = dirNames.join("/".to_string());
        res.push(theDir);
      }
    }
    res.push(operatorsOf_8::installc95directory_51((self.envObj.clone().unwrap())));
    return res;
  }
  fn searchLib(&mut self, mut paths : Vec<String>, libname : String) -> String {
    for i in 0..paths.len() {
      let mut path = paths[i as usize].clone();
      if  operatorsOf_8::filec95exists_9((self.envObj.clone().unwrap()), path.clone(), libname.clone()) {
        return path.clone();
      }
    }
    return "".to_string().clone();
  }
  fn fillStr(&mut self, cnt : i64) -> String {
    let mut s : String = "".to_string();
    let mut i : i64 = cnt;
    while i > 0 {
      s = format!("{}{}", s, " ".to_string());
      i = i - 1;
    }
    return s.clone();
  }
  fn run(&mut self, mut env : InputEnv) -> CompilerResults {
    let mut res : CompilerResults = CompilerResults::new();
    self.envObj = Some(env.clone());
    let mut allowed_languages : Vec<String> = ["es6".to_string(), "go".to_string(), "scala".to_string(), "java7".to_string(), "swift3".to_string(), "swift6".to_string(), "kotlin".to_string(), "cpp".to_string(), "php".to_string(), "csharp".to_string(), "python".to_string(), "rust".to_string()];
    let mut params : CmdParams = env.commandLine.clone().unwrap();
    let mut the_file : String = "".to_string();
    let mut plugins_only : bool = false;
    let mut valid_options : Vec<String> = ["l".to_string(), format!("{}{}", "Selected language, one of ".to_string(), (allowed_languages.join(", ".to_string()))), "d".to_string(), "output directory, default directory is \"bin/\"".to_string(), "o".to_string(), "output file, default is \"output.<language>\"".to_string(), "classdoc".to_string(), "write class documentation .md file".to_string(), "operatordoc".to_string(), "write operator documention into .md file".to_string()];
    let mut valid_flags : Vec<String> = ["deadcode".to_string(), "Eliminate functions which are not called by any other functions".to_string(), "dead4main".to_string(), "Eliminate functions and classes which are unreachable from the main function".to_string(), "forever".to_string(), "Leave the main program into eternal loop (Go, Swift)".to_string(), "allowti".to_string(), "Allow type inference at target lang (creates slightly smaller code)".to_string(), "plugins-only".to_string(), "ignore built-in language output and use only plugins".to_string(), "plugins".to_string(), "(node compiler only) run specified npm plugins -plugins=\"plugin1,plugin2\"".to_string(), "strict".to_string(), "Strict mode. Do not allow automatic unwrapping of optionals outside of try blocks.".to_string(), "typescript".to_string(), "Writes JavaScript code with TypeScript annotations".to_string(), "npm".to_string(), "Write the package.json to the output directory".to_string(), "nodecli".to_string(), "Insert node.js command line header #!/usr/bin/env node to the beginning of the JavaScript file".to_string(), "nodemodule".to_string(), "Export the classes as node.js modules (this option will disable the static main function)".to_string(), "client".to_string(), "the code is ment to be run in the client environment".to_string(), "scalafiddle".to_string(), "scalafiddle.io compatible output".to_string(), "compiler".to_string(), "recompile the compiler".to_string(), "copysrc".to_string(), "copy all the source codes into the target directory".to_string()];
    let mut parser_pragmas : Vec<String> = ["@noinfix(true)".to_string(), "disable operator infix parsing and automatic type definition checking ".to_string()];
    if  params.flags.contains_key(&"compiler".to_string()) {
      println!( "{}", "---------------------------------------------".to_string() );
      println!( "{}", " re-compiling the compiler itself ".to_string() );
      println!( "{}", "---------------------------------------------".to_string() );
      the_file = "ng_Compiler.rgr".to_string();
    } else {
      if  ((params.values.len() as i64)) < 1 {
        println!( "{}", format!("{}{}", "Ranger compiler, version ".to_string(), "".to_string()) );
        println!( "{}", format!("{}{}", "Installed at: ".to_string(), operatorsOf_8::installc95directory_51(env.clone())) );
        println!( "{}", "Usage: <file> <options> <flags>".to_string() );
        println!( "{}", "Options: -<option>=<value> ".to_string() );
        let mut optCnt : i64 = 0;
        while optCnt < ((valid_options.len() as i64)) {
          let option : String = valid_options[optCnt as usize].clone();
          let optionDesc : String = valid_options[(optCnt + 1) as usize].clone();
          println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "  -".to_string(), option)), "=<value> ".to_string())), self.fillStr((13 - (option.len() as i64))))), optionDesc) );
          optCnt = optCnt + 2;
        }
        println!( "{}", "Flags: -<flag> ".to_string() );
        let mut optCnt_1 : i64 = 0;
        while optCnt_1 < ((valid_flags.len() as i64)) {
          let option_1 : String = valid_flags[optCnt_1 as usize].clone();
          let optionDesc_1 : String = valid_flags[(optCnt_1 + 1) as usize].clone();
          println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "  -".to_string(), option_1)), " ".to_string())), self.fillStr((13 - (option_1.len() as i64))))), optionDesc_1) );
          optCnt_1 = optCnt_1 + 2;
        }
        println!( "{}", "Pragmas: (inside the source code files) ".to_string() );
        let mut optCnt_2 : i64 = 0;
        while optCnt_2 < ((parser_pragmas.len() as i64)) {
          let option_2 : String = parser_pragmas[optCnt_2 as usize].clone();
          let optionDesc_2 : String = parser_pragmas[(optCnt_2 + 1) as usize].clone();
          println!( "{}", format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "   ".to_string(), option_2)), " ".to_string())), self.fillStr((16 - (option_2.len() as i64))))), optionDesc_2) );
          optCnt_2 = optCnt_2 + 2;
        }
        return res.clone();
      }
      the_file = params.values[0 as usize].clone();
    }
    let mut root_file : String = the_file;
    let root_dir :  = normalize++format!("{}{}", operatorsOf_8::currentc95directory_51(env.clone()), "/".to_string())pathnamethe_file"/".to_string();
    let the_lang_file : String = "Lang.rgr".to_string();
    let mut the_lang : String = "es6".to_string();
    let mut the_target_dir : String = +root_dir"bin".to_string();
    let mut the_target : String = "output".to_string();
    let mut package_name : String = "".to_string();
    let mut comp_attrs : HashMap<String,String> = HashMap::new();
    let outDir : Option<String> = params.getParam("o".to_string());
    if  outDir.is_some() {
      the_target = outDir.unwrap();
    }
    let mut langLibEnv : String = operatorsOf_8::envc95var_54(env.clone(), "RANGER_LIB".to_string());
    let idir : String = "./";
    =langLibEnv++++++root_dir";".to_string()
    "./"
    ";".to_string()
    "./"
    ";".to_string()langLibEnvenv.setEnv("RANGER_LIB".to_string(), langLibEnv.clone());
    println!( "{}", format!("{}{}", "ENV: ".to_string(), operatorsOf_8::envc95var_54(env.clone(), "RANGER_LIB".to_string())) );
    let mut theFilePaths : Vec<String> = self.possiblePaths(operatorsOf_8::envc95var_54(env.clone(), "RANGER_LIB".to_string()));
    let theFilePath : String = self.searchLib(theFilePaths, the_file.clone());
    if  operatorsOf_8::filec95exists_9(env.clone(), theFilePath.clone(), the_file.clone()) == false {
      println!( "{}", "Could not compile.".to_string() );
      println!( "{}", format!("{}{}", "File not found: ".to_string(), the_file) );
      return res.clone();
    }
    let mut langFilePaths : Vec<String> = let _tmp_1 = self.getEnvVar("RANGER_LIB".to_string());
    self.possiblePaths(_tmp_1);
    let langFilePath : String = self.searchLib(langFilePaths, the_lang_file.clone());
    if  operatorsOf_8::filec95exists_9(env.clone(), langFilePath.clone(), the_lang_file.clone()) == false {
      println!( "{}", format!("{}{}", (format!("{}{}", "language file ".to_string(), the_lang_file)), " not found! Check the library directory or RANGER_LIB enviroment variable".to_string()) );
      println!( "{}", format!("{}{}", "currently pointing at : ".to_string(), langLibEnv) );
      println!( "{}", "download: https://raw.githubusercontent.com/terotests/Ranger/master/compiler/Lang.rgr".to_string() );
      return res.clone();
    } else {
      println!( "{}", format!("{}{}", "Using language file from : ".to_string(), langFilePath) );
    }
    println!( "{}", format!("{}{}", "File to be compiled: ".to_string(), the_file) );
    let mut langFileDirs : Vec<String> = let _tmp_2 = self.getEnvVar("RANGER_LIB".to_string());
    self.possiblePaths(_tmp_2);
    let sourceFileDir : String = "./";
    langFileDirs.push(sourceFileDir);
    let c : Option<String> = operatorsOf_8::readc95file_9(env.clone(), theFilePath.clone(), the_file.clone());
    let mut code : SourceCode = SourceCode::new(c.unwrap());
    code.filename = the_file.clone();
    let mut parser : RangerLispParser = RangerLispParser::new(code.clone());
    if  params.flags.contains_key(&"no-op-transform".to_string()) {
      parser.disableOperators = true;
    }
    parser.parse(params.flags.contains_key(&"no-op-transform".to_string()));
    let mut root : CodeNode = parser.rootNode.clone().unwrap();
    println!( "{}", "--> ready to compile".to_string() );
    let flags :  = keysparams.flags;
    for ci in 0..root.children.len() {
      let mut ch = root.children[ci as usize].clone();
      let mut inserted_nodes : Vec<CodeNode> = Vec::new();
      if  ((ch.children.len() as i64)) > 2 {
        let mut fc : CodeNode = ch.getFirst();
        if  fc.vref == "flag".to_string() {
          let mut fName : CodeNode = ch.getSecond();
          forflagsflag_namei
          if  flag_name == fName.vref {
            let mut compInfo : CodeNode = ch.getThird();
            let mut i_1 : i64 = 0;
            let cnt : i64 = (compInfo.children.len() as i64);
            while i_1 < (cnt - 1) {
              let mut fc_1 : CodeNode = compInfo.children[i_1 as usize].clone();
              let mut sc : CodeNode = compInfo.children[(i_1 + 1) as usize].clone();
              switch (fc_1.vref ) { 
                case "libpath".to_string() : 
                  langFileDirs = self.possiblePaths(sc.string_value.clone());
                  break;
                case "output".to_string() : 
                  the_target = sc.string_value.clone();
                  break;
                case "root-file".to_string() : 
                  root_file = sc.string_value.clone();
                  break;
                case "language".to_string() : 
                  the_lang = sc.string_value.clone();
                  break;
                case "absolute_output_dir".to_string() : 
                  the_target_dir = sc.string_value.clone();
                  break;
                case "relative_output_dir".to_string() : 
                  the_target_dir = format!("{}{}", (format!("{}{}", operatorsOf_8::currentc95directory_51(env.clone()), "/".to_string())), sc.string_value);
                  break;
                case "package".to_string() : 
                  package_name = sc.string_value.clone();
                  break;
                case "android_res_dir".to_string() : 
                  comp_attrs.insert(fc_1.vref, sc.string_value);
                  break;
                case "web_res_dir".to_string() : 
                  comp_attrs.insert(fc_1.vref, sc.string_value);
                  break;
                case "Import".to_string() : 
                  inserted_nodes.push(CodeNode::fromList([CodeNode::vref1("Import".to_string()), CodeNode::newStr(sc.string_value.clone())]));
                  break;
                default: 
                  if  (sc.string_value.len() as i64) > 0 {
                    comp_attrs.insert(fc_1.vref, sc.string_value);
                  }
                  break;
              }
              i_1 = i_1 + 2;
            }
          }
          ch.children.length = 0;
          for i_2 in 0..inserted_nodes.len() {
            let mut new_node = inserted_nodes[i_2 as usize].clone();
            println!( "{}", format!("{}{}", " *** Inserting ".to_string(), new_node.getCode()) );
            root.children.insert(0 as usize, new_node);
          }
        }
      }
    }
    root.children.insert(0 as usize, CodeNode::fromList([CodeNode::vref1("Import".to_string()), CodeNode::newStr("stdlib.rgr".to_string())]));
    let outDir_2 : Option<String> = params.getParam("o".to_string());
    if  outDir_2.is_some() {
      the_target = outDir_2.unwrap();
    }
    comp_attrs.insert("o".to_string(), the_target);
    let dirParam : Option<String> = params.getParam("d".to_string());
    if  dirParam.is_some() {
      the_target_dir = format!("{}{}", (format!("{}{}", operatorsOf_8::currentc95directory_51(env.clone()), "/".to_string())), (dirParam.unwrap()));
    }
    the_target_dir = "./";
    comp_attrs.insert("d".to_string(), the_target_dir);
    let pLang : Option<String> = params.getParam("l".to_string());
    if  pLang.is_some() {
      the_lang = pLang.unwrap();
    }
    let mut appCtx : RangerAppWriterContext = RangerAppWriterContext::new();
    appCtx.env = Some(env.clone());
    appCtx.libraryPaths = langFileDirs.clone();
    appCtx.compilerSettings.insert("package".to_string(), package_name);
    if  appCtx.hasCompilerFlag("verbose".to_string()) {
      for i_3 in 0..appCtx.libraryPaths.len() {
        let mut include_path = appCtx.libraryPaths[i_3 as usize].clone();
        println!( "{}", format!("{}{}", "include-path : ".to_string(), include_path) );
      }
    }
    operatorsOf_13::forEach_55(params.flags, (item, index) => { 
      let n : String = index;
      appCtx.compilerFlags.insert(n, true);
    }
    );
    operatorsOf_13::forEach_40(params.params, (item, index) => { 
      let v : String = item;
      comp_attrs.insert(index, v);
    }
    );
    operatorsOf_13::forEach_40(comp_attrs, (item, index) => { 
      let n_1 : String = item;
      appCtx.compilerSettings.insert(index, n_1);
    }
    );
    if  (allowed_languages.iter().position( |&r| r == the_lang ).unwrap()) < 0 {
      println!( "{}", format!("{}{}", "Invalid language : ".to_string(), the_lang) );
      /** unused:  let s : String = "".to_string();   **/ 
      println!( "{}", format!("{}{}", "allowed languages: ".to_string(), (allowed_languages.join(" ".to_string()))) );
      return res.clone();
    }
    appCtx.compilerSettings.insert("l".to_string(), the_lang);
    if  the_target == "output".to_string() {
      let mut root_parts : Vec<String> = root_file.split(".".to_string());
      if  ((root_parts.len() as i64)) == 2 {
        the_target = root_parts[0 as usize].clone();
      }
    }
    switch (the_lang ) { 
      case "es6".to_string() : 
        if==falseendsWiththe_target".js".to_string()if==falseendsWiththe_target".ts".to_string()
        the_target = format!("{}{}", the_target, ".js".to_string());
        if  appCtx.hasCompilerFlag("typescript".to_string()) {
          the_target = format!("{}{}", the_target, ".ts".to_string());
        }
        break;
      case "swift3".to_string() : 
        if==falseendsWiththe_target".swift".to_string()
        the_target = format!("{}{}", the_target, ".swift".to_string());
        break;
      case "swift6".to_string() : 
        if==falseendsWiththe_target".swift".to_string()
        the_target = format!("{}{}", the_target, ".swift".to_string());
        break;
      case "php".to_string() : 
        if==falseendsWiththe_target".php".to_string()
        the_target = format!("{}{}", the_target, ".php".to_string());
        break;
      case "csharp".to_string() : 
        if==falseendsWiththe_target".cs".to_string()
        the_target = format!("{}{}", the_target, ".cs".to_string());
        break;
      case "java7".to_string() : 
        if==falseendsWiththe_target".java".to_string()
        the_target = format!("{}{}", the_target, ".java".to_string());
        break;
      case "go".to_string() : 
        if==falseendsWiththe_target".go".to_string()
        the_target = format!("{}{}", the_target, ".go".to_string());
        break;
      case "scala".to_string() : 
        if==falseendsWiththe_target".scala".to_string()
        the_target = format!("{}{}", the_target, ".scala".to_string());
        break;
      case "kotlin".to_string() : 
        if==falseendsWiththe_target".kt".to_string()
        the_target = format!("{}{}", the_target, ".kt".to_string());
        break;
      case "cpp".to_string() : 
        if==falseendsWiththe_target".cpp".to_string()
        the_target = format!("{}{}", the_target, ".cpp".to_string());
        break;
      case "python".to_string() : 
        if==falseendsWiththe_target".py".to_string()
        the_target = format!("{}{}", the_target, ".py".to_string());
        break;
      case "rust".to_string() : 
        if==falseendsWiththe_target".rs".to_string()
        the_target = format!("{}{}", the_target, ".rs".to_string());
        break;
    }
    appCtx.compilerSettings.insert("o".to_string(), the_target);
    let mut lcc : LiveCompiler = LiveCompiler::new();
    let mut node : CodeNode = parser.rootNode.clone().unwrap();
    let mut flowParser : RangerFlowParser = RangerFlowParser::new();
    let mut fileSystem : CodeFileSystem = CodeFileSystem::new();
    let mut file : CodeFile = fileSystem.getFile(".".to_string(), the_target.clone());
    let mut wr : Option<CodeWriter> = file.getWriter();
    if  appCtx.hasCompilerFlag("copysrc".to_string()) {
      println!( "{}", format!("{}{}", "--> copying ".to_string(), code.filename) );
      let mut fileWr : CodeWriter = wr.getFileWriter(".".to_string(), code.filename.clone());
      fileWr.raw(code.code.clone(), false);
    }
    appCtx.parser = Some(flowParser.clone());
    appCtx.compiler = Some(lcc.clone());
    lcc.parser = Some(flowParser.clone());
    try {
      flowParser.mergeImports(node.clone(), appCtx.clone(), wr.unwrap());
      let lang_str : Option<String> = operatorsOf_8::readc95file_9(env.clone(), langFilePath.clone(), the_lang_file.clone());
      let mut lang_code : SourceCode = SourceCode::new(lang_str.unwrap());
      lang_code.filename = the_lang_file.clone();
      let mut lang_parser : RangerLispParser = RangerLispParser::new(lang_code.clone());
      lang_parser.parse(false);
      appCtx.langOperators = Some(lang_parser.rootNode.clone().unwrap());
      appCtx.setRootFile(root_file.clone());
      let mut ops : RangerActiveOperators = RangerActiveOperators::new();
      ops.initFrom(lang_parser.rootNode.clone().unwrap());
      appCtx.operators = Some(ops.clone());
      appCtx.targetLangName = the_lang.clone();
      lcc.initWriter(appCtx.clone());
      println!( "{}", "--- context inited ---".to_string() );
      println!( "{}", "1. Collecting available methods.".to_string() );
      flowParser.CollectMethods(node.clone(), appCtx.clone(), wr.unwrap());
      if  ((appCtx.compilerErrors.len() as i64)) > 0 {
        VirtualCompiler::displayCompilerErrors(appCtx.clone());
        res.hasErrors = true;
        res.errorMessage = "Errors during method collection phase".to_string();
        res.ctx = Some(appCtx.clone());
        return res.clone();
      }
      flowParser.CreateCTTI(node.clone(), appCtx.clone(), wr.unwrap());
      if  appCtx.hasCompilerFlag("rtti".to_string()) {
        flowParser.CreateRTTI(node.clone(), appCtx.clone(), wr.unwrap());
      }
      appCtx.initOpList();
      println!( "{}", "2. Analyzing the code.".to_string() );
      println!( "{}", format!("{}{}", "selected language is ".to_string(), appCtx.targetLangName) );
      flowParser.StartWalk(node.clone(), appCtx.clone(), wr.unwrap());
      flowParser.SolveAsyncFuncs(root.clone(), appCtx.clone(), wr.unwrap());
      println!( "{}", "3. Compiling the source code.".to_string() );
      switch (appCtx.targetLangName ) { 
        case "java7".to_string() : 
          if  comp_attrs.contains_key(&"android_res_dir".to_string()) {
            println!( "{}", "--> had android res dir".to_string() );
            let resDir : String = (comp_attrs.get("android_res_dir".to_string())).unwrap();
            let mut resFs : CodeFileSystem = CodeFileSystem::new();
            let mut file_2 : CodeFile = resFs.getFile(".".to_string(), "README.txt".to_string());
            let mut wr_2 : CodeWriter = file_2.getWriter().unwrap();
            let mut builder : viewbuilder_Android = viewbuilder_Android::new();
            operatorsOf_13::forEach_25(appCtx.viewClassBody, (item, index) => { 
              builder.writeClass(item.clone(), appCtx.clone(), wr_2.clone());
            }
            );
            resFs.saveTo(resDir.clone(), appCtx.hasCompilerFlag("show-writes".to_string()));
          }
          break;
        case "es6".to_string() : 
          if  comp_attrs.contains_key(&"web_res_dir".to_string()) {
            println!( "{}", "--> had web res dir".to_string() );
            let resDir_1 : String = (comp_attrs.get("web_res_dir".to_string())).unwrap();
            let mut resFs_1 : CodeFileSystem = CodeFileSystem::new();
            let mut file_3 : CodeFile = resFs_1.getFile(".".to_string(), "webviews.html".to_string());
            let mut wr_3 : CodeWriter = file_3.getWriter().unwrap();
            let mut builder_1 : viewbuilder_Web = viewbuilder_Web::new();
            builder_1.CreateViews(appCtx.clone(), wr_3.clone());
            resFs_1.saveTo(resDir_1.clone(), appCtx.hasCompilerFlag("show-writes".to_string()));
          }
          break;
      }
      let mut staticMethods : Option<RangerAppClassDesc> = None;
      let mut importFork : CodeWriter = wr.fork();
      wr.createTag("after_imports".to_string());
      let mut contentFork : CodeWriter = wr.fork();
      wr.createTag("utilities".to_string());
      /** unused:  let mut theEnd : CodeWriter = wr.createTag("file_end".to_string());   **/ 
      wr = contentFork.clone();
      let mut handledClasses : HashMap<String,bool> = HashMap::new();
      for i_4 in 0..appCtx.definedClassList.len() {
        let mut cName = appCtx.definedClassList[i_4 as usize].clone();
        if  cName == "RangerStaticMethods".to_string() {
          staticMethods = Some(appCtx.definedClasses.get(cName));
          continue;
        }
        let mut cl : Option<RangerAppClassDesc> = appCtx.definedClasses.get(cName);
        if  cl.is_operator_class {
          continue;
        }
        if  cl.is_trait {
          continue;
        }
        if  cl.is_system {
          continue;
        }
        if  cl.is_generic_instance {
          continue;
        }
        if  cl.is_system_union {
          continue;
        }
        if  cl.is_union {
          continue;
        }
        if  handledClasses.contains_key(&cName) {
          continue;
        }
        handledClasses.insert(cName, true);
        if  ((cl.extends_classes.len() as i64)) > 0 {
          for i_5 in 0..cl.extends_classes.len() {
            let mut eClassName = cl.extends_classes[i_5 as usize].clone();
            if  handledClasses.contains_key(&eClassName) {
              continue;
            }
            let mut parentCl : Option<RangerAppClassDesc> = appCtx.definedClasses.get(eClassName);
            lcc.WalkNode(parentCl.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
            handledClasses.insert(eClassName, true);
          }
        }
        lcc.WalkNode(cl.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
      }
      if  staticMethods.is_some() {
        lcc.WalkNode(staticMethods.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
      }
      for i_6 in 0..flowParser.collectedIntefaces.len() {
        let mut ifDesc = flowParser.collectedIntefaces[i_6 as usize].clone();
        println!( "{}", format!("{}{}", "should define also interface ".to_string(), ifDesc.name) );
        lcc.langWriter.writeInterface(ifDesc.clone(), appCtx.clone(), wr.unwrap());
      }
      for i_7 in 0..appCtx.definedClassList.len() {
        let mut cName_1 = appCtx.definedClassList[i_7 as usize].clone();
        if  handledClasses.contains_key(&cName_1) {
          continue;
        }
        if  cName_1 == "RangerStaticMethods".to_string() {
          staticMethods = Some(appCtx.definedClasses.get(cName_1));
          continue;
        }
        let mut cl_1 : Option<RangerAppClassDesc> = appCtx.definedClasses.get(cName_1);
        if  cl_1.is_operator_class {
          continue;
        }
        if  cl_1.is_generic_instance {
          lcc.WalkNode(cl_1.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
        }
        if  cl_1.is_trait {
          continue;
        }
        if  cl_1.is_system {
          continue;
        }
        if  cl_1.is_operator_class {
          continue;
        }
        if  cl_1.is_generic_instance {
          continue;
        }
        if  cl_1.is_system_union {
          continue;
        }
        if  cl_1.is_union {
          continue;
        }
        lcc.WalkNode(cl_1.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
      }
      for i_8 in 0..appCtx.definedClassList.len() {
        let mut cName_2 = appCtx.definedClassList[i_8 as usize].clone();
        let mut cl_2 : Option<RangerAppClassDesc> = appCtx.definedClasses.get(cName_2);
        if  cl_2.is_operator_class {
          lcc.WalkNode(cl_2.classNode.clone().unwrap(), appCtx.clone(), wr.unwrap());
        }
      }
      let mut import_list : Vec<String> = wr.getImports();
      if  appCtx.targetLangName == "go".to_string() {
        importFork.out("package main".to_string(), true);
        importFork.newline();
        importFork.out("import (".to_string(), true);
        importFork.indent(1);
      }
      let mut added_import : HashMap<String,bool> = HashMap::new();
      for i_9 in 0..import_list.len() {
        let mut codeStr = import_list[i_9 as usize].clone();
        if  added_import.contains_key(&codeStr) {
          continue;
        }
        added_import.insert(codeStr, true);
        switch (appCtx.targetLangName ) { 
          case "es6".to_string() : 
            let mut parts : Vec<String> = codeStr.split(".".to_string());
            let p0 : String = parts[0 as usize].clone();
            if  ((parts.len() as i64)) > 1 {
              let p1 : String = parts[1 as usize].clone();
              importFork.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "const ".to_string(), p1)), " = require('".to_string())), p0)), "').".to_string())), p1)), ";".to_string()), true);
            }
            if  ((parts.len() as i64)) == 1 {
              importFork.out(format!("{}{}", (format!("{}{}", (format!("{}{}", (format!("{}{}", "const ".to_string(), p0)), " = require('".to_string())), p0)), "');".to_string()), true);
            }
            break;
          case "go".to_string() : 
            if  (codeStr.chars().nth(0 as usize).unwrap_or('\0') as i64) == (("_".to_string().charCodeAt(0)) as i64 ) {
              importFork.out(format!("{}{}", (format!("{}{}", " _ \"".to_string(), (codeStr.chars().skip(1 as usize).take(((codeStr.len() as i64) - 1) as usize).collect::<String>()))), "\"".to_string()), true);
            } else {
              importFork.out(format!("{}{}", (format!("{}{}", "\"".to_string(), codeStr)), "\"".to_string()), true);
            }
            break;
          case "csharp".to_string() : 
            importFork.out(format!("{}{}", (format!("{}{}", "using ".to_string(), codeStr)), ";".to_string()), true);
            break;
          case "rust".to_string() : 
            importFork.out(format!("{}{}", (format!("{}{}", "use ".to_string(), codeStr)), ";".to_string()), true);
            break;
          case "java7".to_string() : 
            importFork.out(format!("{}{}", (format!("{}{}", "import ".to_string(), codeStr)), ";".to_string()), true);
            break;
          case "cpp".to_string() : 
            importFork.out(format!("{}{}", "#include  ".to_string(), codeStr), true);
            break;
          default: 
            importFork.out(format!("{}{}", "import ".to_string(), codeStr), true);
            break;
        }
      }
      if  appCtx.targetLangName == "go".to_string() {
        importFork.indent(-1);
        importFork.out(")".to_string(), true);
      }
      if  appCtx.hasCompilerSetting("classdoc".to_string()) {
        let mut gen : RangerDocGenerator = RangerDocGenerator::new();
        gen.createClassDoc(root.clone(), appCtx.clone(), wr.unwrap());
      }
      if  appCtx.hasCompilerSetting("operatordoc".to_string()) {
        let mut gen_1 : RangerDocGenerator = RangerDocGenerator::new();
        gen_1.createOperatorDoc(root.clone(), appCtx.clone(), wr.unwrap());
      }
      VirtualCompiler::displayCompilerErrors(appCtx.clone());
      if  ((appCtx.compilerErrors.len() as i64)) > 0 {
        res.hasErrors = true;
        res.errorMessage = "Errors during compilation phase".to_string();
      }
      res.target_dir = the_target_dir.clone();
      res.fileSystem = Some(fileSystem.clone());
      res.ctx = Some(appCtx.clone());
    } catch(e) {
      let err_msg :  = error_msg;
      printerr_msg
      res.hasErrors = true;
      res.ctx = Some(appCtx.clone());
      if lcc.lastProcessedNode.is_some() {
        println!( "{}", "Got compiler error close to".to_string() );
        println!( "{}", lcc.lastProcessedNode.getLineAsString() );
        =res.errorMessageerr_msg
        return res.clone();
      }
      if flowParser.lastProcessedNode.is_some() {
        println!( "{}", "Got compiler error close to".to_string() );
        println!( "{}", flowParser.lastProcessedNode.getLineAsString() );
        =res.errorMessageerr_msg
        return res.clone();
      }
      println!( "{}", "Got unknown compiler error".to_string() );
      =res.errorMessageerr_msg
    }
    return res.clone();
  }
}
fn main() {
}
#[derive(Clone)]
struct CompilerInterface { 
}
impl CompilerInterface { 
  
  pub fn new() ->  CompilerInterface {
    let mut me = CompilerInterface { 
    };
    return me;
  }
  pub fn create_env() -> InputEnv {
    let mut env : InputEnv = InputEnv::new();
    env.use_real = true;
    env.commandLine = Some(CmdParams::new());
    env.commandLine.collect();
    return env.clone();
  }
}
fn main() {
  let mut env : InputEnv = CompilerInterface::create_env();
  let mut o : VirtualCompiler = VirtualCompiler::new();
  let mut res : CompilerResults = o.run(env.clone());
  if  (res.target_dir.len() as i64) > 0 {
    res.fileSystem.saveTo(res.target_dir.clone(), false);
  }
}
#[derive(Clone)]
struct operatorsOf { 
}
impl operatorsOf { 
  
  pub fn new() ->  operatorsOf {
    let mut me = operatorsOf { 
    };
    return me;
  }
  pub fn forEach_2(mut self : Vec<InputFSFolder>, cb : ) -> () {
    for i in 0..__self.len() {
      let mut it = __self[i as usize].clone();
      cb(it, i);
    }
  }
  pub fn filter_6(mut self : Vec<InputFSFile>, cb : ) -> Vec<InputFSFile> {
    let mut res_1 : Vec<InputFSFile> = Vec::new();
    for i_1 in 0..__self.len() {
      let mut it_1 = __self[i_1 as usize].clone();
      if  cb(it_1, i_1) {
        res_1.push(it_1.clone());
      }
    }
    return res_1;
  }
  pub fn filter_7(mut self : Vec<InputFSFolder>, cb : ) -> Vec<InputFSFolder> {
    let mut res_2 : Vec<InputFSFolder> = Vec::new();
    for i_2 in 0..__self.len() {
      let mut it_2 = __self[i_2 as usize].clone();
      if  cb(it_2, i_2) {
        res_2.push(it_2.clone());
      }
    }
    return res_2;
  }
  pub fn forEach_10(mut self : Vec<InputFSFile>, cb : ) -> () {
    for i_4 in 0..__self.len() {
      let mut it_3 = __self[i_4 as usize].clone();
      cb(it_3, i_4);
    }
  }
  pub fn forEach_11(mut self : Vec<RangerAppParamDesc>, cb : ) -> () {
    for i_5 in 0..__self.len() {
      let mut it_4 = __self[i_5 as usize].clone();
      cb(it_4, i_5);
    }
  }
  pub fn forEach_12(mut self : Vec<String>, cb : ) -> () {
    for i_6 in 0..__self.len() {
      let mut it_5 = __self[i_6 as usize].clone();
      cb(it_5, i_6);
    }
  }
  pub fn forEach_15(mut self : Vec<CodeNode>, cb : ) -> () {
    for i_8 in 0..__self.len() {
      let mut it_6 = __self[i_8 as usize].clone();
      cb(it_6, i_8);
    }
  }
  pub fn forEach_17(mut self : Vec<RangerAppOperatorDesc>, cb : ) -> () {
    for i_10 in 0..__self.len() {
      let mut it_7 = __self[i_10 as usize].clone();
      cb(it_7, i_10);
    }
  }
  pub fn clone_18(mut self : Vec<RangerAppOperatorDesc>) -> Vec<RangerAppOperatorDesc> {
    let mut res_5 : Vec<RangerAppOperatorDesc> = Vec::new();
    for i_11 in 0..__self.len() {
      let mut it_8 = __self[i_11 as usize].clone();
      res_5.push(it_8.clone());
    }
    return res_5;
  }
  pub fn forEach_29(mut self : Vec<RangerAppFunctionDesc>, cb : ) -> () {
    for i_15 in 0..__self.len() {
      let mut it_9 = __self[i_15 as usize].clone();
      cb(it_9, i_15);
    }
  }
  pub fn forEach_31(mut self : Vec<RangerAppClassDesc>, cb : ) -> () {
    for i_17 in 0..__self.len() {
      let mut it_10 = __self[i_17 as usize].clone();
      cb(it_10, i_17);
    }
  }
  pub fn filter_32(mut self : Vec<RangerAppFunctionDesc>, cb : ) -> Vec<RangerAppFunctionDesc> {
    let mut res_6 : Vec<RangerAppFunctionDesc> = Vec::new();
    for i_18 in 0..__self.len() {
      let mut it_11 = __self[i_18 as usize].clone();
      if  cb(it_11, i_18) {
        res_6.push(it_11.clone());
      }
    }
    return res_6;
  }
  pub fn filter_36(mut self : Vec<CodeNode>, cb : ) -> Vec<CodeNode> {
    let mut res_7 : Vec<CodeNode> = Vec::new();
    for i_19 in 0..__self.len() {
      let mut it_12 = __self[i_19 as usize].clone();
      if  cb(it_12, i_19) {
        res_7.push(it_12.clone());
      }
    }
    return res_7;
  }
  pub fn forEach_37(mut self : Vec<RangerCompilerMessage>, cb : ) -> () {
    for i_20 in 0..__self.len() {
      let mut it_13 = __self[i_20 as usize].clone();
      cb(it_13, i_20);
    }
  }
  pub fn map_44(mut self : Vec<RangerAppParamDesc>, cb : ) -> Vec<CodeNode> {
    /** unused:  let __len : i64 = (__self.len() as i64);   **/ 
    let mut res_8 : Vec<CodeNode> = Vec::new();
    for i_23 in 0..__self.len() {
      let mut it_14 = __self[i_23 as usize].clone();
      res_8.push(cb(it_14, i_23));
    }
    return res_8;
  }
  pub fn map_45(mut self : Vec<CodeNode>, cb : ) -> Vec<CodeNode> {
    /** unused:  let len_1 : i64 = (__self.len() as i64);   **/ 
    let mut res_9 : Vec<CodeNode> = Vec::new();
    for i_24 in 0..__self.len() {
      let mut it_15 = __self[i_24 as usize].clone();
      res_9.push(cb(it_15, i_24));
    }
    return res_9;
  }
  pub fn clone_46(mut self : Vec<CodeNode>) -> Vec<CodeNode> {
    let mut res_10 : Vec<CodeNode> = Vec::new();
    for i_25 in 0..__self.len() {
      let mut it_16 = __self[i_25 as usize].clone();
      res_10.push(it_16.clone());
    }
    return res_10;
  }
  pub fn map_47(mut self : Vec<CodeNode>, cb : ) -> Vec<String> {
    /** unused:  let len_2 : i64 = (__self.len() as i64);   **/ 
    let mut res_11 : Vec<String> = Vec::new();
    for i_26 in 0..__self.len() {
      let mut it_17 = __self[i_26 as usize].clone();
      res_11.push(cb(it_17, i_26));
    }
    return res_11;
  }
  pub fn filter_50(mut self : Vec<RangerAppParamDesc>, cb : ) -> Vec<RangerAppParamDesc> {
    let mut res_12 : Vec<RangerAppParamDesc> = Vec::new();
    for i_27 in 0..__self.len() {
      let mut it_18 = __self[i_27 as usize].clone();
      if  cb(it_18, i_27) {
        res_12.push(it_18.clone());
      }
    }
    return res_12;
  }
  pub fn filter_52(mut self : Vec<RangerAppOperatorDesc>, cb : ) -> Vec<RangerAppOperatorDesc> {
    let mut res_13 : Vec<RangerAppOperatorDesc> = Vec::new();
    for i_28 in 0..__self.len() {
      let mut it_19 = __self[i_28 as usize].clone();
      if  cb(it_19, i_28) {
        res_13.push(it_19.clone());
      }
    }
    return res_13;
  }
  pub fn groupBy_53(mut self : Vec<RangerAppOperatorDesc>, cb : ) -> Vec<RangerAppOperatorDesc> {
    let mut res_14 : Vec<RangerAppOperatorDesc> = Vec::new();
    let mut mapper : HashMap<String,bool> = HashMap::new();
    for i_29 in 0..__self.len() {
      let mut it_20 = __self[i_29 as usize].clone();
      let key : String = cb(it_20);
      if  false == (mapper.contains_key(&key)) {
        res_14.push(it_20.clone());
        mapper.insert(key, true);
      }
    }
    return res_14;
  }
  pub fn clone_56(mut self : Vec<String>) -> Vec<String> {
    let mut res_15 : Vec<String> = Vec::new();
    for i_31 in 0..__self.len() {
      let mut it_21 = __self[i_31 as usize].clone();
      res_15.push(it_21);
    }
    return res_15;
  }
}
#[derive(Clone)]
struct operatorsOfInputFSFolder_3 { 
}
impl operatorsOfInputFSFolder_3 { 
  
  pub fn new() ->  operatorsOfInputFSFolder_3 {
    let mut me = operatorsOfInputFSFolder_3 { 
    };
    return me;
  }
  pub fn createc95file_4(mut fs : InputFSFolder, name : String, data : String) -> Option<InputFSFile> {
    let mut f_1 : Option<InputFSFile> = operatorsOf_3::createc95file_5(fs.clone(), name.clone());
    if  f_1.is_some() {
      f_1.data = data.clone();
    }
    return f_1.clone();
  }
}
#[derive(Clone)]
struct operatorsOf_3 { 
}
impl operatorsOf_3 { 
  
  pub fn new() ->  operatorsOf_3 {
    let mut me = operatorsOf_3 { 
    };
    return me;
  }
  pub fn createc95file_5(mut fs : InputFSFolder, name : String) -> Option<InputFSFile> {
    let mut res : Option<InputFSFile> = None;
    let mut files : Vec<InputFSFile> = operatorsOf::filter_6(fs.files, (item, index) => { 
      return item.name == name;
    }
    );
    let mut folders : Vec<InputFSFolder> = operatorsOf::filter_7(fs.folders, (item, index) => { 
      return item.name == name;
    }
    );
    if  false == (((folders.len() as i64)) > 0) {
      if  ((files.len() as i64)) > 0 {
        res = Some(files[0 as usize].clone());
      } else {
        let mut f : InputFSFile = InputFSFile::new();
        f.name = name.clone();
        fs.files.push(f.clone());
        res = Some(f.clone());
      }
    }
    return res.clone();
  }
  pub fn createc95file_4(mut fs : InputFSFolder, name : String, data : String) -> Option<InputFSFile> {
    let mut f_2 : Option<InputFSFile> = operatorsOf_3::createc95file_5(fs.clone(), name.clone());
    if  f_2.is_some() {
      f_2.data = data.clone();
    }
    return f_2.clone();
  }
  pub fn createc95folder_5(mut fs : InputFSFolder, name : String) -> Option<InputFSFolder> {
    let mut res_3 : Option<InputFSFolder> = None;
    let mut files_1 : Vec<InputFSFile> = operatorsOf::filter_6(fs.files, (item, index) => { 
      return item.name == name;
    }
    );
    let mut folders_1 : Vec<InputFSFolder> = operatorsOf::filter_7(fs.folders, (item, index) => { 
      return item.name == name;
    }
    );
    if  false == (((files_1.len() as i64)) > 0) {
      if  ((folders_1.len() as i64)) > 0 {
        res_3 = Some(folders_1[0 as usize].clone());
      } else {
        let mut f_3 : InputFSFolder = InputFSFolder::new();
        f_3.name = name.clone();
        fs.folders.push(f_3.clone());
        res_3 = Some(f_3.clone());
      }
    }
    return res_3.clone();
  }
}
#[derive(Clone)]
struct operatorsOfInputEnv_8 { 
}
impl operatorsOfInputEnv_8 { 
  
  pub fn new() ->  operatorsOfInputEnv_8 {
    let mut me = operatorsOfInputEnv_8 { 
    };
    return me;
  }
  pub fn readc95file_9(mut env : InputEnv, path : String, name : String) -> Option<String> {
    if  env.use_real {
      return r_read_file(&path, &name).clone();
    }
    let mut resStr : Option<String> = None;
    let mut f_4 : Option<InputFSFile> = operatorsOf_8::findc95file_9(env.clone(), path.clone(), name.clone());
    if  f_4.is_some() {
      resStr = Some(f_4.data.clone());
    }
    return resStr.clone();
  }
}
#[derive(Clone)]
struct operatorsOf_8 { 
}
impl operatorsOf_8 { 
  
  pub fn new() ->  operatorsOf_8 {
    let mut me = operatorsOf_8 { 
    };
    return me;
  }
  pub fn findc95file_9(mut env : InputEnv, path : String, name : String) -> Option<InputFSFile> {
    let mut res_4 : Option<InputFSFile> = None;
    if  path == "/".to_string() {
      let mut files_2 : Vec<InputFSFile> = operatorsOf::filter_6(env.filesystem.files, (item, index) => { 
        return item.name == name;
      }
      );
      if  ((files_2.len() as i64)) > 0 {
        res_4 = Some(files_2[0 as usize].clone());
      }
      return res_4.clone();
    }
    let mut parts : Vec<String> = path.split("/".to_string());
    let mut fold : Option<InputFSFolder> = env.filesystem;
    let mut i_3 : i64 = 0;
    while (((parts.len() as i64)) > i_3) && (fold.is_some()) {
      let pathName : String = parts[i_3 as usize].clone();
      if  (pathName.len() as i64) > 0 {
        let mut folder : Vec<InputFSFolder> = operatorsOf::filter_7(fold.folders, (item, index) => { 
          return item.name == pathName;
        }
        );
        if  ((folder.len() as i64)) > 0 {
          fold = folder[0 as usize].clone();
        } else {
          return res_4.clone();
        }
      }
      i_3 = i_3 + 1;
    }
    if  fold.is_some() {
      let mut files_3 : Vec<InputFSFile> = operatorsOf::filter_6(fold.files, (item, index) => { 
        return item.name == name;
      }
      );
      if  ((files_3.len() as i64)) > 0 {
        res_4 = Some(files_3[0 as usize].clone());
      }
    }
    return res_4.clone();
  }
  pub fn readc95file_9(mut env : InputEnv, path : String, name : String) -> Option<String> {
    if  env.use_real {
      return r_read_file(&path, &name).clone();
    }
    let mut resStr_1 : Option<String> = None;
    let mut f_5 : Option<InputFSFile> = operatorsOf_8::findc95file_9(env.clone(), path.clone(), name.clone());
    if  f_5.is_some() {
      resStr_1 = Some(f_5.data.clone());
    }
    return resStr_1.clone();
  }
  pub fn filec95exists_9(mut env : InputEnv, path : String, name : String) -> bool {
    if  env.use_real {
      return file_existspathname;
    }
    let mut fo : Option<InputFSFile> = operatorsOf_8::findc95file_9(env.clone(), path.clone(), name.clone());
    return fo.is_some();
  }
  pub fn installc95directory_51(mut env : InputEnv) -> String {
    if  env.use_real {
      return "./".clone();
    }
    return "/".to_string().clone();
  }
  pub fn envc95var_54(mut env : InputEnv, name : String) -> String {
    if  env.use_real {
      if  env.envVars.contains_key(&name) {
        return (env.envVars.get(name)).unwrap().clone();
      }
      let ev :  = env_varname;
      if!null?ev
      return unwrapev;
      return "".to_string().clone();
    }
    return if ((env.envVars.get(name)).is_some()) { ((env.envVars.get(name)).unwrap()) } else { "".to_string() }.clone();
  }
  pub fn currentc95directory_51(mut env : InputEnv) -> String {
    if  env.use_real {
      return ".".clone();
    }
    return "/".to_string().clone();
  }
}
#[derive(Clone)]
struct operatorsOf_13 { 
}
impl operatorsOf_13 { 
  
  pub fn new() ->  operatorsOf_13 {
    let mut me = operatorsOf_13 { 
    };
    return me;
  }
  pub fn forEach_14(mut self : HashMap<String,RangerAppClassDesc>, cb : ) -> () {
    let list :  = keys__self;
    forlistkki_7let mut value : RangerAppClassDesc = (__self.get(kk)).unwrap();
    cb(value, kk);
  }
  pub fn forEach_16(mut self : HashMap<String,RangerOperatorList>, cb : ) -> () {
    let list_1 :  = keys__self;
    forlist_1kk_1i_9let mut value_1 : RangerOperatorList = (__self.get(kk_1)).unwrap();
    cb(value_1, kk_1);
  }
  pub fn forEach_19(mut self : HashMap<String,OpList>, cb : ) -> () {
    let list_2 :  = keys__self;
    forlist_2kk_2i_12let mut value_2 : OpList = (__self.get(kk_2)).unwrap();
    cb(value_2, kk_2);
  }
  pub fn forEach_20(mut self : HashMap<String,RangerAppParamDesc>, cb : ) -> () {
    let list_3 :  = keys__self;
    forlist_3kk_3i_13let mut value_3 : RangerAppParamDesc = (__self.get(kk_3)).unwrap();
    cb(value_3, kk_3);
  }
  pub fn forEach_25(mut self : HashMap<String,CodeNode>, cb : ) -> () {
    let list_4 :  = keys__self;
    forlist_4kk_4i_14let mut value_4 : CodeNode = (__self.get(kk_4)).unwrap();
    cb(value_4, kk_4);
  }
  pub fn forEach_30(mut self : HashMap<String,RangerAppMethodVariants>, cb : ) -> () {
    let list_5 :  = keys__self;
    forlist_5kk_5i_16let mut value_5 : RangerAppMethodVariants = (__self.get(kk_5)).unwrap();
    cb(value_5, kk_5);
  }
  pub fn forEach_40(mut self : HashMap<String,String>, cb : ) -> () {
    let list_6 :  = keys__self;
    forlist_6kk_6i_22let value_6 : String = (__self.get(kk_6)).unwrap();
    cb(value_6, kk_6);
  }
  pub fn forEach_55(mut self : HashMap<String,bool>, cb : ) -> () {
    let list_7 :  = keys__self;
    forlist_7kk_7i_30let value_7 : bool = (__self.get(kk_7)).unwrap();
    cb(value_7, kk_7);
  }
}
#[derive(Clone)]
struct operatorsOfRangerAppWriterContext_21 { 
}
impl operatorsOfRangerAppWriterContext_21 { 
  
  pub fn new() ->  operatorsOfRangerAppWriterContext_21 {
    let mut me = operatorsOfRangerAppWriterContext_21 { 
    };
    return me;
  }
  pub fn getTargetLang_22(mut self : RangerAppWriterContext) -> String {
    if  (__self.targetLangName.len() as i64) > 0 {
      return __self.targetLangName.clone();
    }
    if __self.parent.is_some() {
      return operatorsOf_21::getTargetLang_22(((*__self.parent.clone().unwrap()))).clone();
    }
    return "ranger".to_string().clone();
  }
}
#[derive(Clone)]
struct operatorsOf_21 { 
}
impl operatorsOf_21 { 
  
  pub fn new() ->  operatorsOf_21 {
    let mut me = operatorsOf_21 { 
    };
    return me;
  }
  pub fn getTargetLang_22(mut self : RangerAppWriterContext) -> String {
    if  (__self.targetLangName.len() as i64) > 0 {
      return __self.targetLangName.clone();
    }
    if __self.parent.is_some() {
      return operatorsOf_21::getTargetLang_22(((*__self.parent.clone().unwrap()))).clone();
    }
    return "ranger".to_string().clone();
  }
  pub fn addUsage_28(mut self : RangerAppWriterContext, mut cn : CodeNode) -> () {
    let mut ctx : RangerAppWriterContext = __self;
    let mut currM : RangerAppFunctionDesc = ctx.getCurrentMethod();
    if  ctx.isDefinedClass(cn.type_name.clone()) {
      let mut cl : RangerAppClassDesc = ctx.findClass(cn.type_name.clone());
      currM.addClassUsage(cl.clone(), ctx.clone());
    }
    if  ctx.isDefinedClass(cn.eval_type_name.clone()) {
      let mut cl_1 : RangerAppClassDesc = ctx.findClass(cn.eval_type_name.clone());
      currM.addClassUsage(cl_1.clone(), ctx.clone());
    }
    if  ctx.isDefinedClass(cn.eval_array_type.clone()) {
      let mut cl_2 : RangerAppClassDesc = ctx.findClass(cn.eval_array_type.clone());
      currM.addClassUsage(cl_2.clone(), ctx.clone());
    }
  }
  pub fn getActiveTransaction_22(mut c : RangerAppWriterContext) -> Option<ContextTransaction> {
    let mut rValue : Option<ContextTransaction> = None;
    if  ((c.activeTransaction.len() as i64)) > 0 {
      rValue = Some(c.activeTransaction[(((c.activeTransaction.len() as i64)) - 1) as usize].clone());
    } else {
      if  c.parent.is_some() {
        return operatorsOf_21::getActiveTransaction_22(((*c.parent.clone().unwrap()))).clone();
      }
    }
    return rValue.clone();
  }
  pub fn createc95var_48(mut self : RangerAppWriterContext, name : String, type_name : String) -> RangerAppParamDesc {
    let mut fieldNode : CodeNode = CodeNode::vref2(name.clone(), type_name.clone());
    fieldNode.value_type = fieldNode.typeNameAsType(__self.clone());
    let mut p_2 : RangerAppParamDesc = RangerAppParamDesc::new();
    p_2.name = name.clone();
    p_2.value_type = fieldNode.value_type;
    p_2.node = Some(fieldNode.clone());
    p_2.nameNode = Some(fieldNode.clone());
    p_2.is_optional = false;
    __self.defineVariable(p_2.name.clone(), p_2.clone());
    return p_2.clone();
  }
  pub fn createc95var_49(mut self : RangerAppWriterContext, name : String, mut usingNode : CodeNode) -> RangerAppParamDesc {
    /** unused:  let mut fieldNode_1 : CodeNode = CodeNode::vref1(name.clone());   **/ 
    let mut p_3 : RangerAppParamDesc = RangerAppParamDesc::new();
    p_3.name = name.clone();
    p_3.value_type = usingNode.value_type;
    p_3.node = Some(usingNode.clone());
    p_3.nameNode = Some(usingNode.clone());
    p_3.is_optional = false;
    __self.defineVariable(p_3.name.clone(), p_3.clone());
    return p_3.clone();
  }
}
#[derive(Clone)]
struct operatorsOfchar_23 { 
}
impl operatorsOfchar_23 { 
  
  pub fn new() ->  operatorsOfchar_23 {
    let mut me = operatorsOfchar_23 { 
    };
    return me;
  }
  pub fn isc95notc95limiter_24(c : u8) -> bool {
    return (((((c > 32) && (c != (59))) && (c != (41))) && (c != (40))) && (c != (125))) && (c != (44));
  }
}
#[derive(Clone)]
struct operatorsOfRangerFlowParser_26 { 
}
impl operatorsOfRangerFlowParser_26 { 
  
  pub fn new() ->  operatorsOfRangerFlowParser_26 {
    let mut me = operatorsOfRangerFlowParser_26 { 
    };
    return me;
  }
  pub fn EnterVarDef_27(mut self : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ctx.isInMethod() {
      if  ((node.children.len() as i64)) < 2 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
        return;
      }
      let mut tName : CodeNode = node.getSecond();
      __self.CheckTypeAnnotationOf(tName.clone(), ctx.clone(), wr.clone());
      if  tName.expression {
        removenode.children1operatorsOf::forEach_15(tName.children, (item, index) => { 
          if  index == 1 {
            if  item.expression {
              node.children.push(((item.children[0 as usize].clone())).copy());
            } else {
              node.children.push(item.copy());
            }
          }
          if  index > 1 {
            node.children.push(item.copy());
          }
        }
        );
      }
      if  ((node.children.len() as i64)) > 3 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
        return;
      }
      let mut cn : CodeNode = node.children[1 as usize].clone();
      let mut p : RangerAppParamDesc = RangerAppParamDesc::new();
      let mut defaultArg : Option<CodeNode> = None;
      let mut is_immutable : bool = false;
      cn.definedTypeClass = Some(TFactory::new_def_signature(cn.clone(), ctx.clone(), wr.clone()));
      if  ((node.children.len() as i64)) == 2 {
        if  (cn.value_type != 6) && (cn.value_type != 7) {
          if==falsecn.hasFlag"unwrap".to_string()cn.setFlag"optional".to_string()
        }
      }
      if  (cn.vref.len() as i64) == 0 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
      }
      if  cn.hasFlag("weak".to_string()) {
        p.changeStrength(0, 1, node.clone());
      } else {
        p.changeStrength(1, 1, node.clone());
      }
      node.hasVarDef = true;
      if  ((node.children.len() as i64)) > 2 {
        p.init_cnt = 1;
        p.def_value = Some(node.children[2 as usize].clone());
        p.is_optional = false;
        defaultArg = Some(node.children[2 as usize].clone());
        ctx.setInExpr();
        __self.WalkNode(defaultArg.unwrap(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        if  defaultArg.hasFlag("optional".to_string()) {
          cn.setFlag("optional".to_string());
        }
        if  defaultArg.hasFlag("immutable".to_string()) {
          cn.setFlag("immutable".to_string());
        }
        if  defaultArg.hasParamDesc {
          let mut paramDesc : RangerAppParamDesc = defaultArg.paramDesc.clone().unwrap();
          if  paramDesc.propertyClass.is_some() {
            if  paramDesc.propertyClass.nameNode.hasFlag("immutable".to_string()) {
              if  (defaultArg.eval_type == 6) || (defaultArg.eval_type == 7) {
                is_immutable = true;
              }
            }
          }
          if  paramDesc.is_immutable {
            is_immutable = true;
          }
        }
        if  defaultArg.eval_type == 6 {
          node.op_index = 1;
        }
        if  cn.value_type == 13 {
          cn.eval_type_name = defaultArg.ns[0 as usize].clone();
        }
        if  cn.value_type == 14 {
          if  (defaultArg.eval_type != 3) && (defaultArg.eval_type != 14) {
            ctx.addError(defaultArg.unwrap(), format!("{}{}", "Char should be assigned char or integer value --> ".to_string(), defaultArg.getCode()));
          } else {
            defaultArg.eval_type = 14;
          }
        }
      } else {
        if  ((cn.value_type != 7) && (cn.value_type != 6)) && (false == cn.hasFlag("optional".to_string())) {
          if  cn.hasFlag("unwrap".to_string()) {
          } else {
            cn.setFlag("optional".to_string());
          }
        }
      }
      if  ((node.children.len() as i64)) > 2 {
        if  ((cn.type_name.len() as i64) == 0) && ((cn.array_type.len() as i64) == 0) {
          cn.inferDefTypeFromValue(node.clone());
          if  cn.value_type == 17 {
            cn.eval_type = 17;
          }
        }
      }
      ctx.hadValidType(cn.clone());
      cn.defineNodeTypeTo(cn.clone(), ctx.clone());
      p.name = cn.vref.clone();
      if  p.value_type == 0 {
        if  (0 == (cn.type_name.len() as i64)) && (defaultArg.is_some()) {
          p.value_type = defaultArg.eval_type;
          cn.type_name = defaultArg.eval_type_name.clone();
          cn.eval_type_name = defaultArg.eval_type_name.clone();
          cn.value_type = defaultArg.eval_type;
        }
      } else {
        p.value_type = cn.value_type;
      }
      p.node = Some(node.clone());
      p.nameNode = Some(cn.clone());
      p.varType = 5;
      if  is_immutable {
        p.is_immutable = is_immutable;
      }
      if  cn.has_vref_annotation {
        ctx.log(node.clone(), "ann".to_string(), "At a variable -> Found has_vref_annotation annotated reference ".to_string());
        let mut ann : Option<CodeNode> = cn.vref_annotation;
        if  ((ann.children.len() as i64)) > 0 {
          let mut fc : CodeNode = ann.children[0 as usize].clone();
          ctx.log(node.clone(), "ann".to_string(), format!("{}{}", (format!("{}{}", (format!("{}{}", "value of first annotation ".to_string(), fc.vref)), " and variable name ".to_string())), cn.vref));
        }
      }
      if  cn.has_type_annotation {
        ctx.log(node.clone(), "ann".to_string(), "At a variable -> Found annotated reference ".to_string());
        let mut ann_1 : Option<CodeNode> = cn.type_annotation;
        if  ((ann_1.children.len() as i64)) > 0 {
          let mut fc_1 : CodeNode = ann_1.children[0 as usize].clone();
          ctx.log(node.clone(), "ann".to_string(), format!("{}{}", (format!("{}{}", (format!("{}{}", "value of first annotation ".to_string(), fc_1.vref)), " and variable name ".to_string())), cn.vref));
        }
      }
      cn.hasParamDesc = true;
      cn.ownParamDesc = Some(p.clone());
      cn.paramDesc = Some(p.clone());
      node.hasParamDesc = true;
      node.paramDesc = Some(p.clone());
      cn.eval_type = cn.typeNameAsType(ctx.clone());
      cn.eval_type_name = cn.type_name.clone();
      if  ((node.children.len() as i64)) > 2 {
        if  (defaultArg.register_name.len() as i64) > 0 {
          let mut rr : RangerAppParamDesc = ctx.getVariableDef(defaultArg.register_name.clone());
          if  rr.nameNode.is_some() {
            if  rr.nameNode.expression_value.is_some() {
              cn.expression_value = Some(Box::new(rr.nameNode.expression_value.copy().clone()));
            }
          }
        }
        if  defaultArg.eval_type == 17 {
          if  defaultArg.expression_value.is_some() {
            cn.expression_value = Some(Box::new(defaultArg.expression_value.copy().clone()));
          } else {
            if  defaultArg.hasParamDesc {
              if  (defaultArg.paramDesc.nameNode.is_some()) && (defaultArg.paramDesc.nameNode.expression_value.is_some()) {
                cn.eval_type = 17;
                cn.expression_value = Some(Box::new(defaultArg.paramDesc.nameNode.expression_value.copy().clone()));
              }
            }
          }
        }
        if  defaultArg.is_some() {
          __self.convertToUnion(cn.eval_type_name.clone(), defaultArg.unwrap(), ctx.clone(), wr.clone());
          if  defaultArg.evalTypeClass.is_some() {
            cn.evalTypeClass = defaultArg.evalTypeClass.clone();
          }
        }
        if  cn.eval_type != defaultArg.eval_type {
          let b1 : bool = (cn.eval_type == 14) && (defaultArg.eval_type == 3);
          let b2 : bool = (cn.eval_type == 3) && (defaultArg.eval_type == 14);
          if  false == (b1 || b2) {
            ctx.addError(node.clone(), [(format!("{}{}", (["Variable was assigned an incompatible type. Types were ".to_string() , (cn.eval_type.to_string()) ].join("")), " vs ".to_string())) , (defaultArg.eval_type.to_string()) ].join(""));
          }
        }
      } else {
        p.is_optional = true;
      }
      ctx.defineVariable(p.name.clone(), p.clone());
      if  ((node.children.len() as i64)) > 2 {
        __self.shouldBeEqualTypes(cn.clone(), p.def_value.clone().unwrap(), ctx.clone(), "Variable was assigned an incompatible type.".to_string());
      }
      operatorsOf_21::addUsage_28(ctx.clone(), cn.clone());
    } else {
      let mut cn_1 : CodeNode = node.children[1 as usize].clone();
      cn_1.eval_type = cn_1.typeNameAsType(ctx.clone());
      cn_1.eval_type_name = cn_1.type_name.clone();
      if  ((node.children.len() as i64)) > 2 {
        __self.shouldBeEqualTypes(node.children[1 as usize].clone(), node.children[2 as usize].clone(), ctx.clone(), "Variable was assigned an incompatible type.".to_string());
      }
    }
  }
}
#[derive(Clone)]
struct operatorsOf_26 { 
}
impl operatorsOf_26 { 
  
  pub fn new() ->  operatorsOf_26 {
    let mut me = operatorsOf_26 { 
    };
    return me;
  }
  pub fn EnterVarDef_27(mut self : RangerFlowParser, mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> () {
    if  ctx.isInMethod() {
      if  ((node.children.len() as i64)) < 2 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
        return;
      }
      let mut tName_1 : CodeNode = node.getSecond();
      __self.CheckTypeAnnotationOf(tName_1.clone(), ctx.clone(), wr.clone());
      if  tName_1.expression {
        removenode.children1operatorsOf::forEach_15(tName_1.children, (item, index) => { 
          if  index == 1 {
            if  item.expression {
              node.children.push(((item.children[0 as usize].clone())).copy());
            } else {
              node.children.push(item.copy());
            }
          }
          if  index > 1 {
            node.children.push(item.copy());
          }
        }
        );
      }
      if  ((node.children.len() as i64)) > 3 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
        return;
      }
      let mut cn_2 : CodeNode = node.children[1 as usize].clone();
      let mut p_1 : RangerAppParamDesc = RangerAppParamDesc::new();
      let mut defaultArg_1 : Option<CodeNode> = None;
      let mut is_immutable_1 : bool = false;
      cn_2.definedTypeClass = Some(TFactory::new_def_signature(cn_2.clone(), ctx.clone(), wr.clone()));
      if  ((node.children.len() as i64)) == 2 {
        if  (cn_2.value_type != 6) && (cn_2.value_type != 7) {
          if==falsecn.hasFlag"unwrap".to_string()cn.setFlag"optional".to_string()
        }
      }
      if  (cn_2.vref.len() as i64) == 0 {
        ctx.addError(node.clone(), "invalid variable definition".to_string());
      }
      if  cn_2.hasFlag("weak".to_string()) {
        p_1.changeStrength(0, 1, node.clone());
      } else {
        p_1.changeStrength(1, 1, node.clone());
      }
      node.hasVarDef = true;
      if  ((node.children.len() as i64)) > 2 {
        p_1.init_cnt = 1;
        p_1.def_value = Some(node.children[2 as usize].clone());
        p_1.is_optional = false;
        defaultArg_1 = Some(node.children[2 as usize].clone());
        ctx.setInExpr();
        __self.WalkNode(defaultArg_1.unwrap(), ctx.clone(), wr.clone());
        ctx.unsetInExpr();
        if  defaultArg_1.hasFlag("optional".to_string()) {
          cn_2.setFlag("optional".to_string());
        }
        if  defaultArg_1.hasFlag("immutable".to_string()) {
          cn_2.setFlag("immutable".to_string());
        }
        if  defaultArg_1.hasParamDesc {
          let mut paramDesc_1 : RangerAppParamDesc = defaultArg_1.paramDesc.clone().unwrap();
          if  paramDesc_1.propertyClass.is_some() {
            if  paramDesc_1.propertyClass.nameNode.hasFlag("immutable".to_string()) {
              if  (defaultArg_1.eval_type == 6) || (defaultArg_1.eval_type == 7) {
                is_immutable_1 = true;
              }
            }
          }
          if  paramDesc_1.is_immutable {
            is_immutable_1 = true;
          }
        }
        if  defaultArg_1.eval_type == 6 {
          node.op_index = 1;
        }
        if  cn_2.value_type == 13 {
          cn_2.eval_type_name = defaultArg_1.ns[0 as usize].clone();
        }
        if  cn_2.value_type == 14 {
          if  (defaultArg_1.eval_type != 3) && (defaultArg_1.eval_type != 14) {
            ctx.addError(defaultArg_1.unwrap(), format!("{}{}", "Char should be assigned char or integer value --> ".to_string(), defaultArg_1.getCode()));
          } else {
            defaultArg_1.eval_type = 14;
          }
        }
      } else {
        if  ((cn_2.value_type != 7) && (cn_2.value_type != 6)) && (false == cn_2.hasFlag("optional".to_string())) {
          if  cn_2.hasFlag("unwrap".to_string()) {
          } else {
            cn_2.setFlag("optional".to_string());
          }
        }
      }
      if  ((node.children.len() as i64)) > 2 {
        if  ((cn_2.type_name.len() as i64) == 0) && ((cn_2.array_type.len() as i64) == 0) {
          cn_2.inferDefTypeFromValue(node.clone());
          if  cn_2.value_type == 17 {
            cn_2.eval_type = 17;
          }
        }
      }
      ctx.hadValidType(cn_2.clone());
      cn_2.defineNodeTypeTo(cn_2.clone(), ctx.clone());
      p_1.name = cn_2.vref.clone();
      if  p_1.value_type == 0 {
        if  (0 == (cn_2.type_name.len() as i64)) && (defaultArg_1.is_some()) {
          p_1.value_type = defaultArg_1.eval_type;
          cn_2.type_name = defaultArg_1.eval_type_name.clone();
          cn_2.eval_type_name = defaultArg_1.eval_type_name.clone();
          cn_2.value_type = defaultArg_1.eval_type;
        }
      } else {
        p_1.value_type = cn_2.value_type;
      }
      p_1.node = Some(node.clone());
      p_1.nameNode = Some(cn_2.clone());
      p_1.varType = 5;
      if  is_immutable_1 {
        p_1.is_immutable = is_immutable_1;
      }
      if  cn_2.has_vref_annotation {
        ctx.log(node.clone(), "ann".to_string(), "At a variable -> Found has_vref_annotation annotated reference ".to_string());
        let mut ann_2 : Option<CodeNode> = cn_2.vref_annotation;
        if  ((ann_2.children.len() as i64)) > 0 {
          let mut fc_2 : CodeNode = ann_2.children[0 as usize].clone();
          ctx.log(node.clone(), "ann".to_string(), format!("{}{}", (format!("{}{}", (format!("{}{}", "value of first annotation ".to_string(), fc_2.vref)), " and variable name ".to_string())), cn_2.vref));
        }
      }
      if  cn_2.has_type_annotation {
        ctx.log(node.clone(), "ann".to_string(), "At a variable -> Found annotated reference ".to_string());
        let mut ann_3 : Option<CodeNode> = cn_2.type_annotation;
        if  ((ann_3.children.len() as i64)) > 0 {
          let mut fc_3 : CodeNode = ann_3.children[0 as usize].clone();
          ctx.log(node.clone(), "ann".to_string(), format!("{}{}", (format!("{}{}", (format!("{}{}", "value of first annotation ".to_string(), fc_3.vref)), " and variable name ".to_string())), cn_2.vref));
        }
      }
      cn_2.hasParamDesc = true;
      cn_2.ownParamDesc = Some(p_1.clone());
      cn_2.paramDesc = Some(p_1.clone());
      node.hasParamDesc = true;
      node.paramDesc = Some(p_1.clone());
      cn_2.eval_type = cn_2.typeNameAsType(ctx.clone());
      cn_2.eval_type_name = cn_2.type_name.clone();
      if  ((node.children.len() as i64)) > 2 {
        if  (defaultArg_1.register_name.len() as i64) > 0 {
          let mut rr_1 : RangerAppParamDesc = ctx.getVariableDef(defaultArg_1.register_name.clone());
          if  rr_1.nameNode.is_some() {
            if  rr_1.nameNode.expression_value.is_some() {
              cn_2.expression_value = Some(Box::new(rr_1.nameNode.expression_value.copy().clone()));
            }
          }
        }
        if  defaultArg_1.eval_type == 17 {
          if  defaultArg_1.expression_value.is_some() {
            cn_2.expression_value = Some(Box::new(defaultArg_1.expression_value.copy().clone()));
          } else {
            if  defaultArg_1.hasParamDesc {
              if  (defaultArg_1.paramDesc.nameNode.is_some()) && (defaultArg_1.paramDesc.nameNode.expression_value.is_some()) {
                cn_2.eval_type = 17;
                cn_2.expression_value = Some(Box::new(defaultArg_1.paramDesc.nameNode.expression_value.copy().clone()));
              }
            }
          }
        }
        if  defaultArg_1.is_some() {
          __self.convertToUnion(cn_2.eval_type_name.clone(), defaultArg_1.unwrap(), ctx.clone(), wr.clone());
          if  defaultArg_1.evalTypeClass.is_some() {
            cn_2.evalTypeClass = defaultArg_1.evalTypeClass.clone();
          }
        }
        if  cn_2.eval_type != defaultArg_1.eval_type {
          let b1_1 : bool = (cn_2.eval_type == 14) && (defaultArg_1.eval_type == 3);
          let b2_1 : bool = (cn_2.eval_type == 3) && (defaultArg_1.eval_type == 14);
          if  false == (b1_1 || b2_1) {
            ctx.addError(node.clone(), [(format!("{}{}", (["Variable was assigned an incompatible type. Types were ".to_string() , (cn_2.eval_type.to_string()) ].join("")), " vs ".to_string())) , (defaultArg_1.eval_type.to_string()) ].join(""));
          }
        }
      } else {
        p_1.is_optional = true;
      }
      ctx.defineVariable(p_1.name.clone(), p_1.clone());
      if  ((node.children.len() as i64)) > 2 {
        __self.shouldBeEqualTypes(cn_2.clone(), p_1.def_value.clone().unwrap(), ctx.clone(), "Variable was assigned an incompatible type.".to_string());
      }
      operatorsOf_21::addUsage_28(ctx.clone(), cn_2.clone());
    } else {
      let mut cn_3 : CodeNode = node.children[1 as usize].clone();
      cn_3.eval_type = cn_3.typeNameAsType(ctx.clone());
      cn_3.eval_type_name = cn_3.type_name.clone();
      if  ((node.children.len() as i64)) > 2 {
        __self.shouldBeEqualTypes(node.children[1 as usize].clone(), node.children[2 as usize].clone(), ctx.clone(), "Variable was assigned an incompatible type.".to_string());
      }
    }
  }
}
#[derive(Clone)]
struct operatorsOfstring_33 { 
}
impl operatorsOfstring_33 { 
  
  pub fn new() ->  operatorsOfstring_33 {
    let mut me = operatorsOfstring_33 { 
    };
    return me;
  }
  pub fn transactionc95depth_34(name : String, mut c : RangerAppWriterContext) -> i64 {
    let mut t : Option<ContextTransaction> = operatorsOf_21::getActiveTransaction_22(c.clone());
    let mut d : i64 = 0;
    while t.is_some() {
      if  t.name == name {
        d = d + 1;
      }
      t = t.parent.clone();
    }
    return d;
  }
}
#[derive(Clone)]
struct operatorsOf_33 { 
}
impl operatorsOf_33 { 
  
  pub fn new() ->  operatorsOf_33 {
    let mut me = operatorsOf_33 { 
    };
    return me;
  }
  pub fn startc95transaction_35(name : String, desc : String, mut c : RangerAppWriterContext) -> ContextTransaction {
    let mut t_1 : ContextTransaction = ContextTransaction::new();
    t_1.name = name.clone();
    t_1.desc = desc.clone();
    t_1.ctx = Some(c.clone());
    let mut currC : Option<ContextTransaction> = operatorsOf_21::getActiveTransaction_22(c.clone());
    c.activeTransaction.push(t_1.clone());
    c.transactions.push(t_1.clone());
    if  currC.is_some() {
      currC.children.push(t_1.clone());
      t_1.parent = Some(Box::new(currC.clone()));
    }
    return t_1.clone();
  }
  pub fn transactionc95depth_34(name : String, mut c : RangerAppWriterContext) -> i64 {
    let mut t_2 : Option<ContextTransaction> = operatorsOf_21::getActiveTransaction_22(c.clone());
    let mut d_1 : i64 = 0;
    while t_2.is_some() {
      if  t_2.name == name {
        d_1 = d_1 + 1;
      }
      t_2 = t_2.parent.clone();
    }
    return d_1;
  }
}
#[derive(Clone)]
struct operatorsOfContextTransaction_38 { 
}
impl operatorsOfContextTransaction_38 { 
  
  pub fn new() ->  operatorsOfContextTransaction_38 {
    let mut me = operatorsOfContextTransaction_38 { 
    };
    return me;
  }
  pub fn endc95transaction_39(mut t : ContextTransaction) -> () {
    let mut c : RangerAppWriterContext = t.ctx.clone().unwrap();
    let i_21 : i64 = c.activeTransaction.iter().position( |&r| r == t ).unwrap();
    if  i_21 >= 0 {
      removec.activeTransactioni
    }
    t.ended = true;
  }
}
#[derive(Clone)]
struct operatorsOfCodeNode_41 { 
}
impl operatorsOfCodeNode_41 { 
  
  pub fn new() ->  operatorsOfCodeNode_41 {
    let mut me = operatorsOfCodeNode_41 { 
    };
    return me;
  }
  pub fn rc46funcdesc_42(mut node : CodeNode, mut ctx : RangerAppWriterContext) -> RangerAppFunctionDesc {
    let mut m : RangerAppFunctionDesc = RangerAppFunctionDesc::new();
    let mut cn_4 : CodeNode = node.getSecond();
    m.name = cn_4.vref.clone();
    m.compiledName = ctx.transformWord(cn_4.vref.clone());
    m.node = Some(node.clone());
    m.nameNode = Some(node.children[1 as usize].clone());
    if  node.hasBooleanProperty("strong".to_string()) {
      m.refType = 2;
    } else {
      m.refType = 1;
    }
    return m.clone();
  }
}
#[derive(Clone)]
struct operatorsOf_41 { 
}
impl operatorsOf_41 { 
  
  pub fn new() ->  operatorsOf_41 {
    let mut me = operatorsOf_41 { 
    };
    return me;
  }
  pub fn rc46func_43(mut node : CodeNode, mut ctx : RangerAppWriterContext, mut wr : CodeWriter) -> RangerAppFunctionDesc {
    let mut parser : RangerFlowParser = RangerFlowParser::new();
    return parser.CreateFunctionObject(node.clone(), ctx.clone(), wr.clone()).clone();
  }
}
#[derive(Clone)]
struct operatorsOfJSONArrayObject_57 { 
}
impl operatorsOfJSONArrayObject_57 { 
  
  pub fn new() ->  operatorsOfJSONArrayObject_57 {
    let mut me = operatorsOfJSONArrayObject_57 { 
    };
    return me;
  }
  pub fn forEach_58(mut self : JSONArrayObject, cb : ) -> () {
    let mut cnt : i64 = __self.len() as i64;
    let mut i_32 : i64 = 0;
    while cnt > 0 {
      let mut value_8 : JSONValueUnion = __self[i_32 as usize].clone();
      cb(value_8, i_32);
      cnt = cnt - 1;
      i_32 = i_32 + 1;
    }
  }
}
#[derive(Clone)]
struct operatorsOf_57 { 
}
impl operatorsOf_57 { 
  
  pub fn new() ->  operatorsOf_57 {
    let mut me = operatorsOf_57 { 
    };
    return me;
  }
  pub fn forEach_58(mut self : JSONArrayObject, cb : ) -> () {
    let mut cnt_1 : i64 = __self.len() as i64;
    let mut i_33 : i64 = 0;
    while cnt_1 > 0 {
      let mut value_9 : JSONValueUnion = __self[i_33 as usize].clone();
      cb(value_9, i_33);
      cnt_1 = cnt_1 - 1;
      i_33 = i_33 + 1;
    }
  }
}

fn r_write_file(path: &str, filename: &str, data: &str) {
    let full_path = format!("{}/{}", path, filename);
    let _ = std::fs::write(full_path, data);
}


fn r_read_file(path: &str, filename: &str) -> Option<String> {
    let full_path = format!("{}/{}", path, filename);
    std::fs::read_to_string(full_path).ok()
}

