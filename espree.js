(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.espree = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ /* eslint no-undefined:0, no-use-before-define: 0 */ "use strict"; var astNodeTypes = require("./lib/ast-node-types"), commentAttachment = require("./lib/comment-attachment"), TokenTranslator = require("./lib/token-translator"), acornJSX = require("acorn-jsx/inject"), rawAcorn = require("acorn"); var acorn = acornJSX(rawAcorn); var lookahead, extra, lastToken; /** * Resets the extra object to its default. * @returns {void} * @private */ function resetExtra() { extra = { tokens: null, range: false, loc: false, comment: false, comments: [], tolerant: false, errors: [], strict: false, ecmaFeatures: {}, ecmaVersion: 5, isModule: false }; } var tt = acorn.tokTypes, Parser = acorn.Parser, pp = Parser.prototype, getLineInfo = acorn.getLineInfo; // custom type for JSX attribute values tt.jsxAttrValueToken = {}; /** * Determines if a node is valid given the set of ecmaFeatures. * @param {ASTNode} node The node to check. * @returns {boolean} True if the node is allowed, false if not. * @private */ function isValidNode(node) { var ecma = extra.ecmaFeatures; switch (node.type) { case "Identifier": return !extra.isModule || node.name !== "await"; case "ExperimentalSpreadProperty": case "ExperimentalRestProperty": return ecma.experimentalObjectRestSpread; case "ImportDeclaration": case "ExportNamedDeclaration": case "ExportDefaultDeclaration": case "ExportAllDeclaration": return extra.isModule; default: return true; } } /** * Performs last-minute Esprima-specific compatibility checks and fixes. * @param {ASTNode} result The node to check. * @returns {ASTNode} The finished node. * @private * @this acorn.Parser */ function esprimaFinishNode(result) { // ensure that parsed node was allowed through ecmaFeatures if (!isValidNode(result)) { this.unexpected(result.start); } // https://github.com/marijnh/acorn/issues/323 if (result.type === "TryStatement") { delete result.guardedHandlers; } else if (result.type === "CatchClause") { delete result.guard; } // Acorn doesn't count the opening and closing backticks as part of templates // so we have to adjust ranges/locations appropriately. if (result.type === "TemplateElement") { // additional adjustment needed if ${ is the last token var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${"; if (result.range) { result.range[0]--; result.range[1] += (terminalDollarBraceL ? 2 : 1); } if (result.loc) { result.loc.start.column--; result.loc.end.column += (terminalDollarBraceL ? 2 : 1); } } // Acorn currently uses expressions instead of declarations in default exports if (result.type === "ExportDefaultDeclaration") { if (/^(Class|Function)Expression$/.test(result.declaration.type)) { result.declaration.type = result.declaration.type.replace("Expression", "Declaration"); } } // Acorn uses undefined instead of null, which affects serialization if (result.type === "Literal" && result.value === undefined) { result.value = null; } if (extra.attachComment) { commentAttachment.processComment(result); } if (result.type.indexOf("Function") > -1 && !result.generator) { result.generator = false; } return result; } /** * Determines if a token is valid given the set of ecmaFeatures. * @param {acorn.Parser} parser The parser to check. * @returns {boolean} True if the token is allowed, false if not. * @private */ function isValidToken(parser) { var ecma = extra.ecmaFeatures; var type = parser.type; switch (type) { case tt.jsxName: case tt.jsxText: case tt.jsxTagStart: case tt.jsxTagEnd: return ecma.jsx; // https://github.com/ternjs/acorn/issues/363 case tt.regexp: if (extra.ecmaVersion < 6 && parser.value.flags && parser.value.flags.indexOf("y") > -1) { return false; } return true; default: return true; } } /** * Injects esprimaFinishNode into the finishNode process. * @param {Function} finishNode Original finishNode function. * @returns {ASTNode} The finished node. * @private */ function wrapFinishNode(finishNode) { return /** @this acorn.Parser */ function(node, type, pos, loc) { var result = finishNode.call(this, node, type, pos, loc); return esprimaFinishNode.call(this, result); }; } pp.extend("finishNode", wrapFinishNode); pp.extend("finishNodeAt", wrapFinishNode); pp.extend("next", function(next) { return /** @this acorn.Parser */ function() { if (!isValidToken(this)) { this.unexpected(); } return next.call(this); }; }); // needed for experimental object rest/spread pp.extend("checkLVal", function(checkLVal) { return /** @this acorn.Parser */ function(expr, isBinding, checkClashes) { if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") { for (var i = 0; i < expr.properties.length; i++) { if (expr.properties[i].type.indexOf("Experimental") === -1) { this.checkLVal(expr.properties[i].value, isBinding, checkClashes); } } return undefined; } return checkLVal.call(this, expr, isBinding, checkClashes); }; }); /** * Method to parse an object rest or object spread. * @returns {ASTNode} The node representing object rest or object spread. * @this acorn.Parser */ pp.parseObjectRest = function() { var node = this.startNode(); this.next(); node.argument = this.parseIdent(); return this.finishNode(node, "ExperimentalRestProperty"); }; /** * Method to parse an object with object rest or object spread. * @param {boolean} isPattern True if the object is a destructuring pattern. * @param {Object} refShorthandDefaultPos ? * @returns {ASTNode} The node representing object rest or object spread. * @this acorn.Parser */ pp.parseObj = function(isPattern, refShorthandDefaultPos) { var node = this.startNode(), first = true, propHash = {}; node.properties = []; this.next(); while (!this.eat(tt.braceR)) { if (!first) { this.expect(tt.comma); if (this.afterTrailingComma(tt.braceR)) { break; } } else { first = false; } var prop = this.startNode(), isGenerator, startPos, startLoc; if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) { if (isPattern) { prop = this.parseObjectRest(); } else { prop = this.parseSpread(); prop.type = "ExperimentalSpreadProperty"; } node.properties.push(prop); continue; } if (this.options.ecmaVersion >= 6) { prop.method = false; prop.shorthand = false; if (isPattern || refShorthandDefaultPos) { startPos = this.start; startLoc = this.startLoc; } if (!isPattern) { isGenerator = this.eat(tt.star); } } this.parsePropertyName(prop); this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos); this.checkPropClash(prop, propHash); node.properties.push(this.finishNode(prop, "Property")); } return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression"); }; /** * Overwrites the default raise method to throw Esprima-style errors. * @param {int} pos The position of the error. * @param {string} message The error message. * @throws {SyntaxError} A syntax error. * @returns {void} */ pp.raise = function(pos, message) { var loc = getLineInfo(this.input, pos); var err = new SyntaxError(message); err.index = pos; err.lineNumber = loc.line; err.column = loc.column + 1; // acorn uses 0-based columns throw err; }; /** * Overwrites the default unexpected method to throw Esprima-style errors. * @param {int} pos The position of the error. * @throws {SyntaxError} A syntax error. * @returns {void} */ pp.unexpected = function(pos) { var message = "Unexpected token"; if (pos !== null && pos !== undefined) { this.pos = pos; if (this.options.locations) { while (this.pos < this.lineStart) { this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1; --this.curLine; } } this.nextToken(); } if (this.end > this.start) { message += " " + this.input.slice(this.start, this.end); } this.raise(this.start, message); }; /* * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX * uses regular tt.string without any distinction between this and regular JS * strings. As such, we intercept an attempt to read a JSX string and set a flag * on extra so that when tokens are converted, the next token will be switched * to JSXText via onToken. */ pp.extend("jsx_readString", function(jsxReadString) { return /** @this acorn.Parser */ function(quote) { var result = jsxReadString.call(this, quote); if (this.type === tt.string) { extra.jsxAttrValueToken = true; } return result; }; }); //------------------------------------------------------------------------------ // Tokenizer //------------------------------------------------------------------------------ /** * Tokenizes the given code. * @param {string} code The code to tokenize. * @param {Object} options Options defining how to tokenize. * @returns {Token[]} An array of tokens. * @throws {SyntaxError} If the input code is invalid. * @private */ function tokenize(code, options) { var toString, tokens, translator = new TokenTranslator(tt, code); toString = String; if (typeof code !== "string" && !(code instanceof String)) { code = toString(code); } lookahead = null; // Options matching. options = options || {}; var acornOptions = { ecmaVersion: 5 }; resetExtra(); // Of course we collect tokens here. options.tokens = true; extra.tokens = []; extra.range = (typeof options.range === "boolean") && options.range; acornOptions.ranges = extra.range; extra.loc = (typeof options.loc === "boolean") && options.loc; acornOptions.locations = extra.loc; extra.comment = typeof options.comment === "boolean" && options.comment; if (extra.comment) { acornOptions.onComment = function() { var comment = convertAcornCommentToEsprimaComment.apply(this, arguments); extra.comments.push(comment); }; } extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant; if (typeof options.ecmaVersion === "number") { switch (options.ecmaVersion) { case 3: case 5: case 6: acornOptions.ecmaVersion = options.ecmaVersion; extra.ecmaVersion = options.ecmaVersion; break; default: throw new Error("ecmaVersion must be 3, 5, or 6."); } } // apply parsing flags if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") { extra.ecmaFeatures = options.ecmaFeatures; } try { var tokenizer = acorn.tokenizer(code, acornOptions); while ((lookahead = tokenizer.getToken()).type !== tt.eof) { translator.onToken(lookahead, extra); } // filterTokenLocation(); tokens = extra.tokens; if (extra.comment) { tokens.comments = extra.comments; } if (extra.tolerant) { tokens.errors = extra.errors; } } catch (e) { throw e; } return tokens; } //------------------------------------------------------------------------------ // Parser //------------------------------------------------------------------------------ /** * Converts an Acorn comment to a Esprima comment. * @param {boolean} block True if it's a block comment, false if not. * @param {string} text The text of the comment. * @param {int} start The index at which the comment starts. * @param {int} end The index at which the comment ends. * @param {Location} startLoc The location at which the comment starts. * @param {Location} endLoc The location at which the comment ends. * @returns {Object} The comment object. * @private */ function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) { var comment = { type: block ? "Block" : "Line", value: text }; if (typeof start === "number") { comment.start = start; comment.end = end; comment.range = [start, end]; } if (typeof startLoc === "object") { comment.loc = { start: startLoc, end: endLoc }; } return comment; } /** * Parses the given code. * @param {string} code The code to tokenize. * @param {Object} options Options defining how to tokenize. * @returns {ASTNode} The "Program" AST node. * @throws {SyntaxError} If the input code is invalid. * @private */ function parse(code, options) { var program, toString = String, translator, acornOptions = { ecmaVersion: 5 }; if (typeof code !== "string" && !(code instanceof String)) { code = toString(code); } resetExtra(); commentAttachment.reset(); if (typeof options !== "undefined") { extra.range = (typeof options.range === "boolean") && options.range; extra.loc = (typeof options.loc === "boolean") && options.loc; extra.attachComment = (typeof options.attachComment === "boolean") && options.attachComment; if (extra.loc && options.source !== null && options.source !== undefined) { extra.source = toString(options.source); } if (typeof options.tokens === "boolean" && options.tokens) { extra.tokens = []; translator = new TokenTranslator(tt, code); } if (typeof options.comment === "boolean" && options.comment) { extra.comment = true; extra.comments = []; } if (typeof options.tolerant === "boolean" && options.tolerant) { extra.errors = []; } if (extra.attachComment) { extra.range = true; extra.comments = []; commentAttachment.reset(); } if (typeof options.ecmaVersion === "number") { switch (options.ecmaVersion) { case 3: case 5: case 6: acornOptions.ecmaVersion = options.ecmaVersion; extra.ecmaVersion = options.ecmaVersion; break; default: throw new Error("ecmaVersion must be 3, 5, or 6."); } } if (options.sourceType === "module") { extra.isModule = true; // modules must be in 6 at least if (acornOptions.ecmaVersion < 6) { acornOptions.ecmaVersion = 6; extra.ecmaVersion = 6; } acornOptions.sourceType = "module"; } // apply parsing flags after sourceType to allow overriding if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") { extra.ecmaFeatures = options.ecmaFeatures; if (options.ecmaFeatures.globalReturn) { acornOptions.allowReturnOutsideFunction = true; } } acornOptions.onToken = function(token) { if (extra.tokens) { translator.onToken(token, extra); } if (token.type !== tt.eof) { lastToken = token; } }; if (extra.attachComment || extra.comment) { acornOptions.onComment = function() { var comment = convertAcornCommentToEsprimaComment.apply(this, arguments); extra.comments.push(comment); if (extra.attachComment) { commentAttachment.addComment(comment); } }; } if (extra.range) { acornOptions.ranges = true; } if (extra.loc) { acornOptions.locations = true; } if (extra.ecmaFeatures.jsx) { acornOptions.plugins = { jsx: true }; } } program = acorn.parse(code, acornOptions); program.sourceType = extra.isModule ? "module" : "script"; if (extra.comment || extra.attachComment) { program.comments = extra.comments; } if (extra.tokens) { program.tokens = extra.tokens; } /* * Adjust opening and closing position of program to match Esprima. * Acorn always starts programs at range 0 whereas Esprima starts at the * first AST node's start (the only real difference is when there's leading * whitespace or leading comments). Acorn also counts trailing whitespace * as part of the program whereas Esprima only counts up to the last token. */ if (program.range) { program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0]; program.range[1] = lastToken.range[1]; } if (program.loc) { program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start; program.loc.end = lastToken.loc.end; } return program; } //------------------------------------------------------------------------------ // Public //------------------------------------------------------------------------------ exports.version = require("./package.json").version; exports.tokenize = tokenize; exports.parse = parse; // Deep copy. /* istanbul ignore next */ exports.Syntax = (function() { var name, types = {}; if (typeof Object.create === "function") { types = Object.create(null); } for (name in astNodeTypes) { if (astNodeTypes.hasOwnProperty(name)) { types[name] = astNodeTypes[name]; } } if (typeof Object.freeze === "function") { Object.freeze(types); } return types; }()); /* istanbul ignore next */ exports.VisitorKeys = (function() { var visitorKeys = require("./lib/visitor-keys"); var name, keys = {}; if (typeof Object.create === "function") { keys = Object.create(null); } for (name in visitorKeys) { if (visitorKeys.hasOwnProperty(name)) { keys[name] = visitorKeys[name]; } } if (typeof Object.freeze === "function") { Object.freeze(keys); } return keys; }()); },{"./lib/ast-node-types":2,"./lib/comment-attachment":3,"./lib/token-translator":4,"./lib/visitor-keys":5,"./package.json":8,"acorn":9,"acorn-jsx/inject":6}],2:[function(require,module,exports){ /** * @fileoverview The AST node types produced by the parser. * @author Nicholas C. Zakas * @copyright 2014 Nicholas C. Zakas. All rights reserved. * @copyright 2011-2013 Ariya Hidayat * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ "use strict"; //------------------------------------------------------------------------------ // Requirements //------------------------------------------------------------------------------ // None! //------------------------------------------------------------------------------ // Public //------------------------------------------------------------------------------ module.exports = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExperimentalRestProperty: "ExperimentalRestProperty", ExperimentalSpreadProperty: "ExperimentalSpreadProperty", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression", JSXIdentifier: "JSXIdentifier", JSXNamespacedName: "JSXNamespacedName", JSXMemberExpression: "JSXMemberExpression", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXElement: "JSXElement", JSXClosingElement: "JSXClosingElement", JSXOpeningElement: "JSXOpeningElement", JSXAttribute: "JSXAttribute", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportAllDeclaration: "ExportAllDeclaration", ExportSpecifier: "ExportSpecifier", ImportDeclaration: "ImportDeclaration", ImportSpecifier: "ImportSpecifier", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier" }; },{}],3:[function(require,module,exports){ /** * @fileoverview Attaches comments to the AST. * @author Nicholas C. Zakas * @copyright 2015 Nicholas C. Zakas. All rights reserved. * @copyright 2011-2013 Ariya Hidayat * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ "use strict"; //------------------------------------------------------------------------------ // Requirements //------------------------------------------------------------------------------ var astNodeTypes = require("./ast-node-types"); //------------------------------------------------------------------------------ // Private //------------------------------------------------------------------------------ var extra = { trailingComments: [], leadingComments: [], bottomRightStack: [] }; //------------------------------------------------------------------------------ // Public //------------------------------------------------------------------------------ module.exports = { reset: function() { extra.trailingComments = []; extra.leadingComments = []; extra.bottomRightStack = []; }, addComment: function(comment) { extra.trailingComments.push(comment); extra.leadingComments.push(comment); }, processComment: function(node) { var lastChild, trailingComments, i; if (node.type === astNodeTypes.Program) { if (node.body.length > 0) { return; } } if (extra.trailingComments.length > 0) { /* * If the first comment in trailingComments comes after the * current node, then we're good - all comments in the array will * come after the node and so it's safe to add then as official * trailingComments. */ if (extra.trailingComments[0].range[0] >= node.range[1]) { trailingComments = extra.trailingComments; extra.trailingComments = []; } else { /* * Otherwise, if the first comment doesn't come after the * current node, that means we have a mix of leading and trailing * comments in the array and that leadingComments contains the * same items as trailingComments. Reset trailingComments to * zero items and we'll handle this by evaluating leadingComments * later. */ extra.trailingComments.length = 0; } } else { if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) { trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments; delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments; } } // Eating the stack. while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) { lastChild = extra.bottomRightStack.pop(); } if (lastChild) { if (lastChild.leadingComments) { if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) { node.leadingComments = lastChild.leadingComments; delete lastChild.leadingComments; } else { // A leading comment for an anonymous class had been stolen by its first MethodDefinition, // so this takes back the leading comment. // See Also: https://github.com/eslint/espree/issues/158 for (i = lastChild.leadingComments.length - 2; i >= 0; --i) { if (lastChild.leadingComments[i].range[1] <= node.range[0]) { node.leadingComments = lastChild.leadingComments.splice(0, i + 1); break; } } } } } else if (extra.leadingComments.length > 0) { if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) { node.leadingComments = extra.leadingComments; extra.leadingComments = []; } else { // https://github.com/eslint/espree/issues/2 /* * In special cases, such as return (without a value) and * debugger, all comments will end up as leadingComments and * will otherwise be eliminated. This extra step runs when the * bottomRightStack is empty and there are comments left * in leadingComments. * * This loop figures out the stopping point between the actual * leading and trailing comments by finding the location of the * first comment that comes after the given node. */ for (i = 0; i < extra.leadingComments.length; i++) { if (extra.leadingComments[i].range[1] > node.range[0]) { break; } } /* * Split the array based on the location of the first comment * that comes after the node. Keep in mind that this could * result in an empty array, and if so, the array must be * deleted. */ node.leadingComments = extra.leadingComments.slice(0, i); if (node.leadingComments.length === 0) { delete node.leadingComments; } /* * Similarly, trailing comments are attached later. The variable * must be reset to null if there are no trailing comments. */ trailingComments = extra.leadingComments.slice(i); if (trailingComments.length === 0) { trailingComments = null; } } } if (trailingComments) { node.trailingComments = trailingComments; } extra.bottomRightStack.push(node); } }; },{"./ast-node-types":2}],4:[function(require,module,exports){ /** * @fileoverview Translates tokens between Acorn format and Esprima format. * @author Nicholas C. Zakas * @copyright 2015 Nicholas C. Zakas. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ /* eslint no-underscore-dangle: 0 */ "use strict"; //------------------------------------------------------------------------------ // Requirements //------------------------------------------------------------------------------ // none! //------------------------------------------------------------------------------ // Private //------------------------------------------------------------------------------ // Esprima Token Types var Token = { Boolean: "Boolean", EOF: "", Identifier: "Identifier", Keyword: "Keyword", Null: "Null", Numeric: "Numeric", Punctuator: "Punctuator", String: "String", RegularExpression: "RegularExpression", Template: "Template", JSXIdentifier: "JSXIdentifier", JSXText: "JSXText" }; /** * Converts part of a template into an Esprima token. * @param {AcornToken[]} tokens The Acorn tokens representing the template. * @param {string} code The source code. * @returns {EsprimaToken} The Esprima equivalent of the template token. * @private */ function convertTemplatePart(tokens, code) { var firstToken = tokens[0], lastTemplateToken = tokens[tokens.length - 1]; var token = { type: Token.Template, value: code.slice(firstToken.start, lastTemplateToken.end) }; if (firstToken.loc) { token.loc = { start: firstToken.loc.start, end: lastTemplateToken.loc.end }; } if (firstToken.range) { token.range = [firstToken.range[0], lastTemplateToken.range[1]]; } return token; } /** * Contains logic to translate Acorn tokens into Esprima tokens. * @param {Object} acornTokTypes The Acorn token types. * @param {string} code The source code Acorn is parsing. This is necessary * to correct the "value" property of some tokens. * @constructor */ function TokenTranslator(acornTokTypes, code) { // token types this._acornTokTypes = acornTokTypes; // token buffer for templates this._tokens = []; // track the last curly brace this._curlyBrace = null; // the source code this._code = code; } TokenTranslator.prototype = { constructor: TokenTranslator, /** * Translates a single Esprima token to a single Acorn token. This may be * inaccurate due to how templates are handled differently in Esprima and * Acorn, but should be accurate for all other tokens. * @param {AcornToken} token The Acorn token to translate. * @param {Object} extra Espree extra object. * @returns {EsprimaToken} The Esprima version of the token. */ translate: function(token, extra) { var type = token.type, tt = this._acornTokTypes; if (type === tt.name) { token.type = Token.Identifier; // TODO: See if this is an Acorn bug if (token.value === "static") { token.type = Token.Keyword; } } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.jsxTagEnd || (type.binop && !type.keyword) || type.isAssign) { token.type = Token.Punctuator; token.value = this._code.slice(token.start, token.end); } else if (type === tt.jsxName) { token.type = Token.JSXIdentifier; } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) { token.type = Token.JSXText; } else if (type.keyword) { if (type.keyword === "true" || type.keyword === "false") { token.type = Token.Boolean; } else if (type.keyword === "null") { token.type = Token.Null; } else { token.type = Token.Keyword; } } else if (type === tt.num) { token.type = Token.Numeric; token.value = this._code.slice(token.start, token.end); } else if (type === tt.string) { if (extra.jsxAttrValueToken) { extra.jsxAttrValueToken = false; token.type = Token.JSXText; } else { token.type = Token.String; } token.value = this._code.slice(token.start, token.end); } else if (type === tt.regexp) { token.type = Token.RegularExpression; var value = token.value; token.regex = { flags: value.flags, pattern: value.pattern }; token.value = "/" + value.pattern + "/" + value.flags; } return token; }, /** * Function to call during Acorn's onToken handler. * @param {AcornToken} token The Acorn token. * @param {Object} extra The Espree extra object. * @returns {void} */ onToken: function(token, extra) { var that = this, tt = this._acornTokTypes, tokens = extra.tokens, templateTokens = this._tokens; /** * Flushes the buffered template tokens and resets the template * tracking. * @returns {void} * @private */ function translateTemplateTokens() { tokens.push(convertTemplatePart(that._tokens, that._code)); that._tokens = []; } if (token.type === tt.eof) { // might be one last curlyBrace if (this._curlyBrace) { tokens.push(this.translate(this._curlyBrace, extra)); } return; } if (token.type === tt.backQuote) { templateTokens.push(token); // it's the end if (templateTokens.length > 1) { translateTemplateTokens(); } return; } else if (token.type === tt.dollarBraceL) { templateTokens.push(token); translateTemplateTokens(); return; } else if (token.type === tt.braceR) { // if there's already a curly, it's not part of the template if (this._curlyBrace) { tokens.push(this.translate(this._curlyBrace, extra)); } // store new curly for later this._curlyBrace = token; return; } else if (token.type === tt.template) { if (this._curlyBrace) { templateTokens.push(this._curlyBrace); this._curlyBrace = null; } templateTokens.push(token); return; } if (this._curlyBrace) { tokens.push(this.translate(this._curlyBrace, extra)); this._curlyBrace = null; } tokens.push(this.translate(token, extra)); } }; //------------------------------------------------------------------------------ // Public //------------------------------------------------------------------------------ module.exports = TokenTranslator; },{}],5:[function(require,module,exports){ /** * @fileoverview The visitor keys for the node types Espree supports * @author Nicholas C. Zakas * @copyright 2015 Nicholas C. Zakas. All rights reserved. * @copyright 2012-2013 Yusuke Suzuki (twitter: @Constellation) and other contributors. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * Contains code from estraverse-fb. * * The MIT license. Copyright (c) 2014 Ingvar Stepanyan * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the "Software"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ "use strict"; //------------------------------------------------------------------------------ // Requirements //------------------------------------------------------------------------------ // None! //------------------------------------------------------------------------------ // Public //------------------------------------------------------------------------------ module.exports = { // ECMAScript AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], Program: ["body"], Property: ["key", "value"], RestElement: [ "argument" ], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"], // JSX JSXIdentifier: [], JSXNamespacedName: ["namespace", "name"], JSXMemberExpression: ["object", "property"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXElement: ["openingElement", "closingElement", "children"], JSXClosingElement: ["name"], JSXOpeningElement: ["name", "attributes"], JSXAttribute: ["name", "value"], JSXText: null, JSXSpreadAttribute: ["argument"], // Experimental features ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"] }; },{}],6:[function(require,module,exports){ 'use strict'; var XHTMLEntities = require('./xhtml'); var hexNumber = /^[\da-fA-F]+$/; var decimalNumber = /^\d+$/; module.exports = function(acorn) { var tt = acorn.tokTypes; var tc = acorn.tokContexts; tc.j_oTag = new acorn.TokContext('...', true, true); tt.jsxName = new acorn.TokenType('jsxName'); tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true}); tt.jsxTagStart = new acorn.TokenType('jsxTagStart'); tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd'); tt.jsxTagStart.updateContext = function() { this.context.push(tc.j_expr); // treat as beginning of JSX expression this.context.push(tc.j_oTag); // start opening tag context this.exprAllowed = false; }; tt.jsxTagEnd.updateContext = function(prevType) { var out = this.context.pop(); if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) { this.context.pop(); this.exprAllowed = this.curContext() === tc.j_expr; } else { this.exprAllowed = true; } }; var pp = acorn.Parser.prototype; // Reads inline JSX contents token. pp.jsx_readToken = function() { var out = '', chunkStart = this.pos; for (;;) { if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents'); var ch = this.input.charCodeAt(this.pos); switch (ch) { case 60: // '<' case 123: // '{' if (this.pos === this.start) { if (ch === 60 && this.exprAllowed) { ++this.pos; return this.finishToken(tt.jsxTagStart); } return this.getTokenFromCode(ch); } out += this.input.slice(chunkStart, this.pos); return this.finishToken(tt.jsxText, out); case 38: // '&' out += this.input.slice(chunkStart, this.pos); out += this.jsx_readEntity(); chunkStart = this.pos; break; default: if (acorn.isNewLine(ch)) { out += this.input.slice(chunkStart, this.pos); out += this.jsx_readNewLine(true); chunkStart = this.pos; } else { ++this.pos; } } } }; pp.jsx_readNewLine = function(normalizeCRLF) { var ch = this.input.charCodeAt(this.pos); var out; ++this.pos; if (ch === 13 && this.input.charCodeAt(this.pos) === 10) { ++this.pos; out = normalizeCRLF ? '\n' : '\r\n'; } else { out = String.fromCharCode(ch); } if (this.options.locations) { ++this.curLine; this.lineStart = this.pos; } return out; }; pp.jsx_readString = function(quote) { var out = '', chunkStart = ++this.pos; for (;;) { if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant'); var ch = this.input.charCodeAt(this.pos); if (ch === quote) break; if (ch === 38) { // '&' out += this.input.slice(chunkStart, this.pos); out += this.jsx_readEntity(); chunkStart = this.pos; } else if (acorn.isNewLine(ch)) { out += this.input.slice(chunkStart, this.pos); out += this.jsx_readNewLine(false); chunkStart = this.pos; } else { ++this.pos; } } out += this.input.slice(chunkStart, this.pos++); return this.finishToken(tt.string, out); }; pp.jsx_readEntity = function() { var str = '', count = 0, entity; var ch = this.input[this.pos]; if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand'); var startPos = ++this.pos; while (this.pos < this.input.length && count++ < 10) { ch = this.input[this.pos++]; if (ch === ';') { if (str[0] === '#') { if (str[1] === 'x') { str = str.substr(2); if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16)); } else { str = str.substr(1); if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10)); } } else { entity = XHTMLEntities[str]; } break; } str += ch; } if (!entity) { this.pos = startPos; return '&'; } return entity; }; // Read a JSX identifier (valid tag or attribute name). // // Optimized version since JSX identifiers can't contain // escape characters and so can be read as single slice. // Also assumes that first character was already checked // by isIdentifierStart in readToken. pp.jsx_readWord = function() { var ch, start = this.pos; do { ch = this.input.charCodeAt(++this.pos); } while (acorn.isIdentifierChar(ch) || ch === 45); // '-' return this.finishToken(tt.jsxName, this.input.slice(start, this.pos)); }; // Transforms JSX element name to string. function getQualifiedJSXName(object) { if (object.type === 'JSXIdentifier') return object.name; if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name; if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property); } // Parse next token as JSX identifier pp.jsx_parseIdentifier = function() { var node = this.startNode(); if (this.type === tt.jsxName) node.name = this.value; else if (this.type.keyword) node.name = this.type.keyword; else this.unexpected(); this.next(); return this.finishNode(node, 'JSXIdentifier'); }; // Parse namespaced identifier. pp.jsx_parseNamespacedName = function() { var startPos = this.start, startLoc = this.startLoc; var name = this.jsx_parseIdentifier(); if (!this.eat(tt.colon)) return name; var node = this.startNodeAt(startPos, startLoc); node.namespace = name; node.name = this.jsx_parseIdentifier(); return this.finishNode(node, 'JSXNamespacedName'); }; // Parses element name in any form - namespaced, member // or single identifier. pp.jsx_parseElementName = function() { var startPos = this.start, startLoc = this.startLoc; var node = this.jsx_parseNamespacedName(); while (this.eat(tt.dot)) { var newNode = this.startNodeAt(startPos, startLoc); newNode.object = node; newNode.property = this.jsx_parseIdentifier(); node = this.finishNode(newNode, 'JSXMemberExpression'); } return node; }; // Parses any type of JSX attribute value. pp.jsx_parseAttributeValue = function() { switch (this.type) { case tt.braceL: var node = this.jsx_parseExpressionContainer(); if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression'); return node; case tt.jsxTagStart: case tt.string: return this.parseExprAtom(); default: this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text'); } }; // JSXEmptyExpression is unique type since it doesn't actually parse anything, // and so it should start at the end of last read token (left brace) and finish // at the beginning of the next one (right brace). pp.jsx_parseEmptyExpression = function() { var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc); return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc); }; // Parses JSX expression enclosed into curly brackets. pp.jsx_parseExpressionContainer = function() { var node = this.startNode(); this.next(); node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(); this.expect(tt.braceR); return this.finishNode(node, 'JSXExpressionContainer'); }; // Parses following JSX attribute name-value pair. pp.jsx_parseAttribute = function() { var node = this.startNode(); if (this.eat(tt.braceL)) { this.expect(tt.ellipsis); node.argument = this.parseMaybeAssign(); this.expect(tt.braceR); return this.finishNode(node, 'JSXSpreadAttribute'); } node.name = this.jsx_parseNamespacedName(); node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null; return this.finishNode(node, 'JSXAttribute'); }; // Parses JSX opening tag starting after '<'. pp.jsx_parseOpeningElementAt = function(startPos, startLoc) { var node = this.startNodeAt(startPos, startLoc); node.attributes = []; node.name = this.jsx_parseElementName(); while (this.type !== tt.slash && this.type !== tt.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute()); node.selfClosing = this.eat(tt.slash); this.expect(tt.jsxTagEnd); return this.finishNode(node, 'JSXOpeningElement'); }; // Parses JSX closing tag starting after ''); } } node.openingElement = openingElement; node.closingElement = closingElement; node.children = children; if (this.type === tt.relational && this.value === "<") { this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"); } return this.finishNode(node, 'JSXElement'); }; // Parses entire JSX element from current position. pp.jsx_parseElement = function() { var startPos = this.start, startLoc = this.startLoc; this.next(); return this.jsx_parseElementAt(startPos, startLoc); }; acorn.plugins.jsx = function(instance) { instance.extend('parseExprAtom', function(inner) { return function(refShortHandDefaultPos) { if (this.type === tt.jsxText) return this.parseLiteral(this.value); else if (this.type === tt.jsxTagStart) return this.jsx_parseElement(); else return inner.call(this, refShortHandDefaultPos); }; }); instance.extend('readToken', function(inner) { return function(code) { var context = this.curContext(); if (context === tc.j_expr) return this.jsx_readToken(); if (context === tc.j_oTag || context === tc.j_cTag) { if (acorn.isIdentifierStart(code)) return this.jsx_readWord(); if (code == 62) { ++this.pos; return this.finishToken(tt.jsxTagEnd); } if ((code === 34 || code === 39) && context == tc.j_oTag) return this.jsx_readString(code); } if (code === 60 && this.exprAllowed) { ++this.pos; return this.finishToken(tt.jsxTagStart); } return inner.call(this, code); }; }); instance.extend('updateContext', function(inner) { return function(prevType) { if (this.type == tt.braceL) { var curContext = this.curContext(); if (curContext == tc.j_oTag) this.context.push(tc.b_expr); else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl); else inner.call(this, prevType); this.exprAllowed = true; } else if (this.type === tt.slash && prevType === tt.jsxTagStart) { this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore this.context.push(tc.j_cTag); // reconsider as closing tag context this.exprAllowed = false; } else { return inner.call(this, prevType); } }; }); }; return acorn; }; },{"./xhtml":7}],7:[function(require,module,exports){ module.exports = { quot: '\u0022', amp: '&', apos: '\u0027', lt: '<', gt: '>', nbsp: '\u00A0', iexcl: '\u00A1', cent: '\u00A2', pound: '\u00A3', curren: '\u00A4', yen: '\u00A5', brvbar: '\u00A6', sect: '\u00A7', uml: '\u00A8', copy: '\u00A9', ordf: '\u00AA', laquo: '\u00AB', not: '\u00AC', shy: '\u00AD', reg: '\u00AE', macr: '\u00AF', deg: '\u00B0', plusmn: '\u00B1', sup2: '\u00B2', sup3: '\u00B3', acute: '\u00B4', micro: '\u00B5', para: '\u00B6', middot: '\u00B7', cedil: '\u00B8', sup1: '\u00B9', ordm: '\u00BA', raquo: '\u00BB', frac14: '\u00BC', frac12: '\u00BD', frac34: '\u00BE', iquest: '\u00BF', Agrave: '\u00C0', Aacute: '\u00C1', Acirc: '\u00C2', Atilde: '\u00C3', Auml: '\u00C4', Aring: '\u00C5', AElig: '\u00C6', Ccedil: '\u00C7', Egrave: '\u00C8', Eacute: '\u00C9', Ecirc: '\u00CA', Euml: '\u00CB', Igrave: '\u00CC', Iacute: '\u00CD', Icirc: '\u00CE', Iuml: '\u00CF', ETH: '\u00D0', Ntilde: '\u00D1', Ograve: '\u00D2', Oacute: '\u00D3', Ocirc: '\u00D4', Otilde: '\u00D5', Ouml: '\u00D6', times: '\u00D7', Oslash: '\u00D8', Ugrave: '\u00D9', Uacute: '\u00DA', Ucirc: '\u00DB', Uuml: '\u00DC', Yacute: '\u00DD', THORN: '\u00DE', szlig: '\u00DF', agrave: '\u00E0', aacute: '\u00E1', acirc: '\u00E2', atilde: '\u00E3', auml: '\u00E4', aring: '\u00E5', aelig: '\u00E6', ccedil: '\u00E7', egrave: '\u00E8', eacute: '\u00E9', ecirc: '\u00EA', euml: '\u00EB', igrave: '\u00EC', iacute: '\u00ED', icirc: '\u00EE', iuml: '\u00EF', eth: '\u00F0', ntilde: '\u00F1', ograve: '\u00F2', oacute: '\u00F3', ocirc: '\u00F4', otilde: '\u00F5', ouml: '\u00F6', divide: '\u00F7', oslash: '\u00F8', ugrave: '\u00F9', uacute: '\u00FA', ucirc: '\u00FB', uuml: '\u00FC', yacute: '\u00FD', thorn: '\u00FE', yuml: '\u00FF', OElig: '\u0152', oelig: '\u0153', Scaron: '\u0160', scaron: '\u0161', Yuml: '\u0178', fnof: '\u0192', circ: '\u02C6', tilde: '\u02DC', Alpha: '\u0391', Beta: '\u0392', Gamma: '\u0393', Delta: '\u0394', Epsilon: '\u0395', Zeta: '\u0396', Eta: '\u0397', Theta: '\u0398', Iota: '\u0399', Kappa: '\u039A', Lambda: '\u039B', Mu: '\u039C', Nu: '\u039D', Xi: '\u039E', Omicron: '\u039F', Pi: '\u03A0', Rho: '\u03A1', Sigma: '\u03A3', Tau: '\u03A4', Upsilon: '\u03A5', Phi: '\u03A6', Chi: '\u03A7', Psi: '\u03A8', Omega: '\u03A9', alpha: '\u03B1', beta: '\u03B2', gamma: '\u03B3', delta: '\u03B4', epsilon: '\u03B5', zeta: '\u03B6', eta: '\u03B7', theta: '\u03B8', iota: '\u03B9', kappa: '\u03BA', lambda: '\u03BB', mu: '\u03BC', nu: '\u03BD', xi: '\u03BE', omicron: '\u03BF', pi: '\u03C0', rho: '\u03C1', sigmaf: '\u03C2', sigma: '\u03C3', tau: '\u03C4', upsilon: '\u03C5', phi: '\u03C6', chi: '\u03C7', psi: '\u03C8', omega: '\u03C9', thetasym: '\u03D1', upsih: '\u03D2', piv: '\u03D6', ensp: '\u2002', emsp: '\u2003', thinsp: '\u2009', zwnj: '\u200C', zwj: '\u200D', lrm: '\u200E', rlm: '\u200F', ndash: '\u2013', mdash: '\u2014', lsquo: '\u2018', rsquo: '\u2019', sbquo: '\u201A', ldquo: '\u201C', rdquo: '\u201D', bdquo: '\u201E', dagger: '\u2020', Dagger: '\u2021', bull: '\u2022', hellip: '\u2026', permil: '\u2030', prime: '\u2032', Prime: '\u2033', lsaquo: '\u2039', rsaquo: '\u203A', oline: '\u203E', frasl: '\u2044', euro: '\u20AC', image: '\u2111', weierp: '\u2118', real: '\u211C', trade: '\u2122', alefsym: '\u2135', larr: '\u2190', uarr: '\u2191', rarr: '\u2192', darr: '\u2193', harr: '\u2194', crarr: '\u21B5', lArr: '\u21D0', uArr: '\u21D1', rArr: '\u21D2', dArr: '\u21D3', hArr: '\u21D4', forall: '\u2200', part: '\u2202', exist: '\u2203', empty: '\u2205', nabla: '\u2207', isin: '\u2208', notin: '\u2209', ni: '\u220B', prod: '\u220F', sum: '\u2211', minus: '\u2212', lowast: '\u2217', radic: '\u221A', prop: '\u221D', infin: '\u221E', ang: '\u2220', and: '\u2227', or: '\u2228', cap: '\u2229', cup: '\u222A', 'int': '\u222B', there4: '\u2234', sim: '\u223C', cong: '\u2245', asymp: '\u2248', ne: '\u2260', equiv: '\u2261', le: '\u2264', ge: '\u2265', sub: '\u2282', sup: '\u2283', nsub: '\u2284', sube: '\u2286', supe: '\u2287', oplus: '\u2295', otimes: '\u2297', perp: '\u22A5', sdot: '\u22C5', lceil: '\u2308', rceil: '\u2309', lfloor: '\u230A', rfloor: '\u230B', lang: '\u2329', rang: '\u232A', loz: '\u25CA', spades: '\u2660', clubs: '\u2663', hearts: '\u2665', diams: '\u2666' }; },{}],8:[function(require,module,exports){ module.exports={ "name": "espree", "description": "An actively-maintained fork of Esprima, the ECMAScript parsing infrastructure for multipurpose analysis", "author": "Nicholas C. Zakas ", "homepage": "https://github.com/eslint/espree", "main": "espree.js", "bin": { "esparse": "./bin/esparse.js", "esvalidate": "./bin/esvalidate.js" }, "version": "3.0.0-alpha-2", "files": [ "bin", "lib", "test/run.js", "test/runner.js", "test/test.js", "test/compat.js", "test/reflect.js", "espree.js" ], "engines": { "node": ">=0.10.0" }, "repository": { "type": "git", "url": "http://github.com/eslint/espree.git" }, "bugs": { "url": "http://github.com/eslint/espree.git" }, "licenses": [ { "type": "BSD", "url": "http://github.com/nzakas/espree/raw/master/LICENSE" } ], "devDependencies": { "acorn-jsx": "^2.0.1", "browserify": "^7.0.0", "chai": "^1.10.0", "complexity-report": "~0.6.1", "dateformat": "^1.0.11", "eslint": "^1.10.3", "eslint-config-eslint": "^1.0.1", "esprima": "git://github.com/jquery/esprima", "esprima-fb": "^8001.2001.0-dev-harmony-fb", "istanbul": "~0.2.6", "json-diff": "~0.3.1", "leche": "^1.0.1", "mocha": "^2.0.1", "npm-license": "^0.2.3", "optimist": "~0.6.0", "regenerate": "~0.5.4", "semver": "^4.1.1", "shelljs": "^0.3.0", "shelljs-nodecli": "^0.1.1", "unicode-6.3.0": "~0.1.0" }, "keywords": [ "ast", "ecmascript", "javascript", "parser", "syntax" ], "scripts": { "generate-regex": "node tools/generate-identifier-regex.js", "test": "npm run-script lint && node Makefile.js test", "lint": "node Makefile.js lint", "patch": "node Makefile.js patch", "minor": "node Makefile.js minor", "major": "node Makefile.js major", "browserify": "node Makefile.js browserify" }, "dependencies": { "acorn": "^2.6.4", "acorn-jsx": "^2.0.1" } } },{}],9:[function(require,module,exports){ (function (global){ (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o= 6 && (prop.computed || prop.method || prop.shorthand)) return; var key = prop.key;var name = undefined; switch (key.type) { case "Identifier": name = key.name;break; case "Literal": name = String(key.value);break; default: return; } var kind = prop.kind; if (this.options.ecmaVersion >= 6) { if (name === "__proto__" && kind === "init") { if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property"); propHash.proto = true; } return; } name = "$" + name; var other = propHash[name]; if (other) { var isGetSet = kind !== "init"; if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property"); } else { other = propHash[name] = { init: false, get: false, set: false }; } other[kind] = true; }; // ### Expression parsing // These nest, from the most general expression type at the top to // 'atomic', nondivisible expression types at the bottom. Most of // the functions will simply let the function(s) below them parse, // and, *if* the syntactic construct they handle is present, wrap // the AST node that the inner parser gave them in another node. // Parse a full expression. The optional arguments are used to // forbid the `in` operator (in for loops initalization expressions) // and provide reference for storing '=' operator inside shorthand // property assignment in contexts where both object expression // and object pattern might appear (so it's possible to raise // delayed syntax error at correct position). pp.parseExpression = function (noIn, refDestructuringErrors) { var startPos = this.start, startLoc = this.startLoc; var expr = this.parseMaybeAssign(noIn, refDestructuringErrors); if (this.type === _tokentype.types.comma) { var node = this.startNodeAt(startPos, startLoc); node.expressions = [expr]; while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); return this.finishNode(node, "SequenceExpression"); } return expr; }; // Parse an assignment expression. This includes applications of // operators like `+=`. pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) { if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield(); var validateDestructuring = false; if (!refDestructuringErrors) { refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 }; validateDestructuring = true; } var startPos = this.start, startLoc = this.startLoc; if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start; var left = this.parseMaybeConditional(noIn, refDestructuringErrors); if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc); if (this.type.isAssign) { if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true); var node = this.startNodeAt(startPos, startLoc); node.operator = this.value; node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left; refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly this.checkLVal(left); this.next(); node.right = this.parseMaybeAssign(noIn); return this.finishNode(node, "AssignmentExpression"); } else { if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true); } return left; }; // Parse a ternary conditional (`?:`) operator. pp.parseMaybeConditional = function (noIn, refDestructuringErrors) { var startPos = this.start, startLoc = this.startLoc; var expr = this.parseExprOps(noIn, refDestructuringErrors); if (this.checkExpressionErrors(refDestructuringErrors)) return expr; if (this.eat(_tokentype.types.question)) { var node = this.startNodeAt(startPos, startLoc); node.test = expr; node.consequent = this.parseMaybeAssign(); this.expect(_tokentype.types.colon); node.alternate = this.parseMaybeAssign(noIn); return this.finishNode(node, "ConditionalExpression"); } return expr; }; // Start the precedence parser. pp.parseExprOps = function (noIn, refDestructuringErrors) { var startPos = this.start, startLoc = this.startLoc; var expr = this.parseMaybeUnary(refDestructuringErrors); if (this.checkExpressionErrors(refDestructuringErrors)) return expr; return this.parseExprOp(expr, startPos, startLoc, -1, noIn); }; // Parse binary operators with the operator precedence parsing // algorithm. `left` is the left-hand side of the operator. // `minPrec` provides context that allows the function to stop and // defer further parser to one of its callers when it encounters an // operator that has a lower precedence than the set it is parsing. pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) { var prec = this.type.binop; if (prec != null && (!noIn || this.type !== _tokentype.types._in)) { if (prec > minPrec) { var node = this.startNodeAt(leftStartPos, leftStartLoc); node.left = left; node.operator = this.value; var op = this.type; this.next(); var startPos = this.start, startLoc = this.startLoc; node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn); this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression"); return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn); } } return left; }; // Parse unary operators, both prefix and postfix. pp.parseMaybeUnary = function (refDestructuringErrors) { if (this.type.prefix) { var node = this.startNode(), update = this.type === _tokentype.types.incDec; node.operator = this.value; node.prefix = true; this.next(); node.argument = this.parseMaybeUnary(); this.checkExpressionErrors(refDestructuringErrors, true); if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode"); return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression"); } var startPos = this.start, startLoc = this.startLoc; var expr = this.parseExprSubscripts(refDestructuringErrors); if (this.checkExpressionErrors(refDestructuringErrors)) return expr; while (this.type.postfix && !this.canInsertSemicolon()) { var node = this.startNodeAt(startPos, startLoc); node.operator = this.value; node.prefix = false; node.argument = expr; this.checkLVal(expr); this.next(); expr = this.finishNode(node, "UpdateExpression"); } return expr; }; // Parse call, dot, and `[]`-subscript expressions. pp.parseExprSubscripts = function (refDestructuringErrors) { var startPos = this.start, startLoc = this.startLoc; var expr = this.parseExprAtom(refDestructuringErrors); var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"; if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr; return this.parseSubscripts(expr, startPos, startLoc); }; pp.parseSubscripts = function (base, startPos, startLoc, noCalls) { for (;;) { if (this.eat(_tokentype.types.dot)) { var node = this.startNodeAt(startPos, startLoc); node.object = base; node.property = this.parseIdent(true); node.computed = false; base = this.finishNode(node, "MemberExpression"); } else if (this.eat(_tokentype.types.bracketL)) { var node = this.startNodeAt(startPos, startLoc); node.object = base; node.property = this.parseExpression(); node.computed = true; this.expect(_tokentype.types.bracketR); base = this.finishNode(node, "MemberExpression"); } else if (!noCalls && this.eat(_tokentype.types.parenL)) { var node = this.startNodeAt(startPos, startLoc); node.callee = base; node.arguments = this.parseExprList(_tokentype.types.parenR, false); base = this.finishNode(node, "CallExpression"); } else if (this.type === _tokentype.types.backQuote) { var node = this.startNodeAt(startPos, startLoc); node.tag = base; node.quasi = this.parseTemplate(); base = this.finishNode(node, "TaggedTemplateExpression"); } else { return base; } } }; // Parse an atomic expression — either a single token that is an // expression, an expression started by a keyword like `function` or // `new`, or an expression wrapped in punctuation like `()`, `[]`, // or `{}`. pp.parseExprAtom = function (refDestructuringErrors) { var node = undefined, canBeArrow = this.potentialArrowAt == this.start; switch (this.type) { case _tokentype.types._super: if (!this.inFunction) this.raise(this.start, "'super' outside of function or class"); case _tokentype.types._this: var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super"; node = this.startNode(); this.next(); return this.finishNode(node, type); case _tokentype.types._yield: if (this.inGenerator) this.unexpected(); case _tokentype.types.name: var startPos = this.start, startLoc = this.startLoc; var id = this.parseIdent(this.type !== _tokentype.types.name); if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]); return id; case _tokentype.types.regexp: var value = this.value; node = this.parseLiteral(value.value); node.regex = { pattern: value.pattern, flags: value.flags }; return node; case _tokentype.types.num:case _tokentype.types.string: return this.parseLiteral(this.value); case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false: node = this.startNode(); node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true; node.raw = this.type.keyword; this.next(); return this.finishNode(node, "Literal"); case _tokentype.types.parenL: return this.parseParenAndDistinguishExpression(canBeArrow); case _tokentype.types.bracketL: node = this.startNode(); this.next(); // check whether this is array comprehension or regular array if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) { return this.parseComprehension(node, false); } node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors); return this.finishNode(node, "ArrayExpression"); case _tokentype.types.braceL: return this.parseObj(false, refDestructuringErrors); case _tokentype.types._function: node = this.startNode(); this.next(); return this.parseFunction(node, false); case _tokentype.types._class: return this.parseClass(this.startNode(), false); case _tokentype.types._new: return this.parseNew(); case _tokentype.types.backQuote: return this.parseTemplate(); default: this.unexpected(); } }; pp.parseLiteral = function (value) { var node = this.startNode(); node.value = value; node.raw = this.input.slice(this.start, this.end); this.next(); return this.finishNode(node, "Literal"); }; pp.parseParenExpression = function () { this.expect(_tokentype.types.parenL); var val = this.parseExpression(); this.expect(_tokentype.types.parenR); return val; }; pp.parseParenAndDistinguishExpression = function (canBeArrow) { var startPos = this.start, startLoc = this.startLoc, val = undefined; if (this.options.ecmaVersion >= 6) { this.next(); if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) { return this.parseComprehension(this.startNodeAt(startPos, startLoc), true); } var innerStartPos = this.start, innerStartLoc = this.startLoc; var exprList = [], first = true; var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 }, spreadStart = undefined, innerParenStart = undefined; while (this.type !== _tokentype.types.parenR) { first ? first = false : this.expect(_tokentype.types.comma); if (this.type === _tokentype.types.ellipsis) { spreadStart = this.start; exprList.push(this.parseParenItem(this.parseRest())); break; } else { if (this.type === _tokentype.types.parenL && !innerParenStart) { innerParenStart = this.start; } exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem)); } } var innerEndPos = this.start, innerEndLoc = this.startLoc; this.expect(_tokentype.types.parenR); if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) { this.checkPatternErrors(refDestructuringErrors, true); if (innerParenStart) this.unexpected(innerParenStart); return this.parseParenArrowList(startPos, startLoc, exprList); } if (!exprList.length) this.unexpected(this.lastTokStart); if (spreadStart) this.unexpected(spreadStart); this.checkExpressionErrors(refDestructuringErrors, true); if (exprList.length > 1) { val = this.startNodeAt(innerStartPos, innerStartLoc); val.expressions = exprList; this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc); } else { val = exprList[0]; } } else { val = this.parseParenExpression(); } if (this.options.preserveParens) { var par = this.startNodeAt(startPos, startLoc); par.expression = val; return this.finishNode(par, "ParenthesizedExpression"); } else { return val; } }; pp.parseParenItem = function (item) { return item; }; pp.parseParenArrowList = function (startPos, startLoc, exprList) { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList); }; // New's precedence is slightly tricky. It must allow its argument // to be a `[]` or dot subscript expression, but not a call — at // least, not without wrapping it in parentheses. Thus, it uses the var empty = []; pp.parseNew = function () { var node = this.startNode(); var meta = this.parseIdent(true); if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) { node.meta = meta; node.property = this.parseIdent(true); if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target"); if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions"); return this.finishNode(node, "MetaProperty"); } var startPos = this.start, startLoc = this.startLoc; node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true); if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty; return this.finishNode(node, "NewExpression"); }; // Parse template expression. pp.parseTemplateElement = function () { var elem = this.startNode(); elem.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'), cooked: this.value }; this.next(); elem.tail = this.type === _tokentype.types.backQuote; return this.finishNode(elem, "TemplateElement"); }; pp.parseTemplate = function () { var node = this.startNode(); this.next(); node.expressions = []; var curElt = this.parseTemplateElement(); node.quasis = [curElt]; while (!curElt.tail) { this.expect(_tokentype.types.dollarBraceL); node.expressions.push(this.parseExpression()); this.expect(_tokentype.types.braceR); node.quasis.push(curElt = this.parseTemplateElement()); } this.next(); return this.finishNode(node, "TemplateLiteral"); }; // Parse an object literal or binding pattern. pp.parseObj = function (isPattern, refDestructuringErrors) { var node = this.startNode(), first = true, propHash = {}; node.properties = []; this.next(); while (!this.eat(_tokentype.types.braceR)) { if (!first) { this.expect(_tokentype.types.comma); if (this.afterTrailingComma(_tokentype.types.braceR)) break; } else first = false; var prop = this.startNode(), isGenerator = undefined, startPos = undefined, startLoc = undefined; if (this.options.ecmaVersion >= 6) { prop.method = false; prop.shorthand = false; if (isPattern || refDestructuringErrors) { startPos = this.start; startLoc = this.startLoc; } if (!isPattern) isGenerator = this.eat(_tokentype.types.star); } this.parsePropertyName(prop); this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors); this.checkPropClash(prop, propHash); node.properties.push(this.finishNode(prop, "Property")); } return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression"); }; pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) { if (this.eat(_tokentype.types.colon)) { prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors); prop.kind = "init"; } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) { if (isPattern) this.unexpected(); prop.kind = "init"; prop.method = true; prop.value = this.parseMethod(isGenerator); } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) { if (isGenerator || isPattern) this.unexpected(); prop.kind = prop.key.name; this.parsePropertyName(prop); prop.value = this.parseMethod(false); var paramCount = prop.kind === "get" ? 0 : 1; if (prop.value.params.length !== paramCount) { var start = prop.value.start; if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param"); } } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") { prop.kind = "init"; if (isPattern) { if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name); prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key); } else if (this.type === _tokentype.types.eq && refDestructuringErrors) { if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start; prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key); } else { prop.value = prop.key; } prop.shorthand = true; } else this.unexpected(); }; pp.parsePropertyName = function (prop) { if (this.options.ecmaVersion >= 6) { if (this.eat(_tokentype.types.bracketL)) { prop.computed = true; prop.key = this.parseMaybeAssign(); this.expect(_tokentype.types.bracketR); return prop.key; } else { prop.computed = false; } } return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true); }; // Initialize empty function node. pp.initFunction = function (node) { node.id = null; if (this.options.ecmaVersion >= 6) { node.generator = false; node.expression = false; } }; // Parse object or class method. pp.parseMethod = function (isGenerator) { var node = this.startNode(); this.initFunction(node); this.expect(_tokentype.types.parenL); node.params = this.parseBindingList(_tokentype.types.parenR, false, false); if (this.options.ecmaVersion >= 6) node.generator = isGenerator; this.parseFunctionBody(node, false); return this.finishNode(node, "FunctionExpression"); }; // Parse arrow function expression with given parameters. pp.parseArrowExpression = function (node, params) { this.initFunction(node); node.params = this.toAssignableList(params, true); this.parseFunctionBody(node, true); return this.finishNode(node, "ArrowFunctionExpression"); }; // Parse function body and check parameters. pp.parseFunctionBody = function (node, isArrowFunction) { var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL; if (isExpression) { node.body = this.parseMaybeAssign(); node.expression = true; } else { // Start a new scope with regard to labels and the `inFunction` // flag (restore them to their old value afterwards). var oldInFunc = this.inFunction, oldInGen = this.inGenerator, oldLabels = this.labels; this.inFunction = true;this.inGenerator = node.generator;this.labels = []; node.body = this.parseBlock(true); node.expression = false; this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels; } // If this is a strict mode function, verify that argument names // are not repeated, and it does not try to bind the words `eval` // or `arguments`. if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) { var oldStrict = this.strict; this.strict = true; if (node.id) this.checkLVal(node.id, true); this.checkParams(node); this.strict = oldStrict; } else if (isArrowFunction) { this.checkParams(node); } }; // Checks function params for various disallowed patterns such as using "eval" // or "arguments" and duplicate parameters. pp.checkParams = function (node) { var nameHash = {}; for (var i = 0; i < node.params.length; i++) { this.checkLVal(node.params[i], true, nameHash); } }; // Parses a comma-separated list of expressions, and returns them as // an array. `close` is the token type that ends the list, and // `allowEmpty` can be turned on to allow subsequent commas with // nothing in between them to be parsed as `null` (which is needed // for array literals). pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) { var elts = [], first = true; while (!this.eat(close)) { if (!first) { this.expect(_tokentype.types.comma); if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) { refDestructuringErrors.trailingComma = this.lastTokStart; } if (allowTrailingComma && this.afterTrailingComma(close)) break; } else first = false; var elt = undefined; if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors); elts.push(elt); } return elts; }; // Parse the next token as an identifier. If `liberal` is true (used // when parsing properties), it will also convert keywords into // identifiers. pp.parseIdent = function (liberal) { var node = this.startNode(); if (liberal && this.options.allowReserved == "never") liberal = false; if (this.type === _tokentype.types.name) { if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved"); node.name = this.value; } else if (liberal && this.type.keyword) { node.name = this.type.keyword; } else { this.unexpected(); } this.next(); return this.finishNode(node, "Identifier"); }; // Parses yield expression inside generator. pp.parseYield = function () { var node = this.startNode(); this.next(); if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) { node.delegate = false; node.argument = null; } else { node.delegate = this.eat(_tokentype.types.star); node.argument = this.parseMaybeAssign(); } return this.finishNode(node, "YieldExpression"); }; // Parses array and generator comprehensions. pp.parseComprehension = function (node, isGenerator) { node.blocks = []; while (this.type === _tokentype.types._for) { var block = this.startNode(); this.next(); this.expect(_tokentype.types.parenL); block.left = this.parseBindingAtom(); this.checkLVal(block.left, true); this.expectContextual("of"); block.right = this.parseExpression(); this.expect(_tokentype.types.parenR); node.blocks.push(this.finishNode(block, "ComprehensionBlock")); } node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null; node.body = this.parseExpression(); this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR); node.generator = isGenerator; return this.finishNode(node, "ComprehensionExpression"); }; },{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){ // This is a trick taken from Esprima. It turns out that, on // non-Chrome browsers, to check whether a string is in a set, a // predicate containing a big ugly `switch` statement is faster than // a regular expression, and on Chrome the two are about on par. // This function uses `eval` (non-lexical) to produce such a // predicate from a space-separated string of words. // // It starts by sorting the words by length. // Reserved word lists for various dialects of the language "use strict"; exports.__esModule = true; exports.isIdentifierStart = isIdentifierStart; exports.isIdentifierChar = isIdentifierChar; var reservedWords = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }; exports.reservedWords = reservedWords; // And the keywords var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"; var keywords = { 5: ecma5AndLessKeywords, 6: ecma5AndLessKeywords + " let const class extends export import yield super" }; exports.keywords = keywords; // ## Character categories // Big ugly regular expressions that match characters in the // whitespace, identifier, and identifier-start categories. These // are only applied when a character is found to actually have a // code point above 128. // Generated by `bin/generate-identifier-regex.js`. var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"; var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿"; var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"); var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"); nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the // >0xffff code points that are a valid part of identifiers. The // offset starts at 0x10000, and each pair of numbers represents an // offset to the next range, and then a size of the range. They were // generated by tools/generate-identifier-regex.js var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541]; var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239]; // This has a complexity linear to the value of the code. The // assumption is that looking up astral identifier characters is // rare. function isInAstralSet(code, set) { var pos = 0x10000; for (var i = 0; i < set.length; i += 2) { pos += set[i]; if (pos > code) return false; pos += set[i + 1]; if (pos >= code) return true; } } // Test whether a given character code starts an identifier. function isIdentifierStart(code, astral) { if (code < 65) return code === 36; if (code < 91) return true; if (code < 97) return code === 95; if (code < 123) return true; if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)); if (astral === false) return false; return isInAstralSet(code, astralIdentifierStartCodes); } // Test whether a given character is part of an identifier. function isIdentifierChar(code, astral) { if (code < 48) return code === 36; if (code < 58) return true; if (code < 65) return false; if (code < 91) return true; if (code < 97) return code === 95; if (code < 123) return true; if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)); if (astral === false) return false; return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes); } },{}],3:[function(_dereq_,module,exports){ // Acorn is a tiny, fast JavaScript parser written in JavaScript. // // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and // various contributors and released under an MIT license. // // Git repositories for Acorn are available at // // http://marijnhaverbeke.nl/git/acorn // https://github.com/ternjs/acorn.git // // Please use the [github bug tracker][ghbt] to report issues. // // [ghbt]: https://github.com/ternjs/acorn/issues // // This file defines the main parser interface. The library also comes // with a [error-tolerant parser][dammit] and an // [abstract syntax tree walker][walk], defined in other files. // // [dammit]: acorn_loose.js // [walk]: util/walk.js "use strict"; exports.__esModule = true; exports.parse = parse; exports.parseExpressionAt = parseExpressionAt; exports.tokenizer = tokenizer; var _state = _dereq_("./state"); _dereq_("./parseutil"); _dereq_("./statement"); _dereq_("./lval"); _dereq_("./expression"); _dereq_("./location"); exports.Parser = _state.Parser; exports.plugins = _state.plugins; var _options = _dereq_("./options"); exports.defaultOptions = _options.defaultOptions; var _locutil = _dereq_("./locutil"); exports.Position = _locutil.Position; exports.SourceLocation = _locutil.SourceLocation; exports.getLineInfo = _locutil.getLineInfo; var _node = _dereq_("./node"); exports.Node = _node.Node; var _tokentype = _dereq_("./tokentype"); exports.TokenType = _tokentype.TokenType; exports.tokTypes = _tokentype.types; var _tokencontext = _dereq_("./tokencontext"); exports.TokContext = _tokencontext.TokContext; exports.tokContexts = _tokencontext.types; var _identifier = _dereq_("./identifier"); exports.isIdentifierChar = _identifier.isIdentifierChar; exports.isIdentifierStart = _identifier.isIdentifierStart; var _tokenize = _dereq_("./tokenize"); exports.Token = _tokenize.Token; var _whitespace = _dereq_("./whitespace"); exports.isNewLine = _whitespace.isNewLine; exports.lineBreak = _whitespace.lineBreak; exports.lineBreakG = _whitespace.lineBreakG; var version = "2.6.4"; exports.version = version; // The main exported interface (under `self.acorn` when in the // browser) is a `parse` function that takes a code string and // returns an abstract syntax tree as specified by [Mozilla parser // API][api]. // // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API function parse(input, options) { return new _state.Parser(options, input).parse(); } // This function tries to parse a single expression at a given // offset in a string. Useful for parsing mixed-language formats // that embed JavaScript expressions. function parseExpressionAt(input, pos, options) { var p = new _state.Parser(options, input, pos); p.nextToken(); return p.parseExpression(); } // Acorn is organized as a tokenizer and a recursive-descent parser. // The `tokenizer` export provides an interface to the tokenizer. function tokenizer(input, options) { return new _state.Parser(options, input); } },{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){ "use strict"; var _state = _dereq_("./state"); var _locutil = _dereq_("./locutil"); var pp = _state.Parser.prototype; // This function is used to raise exceptions on parse errors. It // takes an offset integer (into the current `input`) to indicate // the location of the error, attaches the position to the end // of the error message, and then raises a `SyntaxError` with that // message. pp.raise = function (pos, message) { var loc = _locutil.getLineInfo(this.input, pos); message += " (" + loc.line + ":" + loc.column + ")"; var err = new SyntaxError(message); err.pos = pos;err.loc = loc;err.raisedAt = this.pos; throw err; }; pp.curPosition = function () { if (this.options.locations) { return new _locutil.Position(this.curLine, this.pos - this.lineStart); } }; },{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){ "use strict"; exports.__esModule = true; exports.getLineInfo = getLineInfo; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var _whitespace = _dereq_("./whitespace"); // These are used when `options.locations` is on, for the // `startLoc` and `endLoc` properties. var Position = (function () { function Position(line, col) { _classCallCheck(this, Position); this.line = line; this.column = col; } Position.prototype.offset = function offset(n) { return new Position(this.line, this.column + n); }; return Position; })(); exports.Position = Position; var SourceLocation = function SourceLocation(p, start, end) { _classCallCheck(this, SourceLocation); this.start = start; this.end = end; if (p.sourceFile !== null) this.source = p.sourceFile; } // The `getLineInfo` function is mostly useful when the // `locations` option is off (for performance reasons) and you // want to find the line/column position for a given character // offset. `input` should be the code string that the offset refers // into. ; exports.SourceLocation = SourceLocation; function getLineInfo(input, offset) { for (var line = 1, cur = 0;;) { _whitespace.lineBreakG.lastIndex = cur; var match = _whitespace.lineBreakG.exec(input); if (match && match.index < offset) { ++line; cur = match.index + match[0].length; } else { return new Position(line, offset - cur); } } } },{"./whitespace":16}],6:[function(_dereq_,module,exports){ "use strict"; var _tokentype = _dereq_("./tokentype"); var _state = _dereq_("./state"); var _util = _dereq_("./util"); var pp = _state.Parser.prototype; // Convert existing expression atom to assignable pattern // if possible. pp.toAssignable = function (node, isBinding) { if (this.options.ecmaVersion >= 6 && node) { switch (node.type) { case "Identifier": case "ObjectPattern": case "ArrayPattern": break; case "ObjectExpression": node.type = "ObjectPattern"; for (var i = 0; i < node.properties.length; i++) { var prop = node.properties[i]; if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter"); this.toAssignable(prop.value, isBinding); } break; case "ArrayExpression": node.type = "ArrayPattern"; this.toAssignableList(node.elements, isBinding); break; case "AssignmentExpression": if (node.operator === "=") { node.type = "AssignmentPattern"; delete node.operator; // falls through to AssignmentPattern } else { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); break; } case "AssignmentPattern": if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value"); break; case "ParenthesizedExpression": node.expression = this.toAssignable(node.expression, isBinding); break; case "MemberExpression": if (!isBinding) break; default: this.raise(node.start, "Assigning to rvalue"); } } return node; }; // Convert list of expression atoms to binding list. pp.toAssignableList = function (exprList, isBinding) { var end = exprList.length; if (end) { var last = exprList[end - 1]; if (last && last.type == "RestElement") { --end; } else if (last && last.type == "SpreadElement") { last.type = "RestElement"; var arg = last.argument; this.toAssignable(arg, isBinding); if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start); --end; } if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start); } for (var i = 0; i < end; i++) { var elt = exprList[i]; if (elt) this.toAssignable(elt, isBinding); } return exprList; }; // Parses spread element. pp.parseSpread = function (refDestructuringErrors) { var node = this.startNode(); this.next(); node.argument = this.parseMaybeAssign(refDestructuringErrors); return this.finishNode(node, "SpreadElement"); }; pp.parseRest = function (allowNonIdent) { var node = this.startNode(); this.next(); // RestElement inside of a function parameter must be an identifier if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected(); return this.finishNode(node, "RestElement"); }; // Parses lvalue (assignable) atom. pp.parseBindingAtom = function () { if (this.options.ecmaVersion < 6) return this.parseIdent(); switch (this.type) { case _tokentype.types.name: return this.parseIdent(); case _tokentype.types.bracketL: var node = this.startNode(); this.next(); node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true); return this.finishNode(node, "ArrayPattern"); case _tokentype.types.braceL: return this.parseObj(true); default: this.unexpected(); } }; pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) { var elts = [], first = true; while (!this.eat(close)) { if (first) first = false;else this.expect(_tokentype.types.comma); if (allowEmpty && this.type === _tokentype.types.comma) { elts.push(null); } else if (allowTrailingComma && this.afterTrailingComma(close)) { break; } else if (this.type === _tokentype.types.ellipsis) { var rest = this.parseRest(allowNonIdent); this.parseBindingListItem(rest); elts.push(rest); this.expect(close); break; } else { var elem = this.parseMaybeDefault(this.start, this.startLoc); this.parseBindingListItem(elem); elts.push(elem); } } return elts; }; pp.parseBindingListItem = function (param) { return param; }; // Parses assignment pattern around given atom if possible. pp.parseMaybeDefault = function (startPos, startLoc, left) { left = left || this.parseBindingAtom(); if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left; var node = this.startNodeAt(startPos, startLoc); node.left = left; node.right = this.parseMaybeAssign(); return this.finishNode(node, "AssignmentPattern"); }; // Verify that a node is an lval — something that can be assigned // to. pp.checkLVal = function (expr, isBinding, checkClashes) { switch (expr.type) { case "Identifier": if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); if (checkClashes) { if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash"); checkClashes[expr.name] = true; } break; case "MemberExpression": if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression"); break; case "ObjectPattern": for (var i = 0; i < expr.properties.length; i++) { this.checkLVal(expr.properties[i].value, isBinding, checkClashes); }break; case "ArrayPattern": for (var i = 0; i < expr.elements.length; i++) { var elem = expr.elements[i]; if (elem) this.checkLVal(elem, isBinding, checkClashes); } break; case "AssignmentPattern": this.checkLVal(expr.left, isBinding, checkClashes); break; case "RestElement": this.checkLVal(expr.argument, isBinding, checkClashes); break; case "ParenthesizedExpression": this.checkLVal(expr.expression, isBinding, checkClashes); break; default: this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue"); } }; },{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){ "use strict"; exports.__esModule = true; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var _state = _dereq_("./state"); var _locutil = _dereq_("./locutil"); var Node = function Node(parser, pos, loc) { _classCallCheck(this, Node); this.type = ""; this.start = pos; this.end = 0; if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc); if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile; if (parser.options.ranges) this.range = [pos, 0]; } // Start an AST node, attaching a start offset. ; exports.Node = Node; var pp = _state.Parser.prototype; pp.startNode = function () { return new Node(this, this.start, this.startLoc); }; pp.startNodeAt = function (pos, loc) { return new Node(this, pos, loc); }; // Finish an AST node, adding `type` and `end` properties. function finishNodeAt(node, type, pos, loc) { node.type = type; node.end = pos; if (this.options.locations) node.loc.end = loc; if (this.options.ranges) node.range[1] = pos; return node; } pp.finishNode = function (node, type) { return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc); }; // Finish node at given position pp.finishNodeAt = function (node, type, pos, loc) { return finishNodeAt.call(this, node, type, pos, loc); }; },{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){ "use strict"; exports.__esModule = true; exports.getOptions = getOptions; var _util = _dereq_("./util"); var _locutil = _dereq_("./locutil"); // A second optional argument can be given to further configure // the parser process. These options are recognized: var defaultOptions = { // `ecmaVersion` indicates the ECMAScript version to parse. Must // be either 3, or 5, or 6. This influences support for strict // mode, the set of reserved words, support for getters and // setters and other features. ecmaVersion: 5, // Source type ("script" or "module") for different semantics sourceType: "script", // `onInsertedSemicolon` can be a callback that will be called // when a semicolon is automatically inserted. It will be passed // th position of the comma as an offset, and if `locations` is // enabled, it is given the location as a `{line, column}` object // as second argument. onInsertedSemicolon: null, // `onTrailingComma` is similar to `onInsertedSemicolon`, but for // trailing commas. onTrailingComma: null, // By default, reserved words are only enforced if ecmaVersion >= 5. // Set `allowReserved` to a boolean value to explicitly turn this on // an off. When this option has the value "never", reserved words // and keywords can also not be used as property names. allowReserved: null, // When enabled, a return at the top level is not considered an // error. allowReturnOutsideFunction: false, // When enabled, import/export statements are not constrained to // appearing at the top of the program. allowImportExportEverywhere: false, // When enabled, hashbang directive in the beginning of file // is allowed and treated as a line comment. allowHashBang: false, // When `locations` is on, `loc` properties holding objects with // `start` and `end` properties in `{line, column}` form (with // line being 1-based and column 0-based) will be attached to the // nodes. locations: false, // A function can be passed as `onToken` option, which will // cause Acorn to call that function with object in the same // format as tokens returned from `tokenizer().getToken()`. Note // that you are not allowed to call the parser from the // callback—that will corrupt its internal state. onToken: null, // A function can be passed as `onComment` option, which will // cause Acorn to call that function with `(block, text, start, // end)` parameters whenever a comment is skipped. `block` is a // boolean indicating whether this is a block (`/* */`) comment, // `text` is the content of the comment, and `start` and `end` are // character offsets that denote the start and end of the comment. // When the `locations` option is on, two more parameters are // passed, the full `{line, column}` locations of the start and // end of the comments. Note that you are not allowed to call the // parser from the callback—that will corrupt its internal state. onComment: null, // Nodes have their start and end characters offsets recorded in // `start` and `end` properties (directly on the node, rather than // the `loc` object, which holds line/column data. To also add a // [semi-standardized][range] `range` property holding a `[start, // end]` array with the same numbers, set the `ranges` option to // `true`. // // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678 ranges: false, // It is possible to parse multiple files into a single AST by // passing the tree produced by parsing the first file as // `program` option in subsequent parses. This will add the // toplevel forms of the parsed file to the `Program` (top) node // of an existing parse tree. program: null, // When `locations` is on, you can pass this to record the source // file in every node's `loc` object. sourceFile: null, // This value, if given, is stored in every node, whether // `locations` is on or off. directSourceFile: null, // When enabled, parenthesized expressions are represented by // (non-standard) ParenthesizedExpression nodes preserveParens: false, plugins: {} }; exports.defaultOptions = defaultOptions; // Interpret and default an options object function getOptions(opts) { var options = {}; for (var opt in defaultOptions) { options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt]; }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5; if (_util.isArray(options.onToken)) { (function () { var tokens = options.onToken; options.onToken = function (token) { return tokens.push(token); }; })(); } if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment); return options; } function pushComment(options, array) { return function (block, text, start, end, startLoc, endLoc) { var comment = { type: block ? 'Block' : 'Line', value: text, start: start, end: end }; if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc); if (options.ranges) comment.range = [start, end]; array.push(comment); }; } },{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){ "use strict"; var _tokentype = _dereq_("./tokentype"); var _state = _dereq_("./state"); var _whitespace = _dereq_("./whitespace"); var pp = _state.Parser.prototype; // ## Parser utilities // Test whether a statement node is the string literal `"use strict"`. pp.isUseStrict = function (stmt) { return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict"; }; // Predicate that tests whether the next token is of the given // type, and if yes, consumes it as a side effect. pp.eat = function (type) { if (this.type === type) { this.next(); return true; } else { return false; } }; // Tests whether parsed token is a contextual keyword. pp.isContextual = function (name) { return this.type === _tokentype.types.name && this.value === name; }; // Consumes contextual keyword if possible. pp.eatContextual = function (name) { return this.value === name && this.eat(_tokentype.types.name); }; // Asserts that following token is given contextual keyword. pp.expectContextual = function (name) { if (!this.eatContextual(name)) this.unexpected(); }; // Test whether a semicolon can be inserted at the current position. pp.canInsertSemicolon = function () { return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start)); }; pp.insertSemicolon = function () { if (this.canInsertSemicolon()) { if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); return true; } }; // Consume a semicolon, or, failing that, see if we are allowed to // pretend that there is a semicolon at this position. pp.semicolon = function () { if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected(); }; pp.afterTrailingComma = function (tokType) { if (this.type == tokType) { if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); this.next(); return true; } }; // Expect a token of a given type. If found, consume it, otherwise, // raise an unexpected token error. pp.expect = function (type) { this.eat(type) || this.unexpected(); }; // Raise an unexpected token error. pp.unexpected = function (pos) { this.raise(pos != null ? pos : this.start, "Unexpected token"); }; pp.checkPatternErrors = function (refDestructuringErrors, andThrow) { var pos = refDestructuringErrors && refDestructuringErrors.trailingComma; if (!andThrow) return !!pos; if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns"); }; pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) { var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign; if (!andThrow) return !!pos; if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns"); }; },{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){ "use strict"; exports.__esModule = true; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var _identifier = _dereq_("./identifier"); var _tokentype = _dereq_("./tokentype"); var _whitespace = _dereq_("./whitespace"); var _options = _dereq_("./options"); // Registered plugins var plugins = {}; exports.plugins = plugins; function keywordRegexp(words) { return new RegExp("^(" + words.replace(/ /g, "|") + ")$"); } var Parser = (function () { function Parser(options, input, startPos) { _classCallCheck(this, Parser); this.options = options = _options.getOptions(options); this.sourceFile = options.sourceFile; this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]); var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : ""); this.reservedWords = keywordRegexp(reserved); var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict; this.reservedWordsStrict = keywordRegexp(reservedStrict); this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind); this.input = String(input); // Used to signal to callers of `readWord1` whether the word // contained any escape sequences. This is needed because words with // escape sequences must not be interpreted as keywords. this.containsEsc = false; // Load plugins this.loadPlugins(options.plugins); // Set up token state // The current position of the tokenizer in the input. if (startPos) { this.pos = startPos; this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos)); this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length; } else { this.pos = this.lineStart = 0; this.curLine = 1; } // Properties of the current token: // Its type this.type = _tokentype.types.eof; // For tokens that include more information than their type, the value this.value = null; // Its start and end offset this.start = this.end = this.pos; // And, if locations are used, the {line, column} object // corresponding to those offsets this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token this.lastTokEndLoc = this.lastTokStartLoc = null; this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic // context to predict whether a regular expression is allowed in a // given position. this.context = this.initialContext(); this.exprAllowed = true; // Figure out if it's a module code. this.strict = this.inModule = options.sourceType === "module"; // Used to signify the start of a potential arrow function this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator. this.inFunction = this.inGenerator = false; // Labels in scope. this.labels = []; // If enabled, skip leading hashbang line. if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2); } // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them Parser.prototype.isKeyword = function isKeyword(word) { return this.keywords.test(word); }; Parser.prototype.isReservedWord = function isReservedWord(word) { return this.reservedWords.test(word); }; Parser.prototype.extend = function extend(name, f) { this[name] = f(this[name]); }; Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) { for (var _name in pluginConfigs) { var plugin = plugins[_name]; if (!plugin) throw new Error("Plugin '" + _name + "' not found"); plugin(this, pluginConfigs[_name]); } }; Parser.prototype.parse = function parse() { var node = this.options.program || this.startNode(); this.nextToken(); return this.parseTopLevel(node); }; return Parser; })(); exports.Parser = Parser; },{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){ "use strict"; var _tokentype = _dereq_("./tokentype"); var _state = _dereq_("./state"); var _whitespace = _dereq_("./whitespace"); var pp = _state.Parser.prototype; // ### Statement parsing // Parse a program. Initializes the parser, reads any number of // statements, and wraps them in a Program node. Optionally takes a // `program` argument. If present, the statements will be appended // to its body instead of creating a new node. pp.parseTopLevel = function (node) { var first = true; if (!node.body) node.body = []; while (this.type !== _tokentype.types.eof) { var stmt = this.parseStatement(true, true); node.body.push(stmt); if (first) { if (this.isUseStrict(stmt)) this.setStrict(true); first = false; } } this.next(); if (this.options.ecmaVersion >= 6) { node.sourceType = this.options.sourceType; } return this.finishNode(node, "Program"); }; var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" }; // Parse a single statement. // // If expecting a statement and finding a slash operator, parse a // regular expression literal. This is to handle cases like // `if (foo) /blah/.exec(foo)`, where looking at the previous token // does not help. pp.parseStatement = function (declaration, topLevel) { var starttype = this.type, node = this.startNode(); // Most types of statements are recognized by the keyword they // start with. Many are trivial to parse, some require a bit of // complexity. switch (starttype) { case _tokentype.types._break:case _tokentype.types._continue: return this.parseBreakContinueStatement(node, starttype.keyword); case _tokentype.types._debugger: return this.parseDebuggerStatement(node); case _tokentype.types._do: return this.parseDoStatement(node); case _tokentype.types._for: return this.parseForStatement(node); case _tokentype.types._function: if (!declaration && this.options.ecmaVersion >= 6) this.unexpected(); return this.parseFunctionStatement(node); case _tokentype.types._class: if (!declaration) this.unexpected(); return this.parseClass(node, true); case _tokentype.types._if: return this.parseIfStatement(node); case _tokentype.types._return: return this.parseReturnStatement(node); case _tokentype.types._switch: return this.parseSwitchStatement(node); case _tokentype.types._throw: return this.parseThrowStatement(node); case _tokentype.types._try: return this.parseTryStatement(node); case _tokentype.types._let:case _tokentype.types._const: if (!declaration) this.unexpected(); // NOTE: falls through to _var case _tokentype.types._var: return this.parseVarStatement(node, starttype); case _tokentype.types._while: return this.parseWhileStatement(node); case _tokentype.types._with: return this.parseWithStatement(node); case _tokentype.types.braceL: return this.parseBlock(); case _tokentype.types.semi: return this.parseEmptyStatement(node); case _tokentype.types._export: case _tokentype.types._import: if (!this.options.allowImportExportEverywhere) { if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level"); if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); } return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node); // If the statement does not start with a statement keyword or a // brace, it's an ExpressionStatement or LabeledStatement. We // simply start parsing an expression, and afterwards, if the // next token is a colon and the expression was a simple // Identifier node, we switch to interpreting it as a label. default: var maybeName = this.value, expr = this.parseExpression(); if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr); } }; pp.parseBreakContinueStatement = function (node, keyword) { var isBreak = keyword == "break"; this.next(); if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else { node.label = this.parseIdent(); this.semicolon(); } // Verify that there is an actual destination to break or // continue to. for (var i = 0; i < this.labels.length; ++i) { var lab = this.labels[i]; if (node.label == null || lab.name === node.label.name) { if (lab.kind != null && (isBreak || lab.kind === "loop")) break; if (node.label && isBreak) break; } } if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword); return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement"); }; pp.parseDebuggerStatement = function (node) { this.next(); this.semicolon(); return this.finishNode(node, "DebuggerStatement"); }; pp.parseDoStatement = function (node) { this.next(); this.labels.push(loopLabel); node.body = this.parseStatement(false); this.labels.pop(); this.expect(_tokentype.types._while); node.test = this.parseParenExpression(); if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon(); return this.finishNode(node, "DoWhileStatement"); }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of` // loop is non-trivial. Basically, we have to parse the init `var` // statement or expression, disallowing the `in` operator (see // the second parameter to `parseExpression`), and then check // whether the next token is `in` or `of`. When there is no init // part (semicolon immediately after the opening parenthesis), it // is a regular `for` loop. pp.parseForStatement = function (node) { this.next(); this.labels.push(loopLabel); this.expect(_tokentype.types.parenL); if (this.type === _tokentype.types.semi) return this.parseFor(node, null); if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) { var _init = this.startNode(), varKind = this.type; this.next(); this.parseVar(_init, true, varKind); this.finishNode(_init, "VariableDeclaration"); if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init); return this.parseFor(node, _init); } var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 }; var init = this.parseExpression(true, refDestructuringErrors); if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) { this.checkPatternErrors(refDestructuringErrors, true); this.toAssignable(init); this.checkLVal(init); return this.parseForIn(node, init); } else { this.checkExpressionErrors(refDestructuringErrors, true); } return this.parseFor(node, init); }; pp.parseFunctionStatement = function (node) { this.next(); return this.parseFunction(node, true); }; pp.parseIfStatement = function (node) { this.next(); node.test = this.parseParenExpression(); node.consequent = this.parseStatement(false); node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null; return this.finishNode(node, "IfStatement"); }; pp.parseReturnStatement = function (node) { if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function"); this.next(); // In `return` (and `break`/`continue`), the keywords with // optional arguments, we eagerly look for a semicolon or the // possibility to insert one. if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else { node.argument = this.parseExpression();this.semicolon(); } return this.finishNode(node, "ReturnStatement"); }; pp.parseSwitchStatement = function (node) { this.next(); node.discriminant = this.parseParenExpression(); node.cases = []; this.expect(_tokentype.types.braceL); this.labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase // nodes. `cur` is used to keep the node that we are currently // adding statements to. for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) { if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) { var isCase = this.type === _tokentype.types._case; if (cur) this.finishNode(cur, "SwitchCase"); node.cases.push(cur = this.startNode()); cur.consequent = []; this.next(); if (isCase) { cur.test = this.parseExpression(); } else { if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses"); sawDefault = true; cur.test = null; } this.expect(_tokentype.types.colon); } else { if (!cur) this.unexpected(); cur.consequent.push(this.parseStatement(true)); } } if (cur) this.finishNode(cur, "SwitchCase"); this.next(); // Closing brace this.labels.pop(); return this.finishNode(node, "SwitchStatement"); }; pp.parseThrowStatement = function (node) { this.next(); if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw"); node.argument = this.parseExpression(); this.semicolon(); return this.finishNode(node, "ThrowStatement"); }; // Reused empty array added for node fields that are always empty. var empty = []; pp.parseTryStatement = function (node) { this.next(); node.block = this.parseBlock(); node.handler = null; if (this.type === _tokentype.types._catch) { var clause = this.startNode(); this.next(); this.expect(_tokentype.types.parenL); clause.param = this.parseBindingAtom(); this.checkLVal(clause.param, true); this.expect(_tokentype.types.parenR); clause.body = this.parseBlock(); node.handler = this.finishNode(clause, "CatchClause"); } node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null; if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause"); return this.finishNode(node, "TryStatement"); }; pp.parseVarStatement = function (node, kind) { this.next(); this.parseVar(node, false, kind); this.semicolon(); return this.finishNode(node, "VariableDeclaration"); }; pp.parseWhileStatement = function (node) { this.next(); node.test = this.parseParenExpression(); this.labels.push(loopLabel); node.body = this.parseStatement(false); this.labels.pop(); return this.finishNode(node, "WhileStatement"); }; pp.parseWithStatement = function (node) { if (this.strict) this.raise(this.start, "'with' in strict mode"); this.next(); node.object = this.parseParenExpression(); node.body = this.parseStatement(false); return this.finishNode(node, "WithStatement"); }; pp.parseEmptyStatement = function (node) { this.next(); return this.finishNode(node, "EmptyStatement"); }; pp.parseLabeledStatement = function (node, maybeName, expr) { for (var i = 0; i < this.labels.length; ++i) { if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared"); }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null; for (var i = this.labels.length - 1; i >= 0; i--) { var label = this.labels[i]; if (label.statementStart == node.start) { label.statementStart = this.start; label.kind = kind; } else break; } this.labels.push({ name: maybeName, kind: kind, statementStart: this.start }); node.body = this.parseStatement(true); this.labels.pop(); node.label = expr; return this.finishNode(node, "LabeledStatement"); }; pp.parseExpressionStatement = function (node, expr) { node.expression = expr; this.semicolon(); return this.finishNode(node, "ExpressionStatement"); }; // Parse a semicolon-enclosed block of statements, handling `"use // strict"` declarations when `allowStrict` is true (used for // function bodies). pp.parseBlock = function (allowStrict) { var node = this.startNode(), first = true, oldStrict = undefined; node.body = []; this.expect(_tokentype.types.braceL); while (!this.eat(_tokentype.types.braceR)) { var stmt = this.parseStatement(true); node.body.push(stmt); if (first && allowStrict && this.isUseStrict(stmt)) { oldStrict = this.strict; this.setStrict(this.strict = true); } first = false; } if (oldStrict === false) this.setStrict(false); return this.finishNode(node, "BlockStatement"); }; // Parse a regular `for` loop. The disambiguation code in // `parseStatement` will already have parsed the init statement or // expression. pp.parseFor = function (node, init) { node.init = init; this.expect(_tokentype.types.semi); node.test = this.type === _tokentype.types.semi ? null : this.parseExpression(); this.expect(_tokentype.types.semi); node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression(); this.expect(_tokentype.types.parenR); node.body = this.parseStatement(false); this.labels.pop(); return this.finishNode(node, "ForStatement"); }; // Parse a `for`/`in` and `for`/`of` loop, which are almost // same from parser's perspective. pp.parseForIn = function (node, init) { var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement"; this.next(); node.left = init; node.right = this.parseExpression(); this.expect(_tokentype.types.parenR); node.body = this.parseStatement(false); this.labels.pop(); return this.finishNode(node, type); }; // Parse a list of variable declarations. pp.parseVar = function (node, isFor, kind) { node.declarations = []; node.kind = kind.keyword; for (;;) { var decl = this.startNode(); this.parseVarId(decl); if (this.eat(_tokentype.types.eq)) { decl.init = this.parseMaybeAssign(isFor); } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) { this.unexpected(); } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) { this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value"); } else { decl.init = null; } node.declarations.push(this.finishNode(decl, "VariableDeclarator")); if (!this.eat(_tokentype.types.comma)) break; } return node; }; pp.parseVarId = function (decl) { decl.id = this.parseBindingAtom(); this.checkLVal(decl.id, true); }; // Parse a function declaration or literal (depending on the // `isStatement` parameter). pp.parseFunction = function (node, isStatement, allowExpressionBody) { this.initFunction(node); if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star); if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent(); this.parseFunctionParams(node); this.parseFunctionBody(node, allowExpressionBody); return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression"); }; pp.parseFunctionParams = function (node) { this.expect(_tokentype.types.parenL); node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true); }; // Parse a class declaration or literal (depending on the // `isStatement` parameter). pp.parseClass = function (node, isStatement) { this.next(); this.parseClassId(node, isStatement); this.parseClassSuper(node); var classBody = this.startNode(); var hadConstructor = false; classBody.body = []; this.expect(_tokentype.types.braceL); while (!this.eat(_tokentype.types.braceR)) { if (this.eat(_tokentype.types.semi)) continue; var method = this.startNode(); var isGenerator = this.eat(_tokentype.types.star); var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static"; this.parsePropertyName(method); method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL; if (method["static"]) { if (isGenerator) this.unexpected(); isGenerator = this.eat(_tokentype.types.star); this.parsePropertyName(method); } method.kind = "method"; var isGetSet = false; if (!method.computed) { var key = method.key; if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) { isGetSet = true; method.kind = key.name; key = this.parsePropertyName(method); } if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) { if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class"); if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier"); if (isGenerator) this.raise(key.start, "Constructor can't be a generator"); method.kind = "constructor"; hadConstructor = true; } } this.parseClassMethod(classBody, method, isGenerator); if (isGetSet) { var paramCount = method.kind === "get" ? 0 : 1; if (method.value.params.length !== paramCount) { var start = method.value.start; if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param"); } } } node.body = this.finishNode(classBody, "ClassBody"); return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression"); }; pp.parseClassMethod = function (classBody, method, isGenerator) { method.value = this.parseMethod(isGenerator); classBody.body.push(this.finishNode(method, "MethodDefinition")); }; pp.parseClassId = function (node, isStatement) { node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null; }; pp.parseClassSuper = function (node) { node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null; }; // Parses module export declaration. pp.parseExport = function (node) { this.next(); // export * from '...' if (this.eat(_tokentype.types.star)) { this.expectContextual("from"); node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected(); this.semicolon(); return this.finishNode(node, "ExportAllDeclaration"); } if (this.eat(_tokentype.types._default)) { // export default ... var expr = this.parseMaybeAssign(); var needsSemi = true; if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") { needsSemi = false; if (expr.id) { expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration"; } } node.declaration = expr; if (needsSemi) this.semicolon(); return this.finishNode(node, "ExportDefaultDeclaration"); } // export var|const|let|function|class ... if (this.shouldParseExportStatement()) { node.declaration = this.parseStatement(true); node.specifiers = []; node.source = null; } else { // export { x, y as z } [from '...'] node.declaration = null; node.specifiers = this.parseExportSpecifiers(); if (this.eatContextual("from")) { node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected(); } else { // check for keywords used as local names for (var i = 0; i < node.specifiers.length; i++) { if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) { this.unexpected(node.specifiers[i].local.start); } } node.source = null; } this.semicolon(); } return this.finishNode(node, "ExportNamedDeclaration"); }; pp.shouldParseExportStatement = function () { return this.type.keyword; }; // Parses a comma-separated list of module exports. pp.parseExportSpecifiers = function () { var nodes = [], first = true; // export { x, y as z } [from '...'] this.expect(_tokentype.types.braceL); while (!this.eat(_tokentype.types.braceR)) { if (!first) { this.expect(_tokentype.types.comma); if (this.afterTrailingComma(_tokentype.types.braceR)) break; } else first = false; var node = this.startNode(); node.local = this.parseIdent(this.type === _tokentype.types._default); node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local; nodes.push(this.finishNode(node, "ExportSpecifier")); } return nodes; }; // Parses import declaration. pp.parseImport = function (node) { this.next(); // import '...' if (this.type === _tokentype.types.string) { node.specifiers = empty; node.source = this.parseExprAtom(); } else { node.specifiers = this.parseImportSpecifiers(); this.expectContextual("from"); node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected(); } this.semicolon(); return this.finishNode(node, "ImportDeclaration"); }; // Parses a comma-separated list of module imports. pp.parseImportSpecifiers = function () { var nodes = [], first = true; if (this.type === _tokentype.types.name) { // import defaultObj, { x, y as z } from '...' var node = this.startNode(); node.local = this.parseIdent(); this.checkLVal(node.local, true); nodes.push(this.finishNode(node, "ImportDefaultSpecifier")); if (!this.eat(_tokentype.types.comma)) return nodes; } if (this.type === _tokentype.types.star) { var node = this.startNode(); this.next(); this.expectContextual("as"); node.local = this.parseIdent(); this.checkLVal(node.local, true); nodes.push(this.finishNode(node, "ImportNamespaceSpecifier")); return nodes; } this.expect(_tokentype.types.braceL); while (!this.eat(_tokentype.types.braceR)) { if (!first) { this.expect(_tokentype.types.comma); if (this.afterTrailingComma(_tokentype.types.braceR)) break; } else first = false; var node = this.startNode(); node.imported = this.parseIdent(true); node.local = this.eatContextual("as") ? this.parseIdent() : node.imported; this.checkLVal(node.local, true); nodes.push(this.finishNode(node, "ImportSpecifier")); } return nodes; }; },{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){ // The algorithm used to determine whether a regexp can appear at a // given point in the program is loosely based on sweet.js' approach. // See https://github.com/mozilla/sweet.js/wiki/design "use strict"; exports.__esModule = true; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var _state = _dereq_("./state"); var _tokentype = _dereq_("./tokentype"); var _whitespace = _dereq_("./whitespace"); var TokContext = function TokContext(token, isExpr, preserveSpace, override) { _classCallCheck(this, TokContext); this.token = token; this.isExpr = !!isExpr; this.preserveSpace = !!preserveSpace; this.override = override; }; exports.TokContext = TokContext; var types = { b_stat: new TokContext("{", false), b_expr: new TokContext("{", true), b_tmpl: new TokContext("${", true), p_stat: new TokContext("(", false), p_expr: new TokContext("(", true), q_tmpl: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }), f_expr: new TokContext("function", true) }; exports.types = types; var pp = _state.Parser.prototype; pp.initialContext = function () { return [types.b_stat]; }; pp.braceIsBlock = function (prevType) { if (prevType === _tokentype.types.colon) { var _parent = this.curContext(); if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr; } if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start)); if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true; if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat; return !this.exprAllowed; }; pp.updateContext = function (prevType) { var update = undefined, type = this.type; if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr; }; // Token-specific context update code _tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () { if (this.context.length == 1) { this.exprAllowed = true; return; } var out = this.context.pop(); if (out === types.b_stat && this.curContext() === types.f_expr) { this.context.pop(); this.exprAllowed = false; } else if (out === types.b_tmpl) { this.exprAllowed = true; } else { this.exprAllowed = !out.isExpr; } }; _tokentype.types.braceL.updateContext = function (prevType) { this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr); this.exprAllowed = true; }; _tokentype.types.dollarBraceL.updateContext = function () { this.context.push(types.b_tmpl); this.exprAllowed = true; }; _tokentype.types.parenL.updateContext = function (prevType) { var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while; this.context.push(statementParens ? types.p_stat : types.p_expr); this.exprAllowed = true; }; _tokentype.types.incDec.updateContext = function () { // tokExprAllowed stays unchanged }; _tokentype.types._function.updateContext = function () { if (this.curContext() !== types.b_stat) this.context.push(types.f_expr); this.exprAllowed = false; }; _tokentype.types.backQuote.updateContext = function () { if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl); this.exprAllowed = false; }; },{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){ "use strict"; exports.__esModule = true; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var _identifier = _dereq_("./identifier"); var _tokentype = _dereq_("./tokentype"); var _state = _dereq_("./state"); var _locutil = _dereq_("./locutil"); var _whitespace = _dereq_("./whitespace"); // Object type used to represent tokens. Note that normally, tokens // simply exist as properties on the parser object. This is only // used for the onToken callback and the external tokenizer. var Token = function Token(p) { _classCallCheck(this, Token); this.type = p.type; this.value = p.value; this.start = p.start; this.end = p.end; if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc); if (p.options.ranges) this.range = [p.start, p.end]; } // ## Tokenizer ; exports.Token = Token; var pp = _state.Parser.prototype; // Are we running under Rhino? var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]"; // Move to the next token pp.next = function () { if (this.options.onToken) this.options.onToken(new Token(this)); this.lastTokEnd = this.end; this.lastTokStart = this.start; this.lastTokEndLoc = this.endLoc; this.lastTokStartLoc = this.startLoc; this.nextToken(); }; pp.getToken = function () { this.next(); return new Token(this); }; // If we're in an ES6 environment, make parsers iterable if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () { var self = this; return { next: function next() { var token = self.getToken(); return { done: token.type === _tokentype.types.eof, value: token }; } }; }; // Toggle strict mode. Re-reads the next number or string to please // pedantic tests (`"use strict"; 010;` should fail). pp.setStrict = function (strict) { this.strict = strict; if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return; this.pos = this.start; if (this.options.locations) { while (this.pos < this.lineStart) { this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1; --this.curLine; } } this.nextToken(); }; pp.curContext = function () { return this.context[this.context.length - 1]; }; // Read a single token, updating the parser object's token-related // properties. pp.nextToken = function () { var curContext = this.curContext(); if (!curContext || !curContext.preserveSpace) this.skipSpace(); this.start = this.pos; if (this.options.locations) this.startLoc = this.curPosition(); if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof); if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos()); }; pp.readToken = function (code) { // Identifier or keyword. '\uXXXX' sequences are allowed in // identifiers, so '\' also dispatches to that. if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord(); return this.getTokenFromCode(code); }; pp.fullCharCodeAtPos = function () { var code = this.input.charCodeAt(this.pos); if (code <= 0xd7ff || code >= 0xe000) return code; var next = this.input.charCodeAt(this.pos + 1); return (code << 10) + next - 0x35fdc00; }; pp.skipBlockComment = function () { var startLoc = this.options.onComment && this.curPosition(); var start = this.pos, end = this.input.indexOf("*/", this.pos += 2); if (end === -1) this.raise(this.pos - 2, "Unterminated comment"); this.pos = end + 2; if (this.options.locations) { _whitespace.lineBreakG.lastIndex = start; var match = undefined; while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) { ++this.curLine; this.lineStart = match.index + match[0].length; } } if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition()); }; pp.skipLineComment = function (startSkip) { var start = this.pos; var startLoc = this.options.onComment && this.curPosition(); var ch = this.input.charCodeAt(this.pos += startSkip); while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) { ++this.pos; ch = this.input.charCodeAt(this.pos); } if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition()); }; // Called at the start of the parse and after every token. Skips // whitespace and comments, and. pp.skipSpace = function () { loop: while (this.pos < this.input.length) { var ch = this.input.charCodeAt(this.pos); switch (ch) { case 32:case 160: // ' ' ++this.pos; break; case 13: if (this.input.charCodeAt(this.pos + 1) === 10) { ++this.pos; } case 10:case 8232:case 8233: ++this.pos; if (this.options.locations) { ++this.curLine; this.lineStart = this.pos; } break; case 47: // '/' switch (this.input.charCodeAt(this.pos + 1)) { case 42: // '*' this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break loop; } break; default: if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) { ++this.pos; } else { break loop; } } } }; // Called at the end of every token. Sets `end`, `val`, and // maintains `context` and `exprAllowed`, and skips the space after // the token, so that the next one's `start` will point at the // right position. pp.finishToken = function (type, val) { this.end = this.pos; if (this.options.locations) this.endLoc = this.curPosition(); var prevType = this.type; this.type = type; this.value = val; this.updateContext(prevType); }; // ### Token reading // This is the function that is called to fetch the next token. It // is somewhat obscure, because it works in character codes rather // than characters, and because operator parsing has been inlined // into it. // // All in the name of speed. // pp.readToken_dot = function () { var next = this.input.charCodeAt(this.pos + 1); if (next >= 48 && next <= 57) return this.readNumber(true); var next2 = this.input.charCodeAt(this.pos + 2); if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.' this.pos += 3; return this.finishToken(_tokentype.types.ellipsis); } else { ++this.pos; return this.finishToken(_tokentype.types.dot); } }; pp.readToken_slash = function () { // '/' var next = this.input.charCodeAt(this.pos + 1); if (this.exprAllowed) { ++this.pos;return this.readRegexp(); } if (next === 61) return this.finishOp(_tokentype.types.assign, 2); return this.finishOp(_tokentype.types.slash, 1); }; pp.readToken_mult_modulo = function (code) { // '%*' var next = this.input.charCodeAt(this.pos + 1); if (next === 61) return this.finishOp(_tokentype.types.assign, 2); return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1); }; pp.readToken_pipe_amp = function (code) { // '|&' var next = this.input.charCodeAt(this.pos + 1); if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2); if (next === 61) return this.finishOp(_tokentype.types.assign, 2); return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1); }; pp.readToken_caret = function () { // '^' var next = this.input.charCodeAt(this.pos + 1); if (next === 61) return this.finishOp(_tokentype.types.assign, 2); return this.finishOp(_tokentype.types.bitwiseXOR, 1); }; pp.readToken_plus_min = function (code) { // '+-' var next = this.input.charCodeAt(this.pos + 1); if (next === code) { if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) { // A `-->` line comment this.skipLineComment(3); this.skipSpace(); return this.nextToken(); } return this.finishOp(_tokentype.types.incDec, 2); } if (next === 61) return this.finishOp(_tokentype.types.assign, 2); return this.finishOp(_tokentype.types.plusMin, 1); }; pp.readToken_lt_gt = function (code) { // '<>' var next = this.input.charCodeAt(this.pos + 1); var size = 1; if (next === code) { size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2; if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1); return this.finishOp(_tokentype.types.bitShift, size); } if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) { if (this.inModule) this.unexpected(); // `
